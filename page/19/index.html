<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;19&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/19/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/06/%5B%E6%95%B0%E8%AE%BA%5D%E7%B4%A0%E6%95%B0%E7%AD%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/06/%5B%E6%95%B0%E8%AE%BA%5D%E7%B4%A0%E6%95%B0%E7%AD%9B/" itemprop="url">[数论]素数筛</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-06T15:21:05+08:00">
                2019-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址：<a href="https://blog.csdn.net/qq_41117236/article/details/81152055" target="_blank" rel="noopener">https://blog.csdn.net/qq_41117236/article/details/81152055</a></p>
<h2 id="普通筛法-埃式筛法"><a href="#普通筛法-埃式筛法" class="headerlink" title="普通筛法- 埃式筛法"></a>普通筛法- 埃式筛法</h2><p>普通代码： 时间复杂度O(nloglogn)</p>
<pre><code>bool prime[maxn+5];
void isprime()
{
    int i,j;
    memset(prime,true,sizeof(prime));
    for(i=2;i&lt;=maxn;i++)
    {
        if(prime[i]==true)
        {
            for(j= i + i ;j &lt;= N;j += i)
                prime[j]=false;
        }
    }
}</code></pre><p>改进：</p>
<pre><code>bool prime[maxn+5];
void isprime()
{
    int i,j;
    memset(prime,true,sizeof(prime));
    for(i=2;i&lt;=sqrt(N);i++) //第一处： i &lt;= max --- &gt;  i &lt;= sqrt(N)
    {
        if(prime[i]==true)
        {
            for(j = i * i; j &lt;= N ; j += i) //第二处: j = 2 i  --- &gt; j = i*i
                prime[j]=false;
            //二次筛选法:i是素数，则下一个起点是i*i,把后面的所有的i*i+2*n*i筛掉
        }
    }</code></pre><h2 id="线性筛——欧拉Euler筛"><a href="#线性筛——欧拉Euler筛" class="headerlink" title="线性筛——欧拉Euler筛"></a>线性筛——欧拉Euler筛</h2><p>博客地址：<a href="https://www.cnblogs.com/NSD-email0820/p/9490828.html#_label4" target="_blank" rel="noopener">https://www.cnblogs.com/NSD-email0820/p/9490828.html#_label4</a></p>
<pre><code>void primes(int n)
{
    memset(v,0,sizeof(v));//假设全是素数，无合数标记 
    for(int i=2;i&lt;=n;i++)
    {
        if(!v[i])        //是素数
        {
            prime[++cnt]=i;
            v[i]=i;     //存的就是自己，v[i]记录的是筛掉自己的最小质因子 
        }
        for(int j=1;j&lt;=cnt;j++)
        {
            if(prime[j]&gt;v[i]||prime[j]*i&gt;n)break;
            //出现了比i的最小质因数还小的质数（对于4来说出现了3） 
            v[prime[j]*i]=prime[j];
        }    
    }
    for(int i=1;i&lt;=cnt;i++)
        cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/05/%5B%E6%95%B0%E8%AE%BA%5D%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/05/%5B%E6%95%B0%E8%AE%BA%5D%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/" itemprop="url">[数论]积性函数与线性筛</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-05T15:44:35+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博客地址<a href="https://www.cnblogs.com/zhoushuyu/p/8275530.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoushuyu/p/8275530.html</a></p>
<p><em>积性函数_指对于所有互质的整数a和b有性质f(ab)=f(a)f(b)的数论_函数</em></p>
<p>常用积性函数举例</p>
<p>φ(n) －欧拉函数<br>μ(n) －莫比乌斯函数，关于非平方数的质因子数目<br>gcd(n,k) －最大公因子，当k固定的情况<br>d(n) －n的正因子数目<br>σ(n) －n的所有正因子之和</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/05/%5B%E7%AE%97%E6%B3%95%5D%E5%B9%BF%E4%B9%89Fibonacci%E6%95%B0%E5%88%97%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/05/%5B%E7%AE%97%E6%B3%95%5D%E5%B9%BF%E4%B9%89Fibonacci%E6%95%B0%E5%88%97%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/" itemprop="url">[算法]广义Fibonacci数列找循环节</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-05T08:27:33+08:00">
                2019-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原博文连接：<a href="https://blog.csdn.net/ACdreamers/article/details/25616461" target="_blank" rel="noopener">https://blog.csdn.net/ACdreamers/article/details/25616461</a></p>
<p><img src="https://img-blog.csdn.net/20140512141202250" alt=""></p>
<p><img src="https://img-blog.csdn.net/20140512141344500" alt=""></p>
<p><img src="https://img-blog.csdn.net/20140512141547343" alt=""></p>
<p><strong>问题：</strong>给定如上的递推式，求其循环节长度</p>
<p><strong>结论：</strong>设</p>
<p><img src="https://img-blog.csdn.net/20140512150213093" alt=""></p>
<ul>
<li>如果c是模p的二次剩余时：枚举n = p - 1的因子</li>
<li>如果c是模p的非二次剩余时：枚举n = (p - 1)*(p + 1)的因子</li>
</ul>
<p>找到最小的ans，使得</p>
<p><img src="https://img-blog.csdn.net/20140512155210937" alt=""></p>
<p>何为二次剩余：</p>
<p>简单来说就是如果存在一个整数x，使得x^2 ≡ n(mod p)<br>那么则称n是模p的二次剩余。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/04/HDU-1816GetLuffyOut/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/04/HDU-1816GetLuffyOut/" itemprop="url">HDU - 1816 Get Luffy Out *</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-04T20:50:00+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>某两个钥匙为一对，一旦使用了其中一个钥匙，另一个钥匙就不能用了（约束条件1） 开每个门，至少要用一个钥匙（约束条件2），求能开的门数的最大值（二分）。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>将钥匙的状态视为0和1。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-04-15.56.39
 Question_Number   ：hdu 1816
 Question_Name     ：二分 + 2-sat
 Description       :
每片钥匙，有两个状态 A1为用这片钥匙， A0 为不用这片钥匙

 你还是没理解透彻2-SAT的实质
 对于第一个约束规则（一对钥匙中的一片用了，另一篇就不能用了）
 假如有一对钥匙A B
 所以得到约束关系   A and B ！= 1；
 也就是说如果
 A1  -- &gt; B0        //如果用A这片钥匙，那么B的状态就是不用这片钥匙了
 B1  -- &gt; A0

 对于第二个约束规则（一扇门有两把锁，开了一把，另一把的钥匙就不能用了）
 假如这扇门用的钥匙为A，B；
 所以得到约束关系   A and B != 1;   A or B != 0
 A1  -- &gt; B0;
 B1  -- &gt; A0;
 A0  -- &gt; B1;
 B0  -- &gt; A1;


 然后本题问的是能打开的最多的门数是多少
 一般这种都是二分
 每次都建一遍图

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
const int MAXM = 2048 + 10;
stack &lt; int &gt; st;
int n, m, tot, cnt, sum;
int head[4 * MAXN], low[4 * MAXN], dfn[4 * MAXN], belong[4 * MAXN];
bool vis[4 * MAXN];
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXN + 4 * MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    int x, y;
};
Node key[MAXN];
Node door[MAXM];
void init()
{
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    cnt = sum = tot = 0;
}
void Tarjan(int u)
{
    vis[u] = true;
    low[u] = dfn[u] = ++tot;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 4 * n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
    for(int i = 0; i &lt; 4 * n; i += 2)
        if(belong[i] == belong[i + 1])
            return false;

    return true;
}
void built(int mid)
{
    init();
    for(int i = 1; i &lt;= n; i++)
    {
        int u = key[i].x;
        int v = key[i].y;
        int u1 = u * 2;     //u1表示选这个钥匙
        int u2 = u * 2 + 1;
        int v1 = v * 2;
        int v2 = v * 2 + 1;
        addEdge(u1, v2);
        addEdge(v1, u2);
    }
    for(int i = 1; i &lt;= mid; i++)   //一种特殊情况，一个门两片的钥匙是一样的
    {
        int u = door[i].x;
        int v = door[i].y;
        int u1 = u * 2;     //u1表示选这个钥匙
        int u2 = u * 2 + 1;
        int v1 = v * 2;
        int v2 = v * 2 + 1;
   //     addEdge(u1, v2);
     //   addEdge(v1, u2); 为什么不要？？
        addEdge(u2, v1);
        addEdge(v2, u1);
    }
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n + m)
    {
        // 意思是有2n把钥匙，那么图中有4n个点
        // 编号为0 .... 4n - 1
        // 01  23
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;, &amp;key[i].x, &amp;key[i].y);
        for(int i = 1; i &lt;= m; i++)
            scanf(&quot;%d%d&quot;, &amp;door[i].x, &amp;door[i].y);
        int L = 0;  //
        int R = m;  // 这是最多的层数
        int mid;
        int ans = 0;
        while(L &lt;= R)
        {
            mid = (L + R) / 2;
            built(mid);
            if(solve())
            {
                ans = max(ans, mid);
                L = mid + 1;
            }
            else
            {
                R = mid - 1;
            }
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/04/HDU-1815Buildingroads/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/04/HDU-1815Buildingroads/" itemprop="url">HDU - 1815 Building roads</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-04T20:47:25+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n个堆，2个特殊点，每个堆有两个状态，要么连接到s1这个特殊点，要么连到s2这个特殊点。存在某些约束关系，例如某两堆不能连在同一个特殊点，or某两堆必须连在同一个特殊点。求任意两点距离的最大值的 最小值</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>二分最大值，如果两点距离大于这个最大值，就说明这两者矛盾，填加约束条件。再配合上之前的两堆不能连同一点，两堆要连同一点的约束条件，构成一个图。用2-SAT求适定性即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-04-13.46.03
 Question_Number   ：hdu 1815
 Question_Name     ：二分+ 2-sat
 Description       :
 二分一个最大距离
 首先求出每个点  到s1 和 s2的距离
 然后求出每对点（A,B）的距离
 如果A到s1的距离 加上distance 再加上B到s2的距离
 要大于mid，说明不能连二者
 也就是说如果A连到s1,  B那么一定不能连s2
 如果B连到了s2，A那么一定不能连到s1
 每对点，要考虑4个情况
 都连s1  都连s2  A连s1 B连s2  A连s2 A连s1
 然后将这四种诞生的限制条件添加入图中
 如果适定，说明限制条件还少了
 那么缩小mid
 如果不适定，说明限制条件多了
 那么放大mid
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 500 + 10;
const int MAXM = 1000 + 10;
stack &lt; int &gt; st;
int head[2*MAXN], ans[2*MAXN], low[2*MAXN], dfn[2*MAXN], belong[2*MAXN];
bool mark[2*MAXN], vis[2*MAXN];
int dis[MAXN][2], cnt, dfsSum, distant, n, m, a, b, tot, sum;
struct Node
{
    int x, y;
};
Node node[MAXN];
Node s1, s2;
Node dislike[MAXM];
Node like[MAXM];
int getDis(Node a, Node b)
{
    return abs(a.x - b.x) + abs(a.y - b.y);
}
struct Edge
{
    int v, next;
};
Edge edge[MAXN * MAXN * 4];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(head, -1, sizeof head);
    while(!st.empty())
        st.pop();
    cnt = tot = sum = 0;
}
int oth(int x)
{
    if(x % 2)
        return x + 1;
    else
        return x - 1;
}
void built(int mid)
{
    for(int i = 1; i &lt;= a; i++)
    {
            int u = dislike[i].x;
            int v = dislike[i].y;
            int u1 = u * 2 - 1;
            int u2 = u * 2;
            int v1 = v * 2 - 1;
            int v2 = v * 2;
            addEdge(u1, v2);
            addEdge(u2, v1);
            addEdge(v1, u2);
            addEdge(v2, u1);
    }
    for(int i = 1; i &lt;= b; i++)
    {
            int u = like[i].x;
            int v = like[i].y;
            int u1 = u * 2 - 1;
            int u2 = u * 2;
            int v1 = v * 2 - 1;
            int v2 = v * 2;
            addEdge(u1, v1);
            addEdge(u2, v2);
            addEdge(v1, u1);
            addEdge(v2, u2);
    }
    for(int i = 1; i &lt; n; i++)          //枚举两对点
        for(int j = i + 1; j &lt;= n; j++)     //有四种情况
        {
            int u1 = i * 2 - 1;
            int u2 = i * 2;
            int v1 = j * 2 - 1;         //我是瞎子吗
            int v2 = j * 2;
            int dis1 = dis[i][0] + dis[j][0];
            int dis2 = dis[i][1] + dis[j][1];
            int dis3 = dis[i][0] + dis[j][1] + distant;
            int dis4 = dis[i][1] + dis[j][0] + distant;
            if(dis1 &gt; mid)                //u v 不能同时选0
            {
                addEdge(u1, v2);
                addEdge(v1, u2);
            }
            if(dis2 &gt; mid)              //u v不能同时选1
            {
                addEdge(u2, v1);
                addEdge(v2, u1);
            }
            if(dis3 &gt; mid)              //u选了0后v不能选1
            {
                addEdge(u1, v1);
                addEdge(v2, u2);
            }
            if(dis4 &gt; mid)              //u选了1后， v不能选0
            {
                addEdge(u2, v2);
                addEdge(v1, v1);
            }
        }

}
bool dfs(int u)
{
    if(mark[oth(u)])
        return false;
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++dfsSum] = u;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }

    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)
        if(mark[i] == false &amp;&amp; mark[i + 1] == false)
        {
            dfsSum = 0;
            if(dfs(i) == false)
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;

                if(dfs(i + 1) == false)
                    return false;
            }
        }
    return true;
}
// 的确可以用Tarjan写
/*void Tarjan(int u)
{
    vis[u] = true;
    dfn[u] = low[u] = ++tot;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;      //我是瞎了吗
      //  printf(&quot;@&quot;);
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
   // printf(&quot;@@@@&quot;);
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            //printf(&quot;?&quot;);
            int temp = st.top();
            st.pop();
            belong[temp] = sum;
            vis[temp] = false;
        }
        st.pop();
        belong[u] = sum;
        vis[u] = false;
    }
//    printf(&quot;?&quot;);
}
bool solve()
{
    for(int i = 1; i &lt;= 2*n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
//printf(&quot;there&quot;);
    for(int i = 1; i &lt;= 2*n; i += 2)
        if(belong[i] == belong[i + 1])
            return false;
  //  printf(&quot;here&quot;);
    return true;
}*/
int main()
{
    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b) != EOF)
    {
        //2n个点 12  34 ....
        scanf(&quot;%d%d%d%d&quot;, &amp;s1.x, &amp;s1.y, &amp;s2.x, &amp;s2.y);
        distant = getDis(s1, s2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y);
            dis[i][0] = getDis(node[i], s1);
            dis[i][1] = getDis(node[i], s2);
        }

        for(int i = 1; i &lt;= a; i++)
            scanf(&quot;%d%d&quot;, &amp;dislike[i].x, &amp;dislike[i].y);
        for(int i = 1; i &lt;= b; i++)
            scanf(&quot;%d%d&quot;, &amp;like[i].x, &amp;like[i].y);
        int L = 0;
        int R = 44444444;
        int mid;
        int ans = INF;      //最小的min
        while(L &lt;= R)
        {
           // printf(&quot;i am here\n&quot;);
            init();         //注意
            mid = (L + R) / 2;
          //  printf(&quot;mid = %d\n&quot;, mid);
            built(mid);     //添加一些边
            if(solve())
            {
                ans = mid;
                R = mid - 1;
          //      printf(&quot; i ma&quot;);
            }
            else
            {
                L = mid + 1;
            }
        }
        if(ans &lt; INF)
            printf(&quot;%d\n&quot;, ans);
        else
            printf(&quot;-1\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/04/HDU-1814PeacefulCommission/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/04/HDU-1814PeacefulCommission/" itemprop="url">HDU - 1814 Peaceful Commission</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-04T20:40:10+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>根据宪法，Byteland民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。 此委员会必须满足下列条件：每个党派都在委员会中恰有1个代表，如果2个代表彼此厌恶，则他们不能都属于委员会。<br>每个党在议会中有2个代表。代表从1编号到2n。 编号为2i-1和2i的代表属于第I个党派。<br>任务 写一程序：从文本文件读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表， 结果写入文本文件。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>因为要输出字典序最小的组合，所以只能用dfs来求。模板题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-03-22.43.10
 Question_Number   ：hdu 1814
 Question_Name     ：2sat 判断 + 输出
 Description       :
 最小字典序就只能暴力dfs
 // 通常而言，如果至少判断是否可行，则用缩点法
 如果要输出选择序列的话，就只能用dfs了

 对于每个当前不确定的变量ai，令ai=0然后沿着边DFS访问相连的点。
检查如果会导致任意一个j与j′都被选，那么撤销。否则令ai=0
否则令ai=1，重复2。如果还不行就无解。
继续考虑下一个不确定的变量

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 8e3 + 10;
const int MAXM = 2e4 + 10;
int head[2*MAXN], ans[2*MAXN];
bool mark[2*MAXN];
int n, m, cnt, dfsSum;
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXM];    //一对矛盾，就意味着两个边
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int oth(int x)  // 12是一对
{
    if(x % 2)   //1 就返回2
        return x + 1;
    else
        return x - 1;
}
bool dfs(int u)
{
    if(mark[oth(u)])
        return false;   //如果一对的两个点都被dfs到了，说明不行。
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++ dfsSum] = u;    // 第dfsSum的答案是真实图的u号点, from 1
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }
    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)//图中点的编号为1 ... 2n，枚举每队点
    {
        if(mark[i] == false &amp;&amp; mark[i + 1] == false) // 如果这对点都没有被选择过
        {
            dfsSum = 0;        //意思是从这个点开始dfs，cnt就是此次dfs涉及到的答案
            if(dfs(i) == false) //说明这样不可能，将此次dfs修改的mark标记清除
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;    //选的是j，但为了安全，把其对立点也清除
                if(dfs(oth(i)) == false)
                    return false;
            }
        }
    }
    return true;
}
void init()
{
    cnt = 0;
    memset(head, -1, sizeof head);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {   //有n个党派， 编号1 ... n
        //党派代表编号为 12  23 ...
        init();
        for(int i = 1; i &lt;= m; i++) //开始建边
        {
            int a, b;         //ab是有矛盾的代表编号
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addEdge(a, oth(b));
            addEdge(b, oth(a));
        }

        if(solve()) //能够适定，则输出答案，不能则输出NIE
        {
            for(int i = 1; i &lt;= 2*n; i += 2)    // 枚举每对点，输出这对的选择。
            {
                if(mark[i])
                    printf(&quot;%d\n&quot;, i);
                else
                    printf(&quot;%d\n&quot;, i + 1);
            }
        }
        else
            printf(&quot;NIE\n&quot;);

    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/04/%5B%E6%80%BB%E7%BB%93%5D%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E3%80%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/04/%5B%E6%80%BB%E7%BB%93%5D%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E3%80%82/" itemprop="url">[总结]图论基础刷题总结。</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-04T19:44:57+08:00">
                2019-09-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刷专题的成就感不错，但是需要进一步总结，使得能够明确哪些题目是图论题，是哪类图论题，该怎样解这道题….</p>
<p>将题目抽象简化并且总结归纳。</p>
<p><strong>不要把这个视为累赘，而应该是在享受进步。</strong></p>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><ul>
<li>单源最短路问题</li>
<li>多源最短路问题</li>
</ul>
<h3 id="生成树问题"><a href="#生成树问题" class="headerlink" title="生成树问题"></a>生成树问题</h3><ul>
<li>最小生成树</li>
<li>次小生成树</li>
<li>最小树形图</li>
<li>斯坦纳树</li>
</ul>
<h3 id="并查集问题"><a href="#并查集问题" class="headerlink" title="并查集问题"></a>并查集问题</h3><ul>
<li>简单并查集</li>
<li>带权并查集（种类并查集，异或并查集）</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ul>
<li>Tarjan求LCA</li>
<li>转化为RMQ问题求LCA</li>
</ul>
<h3 id="强连通问题"><a href="#强连通问题" class="headerlink" title="强连通问题"></a>强连通问题</h3><ul>
<li>判断强连通</li>
<li>添边变成强连通</li>
</ul>
<h3 id="双连通问题"><a href="#双连通问题" class="headerlink" title="双连通问题"></a>双连通问题</h3><ul>
<li>求割点</li>
<li>求割边</li>
<li>求边双连通分量</li>
<li>求点双连通分量</li>
</ul>
<h3 id="2-SAT问题"><a href="#2-SAT问题" class="headerlink" title="2-SAT问题"></a>2-SAT问题</h3><ul>
<li>判断适定性</li>
<li>字典序输出决策结果</li>
</ul>
<h3 id="欧拉回路问题："><a href="#欧拉回路问题：" class="headerlink" title="欧拉回路问题："></a>欧拉回路问题：</h3><h3 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h3><h3 id="二分匹配问题"><a href="#二分匹配问题" class="headerlink" title="二分匹配问题"></a>二分匹配问题</h3><p>——————分割线———————————————</p>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2 - SAT"></a>2 - SAT</h2><p>因为刚刷了不少这类题，趁热总结一下。</p>
<h3 id="刷题总结："><a href="#刷题总结：" class="headerlink" title="刷题总结："></a>刷题总结：</h3><p>常常配合 <strong>二分</strong>来使用 ： <strong>用二分来确定最大值的最小，最小值的最大</strong>等等</p>
<p>如果只是判断适定性，dfs和Tarjan缩点的方法都行。</p>
<p>如果要字典序输出，则只能用dfs。</p>
<h3 id="题目抽象："><a href="#题目抽象：" class="headerlink" title="题目抽象："></a>题目抽象：</h3><p>给你n个点，每个点有<strong>两种状态0 或 1</strong>， 不同点之间可能存在<strong>某些约束条件</strong>（例如i点的状态为0的话，j点状态必须为1 等等），<strong>问：是否存在满足这些约束条件的n个点，或者让你输出字典序最小的满足这些约束条件的n个点。</strong></p>
<p><strong>一些常用的建图方式（两个点A,B，A状态为0 表示为 A0 , A点状态为1 表示为A1 ）注意建图过程中，只看约束条件！！！填的边都是约束条件</strong></p>
<ul>
<li>A，B 不能同时取：A1 - &gt; B0; B1 - &gt; A0;</li>
<li>A，B 至少取一个：A0 - &gt; B1; B0 - &gt; A1;</li>
<li>A，B 必须同时选：A1 - &gt; B1 , B1 - &gt;A1;</li>
<li>A，B 必须选一个：A1 - &gt; B0，B1 - &gt; A0, A0 - &gt; B1, B0 - &gt; A1;</li>
<li>A必须选：A0 - &gt; A1</li>
</ul>
<p>建好图然后就是考虑怎么用图论的方式解决2-SAT了。</p>
<p>如果在以上约束条件下，A1 跟 A0在同一个环中，说明无法满足约束条件，所以在二分的时候，如果目前的mid满足了存在满足约定条件的解，那么可以适当添加边，否则就需要适当减少一些边。<strong>要清楚，图中边越多，就以为着约束条件越多，意味着A1 和 A0在同一个环的可能性越大</strong></p>
<h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><p>用dfs算法求解并字典序输出（ <a href="https://cn.vjudge.net/problem/21647/origin" target="_blank" rel="noopener">HDU - 1814</a> 模板题）</p>
<pre><code>bool dfs(int u)
{
    if(mark[oth(u)])
        return false;   //如果一对的两个点都被dfs到了，说明不行。
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++ dfsSum] = u;    // 第dfsSum的答案是真实图的u号点, from 1
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }
    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)//图中点的编号为1 ... 2n，枚举每队点
    {
        if(mark[i] == false &amp;&amp; mark[i + 1] == false) // 如果这对点都没有被选择过
        {
            dfsSum = 0;        //意思是从这个点开始dfs，cnt就是此次dfs涉及到的答案
            if(dfs(i) == false) //说明这样不可能，将此次dfs修改的mark标记清除
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;    //选的是j，但为了安全，把其对立点也清除
                if(dfs(oth(i)) == false)
                    return false;
            }
        }
    }
    return true;
}
..........部分代码略.............
       if(solve()) //能够适定，则输出答案，不能则输出NIE
        {
            for(int i = 1; i &lt;= 2*n; i += 2)    // 枚举每对点，输出这对的选择。
            {
                if(mark[i])
                    printf(&quot;%d\n&quot;, i);
                else
                    printf(&quot;%d\n&quot;, i + 1);
            }
        }
        else
            printf(&quot;NIE\n&quot;);</code></pre><p>用Tarjan缩点判断适定性</p>
<pre><code>   void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++dfsClock;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }

    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)
        if(dfn[i] == 0)
            Tarjan(i);  //对每个点进行缩点
    for(int i = 0; i &lt; n; i++)
        if(belong[i*2] == belong[i*2 + 1])
            return false;
    return true;
}
  ....部分代码略..............
        if(solve())
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);</code></pre><h3 id="题集-题解："><a href="#题集-题解：" class="headerlink" title="题集+题解："></a>题集+题解：</h3><p><a href="http://localhost/?p=192" target="_blank" rel="noopener">HDU – 3062 Party</a> 2-SAT适定性判断的模板题</p>
<p><a href="http://localhost/?p=194" target="_blank" rel="noopener">HDU – 1824 Let’s go home</a> 适定性判断的模板题</p>
<p><a href="http://localhost/?p=197" target="_blank" rel="noopener">HDU – 3622 Bomb Game</a> 二分 + 2 - SAT</p>
<p><a href="http://localhost/?p=199" target="_blank" rel="noopener">HDU – 3715 Go Deeper</a> 二分 +2 - SAT</p>
<p><a href="http://localhost/?p=207" target="_blank" rel="noopener">HDU – 1814 Peaceful Commission</a> dfs求2-SAT的模板题</p>
<p><a href="http://localhost/?p=210" target="_blank" rel="noopener">HDU – 1815 Building roads</a> 二分 + 2-SAT</p>
<p><a href="http://localhost/?p=212" target="_blank" rel="noopener">HDU – 1816 Get Luffy Out *</a> 二分 + 2-SAT</p>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h3 id="单源最短路问题"><a href="#单源最短路问题" class="headerlink" title="单源最短路问题"></a>单源最短路问题</h3><h4 id="Dijkstral算法："><a href="#Dijkstral算法：" class="headerlink" title="Dijkstral算法："></a>Dijkstral算法：</h4><p>我们首先得到一个边权值全为1的图，那么这个图中的单源最短路问题显然可以用BFS解。在解这个问题的时候，维护一个队列，这个队列存的是刚刚更新过的节点编号。并且在这个队列里面，排序的顺序是节点dis顺序递增的。也就是说，每次弹出的队首元素是目前确定下来的节点中的dis最小的那个。 根据等式dis[v] = dis[u] + 1; 要使得dis[v]最小，显然要取dis[u]，而我们每次都取出队列中dis最小的节点，让它去更新其他点，然后将更新过的点，放入队列中…直到队列为空。</p>
<p>即我们想要更新dis[v] = dis[u] + 1的话，一定要取最小的dis[u]。</p>
<p>当我们图的权值不全为1的时候，我们就需要来维护一个优先队列。每次出队的是目前dis最小的点，然后让它去更新dis[v] = dis[u] + w(u, v); 然后将v放入队列。虽然这个时候的dis[v] 不像之前那样就直接确定了，但可以确定是 dis[u] 肯定要小于dis[v] , 接下了队列中弹出下一个点去更新其他点，一直到v从队列中弹出时，dis[] 比他小的点已经全部弹出去更新点了，所以此时dis[v] 已经能够确定为最小值了。</p>
<h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman_Ford算法"></a>Bellman_Ford算法</h4><p>外层一个n - 1次循环，内层循环遍历每条边，进行松弛操作。</p>
<p>但我们发现，这样子nm就跑满了，有大部分冗余操作。我们实际上每次循环要考虑的边，是上次循环更新过的点发出的边。因此用一个队列进行优化，得到了SPFA算法</p>
<h2 id="割点与割边"><a href="#割点与割边" class="headerlink" title="割点与割边"></a>割点与割边</h2><p>在一个无向图中，如果有一个顶点集合，<strong>删除这个顶点集合以及这个集合中所有顶点相关联的边以后，图的连通分量增多，就称这个点集为割点集合</strong>，如果某个割点集合只含有一个顶点 X（也即{X}是一个割点集合），那么X称为一个割点。</p>
<p>类似的，在一个无向图中，如果有一个边集合，<strong>删除这个边集合以后，图的连通分量增多，就称这个边集为割边集合</strong>，如果某个割边集合只含有一条边 X（也即{X}是一个边集合），那么X称为一个割边，也叫做桥。</p>
<h3 id="Tarjan算法求割点与割边模板"><a href="#Tarjan算法求割点与割边模板" class="headerlink" title="Tarjan算法求割点与割边模板"></a>Tarjan算法求割点与割边模板</h3><p>我们先回顾一下Tarjan算法的精髓— dfn 和 low</p>
<p>dfn（x）为节点 x 搜索的次序编号（时间戳）；<br>low（x）为 x 或 x 的子树能够追溯到的最早的祖先的次序号。</p>
<p><strong>割点:</strong></p>
<p>对于一个点 u，有以下两种情况：</p>
<p>如果 u 是根节点，那么当它有多于一个子树时，它就是割点<br>如果 u 不是根节点，并且 u 为 v 在搜索树中的父亲，当 dfn[ u ] ≤ low[ v ] 时，它就是割点  </p>
<p><strong>割边:</strong></p>
<p>一条边（u，v）是割边，当且仅当 u 为 v 在搜索树中的父亲，并且 dfn[ u ] &lt; low[ v ]</p>
<p>在实现的时候，由于有重边的存在，我们还要用一个数组记录一下树枝边</p>
<p><strong>更新low值</strong></p>
<p>起初，low[ u ] = dfn [ u ]，表示能追溯到的最早祖先就是 u</p>
<p>现有一条边（u，v）</p>
<p>如果 dfn[ v ] == 0，那么就继续dfs，回溯的时候 low[ u ] = min ( low[ u ] , low[ v ] )</p>
<p>如果 dfn[ v ] != 0，那么 low[ u ] = min ( low[ u ] , dfn[ v ] )</p>
<p>求割点模板</p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2e4 + 10;
int cnt, head[MAXN], dfn[MAXN], root, low[MAXN], tot;
bool cut[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u, int root)
{
    int child = 0;
    tot++;
    dfn[u] = tot;
    low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v, root);
            low[u] = min(low[u], low[v]);
            if(u != root &amp;&amp; low[v] &gt;= dfn[u])   cut[u] = true;
            if(u == root)   child++;
        }
        low[u] = min(low[u], dfn[v]);
    }
    if(u == root &amp;&amp; child &gt;= 2) cut[root] = true;
}
int solve(int n, int m)
{
    for(int i = 1; i &lt;= n; i++)
        if(dfn[i] == 0)
            Tarjan(i, i);
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  ans++;
    return ans;
    /*
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  printf(&quot;%d&quot;, i);    //输出割点编号
    */
}
void init()
{
    cnt = tot = 0;
    memset(head, -1, sizeof head);
    memset(cut, false, sizeof cut);
    memset(dfn, 0, sizeof dfn);

}
int main()
{
    int t, kase = 0, n, m;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addEdge(a, b);
            addEdge(b, a);
        }
        int ans = solve(n, m);
        printf(&quot;Case %d: %d\n&quot;, ++kase, ans);            //割点的数目
    }
    return 0;
}</code></pre><p><strong>求割边模板</strong></p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
const int MAXM = 1e5 + 10;
int cnt, tot, head[MAXN], fron[MAXN], dfn[MAXN], low[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2], cut[MAXM * 2];
void addEdge(Edge *edge, int u, int v, int *head)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    tot = cnt = 0;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(fron, -1, sizeof fron);
}
void Tarjan(int u, int root)
{
    ++tot;
    dfn[u] = low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == root)   continue;   //双向边
        if(dfn[v] == 0)
        {
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] &gt; dfn[u])                 //AC
                if(u &lt; v)
                    addEdge(cut, u, v, fron);
                else addEdge(cut, v, u, fron);

        }
        low[u] = min(low[u], dfn[v]);
    }

}
int solve(int n)
{
    for(int i = 0; i &lt; n; i++)
        if(dfn[i] == 0) Tarjan(i, i);
    int ans = 0;
    for(int u = 0; u &lt; n; u++)
        for(int i = fron[u]; i != -1; i = cut[i].next)
            ans ++;
    return ans;
}
int main()
{
    int t, n;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        //点的数目
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            int u, k, v;
            scanf(&quot;%d (%d)&quot;, &amp;u, &amp;k);
            while(k--)
            {
                scanf(&quot;%d&quot;, &amp;v);
                addEdge(edge, u, v, head);
            }
        }
        cnt = 0;
        int ans = solve(n);
        printf(&quot;Case %d:\n&quot;, kase);
        printf(&quot;%d critical links\n&quot;, ans);
        for(int u = 0; u &lt; n; u++)          //点的编号从0开始
        {
            vector &lt; int &gt; vec;
            vec.clear();
            for(int i = fron[u]; i != -1; i = cut[i].next)
                vec.push_back(cut[i].v);
            sort(vec.begin(), vec.end());
            for(int i = 0; i &lt; vec.size(); i++)
                printf(&quot;%d - %d\n&quot;, u, vec[i]);
        }
    }
    return 0;
}</code></pre><h3 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h3><p>若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，<strong>即不存在割点（桥）</strong>，则称作点（边）双连通图。<strong>一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量</strong>。</p>
<p>Tarjan求边双连通分量模板</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/03/HDU-3715GoDeeper/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/03/HDU-3715GoDeeper/" itemprop="url">HDU - 3715 Go Deeper</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T22:30:03+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个递推式，问你最多能循环几层？</p>
<p>go(int dep, int n, int m)<br>begin<br>output the value of dep.<br>if dep &lt; m and x[a[dep]] + x[b[dep]] != c[dep] then go(dep + 1, n, m)<br>end   </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样的 二分答案+ 2-SAT。 代码不难敲，重要的是思路。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>二分部分：</p>
<pre><code>int L = 0;
int R = m;
int mid;
int ans = -1;
while(L &lt;= R) //一般整型就可以这样，浮点形的等于不好用。
{
    mid = (L + R) / 2;
    built(mid);             //一直到第mid个约束条件，那么深度就是mid - 1；每次都要建一个新图哦！！！
    if(solve())             //如果满足约束条件，说明深度可以变大，添加更多的约束条件
    {
        ans = max(ans, mid);
        L = mid + 1;        //如果mid = L的话  可以无限循环
    }
    else                    //不满足，说明减少一些深度
        R = mid - 1;
}</code></pre><p>完整代码+分析：</p>
<pre><code>/*
 Date              : 2019-09-03-18.47.52
 Question_Number   ：hdu 3715
 Question_Name     ：2 sat
 Description       :
 n = 2, m = 1;
 a 0
 b 1
 c 0

 x[ai] + x[bi] != ci;
 a1 表示a选0   意思是x这个数组里面ai位置选0
 a2 表示a选1                              1
 因为x这个数组长为n
 所以图中实际上有2n个点
 这2n个点，编号从0开始

 0 1   2 3   4 5

 a1  为 ai * 2;
 a2  为 ai * 2 + 1;
 b1 为

 i*2  i*2+1
 得到约束条件
 a1 - &gt; b2;
 b1 - &gt; a2;

 x[a] + x[b] != 1;
 a2 &gt; b2;
 b2 &gt; a2;
 a1 &gt; b1;
 b1 &gt; a1;

 x[a] + x[b] != 2;
 a2 &gt; b1;
 b2 &gt; a1;
 // 要使得他们不为0

 //为什么要二分呢？？  因为可以简化深度越大，意味着所连的边就越多
                                        //就越有可能ai 和 ai^1 形成一个环
                                        // 假如一个图中  所有 ai 和 ai ^ 1 都不在一个环内
                                        // 那么删掉一些边，这些对点肯定也不再一个环内
                                        // 这就出现了单调性
                                                //  最多有m个条件
        //  所以可以二分边界   0 &lt;= dep &lt;= m
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2*200 + 10;  //图中点的数目为
const int MAXM = 1e4 + 10;
int a[MAXM], b[MAXM], c[MAXM];
int dfn[MAXN], low[MAXN], belong[MAXN], head[MAXN];
bool vis[MAXN];
int n, m, cnt, sum, tot;
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXN * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    cnt = sum = tot = 0;
}
void built(int mid)
{
    init();                         //建图之前  清空图
    for(int i = 1; i &lt;= mid; i++)
    {
        int a1 = a[i] * 2;
        int a2 = a[i] * 2 + 1;
        int b1 = b[i] * 2;
        int b2 = b[i] * 2 + 1;
        switch(c[i])
        {
                case 0:
                    {
                        addEdge(a1, b2);
                        addEdge(b1, a2);
                        break;
                    }
                case 1:
                    {
                        addEdge(a2, b2);
                        addEdge(b2, a2);
                        addEdge(a1, b1);
                        addEdge(b1, a1);
                        break;
                    }
                case 2:
                    {
                        addEdge(a2, b1);
                        addEdge(b2, a1);
                        break;
                    }
        }
    }

}
void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++ tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)       //图中点的编号为0 ... 2n - 1
        if(dfn[i] == 0)
            Tarjan(i);
    for(int i = 0; i &lt; 2*n; i+= 2)
        if(belong[i] == belong[i + 1])
            return false;

    return true;
}
int main()
{
    int t;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
            scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;c[i]);
        int L = 0;
        int R = m;
        int mid;
        int ans = -1;
        while(L &lt;= R)
        {
            mid = (L + R) / 2;
            built(mid);             //一直到第mid个约束条件，那么深度就是mid - 1；
            if(solve())             //如果满足约束条件，说明深度可以变大，添加更多的约束条件
            {
                ans = max(ans, mid);
                L = mid + 1;        //如果mid = L的话  可以无限循环
            }
            else                    //不满足，说明减少一些深度
                R = mid - 1;
        }

         printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/03/HDU-3622BombGame/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/03/HDU-3622BombGame/" itemprop="url">HDU - 3622 Bomb Game</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T22:25:26+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>每回合给定两个坐标点，可以选择一个放置炸弹，自己决定炸弹的半径，问 n 个回合后，使炸弹半径最小值最大。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>二分答案 + 2-SAT;</p>
<p>如何看出用2-SAT呢，因为每回合有两个选择，只能选其中一个。</p>
<p>二分是因为，随着爆炸的半径越大，约束条件就越来越多，约束条件越来越多就意味着存在某对点在同一环的情况就越有可能发生。 是一个单调的，所以可以用二分来求。</p>
<p>二分确定一个半径，然后将所有点中距离小于这个两倍这个半径的两个点(a, b)找出来，说明这两个点在这个半径情况下，不能同时选择,所以一旦选择了a点，那么我们不能选择b点，只能选择b的对立点b^1(b^1 表示b的对立点)，同样的，一旦我们选择了b点，我们就只能选择a的对立点 (a^1 表示a的对立点) 。因此诞生了两个约束条件。</p>
<p>在这个半径的情况下，如果存在满足这个的可能，说明还能添加更多的约束条件，也就是还能添加更多边(约束边)，所以向更大的区间进行二分。如果不能满足这个可能，说明要减少一些边，才能使得某对点由原来的在同一个环中变成不在同一个环中的情况，也就是要往更小的区间二分。</p>
<p><strong>注意：每次二分一个条件后，要重新建一个图哦！！！</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>二分部分</p>
<pre><code>double L = 0.0;              
double R = 40001.0;
double ans = -1; //最大的半径
while( R - L &gt; eps)            // 如果是 R &lt;= L,  则 L = mid - 1 
                                                 // or R = mid + 1;
{
    double mid = (L + R) / 2;
    init();                            //每次都要重新建图！！！
    for(int i = 1; i &lt; 2*n; i += 2)  // 1 3 5 ..
        for(int j = i + 2; j &lt;= 2*n; j ++)//3 4 5 ...
        {
            if(getDis(node[i], node[j]) &lt; 2 * mid) //意思是i j 之间不能选
                int aj;
                if(j % 2)
                    aj = j + 1;
                else
                    aj = j - 1;
                addEdge(i, aj);  //j + 1是j的对立点
                addEdge(j, i + 1);
            }

    for(int i = 2; i &lt;= 2*n; i += 2) // 2 4 6 ...
        for(int j = i + 1; j &lt;= 2*n; j ++)// 3 5 6 ...
            if(getDis(node[i], node[j]) &lt; 2 * mid) //
            {
                int aj;
                if(j % 2)
                    aj = j + 1;
                else
                    aj = j - 1;
                addEdge(i, aj);
                addEdge(j, i - 1);
            }
    if(solve())                                     //这个mid可行，那么mid往右走，变大一些
    {
        ans = max(ans, mid);                        //记录答案
        L = mid;// 因为是 R &lt; L, 所以这样子ok
    }
    else
    {
        R = mid;
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/03/HDU-1824Let'sgohome/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/03/HDU-1824Let'sgohome/" itemprop="url">HDU - 1824 Let's go home</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T22:03:33+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>小时候，乡愁是一枚小小的邮票，我在这头，母亲在那头。<br>                        —— 余光中 </p>
<p>集训是辛苦的，道路是坎坷的，休息还是必须的。经过一段时间的训练，lcy决定让大家回家放松一下，但是训练还是得照常进行，lcy想出了如下回家规定，每一个队（三人一队）或者队长留下或者其余两名队员同时留下；每一对队员，如果队员A留下，则队员B必须回家休息下，或者B留下，A回家。由于今年集训队人数突破往年同期最高记录，管理难度相当大，lcy也不知道自己的决定是否可行，所以这个难题就交给你了，呵呵，好处嘛~，免费**漂流一日。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样的，根据题目给的条件，建立约束边。a1表示队长离开，a2表示队长留下，b1表示第一个队员离开 …..</p>
<p>那么对于第一个规定，如果队长留下了那么 其他队员肯定要离开，则形成了约束条件</p>
<p>a2 -&gt; b1 ; a2 -&gt; c1; //选了a2 就必选b1 c1</p>
<p>对于第一个规定，如果队长离开了，那么必然有其他两名队友留下</p>
<p>a1 -&gt; b2; a1 - &gt; c2 //</p>
<p>同样的，在第一种情况里面，如果b留下了，c肯定一同留下，b走了，c肯定一同走了，所以存在约束条件</p>
<p>b1 - &gt; c1; b2 - &gt; c2;</p>
<p>同样的b留下了， a肯定走， b走了，a肯定留下。。。。</p>
<p>对此会有一大堆约束条件</p>
<p>我们尽量以点来分类，对每个点的情况进行全方面的约束分析。</p>
<p>另外的规范的分析法</p>
<p>对于a点，如果a留下了，b肯定会走，c肯定会走</p>
<p>得到约束条件 a2 - &gt; b1, a2 - &gt; c1;</p>
<p>对于a点，如果a走了，b肯定会留下，c肯定会留下</p>
<p>得到约束条件 a1 - &gt; b2, a1 - &gt; c2;</p>
<p>对于b点，如果b走了，那么a肯定会留下，c肯定会走</p>
<p>b1 - &gt; a2; b1 - &gt; c1;</p>
<p>对于b点，如果b留下了，那么a肯定会离开，c肯定会留下</p>
<p>b2 - &gt; c2, b2 - &gt; a1;</p>
<p>对于c点，如果c走了，那么a肯定会留下，b肯定会走</p>
<p>c1 - &gt; a2, c1 - &gt;b1;</p>
<p>对于c点，如果c留下了，那么a肯定会离开，b肯定会走</p>
<p>c2 - &gt; a1; c2 - &gt; b2;</p>
<p>所以第一个规则下，诞生了12个约束条件</p>
<p>对于第二个规则，相对而言更直接，就不加赘述了。</p>
<p>此后，图建完了，跑一边Tarjan看看同一个点的两个状态是否在同一个环内，如果是则说明不符合条件..</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-03-12.55.06
 Question_Number   ：hdu 1824
 Question_Name     ：2 sat
 Description       :
 枚举每个队伍的情况，如果队长回去，然后继续枚举其他队伍，如果存在，则ok
 否则 队员回去..继续dfs
 题解比较硬核，就直接全部分析了
 好蠢的方法，但真香。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXM = 6 * MAXN;
stack &lt; int &gt; st;
int head[MAXM], low[MAXM], dfn[MAXM], belong[MAXM];
bool vis[MAXM];
int cnt, sum, n, m, tot;
struct Edge
{
    int v, next;
};
Edge edge[MAXM*MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
   // printf(&quot;?&quot;);
}
bool solve()
{
    for(int i = 0; i &lt; 2 * n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
   // printf(&quot;?&quot;);
    for(int i = 0; i &lt; n; i++)
        if(belong[i * 2] == belong[i * 2 + 1])
            return false;
    return true;
}
void init()
{
    cnt = sum = tot = n = 0;
    memset(head, -1, sizeof head);
    memset(vis, false, sizeof vis);
    memset(dfn, 0, sizeof dfn);
}
int main()
{
    int t;
    while(scanf(&quot;%d%d&quot;, &amp;t, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= t; i++)
        {
            int a, b, c;

            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            n = max(n, a);
            n = max(n, b);
            n = max(n, c);
            int a1 = a * 2;
            int a2 = a * 2 + 1;
            int b1 = b * 2;
            int b2 = b * 2 + 1;
            int c1 = c * 2;
            int c2 = c * 2 + 1;
            addEdge(a1, b2);    //a走b留
            addEdge(a1, c2);    //a  c
            addEdge(b1, c1);    //b走c走
            addEdge(b1, a2);
            addEdge(c1, b1);    //c走b走
            addEdge(c1, a2);

            addEdge(a2, b1);
            addEdge(a2, c1);
            addEdge(b2, a1);
            addEdge(b2, c2);
            addEdge(c2, a1);
            addEdge(c2, b2);

        }
        for(int i = 1; i &lt;= m; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            n = max(n, a);
            n = max(n, b);
            int a1 = a * 2;         //a 回去
            int a2 = a * 2 + 1;     //a 不回去
            int b1 = b * 2;
            int b2 = b * 2 + 1;
            addEdge(a1, b2);    //a回去，b就不能回去
            addEdge(b1, a2);    //b回去了，a就不能回去
        }
      //  printf(&quot;n = %d\n&quot;, n);
      //  printf(&quot;?&quot;);
        if(solve())
            printf(&quot;yes\n&quot;);    //直接用Tarjan缩点就行
        else
            printf(&quot;no\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/18/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/18/">18</a><span class="page-number current">19</span><a class="page-number" href="/tpaaaaaa.github.io/page/20/">20</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/20/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
