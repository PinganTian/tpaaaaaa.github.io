<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;22&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/22/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/29/HDU-1811RankofTetris/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/29/HDU-1811RankofTetris/" itemprop="url">HDU - 1811 Rank of Tetris</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-29T10:12:04+08:00">
                2019-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>兰兰工作之后独立开发了一个排名榜。 </p>
<p>为了更好地适应市场需求，兰兰想要制作一个实时更新的排名榜。这个排名榜是按照分数从高到底进行排名的。如果两个人的分数相同，那就按这几个人的幸运值从高到低来排。 </p>
<p>为了便于排名，每个人都被赋予了一个编号，从0到n-1,编号越大的人幸运值越高。<br>现在兰兰已知m个关于排名的信息，有三种类型，分别是”P &gt; Q”,”P = Q”,”P &lt; Q”，分别表示P的分数高于Q,等于Q,小于Q。 </p>
<p>兰兰并不需要你制作这个排名榜，只需要让你告诉他，根据已知的信息是否能够确定这个排名榜，能够确定就输出”OK”。否则输出错误的原因，如果是因为信息不完整，输出”UNCERTAIN”，如果是因为存在冲突的信息，输出”CONFLICT”。 如果错误原因有信息不完全且包含冲突信息，输出”CONFLICT”。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>理解题目意思。 给的是分数，如果分数相同则比较编号。我们可以将A&gt;B理解为AB之间存在着一条由B指向A的边。 那么就可以将原题理解为一个图。</p>
<p><strong>关于拓扑排序</strong>： 在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它之前的节点。 先统计所有节点的入度，<strong>对于入度为0的节点就可以分离出来</strong>，然后把这个节点指向的节点的入度减一。 一直做改操作，直到所有的节点都被分离出来。 <strong>如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况</strong>。</p>
<p>关于此题： 首先将分数相同的合并到一个集合里面，简化成一个点看 大致排名 分数高的 &gt; 分数中的（有一堆相同的） &gt; 分数低的</p>
<p><strong>然后相同的里面又按照编号来排名，所以只需要保证输入的时候，相同数分数 和其根分数大小不发生冲突即可</strong></p>
<p>然后对于不同分数的，我们可以建一个有向图， 分数低的指向分数高的 最后对这个图进行分析 。</p>
<p>如果这个图不能进行拓扑排序，说明存在环，则输出冲突</p>
<p>不能进行拓扑排序的意思是，逐步弹点后，不存在入度为0 的点了. 也就是<strong>已经拓扑排序的点的数目 要小于 总的点（相同的分数理解为一个点了）的个数</strong></p>
<p>如果能有多条拓扑排序，则输出无法判断</p>
<p>意思是某次弹点时，<strong>入度为0的点的数目大于1个，也就是说明有多个选择…所以无法判断</strong></p>
<p>如果只有一条拓扑排序，则输出ok</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是建图部分的代码</p>
<pre><code>for(int i = 1; i &lt;= m; i++)   
{
    int f1 = findRoot(node[i].x);
    int f2 = findRoot(node[i].y);
    if(f1 == f2 &amp;&amp; node[i].w != 0)                 //是同一个点,但却有大小，说明冲突了
    {
       conflict = true;                             //==部分发生了冲突
       break;
    }
    else if(f1 != f2)
    {
        if(node[i].w == 0)          //将这两个联通分量联系在一起
            pre[f2] = f1;
        if(node[i].w == 1)
            addEdge(f2, f1);        //连一条指向f1的边,f1的入度要加1
        else if(node[i].w == 2)
            addEdge(f1, f2);
    }
}</code></pre><p>拓扑排序部分：</p>
<pre><code>int solve()
{
    int sum = 0;                //sum记录图中联通分量（将相等部分看做点）的数目
    queue &lt; int &gt; Q;            //存的是入度为0 的点
    for(int i = 0; i &lt; n; i++)  //对每个点进行遍历一次，看看有多少个连通分量
        if(findRoot(i) == i)  
        {
            sum++;
            if(in[i] == 0)      //具有入度为0的点
                Q.push(i);
        }
    int temSum = 0;             //记录拓扑排序涉及到的点，如果点的数目少于sum，则说明存在环，说明冲突了
    bool uncertain = false;
    while(!Q.empty())           //一直到没有入度为0的点位置
    {
        if(Q.size() &gt;= 2)       //大于1个
            uncertain = true;    //无法判断,但是冲突的优先级大于无法判断的。
                                 //所以不能着急退出循环，因为有可能之后出现冲突的情况
        int u = Q.front();
        Q.pop();                  //然后将这个点连接的所有点的入度减1;
        temSum ++;                //弹出点数目
        for(int i = head[u]; i != -1; i = edge[i].next) //遍历与弹出点相连的点
                                                        //将他们的入度减一
        {
            int v = findRoot(edge[i].to);
            in[v]--;
            if(in[v] == 0)  //减为0了
                Q.push(v);  //加入入度为0的点队列中
        }
    }
    if(temSum &lt; sum)
        return -1;
    else if(uncertain == false)
        return 1;
    else
        return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/29/HDU-2874Connectionsbetweencities/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/29/HDU-2874Connectionsbetweencities/" itemprop="url">HDU - 2874 Connections between cities</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-29T09:56:28+08:00">
                2019-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>第一次世界大战后，许多城市遭到严重破坏，我们需要重建这些城市。但是，某些材料只能在某些地方生产。所以我们需要将这些材料从一个城市运到另一个城市。由于战争期间大部分道路已被完全摧毁，两个城市之间可能没有路径，也没有环存在。 现在，你的任务来了。在告诉您道路状况后，我们想知道任何两个城市之间是否存在路径。如果答案是肯定的，则输出它们之间的最短路径。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目给你的是森林，不是一棵树，所以存在两点不连通的情况，在使用Tarjan遍历询问的时候，之前是判断这个点vis[v] == true ，现在就是判断这个点的vis[v] == tot，也就是说vis这个点记录的不单单是访问过没有，也记录了这点是遍历哪一棵树时候访问过的。</p>
<p>主要改动是：</p>
<pre><code>for(int i = 1; i &lt;= n; i++)  //之前是直接Tarjan(1)，现在是枚举每一个未遍历过的点来进行访问，每次访问的访问标记不同，依次来区别属于哪棵树。
{
    if(vis[i] == 0)
    {
        dis[i] = 0; //dir[i]存的是这棵树到自己根的距离
        k++;
        Tarjan(i, k);
    }
}</code></pre><p>第二个改动就是</p>
<pre><code>for(int i = headq[s]; i != -1; i = ques[i].next)
{
    int v = ques[i].y;
    if(vis[v] == k)  //是在同一棵树下访问过的
    {
        if(i % 2)
            ques[i].lca = ques[i + 1].lca = findRoot(v);
        else
            ques[i].lca = ques[i - 1].lca = findRoot(v);
    }
}</code></pre><p>最后输出时候，每个询问的LCA如果为-1，就意味着这两个点不连通。</p>
<pre><code>for(int i = 1; i &lt;= c; i++)
{
    int j = i * 2;
    int u = ques[j].x;
    int v = ques[j].y;
    int lca = ques[j].lca;      //lca存的最近公共祖先的点编号
    if(lca == -1 )
        printf(&quot;Not connected\n&quot;);
    else
        printf(&quot;%d\n&quot;, dis[u] + dis[v] - 2*dis[lca]);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/29/HDU-2586Howfaraway%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/29/HDU-2586Howfaraway%EF%BC%9F/" itemprop="url">HDU - 2586 How far away ？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-29T09:38:56+08:00">
                2019-08-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>勇气小镇是一个有着n个房屋的小镇，为什么把它叫做勇气小镇呢，这个故事就要从勇气小镇成立的那天说起了，<br>修建小镇的时候，为了让小镇有特色，镇长特地只修了n-1条路，并且规定说，所有在勇气小镇的村民，每一次出门必须规划好路线,<br>路线必须满足在到达终点之前绝对不走回头路。每个人都要这样，不然那个人就不配在小镇生活下去，因为他没有这个勇气。<br>事实上，这并不能算一项挑战，因为n-1条路已经连通了每户人家，不回头地从起点到终点，只是一个时间上的问题。<br>由于小镇上的福利特别好，所以小懒入住了这个小镇，他规划了m次的行程，每次从L房屋到R房屋,他想问你他每次从L房屋到R房屋需要走多远的路。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>给你一棵树，让你求出任意两点的最短距离。 树上点的最短距离问题，可以用最近公共祖先来解决。 dis[i]数组表示i节点距离根节点的距离。对于L和R，我们首先得到LCA， 然后则L到R的最短距离路径就是L往上走，走到LCA，再往下走走到R。</p>
<p>因此最短距离就是 <strong>dis[L] + dis[R] - 2 * dis[LCA]</strong></p>
<p>所以问题就变成了如何求树上两点的LCA了。用离线算法Tarjan可以，或者将LCA转化为RMQ问题求解也可以。下面就依这个题目为依据，将两个方法都具体的解释一遍</p>
<h2 id="Tarjan："><a href="#Tarjan：" class="headerlink" title="Tarjan："></a>Tarjan：</h2><p>首先是输入部分：将边和询问关系全部录入相应的结构体数组中</p>
<pre><code>for(int i = 1; i &lt; n; i++)  // n 个点， 一棵树的话就有n - 1条边
{
    int x, y, w;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
    addEdge(x, y, w);     //无向边
    addEdge(y, x, w);
}
for(int i = 1; i &lt;= m; i++) //问题的编号1.2    3.4   5.6   ....
{
    int x, y;
    scanf(&quot;%d%d&quot;,&amp;x, &amp;y);
    addQues(x, y);            
    addQues(y, x);
}</code></pre><p>接下来以1为根节点，开始Tarjan （其本质就是DFS）</p>
<pre><code>void Tarjan(int s)        //根节点为s
{
    vis[s] = true;        //标记已访问
    pre[s] = s;           //都是自己
    for(int i = head[s]; i != -1; i = edge[i].next) // 开始遍历自己的子节点
        if(vis[edge[i].to] == false)  //这个节点没有访问过
        {
            int v = edge[i].to;
            int w = edge[i].w;
            dis[v] = dis[s] + w;      //更新这个节点的dis数组
            Tarjan(v);                //从这个节点开始继续dfs
            pre[v] = pre[s];          //这个节点dfs回来后，将子树与根合并
            //合并
        }
    for(int i = Qhead[s]; i != -1; i = ques[i].next) //开始遍历每个与s相关的询问
    {
        if(vis[ques[i].to] == true)          //如果这个点已经访问过了。
        {
            int v = ques[i].to;
            if(i%2)
                ques[i].lca = ques[i + 1].lca = findRoot(v);
            else
                ques[i].lca = ques[i - 1].lca = findRoot(v);
        }
    }
}</code></pre><p>所有处理完后，开始输出答案</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    int j = i * 2; // 因为ques[1]ques[2]； ques[3]ques[4] ...是同一个询问
    int u = ques[j].from, v = ques[j].to;
    int lca = ques[j].lca; // 这是这个询问的LCA
    printf(&quot;%d\n&quot;, dir[u] + dir[v] - 2 * dir[lca]);
}</code></pre><h2 id="LCA转RMQ："><a href="#LCA转RMQ：" class="headerlink" title="LCA转RMQ："></a>LCA转RMQ：</h2><p>首先是输入部分：因为是在线算法，所以不需要提前将询问录入</p>
<pre><code>for(int i = 1; i &lt; n; i++)
{
    int u, v, w;
    scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
    addEdge(u, v, w);          //无向边
    addEdge(v, u, w);
}</code></pre><p>接下来也是从根节点开始DFS，生成ver数组（DFS的欧拉序列），depth数组（DFS每次的深度）, dis数组（节点距离根节点的距离），first数组（每个节点第一次出现在ver数组之中的下标）。</p>
<pre><code>void dfs(int u, int dep)
{
    vis[u] = true;  //dfs 的标记           
    ver[++tot] = u; //ver记录的是欧拉序列, tot记录的是节点的访问编号
    first[u] = tot; //u这个点第一次出现的位置
    depth[tot] = dep;   //深度表
    for(int k = head[u]; k != -1; k = edge[k].next) //遍历下一个点
    {
        int v = edge[k].v;
        if(vis[v] == false)
        {
            int w = edge[k].w;
            dis[v] = dis[u] + w;    //更新距离
            dfs(v, dep + 1);        // 向下dfs
            ver[++tot] = u;         //递归下去又上来了
            depth[tot] = dep;
        }
    }
}</code></pre><p>这RMQ求的是区间里面深度最小的点。</p>
<p>如果欧拉序列ver:1 <strong>2</strong> 5 2 6 2 1 3 1 <strong>4</strong> 1；深度序列Depth为: 0 <strong>1</strong> 2 1 2 1 <strong>0</strong> 1 0 <strong>1</strong> 0，first(u)为:1 <strong>2</strong> 8 <strong>10</strong> 3 5。 如果我们要求 2号点到4号点的LCA。则首先利用first数组知道2号点第一次出现在ver数组中的第2个位置，4号点第一次出现在ver数组的第10个位置，那么我们要找的就是depth数组中[2, 10]这个区间里面深度最小的点，显然为depth第7个位置(深度为0)，其对应在ver数组中为 1号点，也就是说2号点和4号点的最近公共祖先是1号点。</p>
<p>求完以上几个数组，还有一个重要的数组要求，就是dp数组，用的是动态规划的思想, dp[i][j] 表示的是从ver第i个点开始的2^j 个点中的深度最小的点的编号，我们用ST函数求。</p>
<pre><code>void ST(int len)                    //len是ver数组的长度
{
    int k = (int) (log((double) len ) / log(2.0) ); //意思是最长的长度为len == 2^k次 
    for(int i = 1; i &lt;= len; i++)   //初始化
        dp[i][0] = i;               //这记得的深度最下的点的下标
    for(int j = 1; j &lt;= k; j++)     //首先枚举j
        for(int i = 1; i + _pow[j] - 1 &lt;= len; i++) // 枚举起点
                                     //这一次枚举考虑的区间就是[i, i + 2^j - 1]
        {
            int a = dp[i][j - 1];    //这个区间的最值，就是将这个区间分成a，b两个区间的这两个区间中的最值的最值。因为原区间为从i开始，连续的2^j个点，所以a区间就是从i开始，连续的2^(j-1)个点，b区间就是从i + 2^(j - 1)开始的连续的2^(j-1)个点
            int b = dp[i + _pow[j - 1]] [j - 1];
            if(depth[a] &lt; depth[b])
                dp[i][j] = a;
            else
                dp[i][j] = b;
        }
}</code></pre><p>然后求的是RMQ函数，作用是返回ver区间中[x, y]这个区间里面深度最小的点的下标。</p>
<pre><code>int RMQ(int x, int y)
{
    int k = (int)(log((double)(y-x+1)) / log(2.0));
    int a = dp[x][k];
    int b = dp[y - _pow[k] + 1][k];
    if(depth[a] &lt; depth[b])
        return a;
    else
        return b;
}</code></pre><p>然后就是LCA函数了，返回的是u号点和v号点的LCA点的编号</p>
<pre><code>int LCA(int u, int v)   // 求的是u 和v的LCA
{
    int x = first[u], y = first[v]; 
    if(x &gt; y)
        swap(x, y);          //要保证x在前，y在后
    int res = RMQ(x, y);    //返回的是在ver的下标
    return ver[res];
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/28/%5B%E7%AE%97%E6%B3%95%5DRMQ%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9F%A5%E8%AF%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/28/%5B%E7%AE%97%E6%B3%95%5DRMQ%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9F%A5%E8%AF%A2/" itemprop="url">[算法]RMQ区间最值查询</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-28T16:03:19+08:00">
                2019-08-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>RMQ（Range Minimum/Maximum Query），即区间最值查询，这是一种在线算法，所谓在线算法，是指用户每次输入一个查询，便马上处理一个查询。RMQ算法一般用较长时间做预处理，时间复杂度为O(nlogn)，然后可以在O（1）的时间内处理每次查询。</p>
<p>下面我们从一个实际问题来解释RMQ</p>
<p>我们假设数组arr为：1，2，6，8，4，3，7</p>
<p>我们设二维数组dp[i][j]表示从第i位开始连续2^j个数中的最小值。例如dp[2][1]就表示从第二位数开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），即2，6中的最小值，所以dp[2][1] = 2;</p>
<p>其实我们求 dp[i][j] 的时候可以把它分成两部分，第一部分是从 i 到 i + 2^(j - 1) - 1 ，第二部分从 i + 2 ^( j - 1) 到 i + 2 ^ j - 1，为什么可以这么分呢？其实我们都知道二进制数前一个数是后一个的两倍，那么可以把 到 这个区间通过分成相等的两部分， 那么转移方程很容易就写出来了。（dp[i][0]就表示第i个数字本身）</p>
<p><strong>dp[i][j] = min(dp [i][j - 1], dp [i + (1 &lt;&lt; j - 1)][j - 1])</strong></p>
<p>现在求出了F[i,j]之后又是怎样求出最大值或者最小值的，怎么转换为o(1)这种算法的~这就是ST算法：</p>
<p>假设我们需要查询区间[l ，r]中的最小值，令k = ln以2为底(j-i+1) <img src="http://localhost/wp-content/uploads/2019/08/%E5%9B%BE%E7%89%87.gif" alt=""> ， 则区间[l, r]的最小值RMQ[l,r] = min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);</p>
<p>但是为什么这样就可以保证是区间最小值了呢？</p>
<p>dp[l][k]维护的是区间 [l, l + 2^k - 1] , dp[r - (1 &lt;&lt; k) + 1][k]维护的是区间 [r - 2^k + 1, r] 。</p>
<p>那么只要我们保证  r - (1 &lt;&lt; k) + 1 ≤ l + 2^k - 1 就能保证RMQ[l,r] = min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k])；</p>
<p>这个时候询问时只要取k=ln(j-i+1)/ln2即可，那么可以令A为i到2^k的块，和B为到2^k结束的长度为2^k的块;那么A，B都是区间[i,j]的子区间，所以即求A区间的最小值和B区间的最小值的最小值。这个时候动态规划为：<strong>RMQ(i,j)=min(dp[i,k],dp[j-2^k+1,k]);</strong></p>
<h2 id="LCA问题转RMQ问题："><a href="#LCA问题转RMQ问题：" class="headerlink" title="LCA问题转RMQ问题："></a>LCA问题转RMQ问题：</h2><p>当然对于RMQ并不只有这个用法，我们可以用它来解决LCA问题。<br> 假设LCA(T,u,v)表示在有根树T中，询问一个离根最远的结点x,使得x为u,v的公共祖先。现在分析下LCA向RMQ问题转化的过程:</p>
<p>对有根树T进行深度优先遍历(DFS),将遍历到的结点按照顺序记录下来，那么我们会得到一个长度为2N-1的序列，称之为T的欧拉序列F，设序列Depth是DFS遍历过程中的结点深度的变化情况。其中每一个结点都会出现在欧拉序列F中，我们记录结点u在欧拉序列中出现的第一个位置pos(u);根据DFS的特性，对于任意两个结点u,v，那么从pos(u)(也就是第一次访问u的时候)到pos(v)(第一次访问v)的过程中，所经历的路径为F(pos(u)…..pos(v)),虽然这些包括u的后代，但是其深度最小的结点一定是u和v的LCA(公共祖先)，不论pos(u)与pos(v)的关系如何，都一定有LCA(T,u,v)=RMQ(Depth,pos(u),pos(v));</p>
<p>下面这个图是有根树的欧拉序列F和深度序列B已经pos(u)的变化情况:</p>
<pre><code>                  1                   深度为0

             /     \     \

       **2**          **3**     4          深度为1

     /   \

5        6                          深度为2</code></pre><p>那么欧拉序列F:1 <strong>2</strong> 5 2 6 2 1 <strong>3</strong> 1 4 1；深度序列Depth为: 0 1 2 1 2 1 0 1 0 1 0，pos(u)为:1 2 8 10 3 5<br>妙哉妙哉</p>
<p>所以步骤就是，首先从根开始用dfs求出 欧拉序列，深度序列，pos数组, dis数组</p>
<p>然后对RMQ中的dp数组初始化</p>
<p>对于每一个询问, u 跟 v, 我们用pos[u], pos[v] 知道其在欧拉序列中的编号L,R</p>
<p>然后求出欧拉序列[L，R]中 深度最小的点，就是u跟v的LCA了</p>
<p>RMQ模板：  </p>
<hr>
<pre><code> // dp[i][j] 保存的是[i, i + 2^j - 1] 这个区间里面的最小值
void rmq_init()  // 作用是初始化dp数组， 题目给的数组是arr[1] ... arr[N]
{
    for(int i=1;i&lt;=N;i++)
        dp[i][0]=arr[i];//初始化
    for(int j=1;(1&lt;&lt;j)&lt;=N;j++)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]);

}

//rmq(l, r) 的作用是查询区间[l, r]中的最小值
int rmq(int l,int r)
{
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/27/%5B%E6%A8%A1%E6%9D%BF%5DLCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/27/%5B%E6%A8%A1%E6%9D%BF%5DLCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" itemprop="url">[模板]LCA最近公共祖先</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T23:04:04+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tarjan-离线-算法-："><a href="#Tarjan-离线-算法-：" class="headerlink" title="Tarjan(离线)算法 ："></a>Tarjan(离线)算法 ：</h2><p>博文推荐：<a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p>
<p>TarjanTarjan 算法基于 dfs ，在 dfs 的过程中，对于每个节点位置的询问做出相应的回答。</p>
<p>　　dfs 的过程中，当一棵子树被搜索完成之后，就把他和他的父亲合并成同一集合；在搜索当前子树节点的询问时，如果该询问的另一个节点已经被访问过，那么该编号的询问是被标记了的，于是直接输出当前状态下，另一个节点所在的并查集的祖先；如果另一个节点还没有被访问过，那么就做下标记，继续 dfs 。</p>
<h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><pre><code>#include&lt;cstdio&gt;
#define N 420000
struct hehe{
    int next;
    int to;
    int lca;
};
hehe edge[N];//树的链表
hehe qedge[N];//需要查询LCA的两节点的链表
int n,m,p,x,y;
int num_edge,num_qedge,head[N],qhead[N];
int father[N];
int visit[N];//判断是否被找过
void add_edge(int from,int to){//建立树的链表
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    head[from]=num_edge;
}
void add_qedge(int from,int to){//建立需要查询LCA的两节点的链表
    qedge[++num_qedge].next=qhead[from];
    qedge[num_qedge].to=to;
    qhead[from]=num_qedge;
}
int find(int z){//找爹函数
    if(father[z]!=z)
        father[z]=find(father[z]);
    return father[z];
}
int dfs(int x){//把整棵树的一部分看作以节点x为根节点的小树
    father[x]=x;//由于节点x被看作是根节点，所以把x的father设为它自己
    visit[x]=1;//标记为已被搜索过
    for(int k=head[x]; k; k=edge[k].next)//遍历所有与x相连的节点
        if(!visit[edge[k].to]){//若未被搜索
            dfs(edge[k].to);//以该节点为根节点搞小树
            father[edge[k].to]=x;//把x的孩子节点的father重新设为x
        }
    for(int k=qhead[x]; k; k=qedge[k].next)//搜索包含节点x的所有询问
        if(visit[qedge[k].to]){//如果另一节点已被搜索过
            qedge[k].lca=find(qedge[k].to);//把另一节点的祖先设为这两个节点的最近公共祖先
            if(k%2)//由于将每一组查询变为两组，所以2n-1和2n的结果是一样的
                qedge[k+1].lca=qedge[k].lca;
            else
                qedge[k-1].lca=qedge[k].lca;
        }
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p);//输入节点数，查询数和根节点
    for(int i=1;i&lt;n;++i){    //因为有n个点，树肯定只有n-1个边
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//输入每条边
        add_edge(x,y);
        add_edge(y,x);
    }
    for(int i=1;i&lt;=m;++i){
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//输入每次查询，考虑(u,v)时若查找到u但v未被查找，所以将(u,v)(v,u)全部记录
        add_qedge(x,y);
        add_qedge(y,x);
    }
    dfs(p);//进入以p为根节点的树的深搜
    for(int i=1;i&lt;=m;i++)
        printf(&quot;%d &quot;,qedge[i*2].lca);//两者结果一样，只输出一组即可
    return 0;
}</code></pre><h2 id="倍增算法："><a href="#倍增算法：" class="headerlink" title="倍增算法："></a>倍增算法：</h2><p>推荐博文：<a href="https://www.cnblogs.com/sllr15/p/5164996.html" target="_blank" rel="noopener">https://www.cnblogs.com/sllr15/p/5164996.html</a></p>
<p><a href="https://www.cnblogs.com/zwfymqz/p/7795299.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/p/7795299.html</a></p>
<p>在没有学习倍增写LCA之前，你是怎么样求LCA的呢？至少，我是老老实实地让这两个点一步一步往上移并找出它们的路径第一次交汇的地方。这种方法固然可行、好想，但它的效率实在不高。但是，我们完全可以通过提高“这两个点一步一步往上移”来提高效率。</p>
<p>所以，我们采用倍增的思路来预处理，分别记录这点的祖先，记录为anc[i][j]。即为第i个点往上2^j个祖先。比如说，当j=0时，2^j=1,anc[i][j]是第i个点的上一个节点，即它的父亲节点。</p>
<p>那么该如何预处理出anc数组呢？</p>
<pre><code>int anc[1005][25];
int fa[1005];
vector &lt;int &gt; tree[1005];
int deep[1005];

void dfs(int x)
{
    anc[x][0]=fa[x]; //x这个节点向上1个节点就是他的父节点
    for (int i=1;i&lt;=22;i++) // 往上处理
    {
        anc[x][i]=anc[anc[x][i-1]][i-1];//倍增思想的体现。不妨在纸上试着画一棵树，脑补一下QWQ
    }
    // anc[x][1] = anc[ anc[x][0] ] [0] x向上两个节点就是他父节点的父节点
    // anc[x][2] = anc[ anc[x][1] ] [1]; 
    //以此类推
    for (int i=0;i&lt;tree[x].size();i++) // 往下处理
    {
        if (tree[x][i]!=fa[x])
        {
            int y=tree[x][i];
            fa[y]=x;//记录父亲节点
            deep[y]=deep[x]+1;//记录深度
            dfs(y);
        }
    }
}

int lca(int x,int y)
{
    if (deep[x]&lt;deep[y]) _swap(x,y);//我们希望X是较深的点。

    for (int i=22;i&gt;=0;i--)//这个循环在完成第一步。
    {
        if (deep[y]&lt;=deep[anc[x][i]]) //不可以丢掉“=“哦Q^Q
        {
            x=anc[x][i];
        }
    }

    if (x==y) return x;//如果Y是X的祖先，就可以直接返回结果了。

    for (int i=22;i&gt;=0;i--)
    {
        if (anc[x][i]!=anc[y][i]) //第二步。
        {
            x=anc[x][i];
            y=anc[y][i];
        }
    }

    return anc[x][0];//注意第二步IF语句的条件。
}</code></pre><p>另一个博主<a href="https://blog.csdn.net/Q_M_X_D_D_/article/details/89924963" target="_blank" rel="noopener">https://blog.csdn.net/Q_M_X_D_D_/article/details/89924963</a></p>
<p>  DP[4][1]=1；结点4的向上2^1=2层的祖先是结点1。<br>        DP[10][1]=2；结点10的向上2^1=2层的祖先是结点2。<br>        特别地，DP[6][0]=3，结点6的向上2^0=1层的祖先是3，即6的父节点。而这一现象正好可以当做DP的初始条件。DP[i][0]为i的父节点。下面写出递推式：</p>
<pre><code>    DP\[i\]\[j\] = DP\[ DP\[i\]\[j-1\] \] \[j-1\]。        如何理解这个递推式呢？DP\[i\]\[j-1\]是结点i往上跳2^(j-1)层的祖先，那我们就在跳到这个结点的基础上，再向上跳2^(j-1)层，这样就相当于从结点i，先跳2^(j-1)层，再跳2^(j-1)层，最后还是到达了2^j层。这部分的代码如下：

//fa表示每个点的父节点 
int fa[100],DP[100][20];
void init()
{
    //n为结点数，先初始化DP数组 
    for(int i=1;i&lt;=n;i++)
        dp[i][0]=fa[i];
    //动态规划求出整个DP数组 
    for(int j=1;(1&lt;&lt;j)&lt;=n;j++)
        for(int i=1;i&lt;=n;i++)
            DP[i][j]=DP[DP[i][j-1]][j-1];
}</code></pre><p>查询函数：<br>        这个函数的参数就是要查询的两个结点a和b。在函数中我们应指定a是深度较大的那个（b也可以），这样方便操作。然后让b不断向上回溯，直到跟a处于同一深度。然后让a和b同时向上回溯，直到二者相遇。这个过程不难理解，但是要实现我们刚才说的一步跳好几层就需要细细思考了。在函数中，共有两次回溯，一次是发生在使a与b处于同一深度时，另一次发生在使a和b共同向上回溯找LCA时，下面我们运用刚才说的两个关键理论对这两次回溯分别进行分析：</p>
<p>假设a和b的深度相差5，我们需要让b向上跳，步步逼近a所在的深度，直到与a同深度。如何选取这个步长呢？两个原则：<br>1、选取的步长肯定不能大于二者的深度差，否则b的深度就小于a的了；<br>2、选择最接近深度差但又不大于深度差的2的幂次数。这使我们每一步都不会超出a，而且步步逼近a。<br>那么我们要做的就是本着这两个原则，根据二者的深度差来选取合适的步长，步步逼近。根据正整数拆分理论，不管深度差是多少，二者最后一定能处于同一深度。<br>第二次回溯与第一次不同的是：第一次回溯，已经知道了要跳多少层，所以就可以用正整数拆分理论选择步长。而这次回溯是要找LCA，即找一个层数使a和b跳上去之后正好相遇，也就是说我们只能试探着往上跳，步步逼近。<br>那我们如何选取a和b同时向上跳的步长？这里用到了我们刚才说的第二个关键理论：若c是a和b的LCA，则c的祖先也是a和b的祖先，但不是最近的。所以这里选取步长的原则就是：大胆地、试探性地往上跳。<br>可能出现两种情况：<br>1、若跳到了某一层后a和b相遇了，则说明相遇处的结点就是a和b的公共祖先，但不一定是最近的。这个点就告诉我们：LCA可能还在这个点的下方。那我们就不往这个点上跳，因为这个点有可能不是我们要找的LCA。<br>2、若跳到了某一层后，a和b没有相遇，则说明a和b的LCA在这层之上，那我们完全可以跳到这一层上，这会使我们步步逼近最终的LCA。根据正整数拆分理论，我们最后也一定能找到LCA。<br>        第一次回溯比较容易理解。重点说一下第二次回溯。换个角度讲，假设我们事先知道LCA与a、b差10层，那么我们如果一步跳了10层以上的话，肯定会跳到LCA的祖先上，那我们就减少步长。如果一步跳8层的话，a和b肯定没有相遇，这时我们就可以跳上来。然后LCA与a、b就差两层了。虽然再跳两层就到了，但是程序只知道这是a和b的公共祖先，但不知道这是不是最近公共祖先，而我们只是开了上帝视角知道了而已，所以程度就会放弃2这个步长，还会将步长减小为1并跳上去。当步长减小为1时，这个试探的过程就可以结束了，因为LCA肯定就是此时a和b的父节点。</p>
<pre><code>    不管LCA与a、b差几层，哪怕是8层、4层这种一步就可以跳上去的情况，程序也不会一步跳上去，因为程序总觉得可能这不是最近的公共祖先。而是会步步逼近，直到与LCA只差一层。所以当试探结束后，a和b的父节点就是他们的LCA啦。结合代码理解一下：  


//查询函数
int LCA(int a,int b)
{
    //确保a的深度大于b，便于后面操作。
    if(dep[a]&lt;dep[b])
        swap(a,b);
    //让a不断往上跳，直到与b处于同一深度
    //若不能确保a的深度大于b，则在这一步中就无法确定往上跳的是a还是b
    for(int i=19;i&gt;=0;i--)
    {
        //往上跳就是深度减少的过程
        if(dep[a]-(1&lt;&lt;i)&gt;=dep[b])
            a=dp[a][i];
    }
    //若二者处于同一深度后，正好相遇，则这个点就是LCA
    if(a==b)
        return a;
    //a和b同时往上跳，从大到小遍历步长，遇到合适的就跳上去，不合适就减少步长
    for(int i=19;i&gt;=0;i--)
    {
        //若二者没相遇则跳上去
        if(dp[a][i]!=dp[b][i])
        {
            a=dp[a][i];
            b=dp[b][i];
        }
    }
    //最后a和b跳到了LCA的下一层，LCA就是a和b的父节点
    return dp[a][0];
}


    至此，倍增法的主要思想和编码就完成了。程序中还剩一小段编码没有完成，就是对树的深搜。在此过程中我们要保存各节点的深度和父节点。</code></pre><p>另一个模板</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1000010;
inline void read(int &amp;n) {
    char c = getchar(); bool flag = 0; n = 0;
    while (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;)    c == &apos;-&apos; ? flag = 1, c = getchar() : c = getchar();
    while (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)    n = n * 10 + c - 48, c = getchar(); flag == 1 ? n = -n : n = n;
}
struct node {
    int v, nxt;
} edge[MAXN];
int head[MAXN];
int num = 1;
inline void add_edge(int x, int y) {
    edge[num].v = y;
    edge[num].nxt = head[x];
    head[x] = num++;
}
int f[MAXN][21];
int deep[MAXN];
int n, m, root;
void dfs(int now) {
    for (int i = head[now]; i != -1; i = edge[i].nxt)
        if (!deep[edge[i].v])
            deep[edge[i].v] = deep[now] + 1, f[edge[i].v][0] = now, dfs(edge[i].v);
}
void PRE() {
    for (int i = 1; i &lt;= 19; i++)
        for (int j = 1; j &lt;= n; j++)
            f[j][i] = f[f[j][i - 1]][i - 1];
}
int LCA(int x, int y) {
    if (deep[x] &lt; deep[y])    swap(x, y);
    for (int i = 19; i &gt;= 0; i--)
        if (deep[f[x][i]] &gt;= deep[y])
            x = f[x][i];
    if (x == y)    return x;
    for (int i = 19; i &gt;= 0; i--)
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    return    f[x][0];
}
int main() {

    memset(head, -1, sizeof(head));
    read(n); read(m); read(root);
    for (int i = 1; i &lt;= n - 1; i++) {
        int x, y; read(x); read(y);
        add_edge(x, y);
        add_edge(y, x);
    }
    deep[root] = 1;
    dfs(root);
    PRE();
    for (int i = 1; i &lt;= m; i++) {
        int x, y;
        read(x); read(y);
        printf(&quot;%d\n&quot;, LCA(x, y));
    }
    return 0;
}</code></pre><h2 id="RMQ算法："><a href="#RMQ算法：" class="headerlink" title="RMQ算法："></a>RMQ算法：</h2><p>看我的另一个博文<a href="http://localhost/?p=114" target="_blank" rel="noopener">http://localhost/?p=114</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE--%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE--%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/" itemprop="url">[算法]最小树形图--朱刘算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T21:46:28+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="最小树形图："><a href="#最小树形图：" class="headerlink" title="最小树形图："></a>最小树形图：</h2><p><strong>定义：</strong>设G = (V,E)是一个有向图，它具有下述性质：</p>
<ol>
<li>G中不包含有向环；　(也就是E的数目等于 V - 1)</li>
<li>存在一个顶点vi，它不是任何弧的终点，而V中的其它顶点都恰好是唯一的一条弧的终点，则称 G是以vi为根的<strong>树形图</strong>。(G是一棵有向图的生成树)</li>
</ol>
<p>最小树形图就是有向图G = (V, E)中以vi为根的树形图中权值和最小的那一个。</p>
<p>另一种说法：最小树形图，就是给有向带权图一个特殊的点root，求一棵以root为根节点的树使得该树的的总权值最小。</p>
<p><strong>性质：</strong>最小树形图基于贪心和缩点的思想。</p>
<p><strong>缩点：</strong>将几个点看成一个点，所有连到这几个点的边都视为连到收缩点,所有从这几个点连出的边都视为从收缩点连出</p>
<p><strong>实现细节 ：</strong></p>
<p>设根结点为v0，</p>
<ul>
<li>（1）求最短弧集合E0</li>
</ul>
<p>　　从所有以vi(i ≠ 0)为终点的弧中取一条最短的，若对于点i，<strong>没有入边，则不存在最小树形图</strong>，算法结束；如果能取，则得到由n个点和n-1条边组成的图G的一个子图G’，这个子图的权值一定是最小的，但是不一定是一棵树</p>
<ul>
<li>（2）检查E0</li>
</ul>
<p>　　若E0没有有向环且不包含收缩点,则计算结束，E0就是图G以v0为根的最小树形图；若E0含有有向环，则转入步骤(3)；若E0没有有向环,但是存在收缩点，转到步骤(4)。</p>
<ul>
<li>（3）收缩G中的有向环</li>
</ul>
<p>　　把G中的环C收缩成点u，对于<strong>图G中两端都属于C的边就会被收缩掉</strong>，其他弧仍然保留，得到一个新的图G1，G1中以<strong>收缩点为终点的弧的长度要变化</strong>。变化的规则是：设点v在环C中，且环中指向v的边的权值为w，点v’不在环C中，则对于G中的每一条边&lt;v’, v&gt;，在G1中有边&lt;v’, u&gt;和其对应，且<strong>权值W**</strong>G1<strong><strong>(&lt;v’, u&gt;) = W</strong></strong>G<strong>**(&lt;v’, v&gt;) - w</strong>；对于图G中以环C中的点为起点的边&lt;v, v’&gt;，在图G1中有边&lt;u, v’&gt;，则WG1(&lt;u, v’&gt;) = WG(&lt;v, v’&gt;)。有一点需要注意,在这里生成的图G1可能存在重边。</p>
<p>　　对于图G和G1：  </p>
<p>　　①如果图G1中没有以v0为根的最小树形图，则图G也没有；</p>
<p>　　②如果G1中有一v0为根的最小树形图，则可按照步骤（4）的展开方法得到图G的最小树形图。</p>
<p>所以，应该对于图G1代到(1)中反复求其最小树形图，直到G1的最小树形图u求出。</p>
<ul>
<li>（4）展开收缩点</li>
</ul>
<p>　　假设图G1的最小树形图为T1,<strong>那么T**</strong>1<strong>**中所有的弧都属于图G的最小树形图T</strong>。将G1的一个收缩点u展开成环C，<strong>从C中去掉与T**</strong>1<strong>**具有相同终点的弧</strong>，其他弧都属于T。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/307740/2012071809493394.jpg" alt=""></p>
<p>最小树形图的构造过程  </p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>int Directed_MST(int root, int V, int E) // 传入的是构造最小树形图的根， 点的数目， 边的数目
{
    int ret = 0;//存最小树形图总权值
    while(true)
    {
        int i;
        //1.找每个节点的最小入边
        for( i = 0; i &lt; V; i++)
            in[i] = INF;//in[i] 保存的是第i个点的最小入边的权值  初始化为无穷大
        for( i = 0; i &lt; E; i++)//遍历每条边
        {
            int u = edge[i].u;
            int v = edge[i].v;
            if(edge[i].w &lt; in[v] &amp;&amp; u != v)//说明顶点v有条权值较小的入边  记录之
            {
                pre[v] = u;//节点u指向v，pre[v]记录的是指向v的最小入边的起始点
                in[v] = edge[i].w;//最小入边
                if(u == root)//这个点就是实际的起点
                    pos = i; //??
            }
        }
        for( i = 0; i &lt; V; i++)//判断是否存在最小树形图
        {
            if(i == root)   // 根 天生不管
                continue;
            if(in[i] == INF)
                return -1;//除了根以外有点没有入边,则根无法到达它  说明它是独立的点 一定不能构成树形图
        }
        //2.找环
        int cnt = 0;//记录环数
        memset(id, -1, sizeof(id)); //id[i] 记录的是点i是属于第几个环
        memset(vis, -1, sizeof(vis));
        in[root] = 0;          // 根的入度为0 
        for( i = 0; i &lt; V; i++) //遍历每个点，标记每个环
        {
            ret += in[i];    //记录权值，就是G1图的n-1条边的权值
            int v = i;
            while(vis[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root)
            {
                vis[v] = i;
                v = pre[v];
            }
            if(v != root &amp;&amp; id[v] == -1) // 找到环了
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = cnt;//标记节点u为第几个环
                id[v] = cnt++;
            }
        }
        if(cnt == 0)
            break; //无环，   则break
        for( i = 0; i &lt; V; i++)
            if(id[i] == -1)
                id[i] = cnt++; // 给每个单独的点赋予一个连通分量的编号
            //3.建立新图   缩点,重新标记
            for( i = 0; i &lt; E; i++)
            {
                int u = edge[i].u;
                int v = edge[i].v;
                edge[i].u = id[u];
                edge[i].v = id[v];
                if(id[u] != id[v])
                    edge[i].w -= in[v];
            }
            V = cnt;   // 这是新图上点的数目
            root = id[root];
    }
    return ret;
}</code></pre><p>另外一个博主的</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

using namespace std;
const int MAXN = 1e4 , INF = 1e8;
int d[MAXN] , id[MAXN] , vis[MAXN] , pre[MAXN]; //d:除root点外每个点的最小入边 id:下一次建图新的节点号 vis:用来判断是否成环 下面程序见 pre:点的前序节点
int V , E;    // V:点的个数    E:边的个数
struct node {
    int u , v , cost;  //边的起点  终点  以及长度
}edge[MAXN];

int zhuliu(int root) {
    int res = 0;   //最小树形图的长度
    while(true) {
        for(int i = 0 ; i &lt; V ; i++) {
            d[i] = INF;
        }
        for(int i = 0 ; i &lt; E ; i++) {    //寻找最小入边
            int u = edge[i].u , v = edge[i].v;
            if(u != v &amp;&amp; edge[i].cost &lt; d[v]) {
                pre[v] = u;
                d[v] = edge[i].cost;
            }
        }
        for(int i = 0 ; i &lt; V ; i++) {
            if(i != root &amp;&amp; d[i] == INF) {        //除了root之外  有别的点无最小入边
                return -1;               
            }
        }
        int cont = 0;
        memset(id , -1 , sizeof(id));
        memset(vis , -1 , sizeof(vis));
        d[root] = 0;
        for(int i = 0 ; i &lt; V ; i++) {   //找环
            res += d[i];
            int v = i;
            //vis[v] == i 表明找到一个环    id[v] != -1 表明这个点在循环中已经被下面的操作缩点(在环中)    v == root 说明寻找到了根节点
            while(vis[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root) {    //每个点寻找前序节点  要么找到根部  要么找到一个环
                vis[v] = i;
                v = pre[v];
            }
            if(v != root &amp;&amp; id[v] == -1) {   //成环 缩点
                for(int u = pre[v] ; u != v ; u = pre[u]) {
                    id[u] = cont;
                }
                id[v] = cont++;
            }
        }
        if(cont == 0) {   //无环  break
            break;
        }
        for(int i = 0 ; i &lt; V ; i++) {
            if(id[i] == -1) {    //没有成环的点
                id[i] = cont++;
            }
        }
        for(int i = 0 ; i &lt; E ; i++) {   //重新建图 重新标记
            int u = edge[i].u , v = edge[i].v;
            edge[i].u = id[u] , edge[i].v = id[v];
            if(id[v] != id[u]) {   
                edge[i].w -= d[v];  //理解上面的文字描述 &gt; . &lt; !(特别是二)
            }
        }
        V = cont;
        root = id[root];   //新的根
    }
}

int main()
{

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/" itemprop="url">[算法]斯坦纳树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-27T16:31:50+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是斯坦纳树？"><a href="#什么是斯坦纳树？" class="headerlink" title="什么是斯坦纳树？"></a>什么是斯坦纳树？</h2><pre><code>斯坦纳树问题是组合优化学科中的一个问题。将**指定点集合**中的所有点连通，且边权总和最小的生成树称为最小斯坦纳树（Minimal Steiner Tree），其实最小生成树是最小斯坦纳树的一种特殊情况。而斯坦纳树可以理解为使得指定集合中的点连通的树，但不一定最小。 （ 给出一个无向图，选择一些边使得几个**特定点**连接起来那就是**斯坦纳树**且边权和最小就是**最小斯坦纳树** ）</code></pre><h2 id="如何求解最小斯坦纳树？"><a href="#如何求解最小斯坦纳树？" class="headerlink" title="如何求解最小斯坦纳树？"></a>如何求解最小斯坦纳树？</h2><p>可以用DP求解，dp[i][state]表示以i （什么点都行）为根，指定集合中的点的连通状态为state的生成树的最小总权值。</p>
<pre><code>转移方程有两重：

第一重(不同的state，由之前的state转移而来)，先通过连通状态state的子集进行转移。

**dp\[i\]\[state\]=min{ dp\[i\]\[subset1\]+dp\[i\]\[subset2\] } **</code></pre><p>说明，dp[i][sta]的最优解可以由合并两棵以i为根的不同形态(相加 == sta)子树得到。</p>
<pre><code>枚举子集的技巧可以用 for(sub=(state-1)&amp;state;sub;sub=(sub-1)&amp;state)。

第二重（相同的state），在当前枚举的连通状态下，对该连通状态进行松弛操作。</code></pre><p>**     dp[j][state | sta[j]] = min( dp[j][sta | sta[j]], dp[i][sta] + w[i][j]);**</p>
<p>看到这个转移方程，与最短路的松弛条件何其相似！因此在枚举状态sta时，如果遇到在第一类转移之后有更新的节点（其实直接使用此时已经取到“最优解”的点即可），将其加入队列，在第一类转移全部完成之后用spfa做一次迭代更新，由于这种转移（第一类转移得到的优解，只是相对于前面状态的，而同一状态之间的差别不知道）既可以从i到j，也可以从j到i，因此普通的转移（第一类转移）是不能保证最优性的，而spfa采用迭代逼近的方式，<strong>将更新过的点再进行更新，</strong>可以保证最后每个节点都是“最短路”。  </p>
<pre><code>为什么只需对该连通状态进行松弛？**因为更后面的连通状态会由先前的连通状态通过第一重转移得到**，所以无需对别的连通状态松弛。松弛操作用SPFA即可</code></pre><p>有点每个连接状态就是一层的感觉，不同层用状压dp求解，然后SPFA只在同一层跑来松弛，这样时间也比较稳定优秀。 。</p>
<pre><code>复杂度 O(n\*3^k+cE\*2^k)

c为SPFA复杂度中的常数，E为边的数量，但几乎达不到全部边的数量，甚至非常小。3^k来自于子集的转移sum{C(i,n)*2^i} (1&lt;=i&lt;=n)，用二项式展开求一下和。</code></pre><h2 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h2><pre><code>/*
 *  Steiner Tree：求，使得指定K个点连通的生成树的最小总权值
 *  st[i] 表示顶点i的标记值，如果i是指定集合内第m(0&lt;=m&lt;K)个点，则st[i]=1&lt;&lt;m 
 *  endSt=1&lt;&lt;K
 *  dptree[i][state] 表示以i为根，连通状态为state的生成树值
 */
#define CLR(x,a) memset(x,a,sizeof(x))

int dptree[N][1&lt;&lt;K],st[N],endSt;
bool vis[N][1&lt;&lt;K];
queue&lt;int&gt; que;

int input()
{
   /*
    *    输入，并且返回指定集合元素个数K
    *    因为有时候元素个数需要通过输入数据处理出来，所以单独开个输入函数。
    */
}

void initSteinerTree()
{
    CLR(dptree,-1);
    CLR(st,0);
    for(int i=1;i&lt;=n;i++) CLR(vis[i],0);
    endSt=1&lt;&lt;input();
    for(int i=1;i&lt;=n;i++)
        dptree[i][st[i]]=0;
}

void update(int &amp;a,int x)
{
    a=(a&gt;x || a==-1)? x : a;
}

void SPFA(int state)
{
    while(!que.empty()){
        int u=que.front();
        que.pop();
        vis[u][state]=false;
        for(int i=head[u];i!=-1;i=e[i].next){
            int v=e[i].to;
 // st[v] | state 这个状态是由u 这个点 转移 到v这个点的
            if(dptree[v][st[v]|state]==-1 || 
                dptree[v][st[v]|state] &gt; dptree[u][state]+e[i].w){

                dptree[v][st[v]|state]=dptree[u][state]+e[i].w;
                if(st[v]|state!=state || vis[v][state]) 
                    continue; //只更新当前连通状态
                vis[v][state]=true;
                que.push(v);
            }
        }
    }
}

void steinerTree()
{
    for(int j=1;j&lt;endSt;j++){
        for(int i=1;i&lt;=n;i++){
            if(st[i] &amp;&amp; (st[i]&amp;j)==0) continue;  //这个情况显然不存在
            for(int sub=(j-1)&amp;j;sub;sub=(sub-1)&amp;j){
                int x=st[i]|sub,y=st[i]|(j-sub); // x, y为两个互补的子状态
                if(dptree[i][x]!=-1 &amp;&amp; dptree[i][y]!=-1)//这两个子状态都存在
                    update(dptree[i][j],dptree[i][x]+dptree[i][y]);
  // 这里面dptree记录的是边的权值，所以直接加没问题，有的题目可能要考虑重复.
            }
            if(dptree[i][j]!=-1) //说明这个状态有可能存在,且目前是最优的点
                que.push(i),vis[i][j]=true;  
        }
        SPFA(j);
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/" itemprop="url">[模板]最小生成树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-26T22:37:04+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h2><pre><code>int   Kruskal()
{
    int mst = 0;  // 记录加入边的长度和
    int sum = 0;  // 加入边的数目， 如果数目 == 顶点数减1，说明所有点联通了 
    for(int i = 0; i &lt;= n; i++)
        pre[i] = i;    //并查集的初始化
    sort(edge + 1, edge + 1 + m);   // 对每条边按权重从小到大排序
    for(int i = 1; i &lt;= m; i ++)  // 从小到大枚举每一条边
    {
        int u = edge[i].from;
        int v = edge[i].to;
        int f1 = findRoot(u);
        int f2 = findRoot(v);
        if(f1 != f2)           //这条边的两个端点不在同一个集合里面
        {
            pre[f2] = f1;      // 将这两个集合合并
            sum++;             // 边数加1
            mst += edge[i].cost; // mst += cost
        }
    }
    if(sum == n - 1)          // n个点完成了联通
        return mst;
    else                       //n个点无法联通
        return -1;
}</code></pre><h2 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E5%B9%B6%E6%9F%A5%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E5%B9%B6%E6%9F%A5%E9%9B%86/" itemprop="url">[模板]并查集</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-26T22:31:09+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>并查集：将不同分散的结点，通过某种关系将他们连接成一个森林</strong><br><strong>并查集分为3步：<br>1、并：给出两点关系，如果属于同一集合，进行unionSet<br>2、查：在合并时，需要先写出查，即找到该点的祖先点<br>3、集：unoinSet后，将新加入的点的祖先点更新</strong></p>
<h3 id="并查集-路径压缩-Rank："><a href="#并查集-路径压缩-Rank：" class="headerlink" title="并查集 + 路径压缩 + Rank："></a>并查集 + 路径压缩 + Rank：</h3><pre><code>int findRoot(int root)
{
    if(pre[root] == root)
        return root;
    return pre[root] = findRoot(pre[root]);    
}
void unionSet(int p, int q)
{
    int f1 = findRoot(p);
    int f2 = findRoot(q);
    if(f1 != f2)
    {
        if(rank[f1] &gt; rank[f2])
            pre[f2] = f1;
        else if(rank[f1] &lt; rank[f2])
            pre[f1] = f2;
        else
        {
            pre[f1] = f2;
            rank[f2] ++;
        }
    }   
}</code></pre><h3 id="带权并查集："><a href="#带权并查集：" class="headerlink" title="带权并查集："></a>带权并查集：</h3><p><a href="https://blog.csdn.net/yjr3426619/article/details/82315133" target="_blank" rel="noopener">更多细节</a></p>
<pre><code>int findRoot(int x)
{
    if(pre[x] != x)
    {
        int par = pre[x];           //记录原来的父节点，  
        pre[x] = findRoot(pre[x]);  // 父节点变成根节点
        value[x] += value[par];
    }
    return pre[x];
}
/*更新权值只多了两行代码，先记录下原本父节点的编号，因为在路径压缩后父节点就变为根节点了，再将当前节点的权值加上原本父节点的权值，此时父节点的权值已经是父节点到根节点的权值了，因此加上这个权值就会得到当前节点到根节点的权值。*/</code></pre><p>普通的带权并查集题目链接</p>
<p><a href="http://localhost/?p=72" target="_blank" rel="noopener">POJ – 1988 Cube Stacking</a></p>
<p><a href="http://localhost/?p=74" target="_blank" rel="noopener">HDU – 3635 Dragon Balls</a></p>
<p><a href="http://localhost/?p=77" target="_blank" rel="noopener">HDU – 3038 How Many Answers Are Wrong</a></p>
<p>模2系的题目链接</p>
<p><a href="http://localhost/?p=89" target="_blank" rel="noopener">POJ – 2492 A Bug’s Life</a></p>
<p><a href="http://localhost/?p=87" target="_blank" rel="noopener">POJ – 1703 Find them, Catch them</a></p>
<p><a href="http://localhost/?p=79" target="_blank" rel="noopener">POJ – 1733 Parity game</a></p>
<p>模3系的题目链接</p>
<p><a href="http://localhost/?p=85" target="_blank" rel="noopener">POJ</a> <a href="http://localhost/?p=85" target="_blank" rel="noopener">– 2912 Rochambeau</a></p>
<p><a href="http://localhost/?p=83" target="_blank" rel="noopener">POJ – 1182 食物链</a></p>
<p>模300系</p>
<p><a href="http://localhost/?p=81" target="_blank" rel="noopener">HDU – 3047 Zjnu Stadium</a></p>
<h3 id="异或并查集："><a href="#异或并查集：" class="headerlink" title="异或并查集："></a>异或并查集：</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/26/HDU-1875%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/26/HDU-1875%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD/" itemprop="url">HDU - 1875 畅通工程再续</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-26T22:19:25+08:00">
                2019-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>Kruskal模板题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-16.12.35
 Question_Number   ：hdu 1875
 Question_Name     ：最小生成树水题
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;

const int MAXN = 100 + 10;
const int MAXM = MAXN * MAXN ;
int cnt, n;
bool vis[MAXN];
int head[MAXN], pre[MAXN];
struct Node
{
    int x, y;
    Node(int x = 0, int y = 0):x(x), y(y){};

};
struct Edge
{
    int from;
    int to;
    double cost;
    Edge(int from = 0, int to = 0, double cost = 0):from(from), to(to), cost(cost){};
    friend bool operator &lt; (Edge a, Edge b)
    {
        return a.cost &lt; b.cost;
    }
};
Node node[MAXN];
Edge edge[MAXM];
double getDis(Node a, Node b)
{
    double temp = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
    return sqrt(temp);
}
void addEdge(int x, int y, double cost)
{
    cnt ++;
    edge[cnt].from = x;
    edge[cnt].to = y;
    edge[cnt].cost = cost;
};
int findRoot(int x) //普通并查集
{
    if(x == pre[x])
        return x;
    return  pre[x] = findRoot(pre[x]);
}
double  Kruskal()
{
    double mst = 0;
    int sum = 0;
    for(int i = 0; i &lt;= n; i++)
        pre[i] = i;
    for(int i = 1; i &lt;= cnt; i ++)
    {
        int u = edge[i].from;
        int v = edge[i].to;
        int f1 = findRoot(u);
        int f2 = findRoot(v);
        if(f1 != f2)
        {
            pre[f2] = f1;
            sum++;
            mst += edge[i].cost;
        }
    }
    if(sum == n - 1)
        return mst;
    else
        return 0;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        memset(head, -1, sizeof head);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;,&amp;node[i].x, &amp;node[i].y);

        for(int i = 1; i &lt; n; i++)
            for(int j = i + 1; j &lt;= n; j++)
            {
                double temp = getDis(node[i], node[j]);
                if(temp &gt;= 10 &amp;&amp; temp &lt;= 1000 )
                     addEdge(i, j, temp);       //我是猪吗，不用链式前向星
            }
        sort(edge + 1, edge + 1 + cnt);
        double ans = Kruskal();
        if(ans == 0)
            printf(&quot;oh!\n&quot;);
        else
            printf(&quot;%.1f\n&quot;, ans * 100);

    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/21/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/tpaaaaaa.github.io/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/23/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
