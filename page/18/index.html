<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;18&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/18/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/POJ2299Ultra-QuickSort/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/POJ2299Ultra-QuickSort/" itemprop="url">POJ 2299 Ultra-QuickSort</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:10:38+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Ultra-QuickSort</strong></p>
<p><strong>Time Limit:</strong> 7000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 79228</p>
<p><strong>Accepted:</strong> 29743</p>
<p>Description</p>
<p><img src="http://poj.org/images/2299_1.jpg" alt=""></p>
<p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.</p>
<p>InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.</p>
<p>OutputFor every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
<p>Sample Input</p>
<p>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0</p>
<p>Sample Output</p>
<p>6<br>0</p>
<p>Source<a href="http://poj.org/searchproblem?field=source&key=Waterloo+local+2005.02.05" target="_blank" rel="noopener">Waterloo local 2005.02.05</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用树状数组求逆序数。</p>
<pre><code>/*
 Date              : 2019-09-10-16.59.56
 Question_Number   ：2
 Question_Name     ：树状数组解逆序对问题模板
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
int c[4 *  MAXN], b[MAXN], n;
int a[MAXN];
struct Node
{
    int val, order;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.val &lt; b.val;
    }
};
Node node[MAXN];
//x是排序后的坐标
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;
    while ( x &gt; 0 )
    {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}
//x是排序后的坐标，u是要改的值
void update(int x, int u)
{
    while(x &lt;= n)
    {
        c[x] += u;
        x += lowbit(x);
    }
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;node[i].val);
            a[i] = node[i].val;
            node[i].order = i;
        }

        sort(node + 1, node + 1 + n);
        for(int i = 1; i &lt;= n; i++)
            b[node[i].order] = i;

        ll ans = 0;
        memset(c, 0, sizeof c);
        for(int i = n; i &gt; 0; i --)
        {
            update(b[i], 1);
            ans += query(b[i]);
            ans --;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/" itemprop="url">[数据结构]莫队算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:07:21+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好的解释：<a href="https://www.zhihu.com/question/27316467?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/27316467?sort=created</a></p>
<p>好的博文，关于分块的选择以及时间复杂度的计算：<a href="https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html</a></p>
<p>关于带修莫队好的分析与时间复杂度的计算：<a href="https://blog.csdn.net/chenxiaoran666/article/details/82220385" target="_blank" rel="noopener">https://blog.csdn.net/chenxiaoran666/article/details/82220385</a></p>
<h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下：</p>
<ol>
<li>只有询问没有修改。</li>
<li>允许离线。</li>
<li>在已知询问 [l,r][l,r] 答案的情况下可以 O(1)O(1) 得到 [l,r−1],[l,r+1],[l−1,r],[l+1,r][l,r−1],[l,r+1],[l−1,r],[l+1,r] 的答案。</li>
</ol>
<p>满足以上三个条件就可以在 O(nm−−√+mlogm)O(nm+mlogm) 的时间复杂度下得到每个询问的解。</p>
<p>例题：</p>
<h2 id="DQUERY-D-query"><a href="#DQUERY-D-query" class="headerlink" title="DQUERY - D-query"></a>DQUERY - D-query</h2><p>Given a sequence of n numbers a1, a2, …, an and a number of d-queries. A d-query is a pair (i, j) (1 ≤ i ≤ j ≤ n). For each d-query (i, j), you have to return the number of distinct elements in the subsequence ai, ai+1, …, aj.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul>
<li>Line 1: n (1 ≤ n ≤ 30000).</li>
<li>Line 2: n numbers a1, a2, …, an (1 ≤ ai ≤ 106).</li>
<li>Line 3: q (1 ≤ q ≤ 200000), the number of d-queries.</li>
<li>In the next q lines, each line contains 2 numbers i, j representing a d-query (1 ≤ i ≤ j ≤ n).</li>
</ul>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><ul>
<li>For each d-query (i, j), print the number of distinct elements in the subsequence ai, ai+1, …, aj in a single line.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input</strong><br>5<br>1 1 2 1 3<br>3<br>1 5<br>2 4<br>3 5</p>
<p><strong>Output</strong><br>3<br>2<br>3 </p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 3e4 + 10;
const int MAXM = 2e5 + 10;
const int MAXA = 1e6 + 10;
int block;
int a[MAXN], ans[MAXM];
int cnt[MAXA];
struct Ques
{
    int L, R;
    int i;
    friend bool operator &lt; (Ques a, Ques b)
    {
        if(a.L / block == b.L / block)
            return a.R &lt; b.R;
        else
            return a.L / block &lt; b.L / block;
    }
};
Ques ques[MAXM];
int main()
{
    int n, m;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        block = sqrt(n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        scanf(&quot;%d&quot;, &amp;m);
//将询问保存。
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;ques[i].L, &amp;ques[i].R);
            ques[i].i = i;
        }
        sort(ques + 1, ques + 1 + m);
//将询问分块排序。
        memset(cnt, 0, sizeof cnt);
//[l, r]为所维护的区间
        int l = 1;
        int r = 0;
        int sum = 0;
        for(int i = 1; i &lt;= m; i++)
        {
            while(l &lt; ques[i].L)// l 往左走，原来l的位置次数的数的出现次数减1
            {
                int temp = a[l];//原来l位置上的数字
                cnt[temp]--;
                if(cnt[temp] == 0)          //减为0了，说明之前有，现在无了
                    sum --;
                l++;
            }
            while(l &gt; ques[i].L)
            {
                l--;
                //说明现在l位置上的数字要算进去了
                int temp = a[l];
                cnt[temp] ++;
                if(cnt[temp] == 1)
                    sum ++;
            }
            while(r &lt; ques[i].R)
            {
                r++;
                int temp = a[r];        //r之后的位置要算了
                cnt[temp] ++;
                if(cnt[temp] == 1)
                    sum ++;
            }
            while(r &gt; ques[i].R)
            {
                int temp = a[r];
                cnt[temp] --;
                if(cnt[temp] == 0)
                    sum --;
                r--;
            }
            ans[ques[i].i] = sum;
        }
        for(int i = 1; i &lt;= m; i++)
            printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}</code></pre><h2 id="待修莫队模板"><a href="#待修莫队模板" class="headerlink" title="待修莫队模板"></a>待修莫队模板</h2><pre><code>/*
题目描述
墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：

1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。

2、 R P Col 把第P支画笔替换为颜色Col。

为了满足墨墨的要求，你知道你需要干什么了吗？

输入输出格式
输入格式：

第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。

第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。

第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。

输出格式：

对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。

输入输出样例
输入样例#1：

6 5
1 2 3 4 5 5
Q 1 4
Q 2 6
R 1 2
Q 1 4
Q 2 6

输出样例#1：

4
4
3
4
*/
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=10007;
const int N=1000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

struct Node{
    int l,r;//询问的左右端点
    int time;//时间维度
    int id;//询问的编号
}q[N];
struct Change{
    int pos;//要修改的位置
    int col;//要改成的值
}c[N];
int n,m,a[N];
int block;//分块
int numQ,numC;//查询、修改操作的次数
LL ans,cnt[N];
LL res[N];

bool cmp(Node a,Node b){//排序
    return (a.l/block)^(b.l/block) ? a.l&lt;b.l : ((a.r/block)^(b.r/block)?a.r&lt;b.r:a.time&lt;b.time);
}

void add(int x){//统计新的，根据具体情况修改
    if(cnt[x]==0)
        ans++;
    cnt[x]++;

}
void del(int x){//减去旧的，根据具体情况修改
    cnt[x]--;
    if(cnt[x]==0)
        ans--;
}
void change(int x,int ti){//改变时间轴
    if(c[ti].pos&gt;=q[x].l&amp;&amp;c[ti].pos&lt;=q[x].r){
        del(a[c[ti].pos]);//删除指定位置上的值
        add(c[ti].col);//统计新的数
    }
    swap(c[ti].col,a[c[ti].pos]);//直接互换，下次执行时必定是回退这次操作
}
int main(){
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){
        ans=0;
        numQ=0;
        numC=0;
        memset(cnt,0,sizeof(cnt));
        block=pow(n,0.66666);//分块

        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);

        for(int i=1;i&lt;=m;i++){
            char op[10];
            scanf(&quot;%s&quot;,op);
            if(op[0]==&apos;Q&apos;){//查询操作
                ++numQ;//查询操作次数+1
                scanf(&quot;%d%d&quot;,&amp;q[numQ].l,&amp;q[numQ].r);
                q[numQ].id=numQ;//序号
                q[numQ].time=numC;//时间轴
            }
            else{//修改操作
                ++numC;//修改操作次数+1
                scanf(&quot;%d%d&quot;,&amp;c[numC].pos,&amp;c[numC].col);
            }
        }
        sort(q+1,q+numQ+1,cmp);//对询问进行排序
        int l=1,r=0,time=0;//左右指针与时间轴
        for(int i=1;i&lt;=numQ;i++){
            int ql=q[i].l,qr=q[i].r;//询问的左右端点
            int qtime=q[i].time;//询问的时间轴
            while(l&gt;ql) add(a[--l]);//[l-1,r,time]
            while(l&lt;ql) del(a[l++]);//[l+1,r,time]
            while(r&lt;qr) add(a[++r]);//[l,r+1,time]
            while(r&gt;qr) del(a[r--]);//[l,r-1,time]
            while(time&lt;qtime) change(i,++time);//[l,r,time+1]
            while(time&gt;qtime) change(i,time--);//[l,r,time-1]
            res[q[i].id]=ans;//获取答案
        }

        for(int i=1;i&lt;=numQ;i++)
            printf(&quot;%lld\n&quot;,res[i]);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/HDU2481cow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/HDU2481cow/" itemprop="url">HDU 2481 cow</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:01:14+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Time Limit:</strong> 3000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 24820</p>
<p><strong>Accepted:</strong> 8305</p>
<p>DescriptionFarmer John’s cows have discovered that the clover growing along the ridge of the hill (which we can think of as a one-dimensional number line) in his field is particularly good. </p>
<p>Farmer John has N cows (we number the cows from 1 to N). Each of Farmer John’s N cows has a range of clover that she particularly likes (these ranges might overlap). The ranges are defined by a closed interval [S,E]. </p>
<p>But some cows are strong and some are weak. Given two cows: cowi and cowj, their favourite clover range is [Si, Ei] and [Sj, Ej]. If Si &lt;= Sj and Ej &lt;= Ei and Ei - Si &gt; Ej - Sj, we say that cowiis stronger than cowj. </p>
<p>For each cow, how many cows are stronger than her? Farmer John needs your help!</p>
<p>InputThe input contains multiple test cases.<br>For each test case, the first line is an integer N (1 &lt;= N &lt;= 105), which is the number of cows. Then come N lines, the i-th of which contains two integers: S and E(0 &lt;= S &lt; E &lt;= 105) specifying the start end location respectively of a range preferred by some cow. Locations are given as distance from the start of the ridge. </p>
<p>The end of the input contains a single 0.</p>
<p>OutputFor each test case, output one line containing n space-separated integers, the i-th of which specifying the number of cows that are stronger than cowi.   </p>
<p>Sample Input</p>
<p>3<br>1 2<br>0 3<br>3 4<br>0</p>
<p>Sample Output</p>
<p>1 0 0</p>
<p>HintHuge input and output,scanf and printf is recommended.</p>
<p>Source<a href="http://poj.org/searchproblem?field=source&key=POJ+Contest" target="_blank" rel="noopener">POJ Contest</a>,Author:Mathematica@ZSU</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>就是给出N个区间，问这个区间是多少个区间的真子集。 用离线算法处理一下N个区间，然后再取计算ans。</p>
<p>对于N个区间[L, R] 按照R递减的顺序，如果R一致，则按L递增的顺序（有相同区间）。这样排序就能保证排序后的第一个区间一定是最大的，即他不是任何区间的真子集，然后将他区间的左端点 在 树状数组中+1。接着对于第二个区间[L, R]，判断树状数组的L的前缀和，即覆盖这个区间的区间数目。接下来是类似的操作。</p>
<p>为什么能保证正确性呢，因为排序的时候，我们已经保证了，排在后面的区间的右端点R 一定比排在前面的右端点R’ 小。那么只要排在后面区间的左端点在此区间左端点L的左边，则此区间被这些区间覆盖了。而且我们也保证了，排在后面的区间绝对不可能覆盖排在前面的区间，因此我们考虑覆盖某个区间的区间数时，只需要考虑排在这个区间前面的区间即可。</p>
<p>小tips： 用线段树维护时，0这个数字不招人喜欢。所以一般将输入的端点+1，避免取0</p>
<p>常规思路，好好理解。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int c[MAXN], ans[MAXN];
int n;
struct Ques
{
    int L, R;
    int i;
    friend bool operator &lt; (Ques a, Ques b)
    {
        if(a.R == b.R)
            return a.L &lt; b.L;
        else
            return a.R &gt; b.R;
    }
};
Ques ques[MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;

    for(int i = x; i &gt; 0; i -= lowbit(i))
        ans += c[i];

    return ans;
}
void update(int x, int v)
{
    for(int i = x; i &lt;= 1e5; i += lowbit(i))
        c[i] += v;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;ques[i].L, &amp;ques[i].R);
            ques[i].L ++;
            ques[i].R ++;       //0麻烦
            ques[i].i = i;
        }
        sort(ques + 1, ques + 1 + n);
        memset(c, 0, sizeof c);

        ans[ques[1].i] = 0;
        update(ques[1].L, 1);

        for(int i = 2; i &lt;= n; i++)
        {
            if(ques[i].L == ques[i - 1].L &amp;&amp; ques[i].R == ques[i - 1].R)
            {
                ans[ques[i].i] = ans[ques[ i - 1 ].i];
            }
            else
                ans[ques[i].i] = query(ques[i].L);
            update(ques[i].L, 1);
        }
        for(int i = 1; i &lt;= n; i++)
            i == 1 ? printf(&quot;%d&quot;, ans[i]) : printf(&quot; %d&quot;, ans[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%A7%A3%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%A7%A3%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/" itemprop="url">[数据结构]树状数组解逆序对问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T18:35:52+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>例题POJ 2299<strong>Ultra-QuickSort</strong></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>样例输入为 9 1 0 5 4</p>
<p>设这个数组为a[]; 并顺便记录a[i]的次序order = i</p>
<p>然后将a[]从小到大排序，得到 0 1 4 5 9</p>
<p>接着得到b[]</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
    b[a[i].order] = i;</code></pre><p>b[在原数组中的编号] = 经过排序后的编号</p>
<p>例如4这个数字，在原数组a[]中排第5，经过排序后排到第3，所以得到b[ 5 ] = 3;</p>
<p>然后逆序枚举b[ i ]，也就是按原数组的逆序拿数出来，第一个取出的数是4</p>
<pre><code>for(int i = n; i &gt; 0; i --)
{
    update(b[i], 1);
    ans += query(b[i]);
    ans --;

}</code></pre><p>4这个数字，在排序后的编号为b[n] = 3, 那么我们将树状数组中的第三个叶子节点标记为1（意思为已经出现了），然后求树状数组中前3个的sum，显然只有第三个叶子节点的值为1，其他的为0，所以得到的query = 1， （包括了自己），所以要再减去1，也就是说在原数组中的最后一个元素4，在他后面的比他小的数的数目为0。</p>
<p>接下来是倒数第二个数5，在排序后的编号为b[ n - 1] = 5，那么我们就将树状数组中的第5个叶子节点标记为1，然后求树状数组的前5个的sum，显然第4个和第5个都为1，所以得到的query为2，然后自减1，意思是原数组中5这个数，在他后面的比他小的数的数目为1.</p>
<p>然后是倒数第三个数0，他在排序后排在第1个位置，那么我们将树状数组中的第1个叶子节点标记为1，然后求前1个的sum，显然为1，然后自减，所以0这个数在原数组中他后面的比他小的数的数目为0；</p>
<p>然后是倒数第4个数1，他在排序后排在第2个位置，然后我们将树状数组中的第2个叶子节点标记为1，然后求前2个的sum，得到2，自减1，也就是说，2的逆序数（朝后面看）为1；</p>
<p>最后是第一个数9，他在排序后排在第5个位置，然后我们将树状数组中的第5个叶子节点标记为1，然后求前5个的sum，得到5，自减1，所以9的逆序数为4；</p>
<p>完整代码：</p>
<pre><code>/*
 Date              : 2019-09-10-16.59.56
 Question_Number   ：2
 Question_Name     ：树状数组解逆序对问题模板
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
int c[4 *  MAXN], b[MAXN], n;
int a[MAXN];
struct Node
{
    int val, order;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.val &lt; b.val;
    }
};
Node node[MAXN];
//x是排序后的坐标
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;
    while ( x &gt; 0 )
    {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}
//x是排序后的坐标，u是要改的值
void update(int x, int u)
{
    while(x &lt;= n)
    {
        c[x] += u;
        x += lowbit(x);
    }
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;node[i].val);
            a[i] = node[i].val;
            node[i].order = i;
        }

        sort(node + 1, node + 1 + n);

        for(int i = 1; i &lt;= n; i++)
            b[node[i].order] = i;

        ll ans = 0;
        memset(c, 0, sizeof c);
        for(int i = n; i &gt; 0; i --)
        {
            update(b[i], 1);
            ans += query(b[i]);
            ans --;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/08/HDU-3308LCIS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/08/HDU-3308LCIS/" itemprop="url">HDU-3308 LCIS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T19:19:40+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>Given n integers.<br>You have two operations:<br>U A B: replace the Ath number by B. (index counting from 0)<br>Q A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树的单点修改，区间查询。 LCIS：最长连续递增子序列</p>
<p>输入部分：</p>
<pre><code>while(t--)
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    built(1, 1, n);
    while(m--)
    {
        cin &gt;&gt; c;
        if(c == &apos;Q&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            int ans = querry(1, x, y);
            printf(&quot;%d\n&quot;, ans);
        }
        else if(c == &apos;U&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            update(1, x, y); //从1号节点开始，将x位置的点的值，变成y
        }
    }
}</code></pre><p>线段树的节点——Node结构体</p>
<pre><code>struct Node
{
    int L, R;           
    int Lsum, Rsum, sum;
};</code></pre><p>线段树的建立——built函数</p>
<pre><code>void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    if(L == R)
    {
        node[root].Lsum = node[root].Rsum = node[root].sum = 1;
        return ;
    }
    int mid = (L + R) / 2;
    built(2 * root, L, mid);
    built(2 * root + 1, mid + 1, R);
    pushUp(root);
}</code></pre><p>线段树的<strong>单点修改</strong>——update函数</p>
<pre><code>void update(int root, int k, int v) //在root所维护的区间中，将k改成v
{
    if(node[root].L == node[root].R) //找到了叶子结点，当然，这叶子节点所维护的就是第k个数
    {
        a[node[root].L] = v;   
        return ;
    }
    int mid = (node[root].L + node[root].R) / 2;
    if(k &lt;= mid)
        update(2 * root, k, v); //k在左半区间
    else
        update(2 * root + 1, k, v);
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)
{
    node[root].Lsum = node[2 * root].Lsum;
    if(node[2 * root].Lsum  == (node[2 * root].R - node[2 * root].L + 1) &amp;&amp; a[ node[2 * root].R ] &lt; a[ node[2 * root].R + 1 ])
        node[root].Lsum += node[2 * root + 1].Lsum;

    node[root].Rsum = node[2 * root + 1].Rsum;
    if(node[2 * root + 1].Rsum  == (node[2 * root + 1].R - node[2 * root + 1].L + 1) &amp;&amp; a[ node[2 * root].R ] &lt; a[ node[2 * root].R + 1 ])
        node[root].Rsum += node[2 * root].Rsum;

    int temp = 0;
        if(a[ node[2 * root].R ]  &lt; a[ node[2 * root].R + 1 ] )
            temp = node[2 * root].Rsum + node[2 * root + 1].Lsum;

    node[root].sum = max(max(node[2 * root].sum, node[2 * root + 1].sum), temp);
}</code></pre><p>线段树的<strong>区间查询</strong>函数——querry</p>
<pre><code>int querry(int root, int L, int R)  //返回的是root所维护的区间中，[L, R]这个区间里面LCIS的长度
{
// 目前root所维护的区间就是我们要找的区间
    if(node[root].L == L &amp;&amp; node[root].R == R)
        return node[root].sum;
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid) //我们要找的区间完全在root的左半区间里面
        return querry(2 * root, L, R);
    else if(L &gt; mid)
        return querry(2 * root + 1, L, R);
    else
    {
// 我们将找[L, R] 中LCIS这个问题分为寻找[L, mid] 和[mid + 1, R]这两个问题
// 分别将这两个问题交给root的两个子区间
        int ans1 = querry(2 * root, L, mid);
        int ans2 = querry(2 * root + 1, mid + 1, R);
        int ans3 = 0;
        if(a[mid] &lt; a[mid + 1])
            ans3 =min(node[2 * root].Rsum, mid - L + 1) + min(node[2 * root + 1].Lsum, R - mid);
        return max(max(ans1, ans2), ans3);
    }
}</code></pre><p>tips：</p>
<p>线段树的区间查询中，如果是在root所维护的区间里面找[L, R]这个区间</p>
<p>①： 如果root所维护的区间就是[L, R] 那么直接返回root中要查找的信息即可</p>
<p>②：如果[L, R]完全在root所维护的区间的左半部分，那么将查找[L, R]的任务传给root的左半部分去做。</p>
<p>③：如果[L, R]完全在root所维护的区间的右半部分，那么将查找[L, R]的任务传给root的右半部分去做。</p>
<p>④：如果[L, R]横跨root所维护的区间的左右两半部分，我们就将查找[L, R]这个任务分解成查找[L, mid] 与 [mid + 1, R]这两个任务，[L, mid]传递给root的左半部分去找，[mid + 1, R]传递给root的右半部分去找。最后合并一下即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/08/POJ-3667Hotel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/08/POJ-3667Hotel/" itemprop="url">POJ - 3667 Hotel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T19:15:36+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>火山经营着一个停车场，假设的停车场有N车位（编号1-N）都在一条线上，最初所有车位都没停车。经常有人来定车位，他要定连续的k(1 ≤ k ≤ N)个车位。火山要确定是否能够满足客人的要求，如果能，他要将这k个连续的车位安排在编号最小的地方停下。若不能，则客人不停在火山的停车场。在某一时间，有些车会被车主开走了。火山的停车场很大，火山想让学弟学妹写个程序帮助他。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树区间合并模板题，代码分析，当做模板。</p>
<p>线段树的节点结构体</p>
<pre><code>struct Node
{
    int L, R;             //节点维护的区间是[L, R]
    int Lsum, Rsum, sum;  //维护的区间上的一些信息
    int lazy;             //懒标记
};
Node node[4 * MAXN];</code></pre><p>输入部分</p>
<pre><code>while(t--)
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    built(1, 1, n);
    while(m--)
    {
        cin &gt;&gt; c;              //别用getchar
        if(c == &apos;Q&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            int ans = querry(1, x, y);
            printf(&quot;%d\n&quot;, ans);
        }
        else if(c == &apos;U&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            update(1, x, y); //从1号节点开始，将x位置的点的值，变成y
        }
    }
}</code></pre><p>线段树的建立——built函数</p>
<pre><code>void built(int root, int L, int R) //建立维护[L, R]区间的root节点
{
    node[root].L = L;
    node[root].R = R;
    node[root].Lsum = node[root].Rsum = node[root].sum = R - L + 1;
    node[root].lazy = -1;      //懒标记赋初值，-1表示暂无操作
    if(L != R)
    {
        int mid = (L + R) / 2;
        built(2 * root, L, mid);
        built(2 * root + 1, mid + 1, R);
    }
}</code></pre><p>线段树的区间修改——update函数+lazy</p>
<pre><code>void update(int root, int L, int R, int v)
//作用是将root所维护的区间里面的[L, R]部分的值变成v。
{
 //目前找到的区间就是我们要改的区间，那么直接改了
    if(node[root].L == L &amp;&amp; node[root].R == R) 
    {
        node[root].lazy = v;  //root的懒标记置为v，将root节点的信息更新
        if(v == 1)
            node[root].Lsum = node[root].Rsum = node[root].sum = R - L + 1;
        else
            node[root].Lsum = node[root].Rsum = node[root].sum = 0;
        return;
    }
//  因为接下来要更新root的子节点，所以要将lazy标记传下去
    pushDown(root);                            
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)         //说明要更新的[L, R]区间完全在root的左半区间
        update(2 * root, L, R, v);
    else if(L &gt; mid)     // 完全在root的右半区间
        update(2 * root + 1, L, R, v);
    else                 
    {
// [L, R]横跨左右半个区间，那么将我们更新[L, R]的任务，分解为更新[L, mid]
// 和[mid + 1, R]这两个任务，分别分配个root的左右子区间
        update(2 * root, L, mid, v);
        update(2 * root + 1, mid + 1, R, v);
    }
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)//作用是用root的两个子区间取更新root所维护的区间
{
    node[root].Lsum = node[2 * root].Lsum;
    if(node[2 * root].Lsum == node[2 * root].R - node[2 * root].L + 1)
        node[root].Lsum += node[2 * root + 1].Lsum;

    node[root].Rsum = node[2 * root + 1].Rsum;
    if(node[2 * root + 1].Rsum == node[2 * root + 1].R - node[2 * root + 1].L + 1)
        node[root].Rsum += node[2 * root].Rsum;

    node[root].sum = max(max(node[2 * root].sum, node[2 * root + 1].sum), node[2 * root].Rsum + node[2 * root + 1].Lsum);
}</code></pre><p>线段树的向下传递——pushDown函数</p>
<pre><code>void pushDown(int root)   //将root节点的lazy标记传递给他的子节点
                          //并清空root节点的lazy标记
{
    if(node[root].lazy != -1)                   //说明存在lazy标记
    {
        node[2 * root].lazy = node[2 * root + 1].lazy = node[root].lazy;
        if(node[root].lazy == 0)                //区间清空的情况
        {
            node[2 * root].sum = node[2 * root].Lsum = node[2 * root].Rsum = 0;
            node[2 * root + 1].sum = node[2 * root + 1].Lsum = node[2 * root + 1].Rsum = 0;
        }
        else
        {
            node[2 * root].sum = node[2 * root].Lsum = node[2 * root].Rsum = node[2 * root].R - node[2 * root].L + 1;
            node[2 * root + 1].sum = node[2 * root + 1].Lsum = node[2 * root + 1].Rsum = node[2 * root + 1].R - node[2 * root + 1].L + 1;
        }
        node[root].lazy = -1;                  //将root节点的lazy标记清除  
    }

}</code></pre><p>线段树的区间查询——querry函数</p>
<pre><code>int  querry(int root, int G) //在root这个节点里面找到连续数目大于等于G个的区间端点
{
    if(node[root].sum &lt; G)
        return 0;
    //接下来开始分配下去，如果做
    if(node[root].Lsum &gt;= G)
        return node[root].L;    //目前区间的最优情况（左端点）符合条件，没必要继续找了
// 因为接下来要查询root的子节点，所以要将root的lazy标记传递下去
    pushDown(root);

    if(node[2 * root].sum &gt;= G) //左半区间存在满足的条件
        return querry(2 * root, G);

    if(node[2 * root].Rsum + node[2 * root + 1].Lsum &gt;= G)
        return (node[2 * root].R - node[2 * root].Rsum + 1);

    if(node[2 * root + 1].sum &gt;= G)
        return querry(2 * root + 1, G);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/08/HDU-1540TunnelWarfare/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/08/HDU-1540TunnelWarfare/" itemprop="url">HDU - 1540 Tunnel Warfare</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-08T18:51:33+08:00">
                2019-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>在抗日战争期间，华北平原广大地区进行了大规模的隧道战。 一般来说，通过隧道连接的村庄排成一列。 除了两端，每个村庄都与两个相邻的村庄直接相连。<br>入侵者经常对一些村庄发动袭击并摧毁其中的部分隧道。 八路军指挥官要求最新的隧道和村庄连接状态。 如果某些村庄严重隔离，必须立即恢复连接！<br> 输入的第一行包含两个正整数n和m（n，m≤50,000），表示村庄和事件的数量。 接下来的m行中的每一行描述一个事件。 以下所示的不同格式描述了三种不同的事件： D x：第x个村庄被毁。 Q x：指挥官询问第x个村庄与其直接或间接相关的村庄数量。 R：最后毁坏的村庄被重建了。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这是线段树的重要应用之一：区间合并，这作为一个模板题，详细分析一下代码</p>
<p>首先是输入部分</p>
<pre><code>while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
 {
     built(1, n, 1); 
     stack &lt; int &gt; st;
     while(m--)
     {
         cin &gt;&gt; c;
         if(c == &apos;D&apos;)
         {
             int x;
             scanf(&quot;%d&quot;, &amp;x);
             st.push(x);
             update(1, x, 0);
         }
         else if( c == &apos;Q&apos;)
         {
             int x;
             scanf(&quot;%d&quot;, &amp;x);
             printf(&quot;%d\n&quot;, query(1, x));
         }
         else if( c == &apos;R&apos;)
         {
             if(st.empty())
                 continue;
             int x = st.top();
             st.pop();
             update(1, x, 1);
         }
     }
 }</code></pre><p>线段树的节点——Node节点</p>
<pre><code>struct Node
{
    int L,R;             //记录着这个节点维护的区间是[L, R]
    int Lsum, Rsum, sum; //Lsum表示这个区间里面从L端点开始的连续1的长度
                         //Rsum表示这个区间里面从R端点开始的连续1的长度
                         //sum表示这个区间里面最长的连续1的长度
};</code></pre><p>线段树的建立——built</p>
<pre><code>void built(int L, int R, int root) // 作用是建立第root个节点，其维护[L, R]
{
    node[root].L = L;
    node[root].R = R;
    if(L == R)    //递归出口，到了叶子节点
        {
            node[root].Lsum = node[root].Rsum = node[root].sum = 1;
            return ;
        }
    int mid = (L + R) / 2;
    built(L, mid, root * 2);
    built(mid + 1, R, root * 2 + 1);
    pushUp(root);   //其实也可以直接在本次built里面就处理完Rsum，Lsum，sum等信息
                    //但这样更加符合建立的顺序，由上到下，再由下回上
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<p>[ root ]</p>
<p>[ 2 * root ] [ 2 * root + 1 ]</p>
<pre><code>void pushUp(int root) //作用是由root的两个子节点 更新得到root节点
{
    node[root].Lsum = node[2*root].Lsum;
    node[root].Rsum = node[2*root + 1].Rsum;
    node[root].sum = max(max(node[2*root].sum, node[2*root + 1].sum), node[2*root].Rsum + node[2*root + 1].Lsum);

    if(node[2 * root].Lsum == (node[2 * root].R - node[2 * root].L + 1))
        node[root].Lsum += node[2 * root + 1].Lsum;//噢噢噢噢我智障了

    if(node[2 * root + 1].Rsum == (node[2 * root + 1].R- node[2 * root + 1].L + 1))
        node[root].Rsum += node[2 * root].Rsum;
}</code></pre><p>线段树的<strong>单点更新</strong>——updata</p>
<pre><code>void update(int root, int k, int v)     //作用是将第k个值变成v。单点修改
{
  //为什么没必要去判断k在不在范围内呢，因为下面的函数已经规定了k肯定会在root所
  //维护的区间里面。找到叶子节点的话，叶子结点维护的就是k
    if(node[root].L == node[root].R)        //已经找到了叶子节点了
    {
        node[root].Lsum = node[root].Rsum = node[root].sum = v;
        return ;
    }
    int mid = (node[root].L + node[root].R) / 2;
//这里已经保证了k一定会在所要update的root所维护的区间里面
    if(k &lt;= mid)
        update(root * 2, k , v);
    else
        update(root * 2 + 1, k, v);
    pushUp(root);
}</code></pre><p>线段树的<strong>单点查询</strong>——query</p>
<pre><code>int  query(int root, int k) //询问在root节点所维护的区间里面，第k值左右连续1的个数最多是多少
{
    if(node[root].L == node[root].R || node[root].sum == 0 || node[root].sum == (node[root].R - node[root].L + 1))
        return node[root].sum;
//如果递归到了叶子节点，或者该结点维护的区间里面全是1 or 0（意味着没必要向下了）
// 就直接返回即可
    int mid = (node[root].L + node[root].R) / 2;                             
    if(k &lt;= mid)
        if(k &gt;= mid - node[2 * root].Rsum + 1)
            return query(2 * root, k) + query(2 * root + 1, mid + 1);
        else
            return query(root * 2, k);
    else    
        if(k &lt;= mid + node[2 * root + 1].Lsum)
            return query(2 * root + 1, k) + query(2 * root, mid);
        else
            return query(root * 2 + 1, k);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/07/%5B%E7%AE%97%E6%B3%95%5D%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/07/%5B%E7%AE%97%E6%B3%95%5D%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" itemprop="url">[算法]归并排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T20:12:43+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址<a href="https://www.jianshu.com/p/33cffa1ce613" target="_blank" rel="noopener">https://www.jianshu.com/p/33cffa1ce613</a></p>
<p>博文地址<a href="https://blog.csdn.net/k_koris/article/details/80508543" target="_blank" rel="noopener">https://blog.csdn.net/k_koris/article/details/80508543</a></p>
<p>博文地址<a href="https://blog.csdn.net/doubleguy/article/details/81390951" target="_blank" rel="noopener">https://blog.csdn.net/doubleguy/article/details/81390951</a></p>
<p>关于逆序数</p>
<p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个<strong>逆序</strong>。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。一个排列中所有逆序总数叫做这个排列的逆序数。也就是说，对于n个不同的元素，先规定各元素之间有一个标准次序（例如n个 不同的自然数，可规定从小到大为标准次序），于是在这n个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有1个逆序。一个排列中所有逆序总数叫做这个排列的逆序数。</p>
<p>OJ 2299 <a href="https://www.cnblogs.com/zhangmingcheng/p/3912958.html" target="_blank" rel="noopener">Ultra-QuickSort</a></p>
<p>但是用<strong>归并排序</strong>并不是为了求交换次数，而是为了求序列的<strong>逆序数</strong>（学过《线代》的同学应该很熟悉了）</p>
<p><strong>一个乱序序列的 逆序数 = 在只允许_相邻_两个元素交换的条件下,得到有序序列的交换次数</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5DST%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5DST%E8%A1%A8/" itemprop="url">[数据结构]ST表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T15:40:55+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址：<a href="https://www.cnblogs.com/qq965921539/p/9608980.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq965921539/p/9608980.html</a></p>
<p>ST表类似树状数组，线段树这两种算法，是一种用于解决RMQ(Range Minimum/Maximum Query,即区间最值查询)问题的离线算法</p>
<p>与线段树相比，预处理复杂度同为O(nlogn),<strong>查询时间上，ST表为O(1),线段树为O(nlogn)</strong></p>
<p>st表的主体是一个二维数组st[i][j]，表示需要查询的数组的从下标i到下标i+2^j - 1的最值，这里以最小值为例</p>
<pre><code>int a[1010];//原始输入数组
int st[1010][20];//st表

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        st[i][0] = a[i];

    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
    {
        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++)
            st[i][j] = min(st[i][j - 1],st[i + (1 &lt;&lt; (j - 1))][j - 1]);
    }
}</code></pre><p>这里首先把从0~n-1的2^0部分进行覆盖，再往下继承</p>
<p>继承这里也很好理解，我们以一个长度为5的数组[5,1,2,3,4]为例</p>
<p>2^0部分覆盖过去自然是5，4，3，2，1</p>
<p>2^1部分的长度为4，从0一直到3，因为从下标为4开始后面只有他自己</p>
<p>st[0][1]是下标为0~1的最小值，自然也就是st[0][0]和st[1][0]的最值</p>
<p>以此往下类推我们可以得出结论：</p>
<p><strong>st[i][j] = min(st[i][j - 1],st[i + 2^(j - 1))][j - 1**</strong>])**</p>
<p>到这里初始化就完成了，注意下标不要越界，如果你对为什么这么处理有困惑的话，请继续看查询</p>
<p>查询函数这里不太好理解</p>
<p>初始化时，每一个状态对应的区间长度都为2^j，由于给出的查询区间长度不一定恰好为2^j，</p>
<p>所以我们要引出一个定理：<strong>2^log(a)&gt;a/2</strong> 。</p>
<p><a href="https://blog.csdn.net/Hanks_o/article/details/77547380" target="_blank" rel="noopener">https://blog.csdn.net/Hanks_o/article/details/77547380</a> 这里有一段非常非常好理解的解释，这里超级感谢原作者，我本人不能做出更好的解释，他的讲解是这样的：</p>
<p>这个很简单，因为log(a)表示小于等于a的2的最大几次方。<br>比如说log(4)=2,log(5)=2,log(6)=2,log(7)=2,log(8)=3,log(9)=3…….<br>那么我们要查询x到y的最小值。<br>设len=y-x+1,t=log(len)<br>根据上面的定理：2^t&gt;len/2<br>从位置上来说，x+2^t越过了x到y的中间！<br>因为位置过了一半<br>所以x到y的最小值可以表示为min(从x往后2^t的最小值，从y往前2^t的最小值)<br>前面的状态表示为mn[t][x]<br>设后面（从y往前2^t的最小值）的初始位置是k，<br>那么k+2^t-1=y，所以k=y-2^t+1<br>所以后面的状态表示为mn[t][y-2^t+1]<br>所以x到y的最小值表示为min(mn[t][x],mn[t][y-2^t+1])，所以查询时间复杂度是O（1）</p>
<p>查询函数：</p>
<pre><code>1 int search(int l, int r)
2 {
3     int k = (int)(log((double)(r - l + 1)) / log(2.0));
4     return min(st[l][k],st[r - (1 &lt;&lt; k) + 1][k]);
5 }</code></pre><p>示例程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int a[1010];//原始输入数组
int st[1010][20];//st表

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        st[i][0] = a[i];

    for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++)
    {
        for (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++)
            st[j][i] = min(st[j][i - 1],st[j + (1 &lt;&lt; (i - 1))][i - 1]);
    }
}

int search(int l, int r)
{
    int k = (int)(log((double)(r - l + 1)) / log(2.0));
    return min(st[l][k],st[r - (1 &lt;&lt; k) + 1][k]);
}

int main()
{
    int n,m;
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; a[i];

        init(n);

        while (m--)
        {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; search(l,r) &lt;&lt; endl;;
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E5%8D%95%E8%B0%83%E6%A0%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E5%8D%95%E8%B0%83%E6%A0%88/" itemprop="url">[数据结构]单调栈</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-07T15:37:03+08:00">
                2019-09-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是单调栈？"><a href="#什么是单调栈？" class="headerlink" title="什么是单调栈？"></a><strong>什么是单调栈？</strong></h2><p>单调栈分为单调递增栈和单调递减栈，单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈，跟单调队列差不多，但是只用到它的一端，利用它可以用来解决一些ACM/ICPC和OI的题目，如RQNOJ 的诺诺的队列等。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>单调递增栈</p>
<pre><code>for(int i = 0; i &lt; T.size(); i++){
  while(! stk.empty() &amp;&amp; stk.top() &gt; T[i]){
    ​stk.pop();
  }
  stk.push(A[i]);
}</code></pre><h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置，当你需要高效率获取某个位置左右两侧比他大（<strong>或小</strong>）的数的位置的的时候就可以用到单调栈。</p>
<p>求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈；<br>求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/17/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/17/">17</a><span class="page-number current">18</span><a class="page-number" href="/tpaaaaaa.github.io/page/19/">19</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/19/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
