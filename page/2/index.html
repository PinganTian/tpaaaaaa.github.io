<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;2&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/2/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/03/1013%5BJSOI2008%5D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8sphere/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/03/1013%5BJSOI2008%5D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8sphere/" itemprop="url">1013: [JSOI2008]球形空间产生器sphere</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T14:36:35+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球<br>面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　第一行是一个整数n(1&lt;=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点<br>后6位，且其绝对值都不超过20000。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点<br>后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2<br>0.0 0.0<br>-1.0 1.0<br>1.0 0.0</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0.500 1.500</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>　　提示：给出两个定义：1、 球心：到球面上任意一点距离都相等的点。2、 距离：设两个n为空间上的点A, B  </p>
<p>的坐标为(a1, a2, …, an), (b1, b2, …, bn)，则AB的距离定义为：dist = sqrt( (a1-b1)^2 + (a2-b2)^2 +   </p>
<p>… + (an-bn)^2 )</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>高斯消元解浮点方程。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    14:10:08
By                : Tpaaaaaa
File_Name         ：1013JSOI2008球形空间产生器sphere.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

//有n个方程
(2x1 - 2x2)x  + (2y1 - 2y2)y + (2z1 - 2z2) = (x1^2 + y1^2 + z1^2) - (x2^2 + y2^2 + z2^2).


所以得到
 (2x1 - 2x2)  (2y1 - 2y2)  (2z1 - 2z2) 
 (2x1 - 2x3)  (2y1 - 2y3)  (2z1 - 2z3)
 (2x1 - 2x4)  (2y1 - 2y4)  (2z1 - 2z4)
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 20;

double a[MAXN][MAXN];
double X[MAXN][MAXN];
int equ,var;//equ个方程,var个变量
double x[MAXN];//解集
bool free_x[MAXN];
int n;
int sgn(double x)
{
    return (x&gt;eps)-(x&lt;-eps);
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(0表示无解，1表示唯一解，大于1表示无穷解，并返回自由变元的个数)
int gauss()
{
    equ=n,var=n;//多少个方程，多少个变量
    int i,j,k;
    int max_r; // 当前这列绝对值最大的行.
    int col; // 当前处理的列.
    double temp;
    int free_x_num;
    int free_index;
    // 转换为阶梯阵.
    col=0; // 当前处理的列.
    memset(free_x,true,sizeof(free_x));
    for(k=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++)
    {
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(sgn(fabs(a[i][col])-fabs(a[max_r][col]))&gt;0)
                max_r=i;
        }
        if(max_r!=k)
        { // 与第k行交换.
            for(j=k;j&lt;var+1;j++)
                swap(a[k][j],a[max_r][j]);
        }
        if(sgn(a[k][col])==0)
        { // 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--; continue;
        }
        for(i=k+1;i&lt;equ;i++)
        { // 枚举要删去的行.
            if (sgn(a[i][col])!=0)
            {
                temp=a[i][col]/a[k][col];
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j]=a[i][j]-a[k][j]*temp;
                }
            }
        }
    }

    for(i=k;i&lt;equ;i++)
    {
        if (sgn(a[i][col])!=0)
            return 0;
    }
    if(k&lt;var)
    {
        for(i=k-1;i&gt;=0;i--)
        {
            free_x_num=0;
            for(j=0;j&lt;var;j++)
            {
                if (sgn(a[i][j])!=0&amp;&amp;free_x[j])
                    free_x_num++,free_index=j;
            }
            if(free_x_num&gt;1) continue;
            temp=a[i][var];
            for(j=0;j&lt;var;j++)
            {
                if(sgn(a[i][j])!=0&amp;&amp;j!=free_index)
                    temp-=a[i][j]*x[j];
            }
            x[free_index]=temp/a[i][free_index];
            free_x[free_index]=0;
        }
        return var-k;
    }

    for (i=var-1;i&gt;=0;i--)
    {
        temp=a[i][var];
        for(j=i+1;j&lt;var;j++)
        {
            if(sgn(a[i][j])!=0)
                temp-=a[i][j]*x[j];
        }
        x[i]=temp/a[i][i];

    }
    return 1;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n + 1; i++)
        {
            for(int j = 1; j &lt;= n; j++)
            {
                scanf(&quot;%lf&quot;, &amp;X[i][j]);
            }
        }
        for(int i = 2; i &lt;= n + 1; i++)
        {
            a[i - 2][n] = 0.0;
            for(int j = 1; j &lt;= n; j++)
            {
                a[i - 2][j - 1] = 2*X[1][j] - 2*X[i][j];
                a[i - 2][n] += X[1][j]*X[1][j] - X[i][j]*X[i][j];
            }
        }
        gauss();
        /*for(int i = 0; i &lt; n; i++)
        {
            for(int j = 0; j &lt;= n; j++)
                printf(&quot;%.2lf &quot;, a[i][j]);
            printf(&quot;\n&quot;);
        }*/
        for(int i = 0; i &lt; n; i++)
            printf(&quot;%.3lf &quot;,x[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/03/1003%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/03/1003%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93/" itemprop="url">1003: [ZJOI2006]物流运输</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T14:34:34+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转<br>停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种<br>因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是<br>修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本<br>尽可能地小。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　第一行是四个整数n（1&lt;=n&lt;=100）、m（1&lt;=m&lt;=20）、K和e。n表示货物运输所需天数，m表示码头总数，K表示<br>每次修改运输路线所需成本。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编<br>号以及航线长度（&gt;0）。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来<br>一行是一个整数d，后面的d行每行是三个整数P（ 1 &lt; P &lt; m）、a、b（1&lt; = a &lt; = b &lt; = n）。表示编号为P的码<br>头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一<br>条从码头A到码头B的运输路线。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 5 10 8<br>1 2 1<br>1 3 3<br>1 4 2<br>2 3 2<br>2 4 4<br>3 4 1<br>3 5 2<br>4 5 2<br>4<br>2 2 3<br>3 1 1<br>3 3 3<br>4 4 5  </p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>32<br>//前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10=32</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>先通过SPFA求出cost[i][j] 表示的是从第i天到第j天，用同一个路线的最小代价，也就是在第i天到第j天都开放的港口组成的最短路乘上天数(j - i + 1)。</p>
<p>然后设dp[i]表示前i天的最小总代价.</p>
<p>可知dp[i] = min{dp[k] + cost[k + 1][j] + K},其中 0 &lt; k &lt; i;</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    11:05:35
By                : Tpaaaaaa
File_Name         ：1003ZJOI2006物流运输.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 25;
const int MAXM = MAXN * MAXN * 2;
int n, m, e, k, cnt;
int head[MAXN];
int dp[110];
bool limit[MAXN][110];
bool vis[MAXN];
int mp[MAXN][MAXN];
int cost[110][110], dis[MAXN];
struct Edge
{
    int v, w, next;
}edge[10000];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
//u在这个期间[s, t]不能用.
inline bool check(int u, int s, int t)
{
    for(int i = s; i &lt;= t; i++)
        if(limit[u][i]) return false;
    return true;
}
void bellman_ford(int s, int t)
{
    queue&lt; int &gt; q;
    memset(vis,false,sizeof vis);
    for(int i = 1; i &lt;= m; i++)
        dis[i] = INF;
    dis[1] = 0;
    q.push(1);
    vis[1] = true;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false ;    //可以多次入队哦
//  这是用vector邻接表存的图
        for(int i = 1; i &lt;= m; i++)
        {
            if(i == u|| mp[u][i] &gt;= INF || check(i, s, t) == false) continue;
//  需要更新的点 的前提是 其前继是之前已经更新过了的emmm有点废话
            if(dis[i] &gt; dis[u] + mp[i][u])
            {
                dis[i]   = dis[u] + mp[i][u];
                if(vis[i] == false)
                {
                    vis[i] = true;
                    q.push(i);
                }
             } 
         } 
    }


}
int main()
{
    while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;e) != EOF)
    {
        //n为天数，m为点数，k为修改成本，e为边
        memset(mp, INF, sizeof mp);
        for(int i = 1; i &lt;= e; i++)
        {
            int u, v, w;
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            mp[v][u] = mp[u][v] = min(mp[u][v], w);
        }
        int d;
        memset(limit, false, sizeof limit);
        scanf(&quot;%d&quot;, &amp;d);
        for(int i = 1; i &lt;= d; i++)
        {
            int p, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;p, &amp;a, &amp;b);    
            for(int j = a; j &lt;= b; j++) limit[p][j] = true; //limit表示该天不能使用
        }
        //求出每一天的最短路的cost
        //cost[i] 表示第i天的最短路的费用.
        //先用spfa求出cost[i][j]
        //表示的是从第i天到j天，用同一方法的最小花费.
        //等于第i到j天，一直没有关门的港口组成的最短路代价乘上(j - i + 1)天数.
        for(int i = 1; i &lt;= n; i++)
            for(int j = i; j &lt;= n; j++)
            {
                bellman_ford(i, j);
                if(dis[m] &lt; INF)
                    cost[i][j] = dis[m] * (j - i + 1);
                else 
                    cost[i][j] = INF;
            }
        //dp[i]表示前i天的代价.
        for(int i = 1; i &lt;= n; i++)
        {
            dp[i] = cost[1][i];
            for(int j = 1; j &lt; i; j++)
                dp[i] = min(dp[i], dp[j] + k + cost[j + 1][i]);
        }
        printf(&quot;%d\n&quot;, dp[n]);
    }
    //fileclose;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/03/1026%5BSCOI2009%5Dwindy%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/03/1026%5BSCOI2009%5Dwindy%E6%95%B0/" itemprop="url">1026: [SCOI2009]windy数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T14:30:33+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，<br>在A和B之间，包括A和B，总共有多少个windy数？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　包含两个整数，A B。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　一个整数</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>【输入样例一】<br>1 10<br>【输入样例二】<br>25 50</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>【输出样例一】<br>9<br>【输出样例二】<br>20</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>数位DP模板题.要注意的是，当limit == true 和 lead == true的时候，不要读取和记录dp值，因为这时候都是有限制的。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    19:40:40
By                : Tpaaaaaa
File_Name         ：1026SCOI2009windy数.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
dp[i][j][limit]表示考虑前i位，且第i位是j的情况下的方案数.有没有限制.


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
ll dp[50][50][2][2];
int dig[50];
ll dfs(int step, int lst, bool zero, bool lim)
{
    if(!step)   return !zero;           //如果是0的话，不算
    if(dp[step][lst][zero][lim] != -1)  //记忆化搜索
        return dp[step][lst][zero][lim];    
    int up = lim ? dig[step] : 9;       //up
    ll res = 0;
    for(int i = 0; i &lt;= up; i++)
    {
        if(abs(i - lst) &lt; 2 &amp;&amp; !zero) continue; //前导0
        res += dfs(step - 1, i, zero &amp;&amp; !i, lim &amp;&amp; i == dig[step]);
    }
    return dp[step][lst][zero][lim] = res;
}
ll solve(ll x)
{
    int len = 0;
    while(x)
    {
        dig[++len] = x%10;
        x/=10;
    }
    dp[len][0][true][true] = -1;
    ll res = dfs(len, 0, true, true); 
    return res;
}
int main()
{
    ll a, b;
    while(scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) != EOF)
    {
        memset(dp, -1, sizeof dp);
        printf(&quot;%lld\n&quot;, solve(b) - solve(a - 1));
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/03/1036%5BZJOI2008%5D%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1Count/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/03/1036%5BZJOI2008%5D%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1Count/" itemprop="url">1036: [ZJOI2008]树的统计Count</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-03T14:23:21+08:00">
                2019-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成<br>一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 I<br>II. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　输入的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有<br>一条边相连。接下来n行，每行一个整数，第i行的整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作<br>的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。<br>对于100％的数据，保证1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4<br>1 2<br>2 3<br>4 1<br>4 2 1 3<br>12<br>QMAX 3 4<br>QMAX 3 3<br>QMAX 3 2<br>QMAX 2 3<br>QSUM 3 4<br>QSUM 2 1<br>CHANGE 1 5<br>QMAX 3 4<br>CHANGE 3 6<br>QMAX 3 4<br>QMAX 2 4<br>QSUM 3 4</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>1<br>2<br>2<br>10<br>6<br>5<br>6<br>5<br>16</p>
<p>分析：</p>
<p>树链剖分模板题.</p>
<pre><code>/*
Date              : 2019-11-30    13:13:04
By                : Tpaaaaaa
File_Name         ：1036ZJOI2008树的统计Count.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 3e4 + 10;
int n;
int cnt, tot;
int head[MAXN], siz[MAXN], dep[MAXN], son[MAXN], fa[MAXN], top[MAXN];
int id[MAXN], rk[MAXN];
ll w[MAXN];
struct Edge
{
    int v, next;
}edge[MAXN * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    int l, r;
    ll mx;
    ll sum;        //区间和，区间最大值.
}node[MAXN * 4];
void init()
{
    memset(head, -1, sizeof head);
    cnt = tot = 0;
}
void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    id[u] = ++tot;
    rk[tot] = u;            //这就是dfn序.
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; son[u] != v)
            dfs2(v, v);
    }
}
inline void pushUp(int rt)
{
    node[rt].mx = max(node[ls(rt)].mx, node[rs(rt)].mx);
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void build(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    if(l == r)
    {
        node[rt].sum = w[rk[l]];
        node[rt].mx = w[rk[l]];
        return;
    }
    else 
    {
        node[rt].sum = 0;
        node[rt].mx = -INF;       
        int mid = md(l, r);
        build(ls(rt), l, mid);
        build(rs(rt), mid + 1, r);
        pushUp(rt);
    }
}
ll query(int rt, int l, int r, int op)
{
    if(node[rt].l &gt;= l &amp;&amp; node[rt].r &lt;= r)
    {
        if(op == 0) return node[rt].sum;
        else        return node[rt].mx;
    }
    int mid = md(node[rt].l, node[rt].r);
    ll ret;
    if(op == 0) ret = 0;
    else        ret = -INF;
    if(l &lt;= mid)    
    {
        if(op == 0) ret += query(ls(rt), l, r, op);
        else ret = max(ret, query(ls(rt), l, r, op));
    }
    if(r &gt; mid)
    {
        if(op == 0) ret += query(rs(rt), l, r, op);
        else ret = max(ret, query(rs(rt), l, r, op));
    }
    return ret;
}
ll mx(int u, int v)
{
    ll ans = -INF;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])   swap(u, v);
        ans = max(ans, query(1, id[top[u]], id[u], 1));
        u = fa[top[u]];

    }
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ans = max(ans, query(1, id[u], id[v], 1));
    return ans;
}

//询问权值和.
//单点更新.
void update(int rt, int t, ll v)
{
    if(node[rt].l == node[rt].r &amp;&amp; node[rt].l == t)
    {
        node[rt].mx = v;
        node[rt].sum = v;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(t &lt;= mid)
        update(ls(rt), t, v);
    else
        update(rs(rt), t, v);

    pushUp(rt);

}
ll sum(int u, int v)
{
    ll ans = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])   swap(u, v);
        ans += query(1, id[top[u]], id[u], 0);
        u = fa[top[u]];

    }
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ans += query(1, id[u], id[v], 0);
    return ans;
}
int main()
{
    fileopen;
        scanf(&quot;%d&quot;, &amp;n);
        init();
        for(int i = 1; i &lt; n; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);addEdge(v, u);
        }
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%lld&quot;, &amp;w[i]);  
        fa[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        build(1, 1, n);             //建树.   
        int q;
        scanf(&quot;%d&quot;, &amp;q);
        char s[10];
        while(q--)
        {
            scanf(&quot;%s&quot;, s);
            if(s[0] == &apos;C&apos;)
            {
                int u;
                ll t;
                scanf(&quot;%d%lld&quot;, &amp;u, &amp;t);
                update(1, id[u], t);         //单点更新.
            }
            else if(s[1] == &apos;M&apos;)            //询问最大值.
            {
                //.....//树链剖分.
                int u, v;
                scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
                printf(&quot;%lld\n&quot;, mx(u, v));
            }
            else                            //询问路径权值和.
            {
                int u, v;
                scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
                printf(&quot;%lld\n&quot;, sum(u, v));
            }   

        }
    fileclose;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/01/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/01/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/" itemprop="url">后缀数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-01T20:25:33+08:00">
                2019-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>好的博文： <a href="https://blog.sengxian.com/algorithms/suffix-array" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/suffix-array</a></p>
<p>好的模板： <a href="https://blog.csdn.net/clover_hxy/article/details/51173982" target="_blank" rel="noopener">https://blog.csdn.net/clover_hxy/article/details/51173982</a></p>
<p>第二篇链接：<a href="https://blog.csdn.net/ruoruo_cheng/article/details/52269746" target="_blank" rel="noopener">https://blog.csdn.net/ruoruo_cheng/article/details/52269746</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KMP 字符串匹配算法，它可以在 O(m + n)<em>O</em>(<em>m</em>+<em>n</em>) 的时间内完成对模版串的匹配。然而，对于多模版串的匹配，每一次都要预处理，十分不高效。这时有 AC 自动机的出现，虽然可以多模匹配，但每次匹配仍然要遍历整个字符串，对于很长很长的字符串，例如 DNA 信息，有上亿的数据，这时候每一次查询遍历就不太科学了。这时就要预处理文本串。</p>
<h2 id="一些约定¶"><a href="#一些约定¶" class="headerlink" title="一些约定¶"></a>一些约定<a href="https://oi-wiki.org/string/sa/#_1" target="_blank" rel="noopener">¶</a></h2><p>字符串相关的定义请参考 <a href="https://oi-wiki.org/string/basic/" target="_blank" rel="noopener">字符串基础</a> 。</p>
<p>字符串下标从  开始。</p>
<p>“ 后缀  “ 代指以第  个字符开头的后缀。</p>
<h2 id="后缀数组是什么？¶"><a href="#后缀数组是什么？¶" class="headerlink" title="后缀数组是什么？¶"></a>后缀数组是什么？<a href="https://oi-wiki.org/string/sa/#_2" target="_blank" rel="noopener">¶</a></h2><p>后缀数组（Suffix Array）主要是两个数组：  和  。</p>
<p>其中，  表示将所有后缀排序后第  小的后缀的编号。  表示后缀  的排名。</p>
<p>这两个数组满足性质：  。</p>
<p>后缀数组示例：</p>
<p><a href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html" target="_blank" rel="noopener"><img src="https://oi-wiki.org/string/images/sa1.png" alt=""></a></p>
<p>另一篇比较好的</p>
<p>后缀数组（Suffix Array）是某一字符串的所有后缀按照字典序的一个排列。本文数组的索引从0开始。称s[j..len(s)-1]为后缀j。sa[i] = j，表示原串的所有后缀按字典序排列，排在第i个的是后缀j。一个字符串的后缀数组是唯一的。</p>
<p>sa根据排名查后缀编号，与之对应的是rank数组，根据后缀编号查排名。sa[i] = j &lt;=&gt; rank[j] = i。</p>
<p>给后缀排序有什么作用呢？一个字符串的所有子串，都可以表示为它某个后缀的前缀。对于一个有序的序列，我们可以二分查找。设文本串的长度为n，模板串的长度为m。直接二分，可以做到O(n lg n)+O(m lg n)的时间复杂度。用height数组进行优化，则可以做到O(n lg n)+O(m+lg n)。height是后缀数组中相邻两个后缀的最长公共前缀。</p>
<p>后缀数组的构造<br>从上一段可以看出，我们能用O(n lg n)的时间构造一个字符串的后缀数组——倍增算法。存在O(n)的算法，在OI中似乎不常用。</p>
<p>给数排序有很多方法。基于比较的排序，最快可做到O(n lg n)，理论上不能进一步优化。在我们的模型中，数之间的比较是O(1)的，然而，字符串的比较是O(n)的。所以，我们得另辟蹊径。</p>
<p>除了基于比较的排序，我们还有计数排序、基数排序等。字符串的集合太大，计数排序不可行。但是字符集往往很小，我们应该试试基于计数排序的基数排序。每次计数排序用时O(n)，进行n轮计数排序，总共是O(n^2)，仍然不理想。</p>
<p>字典序有什么特性？把s和t都拆成[0..i]，[i+1..len-1]两截，则s &lt; t &lt;=&gt; (s[0..i] &lt; t[0..i]) 或 (s[0..i] = t[0..i] 且 s[i+1..len(s)-1] &lt; t[i+1..len(t)-1])。从中看出两点：一，我们可以递归或者递推地比较两个字符串；二，这和二元组之间的比较很像！</p>
<p>设sa_k为只取每个后缀的前缀k得到的“后缀数组”，rank_k类似。我们能根据它们计算出sa_2k和rank_2k。图示如下：</p>
<p>取二元组(rank_k[i], rank_k[i+k])为后缀i的关键字排序，就得到了sa_2k。相当于rank_k能帮助我们快速地比较两个后缀。再根据sa_2k计算出rank_2k。如果i+k越界怎么办？我采用的方法是令它的rank等于-1。后面，我们将看到，置rank[n]=-1即可。</p>
<p>如果用快速排序，至此，我们已经得到O(n lg^2 n)构造后缀数组的算法。</p>
<p>rank的取值范围是0~n-1，统计一下每个rank对应多少个后缀是可接受的，能不能用先前提到的基数排序呢？基数排序从低位到高位循环，每一趟以这一位为关键字采用某种稳定排序算法（如计数排序）排序，最后就得到了有序的序列。以上面banana例子中k=4时的二元组为例：</p>
<p>Pretty cool !</p>
<p>一种简单的实现方法是，以rank_k[i+k]为关键字，对所有后缀计数排序，得到pre。再以rank_k[i]为关键字，对pre计数排序，得到sa_2k。</p>
<p>有没有可以优化的地方？</p>
<p>sa_k是什么？以rank_k[i]为关键字，对所有后缀排序的结果。现在取rank_k[i+k]为关键字，对于那些满足i+k &lt; n的后缀，它们的先后顺序保持不变，而对于那些i+k &gt;= n的后缀，根据上面的约定，其第二关键字等于-1，应该排在pre的最前面。所以，我们可以直接从sa_k得到pre。</p>
<p>开始写代码吧。以下代码仅作说明之用，为了叙述方便打乱了顺序。</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include</h1><p>void build_SA(char s[], int n)<br>{<br>memset(b, 0, sizeof(int)*SIGMA_SIZE);<br>for (int i = 0; i &lt; n; ++i) ++b[s[i]-‘a’]; for (int i = 1; i &lt; SIGMA_SIZE; ++i) b[i] += b[i-1]; for (int i = n-1; i &gt;= 0; –i)<br>sa[–b[s[i]-‘a’]] = i;<br>int m = rank[sa[0]] = 0;<br>for (int i = 1; i &lt; n; ++i) rank[sa[i]] = m += s[sa[i]] != s[sa[i-1]]; ++m; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 这一段求出sa_1和rank_1。假定SIGMA_SIZE &gt; MAX_N。如果字符集比较大，std::sort即可，不影响渐近的运行时间。m是不同rank的种数。</p>
<pre><code>int *&amp;pre = t;
for (int k = 1; m &lt; n; k *= 2, ++m) {
    for (int i = 0, p = k; i &lt; n; ++i)
        if (sa[i] &gt;= k)
            pre[p++] = sa[i]-k;
    for (int i = 0; i &lt; k; ++i)
        pre[i] = n-k+i;</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>这一段求出pre。t是一个指针，定义为全局变量。</p>
<p>int b[MAX_N], buff[2][MAX_N+1], *t = buff[0];<br>1<br>接下来根据第一关键字计数排序。</p>
<pre><code>memset(b, 0, sizeof(int)*m);
for (int i = 0; i &lt; n; ++i)
    ++b[rank[i]];
for (int i = 1; i &lt; m; ++i)
    b[i] += b[i-1];
for (int i = n-1; i &gt;= 0; --i)
    sa[--b[rank[pre[i]]]] = pre[i];</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>至此，已求出新的sa。接着，我们来计算rank。</p>
<pre><code>    m = r[sa[0]] = 0;
    for (int i = 1; i &lt; n; ++i)
        r[sa[i]] = m += rank[sa[i]] != rank[sa[i-1]] || rank[sa[i]+k] != rank[sa[i-1]+k];
    swap(r, rank);
}</code></pre><p>1<br>2<br>3<br>4<br>5<br>r是一个中间“数组”。这时pre数组已经没用了，所以它们可以共用一块内存。rank也定义为指针。</p>
<pre><code>int *&amp;pre = t, *&amp;r = t;</code></pre><p>1<br>现在可以看到定义数组指针的用意。无须copy，无须memcpy，swap即可。DP里搞滚动数组也可以借鉴这个技巧。</p>
<p>int b[MAX_N], sa[MAX_N], buff[2][MAX_N+1], *t = buff[0], *rank = buff[1];<br>1<br>别忘了在for k外面加上这句！</p>
<pre><code>rank[n] = r[n] = -1;</code></pre><p>1<br>两个后缀i、j，设i &lt; j。若j+k &lt;= n，则rank[i+k]和rank[j+k]有定义。若j+k &gt; n，则必有rank[j] &lt; rank[i]，根据短路法则，无须再比较rank[i+k]和rank[j+k]。</p>
<p>最后，还有：</p>
<p>}<br>1<br>最长公共前缀<br>设后缀sa[i]和sa[j]的最长公共前缀为LCP(i, j)，有定理：LCP(i, j) = min{height[k] | min{i, j} &lt; k &lt;= max{i, j}}。</p>
<p>一开始，刘汝佳告诉我这很显然，我是拒绝的。然而现在我也想建议大家使用显然法……</p>
<p>还是证一下吧。先证一个引理，设i &lt; k &lt;= j，则LCP(i, j) = min{LCP(i, k), LCP(k, j)}。当k = j时显然成立。以下说明k &lt; j时的情形。</p>
<p>设LCP(i, k)=a，LCP(j, k)=b，LCP(i, j)=c，sa[i]=x，sa[j]=y，sa[k]=z，不妨设a &lt;= b。那么，s[x..x+a-1] = s[z..z+a-1]，s[z..z+b-1] = s[y..y+b-1]，由传递性，s[x..x+a-1] = s[y+a-1..y+a-1]，故LCP(i, j) &gt;= a。由字典序的定义，后缀数组中i~k项后缀的前c个字符相等，故a &gt;= LCP(i, j)。证毕。</p>
<p>结合这个引理和数学归纳法，上述定理成立。</p>
<p>所以说height数组很重要啦。有了它，再求求RMQ，任意两后缀的最长公共前缀就搞定了。</p>
<p>上面这个定理有个推论，帮我们线性时间求height：height[rank[i]] &gt;= height[rank[i-1]]-1。后缀i和i-1，拿掉i-1的第一个字符，二者就相等了。考虑sa[rank[i-1]-1]=p-1，则后缀p-1&lt;后缀i-1。如果它俩的第一个字符相等，那么，有后缀p &lt; 后缀i，由定理，有height[rank[i-1]]-1 = LCP(sa[p], sa[i]) &lt;= height[rank[i]]。如果它俩的第一个字符不等，则height[rank[i-1]] = 0，显然成立。推论得证。</p>
<p>height[rank[i]]相对于前一项只能增加或减1，最多累计减少(n-1)个1，且height[rank[i]] &lt;= n。于是，按照height[rank[0]], height[rank[1]], height[rank[2]], …的顺序愉快地递推吧！</p>
<p>UOJ #35是一道模板题，我的代码：<a href="http://uoj.ac/submission/93286。" target="_blank" rel="noopener">http://uoj.ac/submission/93286。</a></p>
<p>写在最后<br>后缀数组最初是从兄弟学校的MYJ学长那里学的。研究了一下刘汝佳老师的代码，然后默写了一遍……UOJ #35始终是0分，CodeVS的模板题过了。那时我还没发现UOJ可以看一部分数据啊……我自己也不太清楚自己在写什么，这就是照着别人代码打的坏处。但是自己写不出来啊。于是这个数据结构和莫队算法等等在今年1~4月于匆忙中囫囵吞枣的知识一样，属于不可用的。</p>
<p>这次是自己重新写的，但心底里对于以前的代码还是有个模糊的印象。根据刘汝佳老师的代码修改的。有两个地方比我更优：一是他通过共用pre和r（原代码变量名不一样），只用4n的空间；二是引入m变量。</p>
<p>本文参考了刘汝佳、陈锋编著的《算法竞赛入门经典训练指南》和国家集训队2004年许智磊前辈的《后缀数组》一文。</p>
<p>模板</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 200003
using namespace std;
char ch[200003];
int a[N],v[N],sa[2][N],rk[2][N];//sa[i]表示排名为i的后缀的起点下标，rk[i]表示第i位的后缀的优先级
//之所以有两维是因为2^k是由两段2^k-1推来的，所以两维分别表示的是两段 
int n,m,k;
void calcsa(int sa[N],int rank[N],int SA[N],int Rank[N])
{
     for(int i=1;i&lt;=n;++i)v[rank[sa[i]]]=i;//v[i]表示排名为i的后缀，最靠后的位置在哪一位
     for(int i=n;i&gt;=1;--i)
         if(sa[i]&gt;k)
             SA[v[rank[sa[i]-k]]--]=sa[i]-k;
     for(int i=n-k+1;i&lt;=n;++i)
         SA[v[rank[i]]--]=i;
     for(int i=1;i&lt;=n;++i)
         Rank[SA[i]]=Rank[SA[i-1]]+(rank[SA[i-1]]!=rank[SA[i]]||rank[SA[i-1]+k]!=rank[SA[i]+k]);//双关键字排序
}
void work()
{
    int p=0,q=1;
    for (int i=1;i&lt;=n;i++) v[a[i]]++;//统计每个字符出现了多少次 
    for (int i=1;i&lt;=256;i++) v[i]+=v[i-1];//统计出前缀和即可知道每个字符在串中的排名 
    for (int i=1;i&lt;=n;i++)
     sa[p][v[a[i]]--]=i;//因为每个字符不一定只出现了一次，但是不同的后缀不能用同样的排名，所以每次--，有效的防止了重复，并且保证了后面长度短的后缀排名更靠前 
    for (int i=1;i&lt;=n;i++)//rk 与sa 互为逆运算，知道另一个就可以O(n)求出另一个 
     rk[p][sa[p][i]]=rk[p][sa[p][i-1]]+(a[sa[p][i-1]]!=a[sa[p][i]]);//如果相邻两个相同，那么他们的优先级也是相同的 
    k=1;//字符串的初始长度，因为是双关键字计数排序，所以刚开始sa[q]为0，相当于只看第一个关键字 
    while (k&lt;n)
    {
        calcsa(sa[p],rk[p],sa[q],rk[q]);
        p^=1; q^=1; k&lt;&lt;=1;
    }
    for (int i=1;i&lt;=n;i++)
     {
         printf(&quot;%d &quot;,sa[p][i]);
     } 
    printf(&quot;\n&quot;);
    for (int i=1;i&lt;=n;i++)//sa[p]中存储的就是最终后缀数组的排名 
    {
        if (sa[p][i]&lt;=n/2)
         printf(&quot;%c&quot;,ch[sa[p][i]+n/2-1]);//这里是为什么呢?以样例为例展环为链后为JSOI07JSOI07 ，那么根据排名sa[p]最终会变成 0077IIJJOOSS,因为是读最后一列，所以是sa[p][i]+n/2-1，即当前点的前一位，因为是环嘛，划一划就明白了。 
    }
}
int main()
{
    scanf(&quot;%s&quot;,ch+1);
    int len=strlen(ch+1);
    for (int i=1;i&lt;=len;i++)//展环为链 
    {
        a[i]=int(ch[i]);
        a[i+len]=a[i];
        ch[i+len]=ch[i];
    }
    n=len&lt;&lt;1;
    work();
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/12/01/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/12/01/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/" itemprop="url">最大流最小割</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-01T09:26:28+08:00">
                2019-12-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在最优化理论中，<strong>最大流最小割定理</strong>提供了对于一个网络流，<strong>从源点到目标点的最大的流量</strong>等于<strong>最小割的每一条边的和</strong>。即对于一个如果移除其中任何一边就会断开源点和目标点的边的集合的边的容量的总和。</p>
<p>因此<strong>求最小割：</strong></p>
<p>方法一：用最大流最小割定理，用网络流的dinic 算法解出最大流即可.</p>
<p>方法二：可以求出对偶图，然后求对偶图的最短路即可。</p>
<p>原图里面的封闭的面，在其对偶图里面就是点，横跨两个面的边的权值，就是对偶图连接两个点的边的权值.见例题BZOJ1001</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
typedef long long ll;
int n,m;
int ne;
const int N=1000010;
struct data
{
    int to,next,v;
}e[N&lt;&lt;3];
int head[N];
int h[N],q[N],ans;
inline void add(int u,int v,int w)
{
    ne++;
    e[ne].to=v;
    e[ne].v=w;
    e[ne].next=head[u];
    head[u]=ne;
}
inline bool BFS()
{
    int now,i;
    memset(h,-1,sizeof(h));
    int t=0,w=1;
    q[t]=1;
    h[1]=0;
    while(t&lt;w)
    {
        now=q[t];
        t++;
        i=head[now];
        while(i)
        {
            if(e[i].v&amp;&amp;h[e[i].to]&lt;0)
            {
                q[w++]=e[i].to;
                h[e[i].to]=h[now]+1;
            }
            i=e[i].next;
        }
    }
    if(h[n*m]==-1)
        return false;
    return true;
}
inline int DFS(int x,int f)
{
    if(x==n*m)
        return f;
    int i=head[x];
    int w,used=0;
    while(i)
    {
        if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
        {
            w=f-used;
            w=DFS(e[i].to,min(w,e[i].v));
            e[i].v-=w;
            e[i+1].v+=w;
            used+=w;
            if(used==f)
                return f;
        }
        i=e[i].next;
    }
    if(!used)
        h[x]=-1;
    return used;
}
inline void dinic()
{
    while(BFS())
    {
        ans+=DFS(1,0x7f7f7f7f);
    }
}
int inline get(int x, int y)
{
    return (x - 1)*m + y;
}
main(){
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){
        //init();
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt; m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j), get(i,j+1),temp);
                //add(get(i,j+1), get(i,j), 0);
                add(get(i,j+1), get(i,j), temp); 
                //add(get(i,j), get(i,j+1),0);
            }
        }
        for(int i = 1; i &lt; n; i++)
        {
            for(int j = 1; j &lt;= m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j), get(i+1,j), temp);
                //add(get(i+1,j),get(i,j),0);
                add(get(i+1,j),get(i,j),temp);
                //add(get(i,j), get(i+1,j), 0);
            }
        }
        for(int i = 1; i &lt; n; i++)
        {
            for(int j = 1; j &lt; m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j),get(i+1,j+1),temp);
                //add(get(i+1,j+1),get(i,j),0);
                add(get(i+1,j+1),get(i,j),temp);
                //add(get(i,j),get(i+1,j+1),0);
            }
        }   
        dinic();
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/11/30/BZOJ%E7%9C%9Fnm%E5%AD%A4%E5%84%BF%E8%AF%84%E6%B5%8B%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/11/30/BZOJ%E7%9C%9Fnm%E5%AD%A4%E5%84%BF%E8%AF%84%E6%B5%8B%E6%9C%BA/" itemprop="url">BZOJ真nm孤儿评测机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T23:42:56+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>调了一晚上改成cin变成scanf就可以了???我的时间不重要吗？？？一晚上就写了那道破题。md神经病</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/11/30/%5B%E7%AE%97%E6%B3%95%5D%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/11/30/%5B%E7%AE%97%E6%B3%95%5D%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/" itemprop="url">[算法]矩阵树定理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-30T19:42:54+08:00">
                2019-11-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址 <a href="http://old.orzsiyuan.com/articles/algorithm-Matrix-Tree-Theorem/" target="_blank" rel="noopener">http://old.orzsiyuan.com/articles/algorithm-Matrix-Tree-Theorem/</a></p>
<p>另一篇比较好的： <a href="https://leflacon.github.io/9548c271/" target="_blank" rel="noopener">https://leflacon.github.io/9548c271/</a></p>
<blockquote>
<p>矩阵树定理用于计算无向图生成树个数，和基尔霍夫矩阵的行列式密切相关。</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="基尔霍夫矩阵"><a href="#基尔霍夫矩阵" class="headerlink" title="基尔霍夫矩阵"></a>基尔霍夫矩阵</h3><p>在了解矩阵树定理前，我们先学习一下基尔霍夫矩阵的求法。</p>
<p>我们记基尔霍夫矩阵为 ​K​（Kirchhoff​Kirchhoff​ 的缩写），并直接计算出无向图 ​G​ 的度数矩阵 D​ 和邻接矩阵 ​A​，那么我们同通过 K=D−A​就可以计算出基尔霍夫矩阵。</p>
<p>也就是说：</p>
<p>无向图的基尔霍夫矩阵: 对角线上表示每个点的度数,若ij之间有边则矩阵ij处为-1<br>无向图的生成树的数目为: 任意一个n-1阶主子式的行列式的绝对值.</p>
<h3 id="主子式"><a href="#主子式" class="headerlink" title="主子式"></a>主子式</h3><p>取出矩阵 A 的 k 行和 k 列组成的新矩阵 A′ 叫做 A 的 k 阶主子式。</p>
<hr>
<h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><p>矩阵树定理用于求解一个无向图的生成数个数，<strong>允许有重边和自环</strong>。</p>
<p>对于一个图G来说，G的<strong>「度数矩阵」</strong><code>D[G]</code>是一个<code>n*n</code>的矩阵，当<code>i≠j</code>时，<code>dij=0</code>，当<code>i=j</code>时，dij等于vi的度数</p>
<p>G的<strong>「邻接矩阵」</strong><code>A[G]</code>是一个<code>n*n</code>的矩阵，如果vi，vj之间有边直接相连，<code>dij=1</code>，否则为0</p>
<p>G的<strong>「Kirchhoff矩阵」</strong>（基尔霍夫矩阵/拉普拉斯算子）<code>C[G]</code>为<code>C[G]=D[G]-A[G]</code></p>
<p>如果G是一棵树，那么它的基尔霍夫矩阵C的任一个n-1阶主子式的行列式均为1<strong>「Matrix-Tree定理」（生成树定理）</strong>：G的所有不同的生成树的个数等于其基尔霍夫矩阵<code>C[G]</code>任何一个n-1阶主子式的行列式的绝对值</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>由于笔者能力有限（太菜了不会证明），这里推荐一篇博客：<a href="https://blog.csdn.net/werkeytom_ftd/article/details/54914530" target="_blank" rel="noopener">生成树计数问题——矩阵树定理及其证明 - WerKeyTom_FTD</a></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>构造基尔霍夫矩阵，并求出其任何一个 n−1 阶主子式的行列式即可。行列式的具体求法详见<a href="https://orzsiyuan.com/articles/algorithm-Determinant/" target="_blank" rel="noopener">「算法笔记」行列式</a>。</p>
<p><strong>时间复杂度</strong>：O(n3logn)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/11/28/CodeforcesRound#312(Div.2)(done)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/11/28/CodeforcesRound#312(Div.2)(done)/" itemprop="url">Codeforces Round #312 (Div. 2)(done)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-28T19:57:40+08:00">
                2019-11-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-Amr-and-Chemistry"><a href="#C-Amr-and-Chemistry" class="headerlink" title="C - Amr and Chemistry"></a><a href="https://codeforces.com/contest/558/problem/C" target="_blank" rel="noopener">C - Amr and Chemistry</a></h2><p>数的最短路(自己取的名字).</p>
<pre><code>/*
Date              : 2019-11-24    10:55:11
By                : Tpaaaaaa
File_Name         ：C-andChemistry.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5;
int n;
int cnt[MAXN + 10], step[MAXN + 10];
void solve(int x)
{
    int temp = x;
    int s = 0;
    while(temp &lt;= MAXN)             //往左移.
    {
        cnt[temp]++;
        step[temp] += s;
        temp &lt;&lt;= 1;
        s++;
    }
    s = 1;
    temp = x;
    while(temp &gt; 1)
    {
        if(temp &amp; 1)
        {
            int cc = temp;
            cc &gt;&gt;= 1;
            int ss = 0;
            while(cc &lt;= MAXN)
            {
                cnt[cc]++;
                step[cc] += s + ss;
                ss++;
                cc &lt;&lt;= 1;
            }
            temp &gt;&gt;= 1;
            s++;
        }
        else
        {
            temp &gt;&gt;= 1;
            cnt[temp]++;
            step[temp] += s;
            s++;
        }

    }

}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int ans = INF;
        memset(cnt, 0, sizeof cnt);
        memset(step, 0, sizeof step);
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            solve(temp);
        }
        for(int i = 1; i &lt;= MAXN; i++)
            if(cnt[i] == n)
                ans = min(ans, step[i]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><h2 id="E-A-Simple-Task"><a href="#E-A-Simple-Task" class="headerlink" title="E - A Simple Task"></a><a href="https://codeforces.com/contest/558/problem/E" target="_blank" rel="noopener">E - A Simple Task</a></h2><p>线段树 + 计数排序的思想.</p>
<pre><code>/*
Date              : 2019-11-28    17:12:33
By                : Tpaaaaaa
File_Name         ：EASimpleTask.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
线段树 + 计数排序的思想.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int n, q;
int cnt[30];
struct Node
{
    int L, R;             //节点维护的区间是[L, R]
    int sum;              //维护的区间上的一些信息,这个字母的数目
    int lazy;             //懒标记，0为全置0,1为全置1. -1为无标记
};
Node node[4 * MAXN][30];
void built(int root, int L, int R, int i)
{
    node[root][i].L = L;
    node[root][i].R = R;
    node[root][i].sum = 0;
    node[root][i].lazy = -1;
    if(L != R)
    {
        int mid = md(L, R);
        built(ls(root), L, mid, i);
        built(rs(root), mid + 1, R, i);
    }
}
void pushDown(int root, int i)
{
    if(node[root][i].lazy != -1)
    {
        node[ls(root)][i].lazy = node[rs(root)][i].lazy = node[root][i].lazy;
        if(node[root][i].lazy == 0)
        {
            node[rs(root)][i].sum = 0;
            node[ls(root)][i].sum = 0;
        }
        else
        {
            node[rs(root)][i].sum = node[rs(root)][i].R - node[rs(root)][i].L + 1;
            node[ls(root)][i].sum = node[ls(root)][i].R - node[ls(root)][i].L + 1;
        }
        node[root][i].lazy = -1;

    }
}
void pushUp(int root, int i)
{
    node[root][i].sum = node[ls(root)][i].sum + node[rs(root)][i].sum;
}
void update(int root, int L, int R, int v, int i)
{
    if(node[root][i].L == L &amp;&amp; node[root][i].R == R)
    {
        node[root][i].lazy = v;
        if(v == 1)
            node[root][i].sum = R - L + 1;
        else 
            node[root][i].sum = 0;
        return;
    }
    pushDown(root, i);
    int mid = md(node[root][i].L, node[root][i].R);
    if(R &lt;= mid)
        update(ls(root), L, R, v, i);
    else if(L &gt; mid)
        update(rs(root), L, R, v, i);
    else
    {
        update(ls(root), L, mid, v, i);
        update(rs(root), mid + 1, R, v, i);
    }
    pushUp(root, i);

}
int query(int rt, int l, int r, int i)
{
    if(node[rt][i].L == l &amp;&amp; node[rt][i].R == r)
        return node[rt][i].sum;
    int mid = md(node[rt][i].L, node[rt][i].R);
    pushDown(rt, i);
    if(r &lt;= mid)
        return query(ls(rt), l, r, i);
    else if(l &gt; mid)
        return query(rs(rt), l, r, i);
    else
    {
        return query(ls(rt), l, mid, i) + query(rs(rt), mid + 1, r, i);
    }

}
char s[MAXN];
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) != EOF)
    {
        for(int i = 1; i &lt;= 26; i++)
            built(1, 1, n, i);           //建立26个线段树
        scanf(&quot;%s&quot;, s);
        for(int i = 0; i &lt; n; i++)
        {
            char temp;
            temp = s[i];
            update(1, i + 1, i + 1, 1, temp - &apos;a&apos; + 1);
        }
        //printf(&quot;??&quot;);
        for(int i = 1; i &lt;= q; i++)
        {
            int l, r, k;
            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
            for(int j = 1; j &lt;= 26; j++)
            {
                cnt[j] = query(1, l, r, j);
                update(1, l, r, 0, j);
                //printf(&quot;cnt[%d] = %d\n&quot;, j, cnt[j]);
            }
            if(k == 1)
            {
                int ret = l;
                for(int j = 1; j &lt;= 26; j++)
                {
                    if(cnt[j] &gt; 0)
                    {
                        update(1, ret, ret + cnt[j] - 1, 1, j);
                        ret += cnt[j];
                    }
                }                
            }
            else
            {
                int ret = l;
                for(int j = 26; j &gt;= 1; j--)
                {
                    if(cnt[j] &gt; 0)
                    {
                        update(1, ret, ret + cnt[j] - 1, 1, j);
                        ret += cnt[j];
                    }
                }     
            }

        }  
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= 26; j++)
            {
                if(query(1, i, i, j))
                {
                    printf(&quot;%c&quot;, &apos;a&apos; + j - 1);
                    break;
                }
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><p>D. Guess Your Way Out! II  </p>
<hr>
<p>WA了85点，不想改了。累了累了</p>
<pre><code>/*
Date              : 2019-11-28    19:59:57
By                : Tpaaaaaa
File_Name         ：DGuessYourWayOutII.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
int h, q;
typedef pair&lt;ll, int&gt; P;
struct Ques
{
    int j;
    ll l, r;
    int an;
}ques[100000 + 10];
struct Edge
{
    ll l, r;   //区间[]
    ll sum = 0;    //区间长度, r - l + 1;
}ans;
//返回a与b区间求交
Edge mul(Edge a, Edge b)
{
    Edge temp;
    temp.l = max(a.l, b.l);
    temp.r = min(a.r, b.r);
    temp.sum = temp.r - temp.l + 1;
    return temp;
}
//左右区间
ll getleft(ll u, int i, int h)
{
    return u * pow(2, h - i);
}
ll getright(ll u, int i, int h)
{
    while(i &lt; h)
    {
        u = u * 2 + 1;
        i++;
    }
    return u;
}
vector &lt;Edge&gt; vec;
vector &lt;P&gt; v;
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;h, &amp;q) != EOF)
    {
        vec.clear();
        v.clear();
        ans.l = pow(2, h - 1);
        ans.r = pow(2, h) - 1;
        ans.sum = ans.l;
        int flag = 0;
        for(int i = 1; i &lt;= q ;i++)
        {
            scanf(&quot;%d%lld%lld%d&quot;, &amp;ques[i].j, &amp;ques[i].l, &amp;ques[i].r, &amp;ques[i].an);
        }
        for(int i = 1; i &lt;= q; i++)
        {
            if(ques[i].an == 0) continue;
            int j = ques[i].j;
            ll l = ques[i].l;
            ll r = ques[i].r;

            ll lef = getleft(l, j, h);
            ll rig = getright(r, j, h);
            Edge temp;
            temp.l = lef; 
            temp.r = rig;
            temp.sum = rig - lef + 1;
            ans = mul(ans, temp);
            if(ans.sum &lt;= 0)            //说明不可能.
            {
                flag = -1;              //-1表示cheated.
                break;
            }
        }
        if(flag != -1)
        {
            for(int i = 1; i &lt;= q; i++)
            {
                if(ques[i].an == 1) continue;
                int j = ques[i].j;
                ll l = ques[i].l;
                ll r = ques[i].r;
                ll lef = getleft(l, j, h);
                ll rig = getright(r, j, h);
                v.push_back(P(lef, 1));
                v.push_back(P(rig, -1));
            }
            sort(v.begin(), v.end());
            int sta = 0;
            ll bef = pow(2, h - 1);
            for(int i = 0; i &lt; v.size(); i++)
            {
                if(sta == 0)
                {
                    Edge temp;
                    temp.l = bef;
                    temp.r = v[i].first - 1;

                    temp.sum = temp.r - temp.l + 1;
                    Edge tem = mul(ans, temp);
                    if(tem.sum &gt; 0)
                        vec.push_back(tem);
                }
                sta += v[i].second;
                bef = v[i].first + 1;
            }
            if(sta == 0)
            {
                Edge temp;
                temp.l = bef;
                temp.r = pow(2, h) - 1;

                temp.sum = temp.r - temp.l + 1;
                Edge tem = mul(ans, temp);
                if(tem.sum &gt; 0)
                    vec.push_back(tem);
            }
        }

        int sum = 0;
        //将全域覆盖完了，这就是game cheated
        //也就是vec.size() == 0
        //如果没有询问,则是条件不足
        if(flag == -1 || (vec.size() == 0 &amp;&amp; ans.sum &gt; 0))
            printf(&quot;Game cheated!\n&quot;);
        else
        {
            ll tempans = -1;
            for(int i = 0; i &lt; vec.size(); i++)
            {
                if(vec[i].sum &gt; 0)   
                {
                    sum += vec[i].sum;
                    tempans = vec[i].l;
                }
            }/*
            if(h == 1 &amp;&amp; q == 0)
            {
                printf(&quot;1\n&quot;);
            }*/
            if(sum &gt; 1 || sum &lt; 0)
                printf(&quot;Data not sufficient!\n&quot;);
            else if(sum == 1)
            {
                printf(&quot;%lld\n&quot;, tempans);
            }
            else if(sum == 0)
            {
                printf(&quot;Game cheated!\n&quot;);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/11/27/%E5%88%86%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/11/27/%E5%88%86%E5%9D%97/" itemprop="url">分块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-27T21:15:54+08:00">
                2019-11-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文<a href="https://blog.csdn.net/XianHaoMing/article/details/52201698" target="_blank" rel="noopener">https://blog.csdn.net/XianHaoMing/article/details/52201698</a></p>
<p>先简单介绍一下分块算法。<br>分块算法是一种很常见的根号算法，一般它的时间复杂度会带根号。<br>分块和线段树的区别在于，<strong>分块算法可以维护一些线段树维护不了的东西</strong>，例如单调队列等，<strong>线段树能维护的东西必须能够进行信息合并</strong>，而分块则不需要。不过，它们也有共同点，分块和线段树一样，分块需要支持<strong>类似标记合并</strong>的东西。<br>简单来说，分块算法就是<strong>优化过后的暴力</strong>。</p>
<p>现在讲一下这种算法的实现。<br>这种算法会将序列（序列长度为N）进行分块，通常设置一个上限K，每一块有至多K个元素。在序列分块问题上，一般会严格要求每个块都要有K个元素，这样就会分成约<strong>NK块</strong>。（最后一个块除外）</p>
<p>我们一般都会设K=N−−√，这样块数也就只有NK=N−−√块数可能多一。<br>通常实现时，我们用bei表示<strong>第i个位置所属的块</strong>。对于每个块都进行信息维护。</p>
<p><strong>单点修改</strong>时，我们一般先将对应块的<strong>标记下传</strong>，<strong>再暴力</strong>更新被修改块的状态。<br>时间复杂度O(n−−√)。</p>
<p>如果是<strong>区间[**</strong>L,<strong>**R]修改</strong>的话，对于<strong>被[**</strong>L,<strong>**R]整块跨过的块直接打标记</strong>，<strong>两端剩余的部分暴力重构块的状态</strong>即可。<br>中间最多经过n−−√块，两边暴力修改也是n−−√次的，所以时间复杂度为O(n−−√)。</p>
<p>至于<strong>询问操作</strong>，和区间修改类似，对于中间跨过的整块，<strong>直接利用块保存的信息统计答案</strong>，两端剩余部分任然可以暴力扫描统计。<br>时间复杂度和区间修改一样，也是O(n−−√)。</p>
<p>如果<strong>询问次数为**</strong>m<strong>，那总的时间</strong>复杂度即为<strong><strong>O(</strong></strong>mn−−√)**。</p>
<p>这就是最简单的分块思想，虽然思路很简单，但实现起来，本人觉得有点复杂。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="page-number current">2</span><a class="page-number" href="/tpaaaaaa.github.io/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/3/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">246</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
