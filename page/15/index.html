<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;15&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/15/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/18/POJ3685Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/18/POJ3685Matrix/" itemprop="url">POJ 3685 Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-18T22:52:14+08:00">
                2019-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/" itemprop="url" rel="index">
                    <span itemprop="name">基本算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Matrix</p>
<p><strong>Time Limit:</strong> 6000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 10234</p>
<p><strong>Accepted:</strong> 3190</p>
<p>Description</p>
<p>Given a <em>N</em> × <em>N</em> matrix A, whose element in the <em>i</em>-th row and <em>j</em>-th column <em>Aij</em> is an number that equals <em>i</em>2 + 100000 × <em>i</em> + <em>j</em>2 - 100000 × <em>j</em> + <em>i</em> × <em>j</em>, you are to find the <em>M</em>-th smallest element in the matrix.</p>
<p>Input</p>
<p>The first line of input is the number of test case.<br>For each test case there is only one line contains two integers, <em>N</em>(1 ≤ <em>N</em> ≤ 50,000) and <em>M</em>(1 ≤ <em>M</em> ≤ <em>N</em> × <em>N</em>). There is a blank line before each test case.</p>
<p>Output</p>
<p>For each test case output the answer on a single line.</p>
<p>Sample Input</p>
<p>12</p>
<p>1 1</p>
<p>2 1</p>
<p>2 2</p>
<p>2 3</p>
<p>2 4</p>
<p>3 1</p>
<p>3 2</p>
<p>3 8</p>
<p>3 9</p>
<p>5 1</p>
<p>5 25</p>
<p>5 10</p>
<p>Sample Output</p>
<p>3<br>-99993<br>3<br>12<br>100007<br>-199987<br>-99993<br>100019<br>200013<br>-399969<br>400031<br>-99939</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>题目类型：找第k小的元素。</strong> 方法：二分套二分</p>
<p>给你矩形，矩形上的每个点值都是确定的<br>你要去找第m小的值<br>二分套二分<br>同行元素递减，同列元素递增</p>
<p>我们第一层二分，枚举的是答案，也就是第m小的数，设我们枚举的是midAns</p>
<p>然后去判断比这个数小的数目，如果比他小的数目 要大于or等于m，说明他会排在m的后面，因此我们要将第一次二分往左边缩小<br>否则的话，如果比他小的数目要小于 m，说明他会排在m的前面，因此我们要将第一层二分往右边扩大</p>
<p>那么怎么快速的得到在这个矩阵里面比midAns小的数的数目呢，这就需要在矩形里面矩形二分了，也就是在二分里面套一个二分</p>
<p>我们分析可以知道，i^2 + 100000 × i + j^2 - 100000 × j + i × j 在这个表达式里面，在同一行or同一列里面都是单调的<br>显然可以对行or对列进行二分，快速得到这一列or一行中小于midAns的数目，然后将每一行or列 的数目累加起来，就是整个<br>矩形小于midAns的数目了<br>我们分析每一列的数目<br>那么对于某一列而言，i2 + 100000 × i + j2 - 100000 × j + i × j 这个表示里面的j就相当于是一个常数<br>我们可以求导得到 2i + 100000 - j 这个显然是大于0的，也就是说，在一列当中，按行数递增，第一行最小，最后一行最大<br>那么我们二分枚举中间行，然后…快速确定小于的数目，然后累加</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
ll n;
//那么我们发现1，n
ll cal(ll i, ll j)
{
    return i*i + 100000 * i + j * j - 100000 * j + i * j;
}
//返回矩阵中比m小的数的数目
ll solve(ll m)
{
    ll ret = 0;
    for(int j = 1; j &lt;= n; j++)     //枚举每一列
    {
        ll l = 1;                   //二分每一行，
        ll r = n;
        ll cnt = n;
        while(l &lt;= r)
        {
            ll mid = md(l, r);
            ll temp = cal(mid, j);
            if(temp &gt;= m)
            {
                r = mid - 1;
                cnt = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        ret += cnt;
    }
    return ret;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    ll m;
    while(t--)
    {
        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
        ll l =  - ( 3 * n * n + 200000 * n );
        ll r =    ( 3 * n * n + 200000 * n );
        ll ans=0;
        while(l &lt;= r)
        {
            ll mid = md(l, r);
            ll sum = solve(mid);        //返回的是比mid小的数目
            if(sum &gt;= m)                 //排名靠后了，说明取大了
            {
                r = mid - 1;
                ans = r;
            }
            else
                l = mid + 1；
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/17/HDU5052Yaoge%E2%80%99smaximumprofit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/17/HDU5052Yaoge%E2%80%99smaximumprofit/" itemprop="url">HDU 5052 Yaoge’s maximum profit</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-17T22:47:03+08:00">
                2019-09-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Yaoge’s-maximum-profit"><a href="#Yaoge’s-maximum-profit" class="headerlink" title="Yaoge’s maximum profit"></a>Yaoge’s maximum profit</h1><p>*<em>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)<br>Total Submission(s): 1637    Accepted Submission(s): 546<br>*</em></p>
<p>Problem DescriptionYaoge likes to eat chicken chops late at night. Yaoge has eaten too many chicken chops, so that Yaoge knows the pattern in the world of chicken chops. There are N cities in the world numbered from 1 to N . There are some roads between some cities, and there is one and only one simple path between each pair of cities, i.e. the cities are connected like a tree. When Yaoge moves along a path, Yaoge can choose one city to buy ONE chicken chop and sell it in a city after the city Yaoge buy it. So Yaoge can get profit if Yaoge sell the chicken chop with higher price. Yaoge is famous in the world. AFTER Yaoge has completed one travel, the price of the chicken chop in each city on that travel path will be increased by V .<br>InputThe first line contains an integer T (0 &lt; T ≤ 10), the number of test cases you need to solve. For each test case, the first line contains an integer N (0 &lt; N ≤ 50000), the number of cities. For each of the next N lines, the i-th line contains an integer Wi(0 &lt; Wi ≤ 10000), the price of the chicken chop in city i. Each of the next N - 1 lines contains two integers X Y (1 ≤ X, Y ≤ N ), describing a road between city X and city Y . The next line contains an integer Q(0 ≤ Q ≤ 50000), the number of queries. Each of the next Q lines contains three integer X Y V(1 ≤ X, Y ≤ N ; 0 &lt; V ≤ 10000), meaning that Yaoge moves along the path from city X to city Y , and the price of the chicken chop in each city on the path will be increased by V AFTER Yaoge has completed this travel.<br>OutputFor each query, output the maximum profit Yaoge can get. If no positive profit can be earned, output 0 instead.<br>Sample Input</p>
<p>1<br>5<br>1<br>2<br>3<br>4<br>5<br>1 2<br>2 3<br>3 4<br>4 5<br>5<br>1 5 1<br>5 1 1<br>1 1 2<br>5 1 1<br>1 2 1</p>
<p>Sample Output</p>
<p>4<br>0<br>0<br>1<br>0</p>
<p>Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2014+ACM%2FICPC+Asia+Regional+Shanghai+Online&source=1&searchmode=source" target="_blank" rel="noopener">2014 ACM/ICPC Asia Regional Shanghai Online</a><br>Recommendhujie</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树链剖分。但是细节好多，我这种弱鸡调了半天，烦 但最后还是AC了，今日份的开心。但感觉自己对树链剖分更加熟练了。</p>
<p>要学会自己出数据，学会Debug。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-17-12.16.14
 By                : Tpaaaaaa
 Question_Number   ：HDU 5052
 Question_Name     ：线段树
 Description       :
 询问树上路径的最大值减去最小值
 不对，是有顺序的。
 所以在合并区间的时候。如果右区间的最小值 与 左区间的最大值的差，要大于左区间的差 和右区间的差，则更新差
 不然的话，就用左区间和右区间里面较大的差作为区间的差，并且更最大值和最小值。
 所以线段树维护的区间信息包括 区间的最小值，区间的最大值，区间的顺序最大差。
 还有就是在跳的时候，好像会不一样吧。
 左边的遍历顺序是从dfn大的往dfn小的走
 因此就是左边的区间取的是最大值，右边的区间取得是最小值。
 因此，我们要保存的差，分为两类，左大右小，一类是左小右大。
 然后更新的时候，差不会边，最值分别加v即可。



 变成了区间查询 和区间修改.
 树链剖分就可以解决了
 编一个数据
 1
 5
 1 2 3 4 5
 1 2
 2 4
 2 5
 1 3
 5
 1 2 1
 1 4 1
 1 5 1
 4 3 1
 5 3 1

  1
 5
 1 2 3 4 5
 1 2
 2 4
 2 5
 1 3
 5
 5 3 1
 3 5 1
 5 4 1
 4 5 1
 2 3 1

 题目数据给的太弱了，要自己造几个！！！ 别过了样例就兴高采烈的提交
 AC了   爽！！！！网络赛的题目，感觉自己的线段树变强了

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int e[MAXN][3], head[MAXN], cnt, tot, val, dep[MAXN], son[MAXN], top[MAXN], rk[MAXN], dfn[MAXN], fa[MAXN];
int flag[MAXN];
int siz[MAXN], a[MAXN];
inline int Read(){
     int x = 0,f = 1;char c = getchar();
     while(c &lt; &apos;0&apos; || c &gt; &apos;9&apos;){if(c == &apos;-&apos;) f = -1;c = getchar();}
     while(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;){x = x * 10 + c - &apos;0&apos;;c = getchar();}
     return x * f;
  }
struct Edge
{
    int v, next;
} edge[MAXN * 2];
inline void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    //dif[0]是左小右大
    int l, r, dif[2], mx, mn, lazy;
}node[MAXN * 4];
inline void pushUp(int rt)
{
    node[rt].mx = max(node[ls(rt)].mx, node[rs(rt)].mx);
    node[rt].mn = min(node[ls(rt)].mn, node[rs(rt)].mn);

    node[rt].dif[0] = node[rs(rt)].mx - node[ls(rt)].mn;
    node[rt].dif[0] = max(node[rt].dif[0], node[rs(rt)].dif[0]);
    node[rt].dif[0] = max(node[rt].dif[0], node[ls(rt)].dif[0]);
    node[rt].dif[1] = node[ls(rt)].mx - node[rs(rt)].mn;
    node[rt].dif[1] = max(node[rt].dif[1], node[rs(rt)].dif[1]);
    node[rt].dif[1] = max(node[rt].dif[1], node[ls(rt)].dif[1]);
}
inline void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].lazy = 0;
    if(l == r)
    {
        node[rt].mx = node[rt].mn = a[rk[l]];   //存的是dfn序列，所以用rk
        node[rt].dif[0] = node[rt].dif[1] = 0;
        return ;
    }
    int mid = md(l, r);
    built(ls(rt), l, mid);
    built(rs(rt), mid + 1, r);
    pushUp(rt);
}
//将l, r区间里面的值都加v
inline void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[ls(rt)].lazy += node[rt].lazy;
        node[rs(rt)].lazy += node[rt].lazy;
        node[ls(rt)].mn += node[rt].lazy;
        node[rs(rt)].mn += node[rt].lazy;
        node[ls(rt)].mx += node[rt].lazy;
        node[rs(rt)].mx += node[rt].lazy;
        node[rt].lazy = 0;
    }
}
void update(int rt, int l, int r, int v)
{
    if(l &gt; node[rt].r || r &lt; node[rt].l)
        return;
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy += v;
        node[rt].mn += v;
        node[rt].mx += v;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update(ls(rt), l, r, v);
    else if(l &gt; mid)
        update(rs(rt), l, r, v);
    else
    {
        update(ls(rt), l, mid, v);
        update(rs(rt), mid + 1, r, v);
    }
    pushUp(rt);
}
inline void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
inline void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u]) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
int query(int rt, int l, int r, int com, int &amp;tmax, int &amp;tmin)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        tmax = node[rt].mx;
        tmin = node[rt].mn;
        return node[rt].dif[com];
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r, com, tmax, tmin);
    else if(l &gt; mid)
        return query(rs(rt), l, r, com, tmax, tmin);
    else
        {
            int mx1,mx2,mn1,mn2;
            int ans1 = query(ls(rt), l, mid, com, mx1, mn1);
            int ans2 = query(rs(rt), mid + 1, r, com, mx2, mn2);
            tmax = max(mx1, mx2);
            tmin = min(mn1, mn2);
            int ans = max(ans1, ans2);
            if(com == 0)
                ans = max(ans, mx2 - mn1);
            else
                ans = max(ans, mx1 - mn2);
            return ans;
        }
}
int lca(int u, int v)
{
    int ret = 0;
    // 要明白，要么起点往上跳，要么终点往上跳
    // maxv 和minv记录的是  非起点跳的区间的信息
    int tmax = 0, tmin = INF;
    int maxv = 0, minv = INF;
    int maxu = 0, minu = INF;
   while(top[u] != top[v])
    {
        if(dep[top[u]] &gt; dep[top[v]])               //说明这次跳的是起点
        {
             ret = max(ret, query(1, dfn[top[u]], dfn[u], 1, tmax, tmin));
             update(1, dfn[top[u]], dfn[u], val);
             //temp记录的是本次起点跳的区间的最值。
             ret = max(ret, tmax - minu);
             maxu = max(tmax, maxu);
             minu = min(tmin, minu);
             u = fa[top[u]];
        }
        else                                        //跳的是终点
        {
            ret = max(ret, query(1, dfn[top[v]], dfn[v], 0, tmax, tmin));
            update(1, dfn[top[v]], dfn[v], val);
            ret = max(ret, maxv - tmin);
            maxv = max(maxv, tmax);
            minv = min(minv, tmin);
            v = fa[top[v]];
        }
    }
    //目前在同一个链上了，并且u仍然是起点
    if(dep[u] &gt; dep[v])     //说明要跳起点,那么就要和终点跳的区间合并，我操。好难
    {
        ret = max(ret, query(1, dfn[v], dfn[u], 1, tmax, tmin));
        ret = max(ret, tmax - minu);
        minu = min(tmin, minu);

        ret = max(ret, maxv - minu);
        update(1, dfn[v], dfn[u], val);

    }
    else
    {
        ret = max(ret, query(1, dfn[u], dfn[v], 0, tmax, tmin));
        ret = max(ret, maxv - tmin);
        maxv = max(maxv, tmax);
        ret = max(ret, maxv - minu);
        update(1, dfn[u], dfn[v], val);
    }

    return ret;

}
inline void init()
{
    memset(head, -1, sizeof head);
    memset(siz, 0, sizeof siz);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;
}
int main()
{
    int t, n, x, y, q;
    t = Read();
    while(t--)
    {
        n = Read();
        init();
        for(int i = 1; i &lt;= n; i++)
            a[i] = Read();
        for(int i = 1; i &lt; n; i++)
        {
            x = Read(), y = Read();
            addEdge(x,y);
            addEdge(y,x);
        }
        fa[1] = 1;
        dfs1(1);
        dfs2(1,1);
        built(1, 1, n);
        q = Read();
        for(int i = 1; i &lt;= q; i ++)
        {
            x = Read(), y = Read(), val = Read();
            int ans = lca(x, y);
            printf(&quot;%d\n&quot;, ans);
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/POJ3237Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/POJ3237Tree/" itemprop="url">POJ 3237 Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T23:03:39+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Tree</p>
<p><strong>Time Limit:</strong> 5000MS</p>
<p><strong>Memory Limit:</strong> 131072K</p>
<p><strong>Total Submissions:</strong> 13998</p>
<p><strong>Accepted:</strong> 3547</p>
<p>Description</p>
<p>You are given a tree with <em>N</em> nodes. The tree’s nodes are numbered 1 through <em>N</em> and its edges are numbered 1 through <em>N</em> − 1. Each edge is associated with a weight. Then you are to execute a series of instructions on the tree. The instructions can be one of the following forms:</p>
<p><code>CHANGE</code> <em>i</em> <em>v</em></p>
<p>Change the weight of the <em>i</em>th edge to <em>v</em></p>
<p><code>NEGATE</code> <em>a</em> <em>b</em></p>
<p>Negate the weight of every edge on the path from <em>a</em> to <em>b</em></p>
<p><code>QUERY</code> <em>a</em> <em>b</em></p>
<p>Find the maximum weight of edges on the path from <em>a</em> to <em>b</em></p>
<p>Input</p>
<p>The input contains multiple test cases. The first line of input contains an integer <em>t</em> (<em>t</em> ≤ 20), the number of test cases. Then follow the test cases.</p>
<p>Each test case is preceded by an empty line. The first nonempty line of its contains <em>N</em> (<em>N</em> ≤ 10,000). The next <em>N</em> − 1 lines each contains three integers <em>a</em>, <em>b</em> and c, describing an edge connecting nodes <em>a</em> and <em>b</em> with weight <em>c</em>. The edges are numbered in the order they appear in the input. Below them are the instructions, each sticking to the specification above. A lines with the word “<code>DONE</code>” ends the test case.</p>
<p>Output</p>
<p>For each “<code>QUERY</code>” instruction, output the result on a separate line.</p>
<p>Sample Input</p>
<p>1</p>
<p>3<br>1 2 1<br>2 3 2<br>QUERY 1 2<br>CHANGE 1 3<br>QUERY 1 2<br>DONE</p>
<p>Sample Output</p>
<p>1<br>3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样是树链剖分，只不过在线段树上的操作骚了一些而已。</p>
<p>Change 是改变某条边的权值</p>
<p>Query 是查询某条路径上的最大值</p>
<p>Negate 是将某条路径上的权值全部取相反数</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先是常规的树的输入部分</p>
<pre><code>for(int i = 1; i &lt; n; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
    addEdge(a, b);
    addEdge(b, a);
    e[i][0] = a;
    e[i][1] = b;
    e[i][2] = c;
}
fa[1] = 1;
dfs1(1);
dfs2(1, 1);
build(1, 1, n);</code></pre><p>然后是将边权下沉为点权的操作</p>
<pre><code>//接着是将边权下沉为点权
for(int i = 1; i &lt; n; i++)
{
    int u = e[i][0];
    int v = e[i][1];
    int w = e[i][2];
    if(dep[u] &lt; dep[v])
        swap(u, v);
    update1(1, dfn[u], w);
}</code></pre><p>显然，udpate1是线段树的单点更新，因为此题还要用到区间修改，所以取名update1</p>
<p>因为要进行取相反数的操作，所以我们维护的区间信息要包括最大值和最小值（取相反数后，二者会填负号后交换）</p>
<pre><code>void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>然后是处理查询部分</p>
<pre><code>while(cin &gt;&gt; s)
{
    if(s == &quot;DONE&quot;) break;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
        printf(&quot;%d\n&quot;, lca(a, b));
    else if(s == &quot;NEGATE&quot;)
    {
                          //这里憨憨了，是对dfs序上进行的处理
        Negate(a, b);
    }
    else if(s == &quot;CHANGE&quot;)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        update1(1, dfn[u], b);
    }

}</code></pre><p>lca函数就是树链剖分函数。求的是一条路径上的最大值。</p>
<pre><code>int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}</code></pre><p>query就是常规的线段树查询区间最大值的函数</p>
<pre><code>int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].maxx;
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}</code></pre><p>然后是Negate函数，这也是对路径上的修改，所以也是路径剖分函数（就是这里WA了很久o(╥﹏╥)o）</p>
<pre><code>void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}</code></pre><p>可能稍微麻烦一点的，就是因为是区间修改嘛，所以要用到lazy标记，所以它的区间修改部分就是update2.</p>
<p><strong>这种翻转问题的区间修改，都可以用酱紫的lazy标记哦</strong></p>
<pre><code>    node[rt].lazy = (node[rt].lazy + 1) % 2;

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        node[rt].maxx = - node[rt].maxx;
        node[rt].minn = - node[rt].minn;
        swap(node[rt].maxx, node[rt].minn);
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}</code></pre><p><strong>然后是pushDown函数</strong></p>
<pre><code>void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}</code></pre><p>完整代码：</p>
<pre><code>/*
 Date              : 2019-09-16-16.43.18
 By                : Tpaaaaaa
 Question_Number   ：POJ3237
 Question_Name     ：树链剖分
 Description       :

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int e[MAXN][3], head[MAXN], cnt, tot, dep[MAXN], son[MAXN], top[MAXN], rk[MAXN], dfn[MAXN], fa[MAXN];
int siz[MAXN];
struct Edge
{
    int v, next;
};
Edge edge[MAXN * 2];
struct Node
{
    int l, r, maxx, minn, lazy;    //要维护区间里面的最小值和sum
}node[MAXN * 4 * 2];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(siz, 0, sizeof siz);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;
}
void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u]) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void build(int rt, int l, int r)
{
    node[rt].l = l; //维护的是dfs序
    node[rt].r = r;
    node[rt].minn = node[rt].maxx = node[rt].lazy = 0;
    int mid = md(l, r);
    if(l == r)
        return;
    build(ls(rt), l, mid);
    build(rs(rt), mid + 1, r);
}
inline void pushUp(int rt)
{
    node[rt].minn = min(node[ls(rt)].minn, node[rs(rt)].minn);
    node[rt].maxx = max(node[ls(rt)].maxx, node[rs(rt)].maxx);
}
void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}

void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        int temp =  node[rt].maxx;
        node[rt].maxx = - node[rt].minn;
        node[rt].minn = - temp;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}
int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        return node[rt].maxx;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}
int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}
void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}
int main()
{
    int t, a, b, c, n;
    string s;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);
            addEdge(b, a);
            e[i][0] = a;
            e[i][1] = b;
            e[i][2] = c;
        }
        fa[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        build(1, 1, n);
        //接着是将边权下沉为点权
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            update1(1, dfn[u], w);
        }
        while(cin &gt;&gt; s)
        {
            if(s == &quot;DONE&quot;) break;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
            {
                int ans = lca(a, b);
                printf(&quot;%d\n&quot;, ans);
            }
            else if(s == &quot;NEGATE&quot;)
            {
            //这里憨憨了
                //if(dep[a] &gt; dep[b])
                    //swap(a, b);
                Negate(a, b);
               // update2(1, dfn[a], dfn[b]); //update2的作用是将[]区间里面的翻转次数加1
            }
            else if(s == &quot;CHANGE&quot;)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                update1(1, dfn[u], b);
            }

        }


    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/FZU2082%E8%BF%87%E8%B7%AF%E8%B4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/FZU2082%E8%BF%87%E8%B7%AF%E8%B4%B9/" itemprop="url">FZU 2082 过路费</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T22:47:42+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有n座城市，由n-1条路相连通，使得任意两座城市之间可达。每条路有过路费，要交过路费才能通过。每条路的过路费经常会更新，现问你，当前情况下，从城市a到城市b最少要花多少过路费。Input</p>
<p>有多组样例，每组样例第一行输入两个正整数n,m(2 &lt;= n&lt;=50000，1&lt;=m &lt;= 50000),接下来n-1行，每行3个正整数a b c，(1 &lt;= a,b &lt;= n , a != b , 1 &lt;= c &lt;= 1000000000).数据保证给的路使得任意两座城市互相可达。接下来输入m行，表示m个操作，操作有两种：一. 0 a b，表示更新第a条路的过路费为b，1 &lt;= a &lt;= n-1 ； 二. 1 a b ， 表示询问a到b最少要花多少过路费。Output对于每个询问，输出一行，表示最少要花的过路费。</p>
<p>Sample Input</p>
<p>2 3<br>1 2 1<br>1 1 2<br>0 1 2<br>1 2 1</p>
<p>Sample Output</p>
<p>1<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树链剖分的常用处理方式：将边权下沉到深度较深的点上，作为点的权值。</p>
<p>妙哉妙哉，借此来分析一下树链剖分的代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>树信息的录入</p>
<pre><code>        for(int i = 1; i &lt; n; i ++)
        {
//一条无向边 &lt;a,b&gt; 权值为c
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);</code></pre><p>然后就是树链剖分最为关键的两次dfs，第一次dfs，我们获得相关数组信息</p>
<pre><code>//siz[u]存的是以u为根的子树的大小
//dep[u]存的是结点u的深度
//f[u]存的是结点u的父结点
//son[u]存的是u结点的重儿子结点编号

void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}</code></pre><p>第二次dfs，我们将获得dfs序，top[]等信息</p>
<pre><code>//dfn[u] 存的是u结点在dfs序中的编号
//top[u] 存的是u结点所在重链上的头结点
//rk[tot] 保存的是dfs序中tot号结点的编号

void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}</code></pre><p>获得完dfs序后，我们对dfs序建立线段树，那么我们要将边权下沉到深度较深的结点上，作为点的权值</p>
<pre><code>//常规的线段树建树操作
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}

        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }</code></pre><p>update是线段树的单点更新</p>
<pre><code>void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>接着是处理询问</p>
<pre><code>while(m--)
{
    int op, a, b;
    scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
    //将第a条路的费用变成b
    if(op == 0)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        //妙哉
        update(1, dfn[u], b);
    }
    else //查询a到b的费用
    {
        ll ans = sum(a, b);
        //sum返回的是a到b的权值和
        printf(&quot;%lld\n&quot;, ans);
    }
}</code></pre><p>sum函数也是树链剖分里面一个较为重要的部分，实际上就是利用我们之前求出来的top数组，来进行求LCA等操作。将树上两结点的路径，转化为dfs序上一些区间的组合，这样我们对这条路径上的处理，就转化为了对dfs序上一些区间的处理，而对于一个一维数组的区间处理，线段树是很可的。</p>
<pre><code>//返回的是编号u点到v点的路径权值和，就是常规的线段树区间查询函数
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉，这样就没计算头结点的权值了。
    return ret;

}

/*
 Date              : 2019-09-16-08.40.58
 By                : Tpaaaaaa
 Question_Number   ：FZU 2082
 Question_Name     ：树链剖分
 Description       :
 //将边权转移到点权上，然后变成了树链剖分的模板题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int cnt, tot;
int e[MAXN][3], dep[MAXN], head[MAXN], f[MAXN], top[MAXN], dfn[MAXN], siz[MAXN], son[MAXN], rk[MAXN];
struct Node
{
    int l, r;
    ll sum;
}node[MAXN * 4];

struct Edge
{
    int v, next;
} edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}
//线段树的单点修改
//将k位置的值，变成c
inline void pushUp(int rt)
{
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}
//返回的是编号u点到v点的路径权值和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉
    return ret;

}
void init()
{
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;

}
int main()
{
    int n, m, a, b, c;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt; n; i ++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);
        built(1, 1, n);
        //两次dfs后，我们得到了dfs序
        //我们对dfs序建立线段树
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }
        while(m--)
        {
            int op, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
            //将第a条路的费用变成b
            if(op == 0)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                //妙哉
                update(1, dfn[u], b);
            }
            else //查询a到b的费用
            {
                ll ans = sum(a, b);
                //sum返回的是a到b的权值和
                printf(&quot;%lld\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/%5B%E7%AE%97%E6%B3%95%5DCDQ%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/%5B%E7%AE%97%E6%B3%95%5DCDQ%E5%88%86%E6%B2%BB/" itemprop="url">[算法]CDQ分治</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T21:12:09+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址<a href="https://www.cnblogs.com/hzf29721/p/10343179.html" target="_blank" rel="noopener">https://www.cnblogs.com/hzf29721/p/10343179.html</a></p>
<p>CDQ分治，有国家队某巨佬发明（仿佛是插头dp的论文作者？？？），主要用于解决带修改，查询，可排序序列的一系列问题，仅可支持<strong>离线操作</strong><br>CDQ分治的主要步骤有以下几点：<br>1、读入（废话）<br>1、将已经读入好的数据按照某关键字排序<br>2、设当前区间为[l,r][l,r]，递归处理左区间[l,mid][l,mid]和右区间[mid+1,r][mid+1,r]，计算左区间的修改操作对右区间的影响（一般用树状数组等数据结构维护）<br>3、清除数据结构内的修改数据<br>本题又叫三维偏序问题，是CDQ分治的经典题型<br>先按照第一维（即aiai）排序，这样就将问题转化到了二维<br>设当前区间为[l,r][l,r]<br>讲[l,mid][l,mid]和[mid+1,r][mid+1,r]分别按照第二维排序，此时在左区间中的aa均小于有区间中的aa(<strong>保证第一维</strong>)，设左区间已访问到plpl，右区间已访问到prpr(l≤pl≤mid,mid+1≤pr≤r)(l≤pl≤mid,mid+1≤pr≤r)<br>当b[pl]&lt;=b[pr]b[pl]&lt;=b[pr]时(<strong>保证第二维</strong>)，即将plpl点的cc值加入树状数组<br>统计比prpr点的cc值小或等于的点的数量(<strong>保证第三维</strong>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/%5B%E7%BA%AA%E5%BF%B5%5D%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84100%E7%AF%87%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/%5B%E7%BA%AA%E5%BF%B5%5D%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84100%E7%AF%87%E6%96%87%E7%AB%A0/" itemprop="url">[纪念]新博客的100篇文章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:52:07+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>8月19号开始，到9月15号。将近一个月的时间，感觉自己明显在变强！！！！加油加油！！！十一月的招新赛要加油！！！！！！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/HDU-3015DisharmonyTrees/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/HDU-3015DisharmonyTrees/" itemprop="url">HDU - 3015 Disharmony Trees</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:49:59+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>One day Sophia finds a very big square. There are n trees in the square. They are all so tall. Sophia is very interesting in them.   </p>
<p><img src="https://vj.ti12z.cn/e79e812bfb09daff576ac5ce95a12388?v=1566913617" alt=""></p>
<p>She finds that trees maybe disharmony and the Disharmony Value between two trees is associated with two value called FAR and SHORT. </p>
<p>The FAR is defined as the following:If we rank all these trees according to their X Coordinates in ascending order.The tree with smallest X Coordinate is ranked 1th.The trees with the same X Coordinates are ranked the same. For example,if there are 5 tree with X Coordinates 3,3,1,3,4. Then their ranks may be 2,2,1,2,5. The FAR of two trees with X Coordinate ranks D1 and D2 is defined as F = abs(D1-D2). </p>
<p>The SHORT is defined similar to the FAR. If we rank all these trees according to their heights in ascending order，the tree with shortest height is ranked 1th.The trees with the same heights are ranked the same. For example, if there are 5 tree with heights 4,1,9,7,4. Then their ranks may be 2,1,5,4,2. The SHORT of two trees with height ranks H1 and H2 is defined as S=min(H1,H2). </p>
<p>Two tree’s Disharmony Value is defined as F*S. So from the definition above we can see that, if two trees’s FAR is larger , the Disharmony Value is bigger. And the Disharmony value is also associated with the shorter one of the two trees. </p>
<p>Now give you every tree’s X Coordinate and their height , Please tell Sophia the sum of every two trees’s Disharmony value among all trees.InputThere are several test cases in the input </p>
<p>For each test case, the first line contain one integer N (2 &lt;= N &lt;= 100,000) N represents the number of trees. </p>
<p>Then following N lines, each line contain two integers : X, H (0 &lt; X,H &lt;=1,000,000,000 ), indicating the tree is located in Coordinates X and its height is H.OutputFor each test case output the sum of every two trees’s Disharmony value among all trees. The answer is within signed 64-bit integer.Sample Input</p>
<p>2<br>10 100<br>20 200<br>4<br>10 100<br>50 500<br>20 200<br>20 100</p>
<p>Sample Output</p>
<p>1<br>13</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>与之前的mofest题意差不多，解法差不多。维护两棵树状数组，一棵存的是树的数目，一棵存的是树的坐标和。只不过要离散化而已</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><pre><code>/*
 Date              : 2019-09-15-13.10.03
 By                : Tpaaaaaa
 Question_Number   ：poj 3015
 Question_Name     ：树状数组
 Description       :
 每棵树都有两个属性，一个是x，一个是h
 我们首先按照h单调递减排序
 然后按排序后的顺序依次取点

 假如取到第i棵树
 那么之前的i-1棵树的h 都要大于等于第i棵树的h
 那么第i棵树与之前i-1棵数的S=min(h1, h2) = h
 都是h
 设有3棵树在i之前，他们的坐标分为a，b，c
 设a = D(a), b = D(b) ...
 用离散化操作来处理。
 设第i棵树的坐标为x
 i与之前i-1棵树的value和 sum =
 sum = h*abs(a - x) + h*abs(b - x) + h*abs(c - x)
设a,b,c都小于x，也就是在x之前，那么sum
 sum = h*(x - a) + h*(x - b) + h*(x - c)
     = h(3*x - (a + b + c));
也就是说，将之前i-1棵树分成两部分，第一部分为
坐标小于x的，第二部分是坐标大于x的
 大于x部分的
 sum = h*((i - 3)*x - (tot - ()))




*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
ll c1[MAXN], c2[MAXN];
int lisan[2][MAXN];
struct Tree
{
    int x, h;
    friend bool operator &lt; (Tree a, Tree b)
    {
        return a.h &gt; b.h;
    }
};
Tree tree[MAXN];
int binSearch(int k, int n, int i)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int m = md(l, r);
        if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] != k )
            return m;
        else if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] == k )
            r = m - 1;
        else if(lisan[i][m] &gt; k)
            r = m - 1;
        else
            l = m + 1;
    }
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n, m, cnt;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        cnt = 0;
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;tree[i].x, &amp;tree[i].h);
            lisan[0][++cnt] = tree[i].x;
            lisan[1][cnt] = tree[i].h;
        }
        sort(lisan[0] + 1, lisan[0] + 1 + n);
        sort(lisan[1] + 1, lisan[1] + 1 + n);
        sort(tree + 1, tree + 1 + n);
        ll ans = 0;
        ll tot = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x = binSearch(tree[i].x, n, 0);
            int h = binSearch(tree[i].h, n, 1);
            ll s1 = sum1(x);   //排在x之前的数目
            ll s2 = sum2(x);   //排在x之前的坐标和
            ans += h * (s1 * x - s2);
            ans -= h * ((i - s1 - 1) * x - (tot - s2));
            up1(x, 1);
            up2(x, x);
            tot += x;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ1990MooFest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ1990MooFest/" itemprop="url">POJ 1990 MooFest</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:48:04+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Every year, Farmer John’s N (1 &lt;= N &lt;= 20,000) cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. </p>
<p>Each cow i has an associated “hearing” threshold v(i) (in the range 1..20,000). If a cow moos to cow i, she must use a volume of at least v(i) times the distance between the two cows in order to be heard by cow i. If two cows i and j wish to converse, they must speak at a volume level equal to the distance between them times max(v(i),v(j)). </p>
<p>Suppose each of the N cows is standing in a straight line (each cow at some unique x coordinate in the range 1..20,000), and every pair of cows is carrying on a conversation using the smallest possible volume. </p>
<p>Compute the sum of all the volumes produced by all N(N-1)/2 pairs of mooing cows.<br>Input* Line 1: A single integer, N </p>
<p>* Lines 2..N+1: Two integers: the volume threshold and x coordinate for a cow. Line 2 represents the first cow; line 3 represents the second cow; and so on. No two cows will stand at the same location.<br>Output* Line 1: A single line with a single integer that is the sum of all the volumes of the conversing cows.<br>Sample Input</p>
<p>4<br>3 1<br>2 5<br>2 6<br>4 3</p>
<p>Sample Output</p>
<p>57</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组的一种考法， 维护两棵树状数组。详细见代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>/*
 Date              : 2019-09-15-09.54.27
 By                : Tpaaaaaa
 Question_Number   ：poj1990
 Question_Name     ：树状数组练习题
 Description       :
 N个牛，就有N(N-1)/2 的pair
 我们先将牛按照音量排序
 依次取出牛
 假如考虑牛 i
 之前取出的牛的音量一定小于or等于牛i
 所以我们要计算牛i 和之前出现的牛的cost
 我们将之前出现的牛分为两类
 第一类是坐标小于牛i的
 假设第一类有三头牛，他们的坐标为a,b,c
 则cost1 = v[i](pos[i] - a + pos[i] - b + pos[i] - c)
         = v[i](3 * pos[] - (a + b + c))
 我们将其一般化，设牛i的坐标为x，第一类有num头牛，他们的坐标和为sum
 cost1 = v[i] * (num * x - sum)

 那么第二类里面有总的牛数 - 左边的牛数，他们的坐标和是总的坐标和 减去左边的坐标和
                 numAll - num                          sumAll - sum
 cost2 = v[i] * ( (numAll - num)*x - (sumAll - sum))

 所以我们需要维护两个树状数组，第一棵树状数组维护的是x坐标之前的牛的数目
   这个就是一般的0 1的树状数组
第二棵树状数组维护的是在前i头牛的坐标和
   up!!
   G++为什么会超时
   大量输入的时候，G++很有可能超时
   C++很有可能栈溢出
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define s(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e4 + 10;
ll c1[MAXN];
ll  c2[MAXN];
struct Node
{
    int v, pos;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.v &lt;= b.v;
    }
};
Node node[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].v ,&amp;node[i].pos);
            node[i].i = i;
        }
        sort(node + 1, node + 1 + n);
        ll ans = 0;
        ll total = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x  = node[i].pos;        //当前牛的坐标
            int vo = node[i].v;          //当前牛的音量
            ll s1 = sum1(x);
            ll s2 = sum2(x);
            //sum1返回的是在x坐标之前的牛的数目
            //sum2返回的是那些牛的坐标和
            ans += vo * (s1 * x - s2);
            ans -= vo * ( (i - s1 - 1) * x - (total - s2));
            total += x;
            up1(x, 1);      
            up2(x, x);
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ3321appletree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ3321appletree/" itemprop="url">POJ 3321 apple tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:46:01+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.</p>
<p>The tree has <em>N</em> forks which are connected by branches. Kaka numbers the forks by 1 to <em>N</em> and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.</p>
<p>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?</p>
<p><img src="https://vj.ti12z.cn/95a992a75f75b7d92488d79284d3b4ef?v=1568225018" alt=""></p>
<p>Input</p>
<p>The first line contains an integer <em>N</em> (<em>N</em> ≤ 100,000) , which is the number of the forks in the tree.<br>The following <em>N</em> - 1 lines each contain two integers <em>u</em> and <em>v</em>, which means fork <em>u</em> and fork <em>v</em> are connected by a branch.<br>The next line contains an integer <em>M</em> (<em>M</em> ≤ 100,000).<br>The following <em>M</em> lines each contain a message which is either<br>“<strong>C <em>x</em></strong>“ which means the existence of the apple on fork <em>x</em> has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>“<strong>Q <em>x</em></strong>“ which means an inquiry for the number of apples in the sub-tree above the fork <em>x</em>, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginningOutputFor every inquiry, output the correspond answer per line.Sample Input</p>
<p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1</p>
<p>Sample Output</p>
<p>3<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组+dfs序。emmm可以里面区间查询来实现单点查询。</p>
<p>G++ 与 C++的区别：<a href="https://blog.csdn.net/lynn_ming/article/details/82014563" target="_blank" rel="noopener">https://blog.csdn.net/lynn_ming/article/details/82014563</a></p>
<p>G++ 容易TLE， C++容易RE</p>
<pre><code>/*
 Date              : 2019-09-15-08.56.16
 Question_Number   ：poj 3321
 Question_Name     ：apple tree
 Description       : 用dfs遍历树，得到dfs序。
                     对于每个节点u, 都有他的子树范围是[begin[u], last[u]]
                     字典序中排在[begin. last]之中的，都是u的子树节点
                     所以我们询问的也是这个区间的数目
                     但是我们更改的是某个节点
                     所以我们先查询这个节点是1or0，然后再去更改是+1 还是-1

                     查询的话， sum(last) - sum(begin - 1) 就可以了
                     //全局变量的锅
 By                : Tpaaaaaa
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int cnt, n, m, c[MAXN], a[MAXN], u, v, x, first[MAXN], last[MAXN], tot, head[MAXN];
char ch;
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void dfs(int u, int f)
{
    first[u] = ++ tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == f) continue;
            dfs(v, u);
    }
    last[u] = tot;
}
int down(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
void up(int x, int v)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
        c[i] += v;
}

int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            a[i] = 1;
            up(i, 1);
            head[i] = -1;
        }
        cnt = tot = 0;
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            //addEdge(v, u);
        }
        dfs(1, 1);                  //从第一个root开始
        scanf(&quot;%d&quot;, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            scanf(&quot;%d&quot;, &amp;x);
            if(ch == &apos;Q&apos;)
            {

                int sum = down(last[x]) - down(first[x]) + a[first[x]];
                printf(&quot;%d\n&quot;, sum);
            }
            else
            {
                if(a[first[x]])
                {
                    a[first[x]] = 0;
                    up(first[x], -1);
                }
                else
                {
                    a[first[x]] = 1;
                    up(first[x], 1);
                }
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ2155Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ2155Matrix/" itemprop="url">POJ 2155 Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:42:37+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). </p>
<p>We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. </p>
<p>1. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2).<br>2. Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].<br>InputThe first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case. </p>
<p>The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.<br>OutputFor each querying output one line, which has an integer representing A[x, y]. </p>
<p>There is a blank line between every two continuous test cases.<br>Sample Input</p>
<p>1<br>2 10<br>C 2 1 2 2<br>Q 2 2<br>C 2 1 2 1<br>Q 1 1<br>C 1 1 2 1<br>C 1 2 1 2<br>C 1 1 2 2<br>Q 1 1<br>C 1 1 2 1<br>Q 2 1</p>
<p>Sample Output</p>
<p>1<br>0<br>0<br>1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要理解清楚，树状数组里面的sum函数和update的函数</p>
<p>update(x，v)函数，实际上是一个由a[x] 往上遍历到各个包含他的c[]中，因为x发生了改变，因此所有包含他的c[]的值相应的也要发生改变，所以可以理解为下级向上级反映情况(#^.^#)</p>
<p>sum(x) 函数，实际上是往下找，找到一些c[]，使得这些c[]包含了a[1],a[2] … a[x] 这x个节点的信息，所以可以理解为上级给下级布置任务(#^.^#)</p>
<p>我们可以直接将update函数叫成up函数，sum函数叫成down函数，方便理解</p>
<p>这题目就颠覆了我们传统观念里面up是更新，down是求和的思想。之前是单点更新和区间查找，此题是区间更新和单点查询</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-15-08.09.49
 Question_Number   ：poj 2155
 Question_Name     ：二维树状数组
 Description       :
 By                : Tpaaaaaa
 //直接记录去反的次数呀！！！！
 mod 2 = 0  说明为0

 树状数组up和down操作
 up(x), up(x, y)操作是 往上找  包含这个点(x) or (x, y)的区间
 是由a数组 找到c数组
 down(x)  or (x,y) 操作是往下走，找被他包含的区间, 也就是[0...x] or[0..x][0..y]
 是由c数组，找到a数组
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rsx)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1000 + 10;
int c[MAXN][MAXN], n;
int lowbit(int x)
{
    return x&amp;(-x);
}
void down(int x,int y)
{

    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            c[i][j]++;
}
int up(int x, int y)
{
    int sum = 0;
    for(int i = x; i &lt;= n; i += lowbit(i))
        for(int j = y; j &lt;= n; j += lowbit(j))
           sum += c[i][j];
    return sum;
}
int main()
{
    int t, x1, x2, y1, y2, m;
    char ch;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            if(ch == &apos;C&apos;)
            {
                scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                down(x2, y2);   //是指将[x2, y1]整个范围内的点发生反转一次
                down(x1-1, y2);
                down(x2,y1-1);
                down(x1-1, y1-1);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;x1, &amp;y1);
                int times = up(x1, y1);
                printf(&quot;%d\n&quot;, times&amp;1);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/14/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/tpaaaaaa.github.io/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/16/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">246</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
