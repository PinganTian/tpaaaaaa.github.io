<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;15&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/15/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/POJ3237Tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/POJ3237Tree/" itemprop="url">POJ 3237 Tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T23:03:39+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Tree</p>
<p><strong>Time Limit:</strong> 5000MS</p>
<p><strong>Memory Limit:</strong> 131072K</p>
<p><strong>Total Submissions:</strong> 13998</p>
<p><strong>Accepted:</strong> 3547</p>
<p>Description</p>
<p>You are given a tree with <em>N</em> nodes. The tree’s nodes are numbered 1 through <em>N</em> and its edges are numbered 1 through <em>N</em> − 1. Each edge is associated with a weight. Then you are to execute a series of instructions on the tree. The instructions can be one of the following forms:</p>
<p><code>CHANGE</code> <em>i</em> <em>v</em></p>
<p>Change the weight of the <em>i</em>th edge to <em>v</em></p>
<p><code>NEGATE</code> <em>a</em> <em>b</em></p>
<p>Negate the weight of every edge on the path from <em>a</em> to <em>b</em></p>
<p><code>QUERY</code> <em>a</em> <em>b</em></p>
<p>Find the maximum weight of edges on the path from <em>a</em> to <em>b</em></p>
<p>Input</p>
<p>The input contains multiple test cases. The first line of input contains an integer <em>t</em> (<em>t</em> ≤ 20), the number of test cases. Then follow the test cases.</p>
<p>Each test case is preceded by an empty line. The first nonempty line of its contains <em>N</em> (<em>N</em> ≤ 10,000). The next <em>N</em> − 1 lines each contains three integers <em>a</em>, <em>b</em> and c, describing an edge connecting nodes <em>a</em> and <em>b</em> with weight <em>c</em>. The edges are numbered in the order they appear in the input. Below them are the instructions, each sticking to the specification above. A lines with the word “<code>DONE</code>” ends the test case.</p>
<p>Output</p>
<p>For each “<code>QUERY</code>” instruction, output the result on a separate line.</p>
<p>Sample Input</p>
<p>1</p>
<p>3<br>1 2 1<br>2 3 2<br>QUERY 1 2<br>CHANGE 1 3<br>QUERY 1 2<br>DONE</p>
<p>Sample Output</p>
<p>1<br>3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样是树链剖分，只不过在线段树上的操作骚了一些而已。</p>
<p>Change 是改变某条边的权值</p>
<p>Query 是查询某条路径上的最大值</p>
<p>Negate 是将某条路径上的权值全部取相反数</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先是常规的树的输入部分</p>
<pre><code>for(int i = 1; i &lt; n; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
    addEdge(a, b);
    addEdge(b, a);
    e[i][0] = a;
    e[i][1] = b;
    e[i][2] = c;
}
fa[1] = 1;
dfs1(1);
dfs2(1, 1);
build(1, 1, n);</code></pre><p>然后是将边权下沉为点权的操作</p>
<pre><code>//接着是将边权下沉为点权
for(int i = 1; i &lt; n; i++)
{
    int u = e[i][0];
    int v = e[i][1];
    int w = e[i][2];
    if(dep[u] &lt; dep[v])
        swap(u, v);
    update1(1, dfn[u], w);
}</code></pre><p>显然，udpate1是线段树的单点更新，因为此题还要用到区间修改，所以取名update1</p>
<p>因为要进行取相反数的操作，所以我们维护的区间信息要包括最大值和最小值（取相反数后，二者会填负号后交换）</p>
<pre><code>void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>然后是处理查询部分</p>
<pre><code>while(cin &gt;&gt; s)
{
    if(s == &quot;DONE&quot;) break;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
        printf(&quot;%d\n&quot;, lca(a, b));
    else if(s == &quot;NEGATE&quot;)
    {
                          //这里憨憨了，是对dfs序上进行的处理
        Negate(a, b);
    }
    else if(s == &quot;CHANGE&quot;)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        update1(1, dfn[u], b);
    }

}</code></pre><p>lca函数就是树链剖分函数。求的是一条路径上的最大值。</p>
<pre><code>int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}</code></pre><p>query就是常规的线段树查询区间最大值的函数</p>
<pre><code>int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].maxx;
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}</code></pre><p>然后是Negate函数，这也是对路径上的修改，所以也是路径剖分函数（就是这里WA了很久o(╥﹏╥)o）</p>
<pre><code>void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}</code></pre><p>可能稍微麻烦一点的，就是因为是区间修改嘛，所以要用到lazy标记，所以它的区间修改部分就是update2.</p>
<p><strong>这种翻转问题的区间修改，都可以用酱紫的lazy标记哦</strong></p>
<pre><code>    node[rt].lazy = (node[rt].lazy + 1) % 2;

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        node[rt].maxx = - node[rt].maxx;
        node[rt].minn = - node[rt].minn;
        swap(node[rt].maxx, node[rt].minn);
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}</code></pre><p><strong>然后是pushDown函数</strong></p>
<pre><code>void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}</code></pre><p>完整代码：</p>
<pre><code>/*
 Date              : 2019-09-16-16.43.18
 By                : Tpaaaaaa
 Question_Number   ：POJ3237
 Question_Name     ：树链剖分
 Description       :

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int e[MAXN][3], head[MAXN], cnt, tot, dep[MAXN], son[MAXN], top[MAXN], rk[MAXN], dfn[MAXN], fa[MAXN];
int siz[MAXN];
struct Edge
{
    int v, next;
};
Edge edge[MAXN * 2];
struct Node
{
    int l, r, maxx, minn, lazy;    //要维护区间里面的最小值和sum
}node[MAXN * 4 * 2];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(siz, 0, sizeof siz);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;
}
void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u]) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void build(int rt, int l, int r)
{
    node[rt].l = l; //维护的是dfs序
    node[rt].r = r;
    node[rt].minn = node[rt].maxx = node[rt].lazy = 0;
    int mid = md(l, r);
    if(l == r)
        return;
    build(ls(rt), l, mid);
    build(rs(rt), mid + 1, r);
}
inline void pushUp(int rt)
{
    node[rt].minn = min(node[ls(rt)].minn, node[rs(rt)].minn);
    node[rt].maxx = max(node[ls(rt)].maxx, node[rs(rt)].maxx);
}
void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}

void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        int temp =  node[rt].maxx;
        node[rt].maxx = - node[rt].minn;
        node[rt].minn = - temp;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}
int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        return node[rt].maxx;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}
int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}
void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}
int main()
{
    int t, a, b, c, n;
    string s;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);
            addEdge(b, a);
            e[i][0] = a;
            e[i][1] = b;
            e[i][2] = c;
        }
        fa[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        build(1, 1, n);
        //接着是将边权下沉为点权
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            update1(1, dfn[u], w);
        }
        while(cin &gt;&gt; s)
        {
            if(s == &quot;DONE&quot;) break;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
            {
                int ans = lca(a, b);
                printf(&quot;%d\n&quot;, ans);
            }
            else if(s == &quot;NEGATE&quot;)
            {
            //这里憨憨了
                //if(dep[a] &gt; dep[b])
                    //swap(a, b);
                Negate(a, b);
               // update2(1, dfn[a], dfn[b]); //update2的作用是将[]区间里面的翻转次数加1
            }
            else if(s == &quot;CHANGE&quot;)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                update1(1, dfn[u], b);
            }

        }


    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/FZU2082%E8%BF%87%E8%B7%AF%E8%B4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/FZU2082%E8%BF%87%E8%B7%AF%E8%B4%B9/" itemprop="url">FZU 2082 过路费</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T22:47:42+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有n座城市，由n-1条路相连通，使得任意两座城市之间可达。每条路有过路费，要交过路费才能通过。每条路的过路费经常会更新，现问你，当前情况下，从城市a到城市b最少要花多少过路费。Input</p>
<p>有多组样例，每组样例第一行输入两个正整数n,m(2 &lt;= n&lt;=50000，1&lt;=m &lt;= 50000),接下来n-1行，每行3个正整数a b c，(1 &lt;= a,b &lt;= n , a != b , 1 &lt;= c &lt;= 1000000000).数据保证给的路使得任意两座城市互相可达。接下来输入m行，表示m个操作，操作有两种：一. 0 a b，表示更新第a条路的过路费为b，1 &lt;= a &lt;= n-1 ； 二. 1 a b ， 表示询问a到b最少要花多少过路费。Output对于每个询问，输出一行，表示最少要花的过路费。</p>
<p>Sample Input</p>
<p>2 3<br>1 2 1<br>1 1 2<br>0 1 2<br>1 2 1</p>
<p>Sample Output</p>
<p>1<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树链剖分的常用处理方式：将边权下沉到深度较深的点上，作为点的权值。</p>
<p>妙哉妙哉，借此来分析一下树链剖分的代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>树信息的录入</p>
<pre><code>        for(int i = 1; i &lt; n; i ++)
        {
//一条无向边 &lt;a,b&gt; 权值为c
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);</code></pre><p>然后就是树链剖分最为关键的两次dfs，第一次dfs，我们获得相关数组信息</p>
<pre><code>//siz[u]存的是以u为根的子树的大小
//dep[u]存的是结点u的深度
//f[u]存的是结点u的父结点
//son[u]存的是u结点的重儿子结点编号

void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}</code></pre><p>第二次dfs，我们将获得dfs序，top[]等信息</p>
<pre><code>//dfn[u] 存的是u结点在dfs序中的编号
//top[u] 存的是u结点所在重链上的头结点
//rk[tot] 保存的是dfs序中tot号结点的编号

void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}</code></pre><p>获得完dfs序后，我们对dfs序建立线段树，那么我们要将边权下沉到深度较深的结点上，作为点的权值</p>
<pre><code>//常规的线段树建树操作
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}

        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }</code></pre><p>update是线段树的单点更新</p>
<pre><code>void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>接着是处理询问</p>
<pre><code>while(m--)
{
    int op, a, b;
    scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
    //将第a条路的费用变成b
    if(op == 0)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        //妙哉
        update(1, dfn[u], b);
    }
    else //查询a到b的费用
    {
        ll ans = sum(a, b);
        //sum返回的是a到b的权值和
        printf(&quot;%lld\n&quot;, ans);
    }
}</code></pre><p>sum函数也是树链剖分里面一个较为重要的部分，实际上就是利用我们之前求出来的top数组，来进行求LCA等操作。将树上两结点的路径，转化为dfs序上一些区间的组合，这样我们对这条路径上的处理，就转化为了对dfs序上一些区间的处理，而对于一个一维数组的区间处理，线段树是很可的。</p>
<pre><code>//返回的是编号u点到v点的路径权值和，就是常规的线段树区间查询函数
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉，这样就没计算头结点的权值了。
    return ret;

}

/*
 Date              : 2019-09-16-08.40.58
 By                : Tpaaaaaa
 Question_Number   ：FZU 2082
 Question_Name     ：树链剖分
 Description       :
 //将边权转移到点权上，然后变成了树链剖分的模板题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int cnt, tot;
int e[MAXN][3], dep[MAXN], head[MAXN], f[MAXN], top[MAXN], dfn[MAXN], siz[MAXN], son[MAXN], rk[MAXN];
struct Node
{
    int l, r;
    ll sum;
}node[MAXN * 4];

struct Edge
{
    int v, next;
} edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}
//线段树的单点修改
//将k位置的值，变成c
inline void pushUp(int rt)
{
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}
//返回的是编号u点到v点的路径权值和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉
    return ret;

}
void init()
{
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;

}
int main()
{
    int n, m, a, b, c;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt; n; i ++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);
        built(1, 1, n);
        //两次dfs后，我们得到了dfs序
        //我们对dfs序建立线段树
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }
        while(m--)
        {
            int op, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
            //将第a条路的费用变成b
            if(op == 0)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                //妙哉
                update(1, dfn[u], b);
            }
            else //查询a到b的费用
            {
                ll ans = sum(a, b);
                //sum返回的是a到b的权值和
                printf(&quot;%lld\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/16/%5B%E7%AE%97%E6%B3%95%5DCDQ%E5%88%86%E6%B2%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/16/%5B%E7%AE%97%E6%B3%95%5DCDQ%E5%88%86%E6%B2%BB/" itemprop="url">[算法]CDQ分治</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-16T21:12:09+08:00">
                2019-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址<a href="https://www.cnblogs.com/hzf29721/p/10343179.html" target="_blank" rel="noopener">https://www.cnblogs.com/hzf29721/p/10343179.html</a></p>
<p>CDQ分治，有国家队某巨佬发明（仿佛是插头dp的论文作者？？？），主要用于解决带修改，查询，可排序序列的一系列问题，仅可支持<strong>离线操作</strong><br>CDQ分治的主要步骤有以下几点：<br>1、读入（废话）<br>1、将已经读入好的数据按照某关键字排序<br>2、设当前区间为[l,r][l,r]，递归处理左区间[l,mid][l,mid]和右区间[mid+1,r][mid+1,r]，计算左区间的修改操作对右区间的影响（一般用树状数组等数据结构维护）<br>3、清除数据结构内的修改数据<br>本题又叫三维偏序问题，是CDQ分治的经典题型<br>先按照第一维（即aiai）排序，这样就将问题转化到了二维<br>设当前区间为[l,r][l,r]<br>讲[l,mid][l,mid]和[mid+1,r][mid+1,r]分别按照第二维排序，此时在左区间中的aa均小于有区间中的aa(<strong>保证第一维</strong>)，设左区间已访问到plpl，右区间已访问到prpr(l≤pl≤mid,mid+1≤pr≤r)(l≤pl≤mid,mid+1≤pr≤r)<br>当b[pl]&lt;=b[pr]b[pl]&lt;=b[pr]时(<strong>保证第二维</strong>)，即将plpl点的cc值加入树状数组<br>统计比prpr点的cc值小或等于的点的数量(<strong>保证第三维</strong>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/%5B%E7%BA%AA%E5%BF%B5%5D%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84100%E7%AF%87%E6%96%87%E7%AB%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/%5B%E7%BA%AA%E5%BF%B5%5D%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84100%E7%AF%87%E6%96%87%E7%AB%A0/" itemprop="url">[纪念]新博客的100篇文章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:52:07+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>8月19号开始，到9月15号。将近一个月的时间，感觉自己明显在变强！！！！加油加油！！！十一月的招新赛要加油！！！！！！！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/HDU-3015DisharmonyTrees/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/HDU-3015DisharmonyTrees/" itemprop="url">HDU - 3015 Disharmony Trees</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:49:59+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>One day Sophia finds a very big square. There are n trees in the square. They are all so tall. Sophia is very interesting in them.   </p>
<p><img src="https://vj.ti12z.cn/e79e812bfb09daff576ac5ce95a12388?v=1566913617" alt=""></p>
<p>She finds that trees maybe disharmony and the Disharmony Value between two trees is associated with two value called FAR and SHORT. </p>
<p>The FAR is defined as the following:If we rank all these trees according to their X Coordinates in ascending order.The tree with smallest X Coordinate is ranked 1th.The trees with the same X Coordinates are ranked the same. For example,if there are 5 tree with X Coordinates 3,3,1,3,4. Then their ranks may be 2,2,1,2,5. The FAR of two trees with X Coordinate ranks D1 and D2 is defined as F = abs(D1-D2). </p>
<p>The SHORT is defined similar to the FAR. If we rank all these trees according to their heights in ascending order，the tree with shortest height is ranked 1th.The trees with the same heights are ranked the same. For example, if there are 5 tree with heights 4,1,9,7,4. Then their ranks may be 2,1,5,4,2. The SHORT of two trees with height ranks H1 and H2 is defined as S=min(H1,H2). </p>
<p>Two tree’s Disharmony Value is defined as F*S. So from the definition above we can see that, if two trees’s FAR is larger , the Disharmony Value is bigger. And the Disharmony value is also associated with the shorter one of the two trees. </p>
<p>Now give you every tree’s X Coordinate and their height , Please tell Sophia the sum of every two trees’s Disharmony value among all trees.InputThere are several test cases in the input </p>
<p>For each test case, the first line contain one integer N (2 &lt;= N &lt;= 100,000) N represents the number of trees. </p>
<p>Then following N lines, each line contain two integers : X, H (0 &lt; X,H &lt;=1,000,000,000 ), indicating the tree is located in Coordinates X and its height is H.OutputFor each test case output the sum of every two trees’s Disharmony value among all trees. The answer is within signed 64-bit integer.Sample Input</p>
<p>2<br>10 100<br>20 200<br>4<br>10 100<br>50 500<br>20 200<br>20 100</p>
<p>Sample Output</p>
<p>1<br>13</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>与之前的mofest题意差不多，解法差不多。维护两棵树状数组，一棵存的是树的数目，一棵存的是树的坐标和。只不过要离散化而已</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><pre><code>/*
 Date              : 2019-09-15-13.10.03
 By                : Tpaaaaaa
 Question_Number   ：poj 3015
 Question_Name     ：树状数组
 Description       :
 每棵树都有两个属性，一个是x，一个是h
 我们首先按照h单调递减排序
 然后按排序后的顺序依次取点

 假如取到第i棵树
 那么之前的i-1棵树的h 都要大于等于第i棵树的h
 那么第i棵树与之前i-1棵数的S=min(h1, h2) = h
 都是h
 设有3棵树在i之前，他们的坐标分为a，b，c
 设a = D(a), b = D(b) ...
 用离散化操作来处理。
 设第i棵树的坐标为x
 i与之前i-1棵树的value和 sum =
 sum = h*abs(a - x) + h*abs(b - x) + h*abs(c - x)
设a,b,c都小于x，也就是在x之前，那么sum
 sum = h*(x - a) + h*(x - b) + h*(x - c)
     = h(3*x - (a + b + c));
也就是说，将之前i-1棵树分成两部分，第一部分为
坐标小于x的，第二部分是坐标大于x的
 大于x部分的
 sum = h*((i - 3)*x - (tot - ()))




*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
ll c1[MAXN], c2[MAXN];
int lisan[2][MAXN];
struct Tree
{
    int x, h;
    friend bool operator &lt; (Tree a, Tree b)
    {
        return a.h &gt; b.h;
    }
};
Tree tree[MAXN];
int binSearch(int k, int n, int i)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int m = md(l, r);
        if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] != k )
            return m;
        else if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] == k )
            r = m - 1;
        else if(lisan[i][m] &gt; k)
            r = m - 1;
        else
            l = m + 1;
    }
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n, m, cnt;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        cnt = 0;
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;tree[i].x, &amp;tree[i].h);
            lisan[0][++cnt] = tree[i].x;
            lisan[1][cnt] = tree[i].h;
        }
        sort(lisan[0] + 1, lisan[0] + 1 + n);
        sort(lisan[1] + 1, lisan[1] + 1 + n);
        sort(tree + 1, tree + 1 + n);
        ll ans = 0;
        ll tot = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x = binSearch(tree[i].x, n, 0);
            int h = binSearch(tree[i].h, n, 1);
            ll s1 = sum1(x);   //排在x之前的数目
            ll s2 = sum2(x);   //排在x之前的坐标和
            ans += h * (s1 * x - s2);
            ans -= h * ((i - s1 - 1) * x - (tot - s2));
            up1(x, 1);
            up2(x, x);
            tot += x;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ1990MooFest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ1990MooFest/" itemprop="url">POJ 1990 MooFest</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:48:04+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Every year, Farmer John’s N (1 &lt;= N &lt;= 20,000) cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. </p>
<p>Each cow i has an associated “hearing” threshold v(i) (in the range 1..20,000). If a cow moos to cow i, she must use a volume of at least v(i) times the distance between the two cows in order to be heard by cow i. If two cows i and j wish to converse, they must speak at a volume level equal to the distance between them times max(v(i),v(j)). </p>
<p>Suppose each of the N cows is standing in a straight line (each cow at some unique x coordinate in the range 1..20,000), and every pair of cows is carrying on a conversation using the smallest possible volume. </p>
<p>Compute the sum of all the volumes produced by all N(N-1)/2 pairs of mooing cows.<br>Input* Line 1: A single integer, N </p>
<p>* Lines 2..N+1: Two integers: the volume threshold and x coordinate for a cow. Line 2 represents the first cow; line 3 represents the second cow; and so on. No two cows will stand at the same location.<br>Output* Line 1: A single line with a single integer that is the sum of all the volumes of the conversing cows.<br>Sample Input</p>
<p>4<br>3 1<br>2 5<br>2 6<br>4 3</p>
<p>Sample Output</p>
<p>57</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组的一种考法， 维护两棵树状数组。详细见代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>/*
 Date              : 2019-09-15-09.54.27
 By                : Tpaaaaaa
 Question_Number   ：poj1990
 Question_Name     ：树状数组练习题
 Description       :
 N个牛，就有N(N-1)/2 的pair
 我们先将牛按照音量排序
 依次取出牛
 假如考虑牛 i
 之前取出的牛的音量一定小于or等于牛i
 所以我们要计算牛i 和之前出现的牛的cost
 我们将之前出现的牛分为两类
 第一类是坐标小于牛i的
 假设第一类有三头牛，他们的坐标为a,b,c
 则cost1 = v[i](pos[i] - a + pos[i] - b + pos[i] - c)
         = v[i](3 * pos[] - (a + b + c))
 我们将其一般化，设牛i的坐标为x，第一类有num头牛，他们的坐标和为sum
 cost1 = v[i] * (num * x - sum)

 那么第二类里面有总的牛数 - 左边的牛数，他们的坐标和是总的坐标和 减去左边的坐标和
                 numAll - num                          sumAll - sum
 cost2 = v[i] * ( (numAll - num)*x - (sumAll - sum))

 所以我们需要维护两个树状数组，第一棵树状数组维护的是x坐标之前的牛的数目
   这个就是一般的0 1的树状数组
第二棵树状数组维护的是在前i头牛的坐标和
   up!!
   G++为什么会超时
   大量输入的时候，G++很有可能超时
   C++很有可能栈溢出
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define s(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e4 + 10;
ll c1[MAXN];
ll  c2[MAXN];
struct Node
{
    int v, pos;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.v &lt;= b.v;
    }
};
Node node[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].v ,&amp;node[i].pos);
            node[i].i = i;
        }
        sort(node + 1, node + 1 + n);
        ll ans = 0;
        ll total = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x  = node[i].pos;        //当前牛的坐标
            int vo = node[i].v;          //当前牛的音量
            ll s1 = sum1(x);
            ll s2 = sum2(x);
            //sum1返回的是在x坐标之前的牛的数目
            //sum2返回的是那些牛的坐标和
            ans += vo * (s1 * x - s2);
            ans -= vo * ( (i - s1 - 1) * x - (total - s2));
            total += x;
            up1(x, 1);      
            up2(x, x);
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ3321appletree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ3321appletree/" itemprop="url">POJ 3321 apple tree</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:46:01+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.</p>
<p>The tree has <em>N</em> forks which are connected by branches. Kaka numbers the forks by 1 to <em>N</em> and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.</p>
<p>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?</p>
<p><img src="https://vj.ti12z.cn/95a992a75f75b7d92488d79284d3b4ef?v=1568225018" alt=""></p>
<p>Input</p>
<p>The first line contains an integer <em>N</em> (<em>N</em> ≤ 100,000) , which is the number of the forks in the tree.<br>The following <em>N</em> - 1 lines each contain two integers <em>u</em> and <em>v</em>, which means fork <em>u</em> and fork <em>v</em> are connected by a branch.<br>The next line contains an integer <em>M</em> (<em>M</em> ≤ 100,000).<br>The following <em>M</em> lines each contain a message which is either<br>“<strong>C <em>x</em></strong>“ which means the existence of the apple on fork <em>x</em> has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>“<strong>Q <em>x</em></strong>“ which means an inquiry for the number of apples in the sub-tree above the fork <em>x</em>, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginningOutputFor every inquiry, output the correspond answer per line.Sample Input</p>
<p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1</p>
<p>Sample Output</p>
<p>3<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组+dfs序。emmm可以里面区间查询来实现单点查询。</p>
<p>G++ 与 C++的区别：<a href="https://blog.csdn.net/lynn_ming/article/details/82014563" target="_blank" rel="noopener">https://blog.csdn.net/lynn_ming/article/details/82014563</a></p>
<p>G++ 容易TLE， C++容易RE</p>
<pre><code>/*
 Date              : 2019-09-15-08.56.16
 Question_Number   ：poj 3321
 Question_Name     ：apple tree
 Description       : 用dfs遍历树，得到dfs序。
                     对于每个节点u, 都有他的子树范围是[begin[u], last[u]]
                     字典序中排在[begin. last]之中的，都是u的子树节点
                     所以我们询问的也是这个区间的数目
                     但是我们更改的是某个节点
                     所以我们先查询这个节点是1or0，然后再去更改是+1 还是-1

                     查询的话， sum(last) - sum(begin - 1) 就可以了
                     //全局变量的锅
 By                : Tpaaaaaa
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int cnt, n, m, c[MAXN], a[MAXN], u, v, x, first[MAXN], last[MAXN], tot, head[MAXN];
char ch;
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void dfs(int u, int f)
{
    first[u] = ++ tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == f) continue;
            dfs(v, u);
    }
    last[u] = tot;
}
int down(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
void up(int x, int v)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
        c[i] += v;
}

int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            a[i] = 1;
            up(i, 1);
            head[i] = -1;
        }
        cnt = tot = 0;
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            //addEdge(v, u);
        }
        dfs(1, 1);                  //从第一个root开始
        scanf(&quot;%d&quot;, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            scanf(&quot;%d&quot;, &amp;x);
            if(ch == &apos;Q&apos;)
            {

                int sum = down(last[x]) - down(first[x]) + a[first[x]];
                printf(&quot;%d\n&quot;, sum);
            }
            else
            {
                if(a[first[x]])
                {
                    a[first[x]] = 0;
                    up(first[x], -1);
                }
                else
                {
                    a[first[x]] = 1;
                    up(first[x], 1);
                }
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/POJ2155Matrix/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/POJ2155Matrix/" itemprop="url">POJ 2155 Matrix</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:42:37+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). </p>
<p>We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. </p>
<p>1. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2).<br>2. Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].<br>InputThe first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case. </p>
<p>The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.<br>OutputFor each querying output one line, which has an integer representing A[x, y]. </p>
<p>There is a blank line between every two continuous test cases.<br>Sample Input</p>
<p>1<br>2 10<br>C 2 1 2 2<br>Q 2 2<br>C 2 1 2 1<br>Q 1 1<br>C 1 1 2 1<br>C 1 2 1 2<br>C 1 1 2 2<br>Q 1 1<br>C 1 1 2 1<br>Q 2 1</p>
<p>Sample Output</p>
<p>1<br>0<br>0<br>1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要理解清楚，树状数组里面的sum函数和update的函数</p>
<p>update(x，v)函数，实际上是一个由a[x] 往上遍历到各个包含他的c[]中，因为x发生了改变，因此所有包含他的c[]的值相应的也要发生改变，所以可以理解为下级向上级反映情况(#^.^#)</p>
<p>sum(x) 函数，实际上是往下找，找到一些c[]，使得这些c[]包含了a[1],a[2] … a[x] 这x个节点的信息，所以可以理解为上级给下级布置任务(#^.^#)</p>
<p>我们可以直接将update函数叫成up函数，sum函数叫成down函数，方便理解</p>
<p>这题目就颠覆了我们传统观念里面up是更新，down是求和的思想。之前是单点更新和区间查找，此题是区间更新和单点查询</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-15-08.09.49
 Question_Number   ：poj 2155
 Question_Name     ：二维树状数组
 Description       :
 By                : Tpaaaaaa
 //直接记录去反的次数呀！！！！
 mod 2 = 0  说明为0

 树状数组up和down操作
 up(x), up(x, y)操作是 往上找  包含这个点(x) or (x, y)的区间
 是由a数组 找到c数组
 down(x)  or (x,y) 操作是往下走，找被他包含的区间, 也就是[0...x] or[0..x][0..y]
 是由c数组，找到a数组
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rsx)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1000 + 10;
int c[MAXN][MAXN], n;
int lowbit(int x)
{
    return x&amp;(-x);
}
void down(int x,int y)
{

    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            c[i][j]++;
}
int up(int x, int y)
{
    int sum = 0;
    for(int i = x; i &lt;= n; i += lowbit(i))
        for(int j = y; j &lt;= n; j += lowbit(j))
           sum += c[i][j];
    return sum;
}
int main()
{
    int t, x1, x2, y1, y2, m;
    char ch;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            if(ch == &apos;C&apos;)
            {
                scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                down(x2, y2);   //是指将[x2, y1]整个范围内的点发生反转一次
                down(x1-1, y2);
                down(x2,y1-1);
                down(x1-1, y1-1);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;x1, &amp;y1);
                int times = up(x1, y1);
                printf(&quot;%d\n&quot;, times&amp;1);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/HDU-2852KiKi'sK-Number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/HDU-2852KiKi'sK-Number/" itemprop="url">HDU - 2852 KiKi's K-Number</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:32:51+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>For the k-th number, we all should be very familiar with it. Of course,to kiki it is also simple. Now Kiki meets a very similar problem, kiki wants to design a container, the container is to support the three operations. </p>
<p>Push: Push a given element e to container </p>
<p>Pop: Pop element of a given e from container </p>
<p>Query: Given two elements a and k, query the kth larger number which greater than a in container; </p>
<p>Although Kiki is very intelligent, she can not think of how to do it, can you help her to solve this problem?<br>InputInput some groups of test data ,each test data the first number is an integer m (1 &lt;= m &lt;100000), means that the number of operation to do. The next m lines, each line will be an integer p at the beginning, p which has three values:<br>If p is 0, then there will be an integer e (0 &lt;e &lt;100000), means press element e into Container. </p>
<p>If p is 1, then there will be an integer e (0 &lt;e &lt;100000), indicated that delete the element e from the container   </p>
<p>If p is 2, then there will be two integers a and k (0 &lt;a &lt;100000, 0 &lt;k &lt;10000),means the inquiries, the element is greater than a, and the k-th larger number.<br>OutputFor each deletion, if you want to delete the element which does not exist, the output “No Elment!”. For each query, output the suitable answers in line .if the number does not exist, the output “Not Find!”.Sample Input</p>
<p>5<br>0 5<br>1 2<br>0 6<br>2 3 2<br>2 8 1<br>7<br>0 2<br>0 2<br>0 4<br>2 1 1<br>2 1 2<br>2 1 3<br>2 1 4</p>
<p>Sample Output</p>
<p>No Elment!<br>6<br>Not Find!<br>2<br>2<br>4<br>Not Find!</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组，配合二分，可以寻找第k个位置，或者求某个位置的值</p>
<pre><code>/*
 Date              : 2019-09-15-14.50.27
 By                : Tpaaaaaa
 Question_Number   ：poj2852
 Question_Name     ：树状数组
 Description       :

 sum(x) 返回的是小于等于x的数的数目
 那么对于op = 0
 up(x, 1)
 op = 1
 up(x, -1);（如果sum(x) - sum(x - 1) == 0, 则说明不存在，那么printf）
 op = 2

 小于等于a的数目为sum = sum(a)
 所以我们找的是排名sum + k的数
 int l = 1;
 int r = MAXN
 int m = md(l, r)
 if(sum(m) == sum + k || sum(m) &gt; sum + k &amp;&amp; sum(m - 1) &lt; sum + k)  //注意这里的条件
    while(123123)

    {flag}
 ..
 用二分即可？？
 这个x数存不存在
 sum(x) - sum(x - 1) 是否为0即可知道
 注意：
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int c[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c[i] += v;
}
int sum(int x)
{
    int s = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        s += c[i];
    return s;
}
int binSearch(int k)
{
    int l = 1;
    int r = MAXN - 10;
    while(l &lt;= r)
    {
        int m = md(l, r);
        int s = sum(m);
        int s2 = sum(m - 1);
        if(s == k || (s2 &lt; k &amp;&amp; s &gt; k) )
        {
            while(sum(m - 1) == k)
                m --;
            return m;
        }
        else if(s &gt; k)
            r = m - 1;
        else
            l = m + 1;
    }
    return -1;
}
int main()
{
    int n, op, x, k;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;op);
            if(op == 0)
            {
                scanf(&quot;%d&quot;, &amp;x);
                update(x, 1);
            }
            else if(op == 1)
            {
                scanf(&quot;%d&quot;, &amp;x);
                if(0 == sum(x) - sum(x - 1))
                    printf(&quot;No Elment!\n&quot;);
                else
                    update(x, -1);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;x, &amp;k);
                int rak = k + sum(x);
                int ans = binSearch(rak);
                if(ans == -1)
                    printf(&quot;Not Find!\n&quot;);
                else
                    printf(&quot;%d\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/15/OrderingtheSoldiersSPOJ-ORDERS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/15/OrderingtheSoldiersSPOJ-ORDERS/" itemprop="url">Ordering the Soldiers SPOJ - ORDERS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-15T20:30:04+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>As you are probably well aware, in Byteland it is always the military officer’s main worry to order his soldiers on parade correctly. In Bitland ordering soldiers is not really such a problem. If a platoon consists of n men, all of them have different rank (from 1 - lowest to n - highest) and on parade they should be lined up from left to right in increasing order of rank.</p>
<p>Sounds simple, doesn’t it? Well, Msgt Johnny thought the same, until one day he was faced with a new command. He soon discovered that his elite commandos preferred to do the fighting, and leave the thinking to their superiors. So, when at the first rollcall the soldiers lined up in fairly random order it was not because of their lack of discipline, but simply because they couldn’t work out how to form a line in correct order of ranks. Msgt Johnny was not at all amused, particularly as he soon found that none of the soldiers even remembered his own rank. Over the years of service every soldier had only learned which of the other soldiers were his superiors. But Msgt Johnny was not a man to give up easily when faced with a true military challenge. After a moment’s thought a solution of brilliant simplicity struck him and he issued the following order: “men, starting from the left, one by one, do: (step forward; go left until there is no superior to the left of you; get back in line).”. This did indeed get the men sorted in a few minutes. The problem was solved… for the time being.</p>
<p>The next day, the soldiers came in exactly the same order as the day before, and had to be rearranged using the same method. History repeated. After some weeks, Msgt Johnny managed to force each of his soldiers to remember how many men he passed when going left, and thus make the sorting process even faster.</p>
<p>If you know how many positions each man has to walk to the left, can you try to find out what order of ranks the soldiers initially line up in?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains an integer t&lt;=50, the number of test cases. It is followed by t test cases, each consisting of 2 lines. The first line contains a single integer n (1&lt;=n&lt;=200000). The second line contains n space separated integers wi, denoting how far the i-th soldier in line must walk to the left when applying Msgt Johnny’s algorithm.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output a single line consisting of n space separated integers - the ranks of the soldiers, given from left to right in their initial arrangement.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input:</strong><br>2<br>3<br>0 1 0<br>5<br>0 1 2 0 1</p>
<p><strong>Output:</strong><br>2 1 3<br>3 2 1 5 4</p>
<p><strong>Warning: large Input/Output data, be careful with certain languages</strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>分析一下发现，其实可以看成一个插队问题，因为最后一个人总能排到他想去的位置，就像最后一个插队的人，总不会被插队一样。</p>
<p>5</p>
<p>0 1 2 0 1</p>
<p>转化为插队问题 数字代表的是想插的位置</p>
<p>1 1 1 4 4</p>
<p>我们从后往前，就像解决插队问题一样。用树状数组解决即可</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-15-14.09.35
 By                : Tpaaaaaa
 Question_Number   ：ordering the soldiers
 Question_Name     ：树状数组，插队问题
 Description       :
 插队问题，从后往前插
 最后一个人插队的位置是固定的
 5
 0 1 2 0 1
 转化为插队问题
 数字代表的是想插的位置
 1  1  1  4  4
 用线段树解决
 那么树状数组怎么解呢？
 配合二分试试
 l = 1, r = 5
 md = (l, r);
 if(sum(md) == i)
    return md;
update(md, 0);
 else
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
int c[MAXN], a[MAXN], pos[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c[i] += v;
}
//找到空余为x的位置
int down(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
int binSearch(int x, int n)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int m = md(l, r);
        int sum = down(m);
        //m这个位置之前剩余的位置数，等于要插入的序号
        if(sum == x )
        {
            while(down(m - 1) == x)
                m = m - 1;
            return m;
        }

        else if(sum &gt; x)
            r = m - 1;
        else
            l = m + 1;
    }
}
int main()
{
    int t, n, d;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;d);
            a[i] = i - d;
            update(i, 1);
            //a[i]记录的是要插的位置
        }
        for(int i =  n; i &gt; 0; i--)
        {
            pos[i] = binSearch(a[i], n);
            update(pos[i], -1);
            //1表示空余，0表示被占了
        }
        for(int i = 1; i &lt;= n; i++)
         i == 1 ? printf(&quot;%d&quot;,pos[i]) : printf(&quot; %d&quot;, pos[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/14/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/tpaaaaaa.github.io/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/16/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
