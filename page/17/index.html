<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;17&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/17/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/13/HDU4417SuperMario/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/13/HDU4417SuperMario/" itemprop="url">HDU 4417 Super Mario</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-13T11:07:13+08:00">
                2019-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mario is world-famous plumber. His “burly” figure and amazing jumping ability reminded in our memory. Now the poor princess is in trouble again and Mario needs to save his lover. We regard the road to the boss’s castle as a line (the length is n), on every integer point i there is a brick on height hi. Now the question is how many bricks in [L, R] Mario can hit if the maximal height he can jump is H.InputThe first line follows an integer T, the number of test data.<br>For each test data:<br>The first line contains two integers n, m (1 &lt;= n &lt;=10^5, 1 &lt;= m &lt;= 10^5), n is the length of the road, m is the number of queries.<br>Next line contains n integers, the height of each brick, the range is [0, 1000000000].<br>Next m lines, each line contains three integers L, R,H.( 0 &lt;= L &lt;= R &lt; n 0 &lt;= H &lt;= 1000000000.)OutputFor each case, output “Case X: “ (X is the case number starting from 1) followed by m lines, each line contains an integer. The ith integer is the number of bricks Mario can hit for the ith query.<br>Sample Input</p>
<p>1<br>10 10<br>0 5 2 7 5 4 3 8 7 7<br>2 8 6<br>3 5 0<br>1 3 1<br>1 9 4<br>0 1 0<br>3 5 5<br>5 5 1<br>4 6 3<br>1 5 7<br>5 7 3</p>
<p>Sample Output</p>
<p>Case 1:<br>4<br>0<br>0<br>3<br>1<br>2<br>0<br>1<br>5<br>1</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>给一个数列，问这个数列里面的某个区间[L, R]中 比H小or 等的数目有多少个</p>
<p>主席树。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>输入和离散化以及主席树初始化</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
for(int i = 1; i &lt;= n; i++)
{
    scanf(&quot;%d&quot;, &amp;a[i]);
    lisan[i] = a[i];
}
sort(lisan + 1, lisan + 1 + n);
int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
cnt = 0;
root[0] = 0;
node[0].lson = node[0].rson = node[0].sum = 0;</code></pre><p>建立第1 … n棵主席树</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    int pos = binSearch(a[i], q);
    root[i] = root[i - 1];
    update(pos, root[i], 1, q);
}</code></pre><p>主席树的构建——update（是不是叫built更合适）</p>
<pre><code>void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];
    root = cnt;
    node[cnt].sum++;
    if(L == R)
        return;     //已经递归到pos位了
    int mid = md(L, R);

    if(pos &lt;= mid)  //pos位要小于mid位，说明左子树要改
        update(pos, node[root].lson, L, mid);
    else
        update(pos, node[root].rson, mid + 1, R);
}</code></pre><p>接下来是查询第[x, y]区间中比h小或等的数目</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
    x++;
    y++; //孤儿题目
    //不是求[x, y]区间中第k大的数，而是比k小于等于的数的数目
    int pos = query(root[x - 1], root[y], k, 1, q);
    printf(&quot;%d\n&quot;, pos);
}</code></pre><p>查询部分</p>
<pre><code>int query(int i, int j, int k, int L, int R)
{
 //o记录的是原数列中[L, R]区间数的总数
    int o = node[j].sum - node[i].sum;      //[L, R]这个区间里面的总次数
    if(L == R)
    {
        if(k &gt;= lisan[L])
            return o;
        else
            return 0;
    }
    int ld = node[node[j].lson].sum - node[node[i].lson].sum; 
//ld记录的是原数列中[L, R]区间中  位于离散化后数组前半部分的数的数目
    int rd = node[node[j].rson].sum - node[node[i].rson].sum;   //[mid + 1, R] 这里面的次数
    int mid = md(L, R);     //返回的是在离散数组中的下标
    if( k &lt;= lisan[mid])   
        return query(node[i].lson, node[j].lson, k, L, mid);
    else
        return query(node[i].rson, node[j].rson, k, mid + 1, R) + ld;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/13/POJ2761feedthedogs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/13/POJ2761feedthedogs/" itemprop="url">POJ 2761 feed the dogs</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-13T11:00:11+08:00">
                2019-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Feed the dogs</p>
<p><strong>Time Limit:</strong> 6000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 23590</p>
<p><strong>Accepted:</strong> 7497</p>
<p>DescriptionWind loves pretty dogs very much, and she has n pet dogs. So Jiajia has to feed the dogs every day for Wind. Jiajia loves Wind, but not the dogs, so Jiajia use a special way to feed the dogs. At lunchtime, the dogs will stand on one line, numbered from 1 to n, the leftmost one is 1, the second one is 2, and so on. In each feeding, Jiajia choose an inteval[i,j], select the k-th pretty dog to feed. Of course Jiajia has his own way of deciding the pretty value of each dog. It should be noted that Jiajia do not want to feed any position too much, because it may cause some death of dogs. If so, Wind will be angry and the aftereffect will be serious. Hence any feeding inteval will not contain another completely, though the intervals may intersect with each other. </p>
<p>Your task is to help Jiajia calculate which dog ate the food after each feeding.   </p>
<p>InputThe first line contains n and m, indicates the number of dogs and the number of feedings. </p>
<p>The second line contains n integers, describe the pretty value of each dog from left to right. You should notice that the dog with lower pretty value is prettier. </p>
<p>Each of following m lines contain three integer i,j,k, it means that Jiajia feed the k-th pretty dog in this feeding. </p>
<p>You can assume that n&lt;100001 and m&lt;50001.   </p>
<p>OutputOutput file has m lines. The i-th line should contain the pretty value of the dog who got the food in the i-th feeding.</p>
<p>Sample Input</p>
<p>7 2<br>1 5 2 6 3 7 4<br>1 5 3<br>2 7 1</p>
<p>Sample Output</p>
<p>3<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>给定一个长度为n的序列，有m个询问，每次查询区间第K大的元素。 主席树裸题</p>
<p>依次来分析代码：</p>
<p>主席树的节点</p>
<pre><code>struct Node
{
    int lson, rson;//记录的是子节点的下标
    int sum;       //记录的是这个节点维护的区间中数的数目
};</code></pre><p>输入部分</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    scanf(&quot;%d&quot;, &amp;a[i]);
    lisan[i] = a[i];
}
sort(lisan + 1, lisan + 1 + n);
int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
//1.离散化</code></pre><p>主席树初始化：</p>
<pre><code>root[0] = 0;
node[0].L = node[0].R = node[0].sum = 0;
cnt = 0;</code></pre><p>开始建立第1 .. n 棵主席树</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    root[i] = root[i - 1];       //第i棵主席树，是依照第i-1棵构建的
    int pos = binSearch(a[i], q);
    update(pos, root[i], 1, q);  //与第i-1棵的差别是，第pos位置置1
}</code></pre><p>主席树的构建函数——update</p>
<pre><code>void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];   //node[cnt]先完全依照node[root]构建
    root = cnt;
    node[cnt].sum ++;         //对sum进行修改

    if(L == R)
        return;

    int mid = md(L, R);
    if(pos &lt;= mid)           //说明左子区间部分与第i-1主席树不同，要改
        update(pos, node[root].L, L, mid);
    else
        update(pos, node[root].R, mid + 1, R);
}</code></pre><p>接下来是查询部分，查询第 i - 1棵和第 j 棵主席树，就可以知道[i, j]这个区间的信息了。</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
    int pos = query(root[x - 1], root[y], k, 1, q);
    printf(&quot;%d\n&quot;, lisan[pos]);
}</code></pre><p>接下来是查询函数query</p>
<pre><code>int query(int i, int j, int k, int L, int R)
{
    if(L == R)
        return L;   //要继续深刻理解一下，因为每一棵主席树，是基于离散化数组的树
                    //返回的也是离散化后的下标

    int d = node[node[j].L].sum - node[node[i].L].sum;

    int mid = md(L, R);
    if(k &lt;= d)
        return query(node[i].L, node[j].L, k, L, mid);
    else
        return query(node[i].R, node[j].R, k - d, mid + 1, R);
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/11/SPOJMatrixSummation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/11/SPOJMatrixSummation/" itemprop="url">SPOJ Matrix Summation</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:46:40+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-11-12.59.57
 Question_Number   ：MATSUM - Matrix Summation
 Question_Name     ：树状数组
 Description       :
 二维树状数组，与以往不同的是
 直接将某个点的值set为某个值。
 所以要知道这个点之前是什么值，然后再去更改
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
int c[MAXN][MAXN];
int n;
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int y, int v)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
        for(int j = y; j &lt;= n; j += lowbit(j))
            c[i][j] += v;
}
int query(int x, int y)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            sum += c[i][j];
    return sum;
}
int main()
{
    char s[3];
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        memset(c, 0, sizeof c);
        while(1)
        {
            getchar();
            scanf(&quot;%s&quot;, s);
            if(s[0] == &apos;E&apos;)
                break;
            if(s[1] == &apos;E&apos;)
            {
                int x, y, num;
                scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;num);
                x ++;
                y ++;
                int temp = query(x, y) - query(x - 1, y) - query(x, y - 1) + query(x - 1, y - 1);
                int add = num - temp;
                update(x, y, add);
            }
            else if(s[1] == &apos;U&apos;)
            {
                int x1, y1, x2, y2;
                scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                x1 ++; y1 ++; x2 ++; y2 ++;
                int  ans = query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
                printf(&quot;%d\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/11/POJ1195Mobilephones/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/11/POJ1195Mobilephones/" itemprop="url">POJ 1195 Mobile phones</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:44:29+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mobile phones</p>
<p><strong>Time Limit:</strong> 5000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 24007</p>
<p><strong>Accepted:</strong> 11040</p>
<p>DescriptionSuppose that the fourth generation mobile phone base stations in the Tampere area operate as follows. The area is divided into squares. The squares form an S * S matrix with the rows and columns numbered from 0 to S-1. Each square contains a base station. The number of active mobile phones inside a square can change because a phone is moved from a square to another or a phone is switched on or off. At times, each base station reports the change in the number of active phones to the main base station along with the row and the column of the matrix. </p>
<p>Write a program, which receives these reports and answers queries about the current total number of active mobile phones in any rectangle-shaped area.   </p>
<p>InputThe input is read from standard input as integers and the answers to the queries are written to standard output as integers. The input is encoded as follows. Each input comes on a separate line, and consists of one instruction integer and a number of parameter integers according to the following table.   </p>
<p><img src="http://poj.org/images/1195_1.jpg" alt=""></p>
<p>The values will always be in range, so there is no need to check them. In particular, if A is negative, it can be assumed that it will not reduce the square value below zero. The indexing starts at 0, e.g. for a table of size 4 * 4, we have 0 &lt;= X &lt;= 3 and 0 &lt;= Y &lt;= 3. </p>
<p>Table size: 1 * 1 &lt;= S * S &lt;= 1024 * 1024<br>Cell value V at any time: 0 &lt;= V &lt;= 32767<br>Update amount: -32768 &lt;= A &lt;= 32767<br>No of instructions in input: 3 &lt;= U &lt;= 60002<br>Maximum number of phones in the whole table: M= 2^30   </p>
<p>OutputYour program should not answer anything to lines with an instruction other than 2. If the instruction is 2, then your program is expected to answer the query by writing the answer as a single line containing a single integer to standard output.</p>
<p>Sample Input</p>
<p>0 4<br>1 1 2 3<br>2 0 0 2 2<br>1 1 1 2<br>1 1 2 -1<br>2 1 1 2 3<br>3</p>
<p>Sample Output</p>
<p>3<br>4</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>二维树状数组。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
const int MAX = 1024 + 10;
int c[MAXN][MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
void update(int x, int y, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        for(int j = y; j &lt; MAXN; j += lowbit(j))
            c[i][j] += v;
}
int query(int x, int y)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            sum += c[i][j];
    return sum;
}

int main()
{
    int com, n;
    scanf(&quot;%d%d&quot;, &amp;com, &amp;n);
    memset(c, 0, sizeof c);
    while(scanf(&quot;%d&quot;, &amp;com) &amp;&amp; com &lt; 3)
    {
        if(com == 1)
        {
            int x, y, a;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;a);
            x ++;
            y ++;
            update(x, y, a);
        }
        else if(com == 2)
        {
            int l, b, r, t;
            scanf(&quot;%d%d%d%d&quot;, &amp;l, &amp;b, &amp;r, &amp;t);
            l++; b++; r++; t++;
            ll ans = query(r, t) - query(l - 1, t) - query(r, b - 1) + query(l - 1, b - 1);
            printf(&quot;%lld\n&quot;, ans);
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/11/POJ2352Stars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/11/POJ2352Stars/" itemprop="url">POJ 2352 Stars</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:42:51+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Stars</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 59723</p>
<p><strong>Accepted:</strong> 25480</p>
<p>DescriptionAstronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars.   </p>
<p><img src="http://poj.org/images/2352_1.jpg" alt=""></p>
<p>For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3. </p>
<p>You are to write a program that will count the amounts of the stars of each level on a given map.</p>
<p>InputThe first line of the input file contains a number of stars N (1&lt;=N&lt;=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate.   </p>
<p>OutputThe output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.</p>
<p>Sample Input</p>
<p>5<br>1 1<br>5 1<br>7 1<br>3 3<br>5 5</p>
<p>Sample Output</p>
<p>1<br>2<br>1<br>1<br>0</p>
<p>HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>将所给的[x, y]按照y从小到大，y相同，则x从小到大<br>对于每一个区间[a, b]，排在他前面的点，一定在他下面<br>那么它的level值，就是他的b的sum(b);</p>
<p>ans += sum(b + 1);<br>update(b, 1);</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-11-11.32.59
 Question_Number   ：poj 2352
 Question_Name     ：树状数组
 Description       :
 将所给的[x, y]按照y从小到大，y相同，则x从小到大
 对于每一个区间[a, b]，排在他前面的点，一定在他下面
 那么它的level值，就是他的b的sum(b);

 ans += sum(b + 1);
 update(b, 1);
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 15000 + 10;
const int MAXM = 32000 + 10;
int n;
int ans[MAXN];
int c[MAXM];
int lowbit(int x)
{
    return x&amp;(-x);
}
int query(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXM; i += lowbit(i))
        c[i] += v;
}
struct Node
{
    int x, y;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.y == b.y)
            return a.x &lt; b.x;
        else
            return a.y &lt; b.y;
    }
};
Node node[MAXN];
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y);
            node[i].x ++;
            node[i].y ++;
            node[i].i = i;
        }
        sort(node + 1, node + 1 + n);
        memset(c, 0, sizeof c);
        memset(ans, 0, sizeof ans);
        for(int i = 1; i &lt;= n; i++)
        {
            ans[query(node[i].x)] ++;
            update(node[i].x, 1);
        }
        for(int i = 0; i &lt; n; i++)
            printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/11/POJ3067Japan/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/11/POJ3067Japan/" itemprop="url">POJ 3067 Japan</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:41:15+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Japan</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 35873</p>
<p><strong>Accepted:</strong> 9601</p>
<p>DescriptionJapan plans to welcome the ACM ICPC World Finals and a lot of roads must be built for the venue. Japan is tall island with N cities on the East coast and M cities on the West coast (M &lt;= 1000, N &lt;= 1000). K superhighways will be build. Cities on each coast are numbered 1, 2, … from North to South. Each superhighway is straight line and connects city on the East coast with city of the West coast. The funding for the construction is guaranteed by ACM. A major portion of the sum is determined by the number of crossings between superhighways. At most two superhighways cross at one location. Write a program that calculates the number of the crossings between superhighways.</p>
<p>InputThe input file starts with T - the number of test cases. Each test case starts with three numbers – N, M, K. Each of the next K lines contains two numbers – the numbers of cities connected by the superhighway. The first one is the number of the city on the East coast and second one is the number of the city of the West coast.</p>
<p>OutputFor each test case write one line on the standard output:<br>Test case (case number): (number of crossings)</p>
<p>Sample Input</p>
<p>1<br>3 4 4<br>1 4<br>2 3<br>3 2<br>3 1</p>
<p>Sample Output</p>
<p>Test case 1: 5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先将题目的交叉转化为数学意思<br>[A, B], [C, D] 对于这俩个区间，如果存在交叉<br>就意味着(A - C) * (B - D) &lt; 0 那么我们按照所给区间的左端点从小到大排序 如果左端点相同，那么右端点从小到达排序 对于任意个区间[A, B]，排在他前面的区间[C, D] 肯定有A &gt;= C, 对于A &gt; C的情况，我们可以根据<br>D的位置来确定[A, B]和[C, D]是否存在交点。<br>若B &lt; D,则二者存在交点。</p>
<p>所以我们维护一棵树状数组，叶子节点1 … M<br>叶子节点状态 = 0表示这个点还没有出现<br>= 1 表示这个点已经出现了</p>
<p>那么我们按照排序的顺序，依次取出区间[A, B]<br>然后利用树状数组求出sum(m) - sum(B)<br>然而将B这个叶子结点+1.<br>妙哉妙哉</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXM = MAXN * MAXN;
int c[MAXN];
int n, m, k;
struct Node
{
    int L, R;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.L == b.L)
            return a.R &lt; b.R;
        else
            return a.L &lt; b.L;
    }
};
Node node[MAXM];
int lowbit(int x)
{
    return x&amp;(-x);
}
int query(int x)
{
    int ans = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        ans += c[i];
    return ans;
}
void update(int x, int v)
{
    for(int i = x; i &lt;= m; i += lowbit(i))
        c[i] += v;
}
int main()
{
    int t, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
        for(int i = 1; i &lt;= k; i++)
            scanf(&quot;%d%d&quot;, &amp;node[i].L, &amp;node[i].R);
        ll ans = 0;
        sort(node + 1, node + 1 + k);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= k; i++)
        {
            ans += query(m) - query(node[i].R);
            update(node[i].R, 1);
        }
        printf(&quot;Test case %d: %lld\n&quot;, ++kase , ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/11/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E4%B8%BB%E5%B8%AD%E6%A0%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/11/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E4%B8%BB%E5%B8%AD%E6%A0%91/" itemprop="url">[数据结构]主席树</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-11T22:37:27+08:00">
                2019-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>主席树的视频讲解：</p>
<h2 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h2><p>主席树的Node节点（注意L，R与平常的线段树中的定义不同哦！！！）：</p>
<pre><code>struct Node
{
    int L, R, sum;
    //这个L和R存的不是区间范围
    //然而左孩子和右孩子的数组下标
    //sum为这个节点所维护区间中的数字数目。
};</code></pre><p>主席树的建立：</p>
<pre><code>        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            lisan[i] = a[i];
        }
        sort(lisan + 1, lisan + 1 + n);
        int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
//对输入的数组a[]进行离散化操作。
//主席树初始化
        cnt = 0;    
        root[0] = 0;
        node[0].L = node[0].R = node[0].sum = 0;
//开始枚举n个点，依次建立n个树。
        for(int i = 1; i &lt;= n; i++)
        {
            root[i] = root[i - 1];
            int pos = binSearch(a[i], q);
            update(pos, root[i], 1, n);
        }</code></pre><p>各个变量的解释</p>
<pre><code>int a[MAXN], lisan[MAXN], root[MAXN];
//a是输入进来的数组，lisan是离散化后的数组，root[i]存的是第i个带权线段树的树根的下标</code></pre><p>第 i 个带权线段树保存的信息是，a[1] … a[ i ]这 i 个数的带权线段树。</p>
<p>主席树的更新——update函数</p>
<pre><code>//作用是相较于以rt为根的原主席树，添加一个位置为pos的数，产生一个新的主席树
void update(int pos, int &amp;rt, int l, int r)
{
    node[++cnt] = node[rt];
    //完全复制成前一个权值线段树。
    //也就是添加pos这个位置的数之前的状态
    rt = cnt;       //更改成根节点编号
    node[cnt].sum ++;
    //因为相较于前一个权值线段树，我这个
    //里面多了一个a[i]，也就是说数的数目多了1
    if(l == r)
        return;
    int mid = md(l, r);
    //如果pos在左边，那么意味着右边的权值线段树
    //可以不改，只需要改左边的，那么右边则保留原来
    //前一个线段树的编号，而利用递归去更改左边的
    if(pos &lt;= mid)
        update(pos, node[rt].L, l, mid);
    else
        update(pos, node[rt].R, mid + 1, r);
}</code></pre><p>对于每个区间的查询的部分是：</p>
<pre><code>        for(int i = 1; i &lt;= m; i++)
        {
            int x, y, k;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
            int pos = query(root[x - 1], root[y], k, 1, n);
            printf(&quot;%d\n&quot;, lisan[pos]);
        }

//作用是求[i + 1,j]中第k大的数
int query(int i, int j, int k, int l, int r)
{
    int d = node[node[j].L].sum - node[node[i].L].sum;
    //这计算的是在[i,j]这个区间里面
    // 左半部分变化的值。也就是
    if(l == r)
        return l;
    int mid = md(l, r);
    if(k &lt;= d)          //说明左半部分的数目大于k th
        return query(node[i].L, node[j].L, k, l, mid);
    else
        return query(node[i].R, node[j].R, k - d , mid + 1, r);//我这里犯傻了
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/%5B%E7%AE%97%E6%B3%95%5D%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/%5B%E7%AE%97%E6%B3%95%5D%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95/" itemprop="url">[算法]线段树的应用——扫描线法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:29:08+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博文地址：<a href="https://blog.csdn.net/xianpingping/article/details/83032798" target="_blank" rel="noopener">https://blog.csdn.net/xianpingping/article/details/83032798</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>二维平面有n个平行于坐标轴的矩形,现在要求出这些矩形的总面积. 重叠部分只能算一次.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>线段树的典型扫描线用法.</p>
<pre><code>首先假设有下图两个矩阵,我们如果用扫描线的方法如何计算它们的总面积呢?</code></pre><p><img src="https://img-blog.csdn.net/20140330014222578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>首先我们将矩形的<strong>上下边分为上位边(即y坐标大的那条平行于x轴的边),和下位边(y坐标小的平行于x轴的边).放入结构体数组seg[]中，</strong>然后我们将他们按照y坐标从小到大排序,可以得到4条扫描线:</p>
<p><img src="https://img-blog.csdn.net/20140330014311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>又因为上面2个矩形有4个不同的浮点数x坐标,但通常x的取值范围很大，但图中x坐标的数目并没有那么多，所以我们需要把x坐标离散化, 同时这样才能用线段树来维护信息.所以我们这样离散化:</p>
<p><img src="https://img-blog.csdn.net/20140330014323453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>由上图可知,4个不同的x坐标把x轴分成了<strong>3段有效的区间.这里要注意我们线段树中每个叶节点(控制区间[L,L])不是指X[L]坐标,而是指区间[X[L],X[L+1]]. 也就是说，线段树的叶子不是原图中的节点，而是原图中最小的一段区间而已。</strong>线段树中其他节点控制的区间[L,R],也是指的第L个区间到第R个区间。例如[1, 2]在图中表示的区间是[x1, x2]（这是1） + [x2, x3] (这是2) = [x1, x3];</p>
<p><strong>所以[L, R]控制的范围实际上是[Xr, Xl + 1];</strong></p>
<p>然后我们Y坐标从小到大的顺序读入每条扫描线,并维护当前我们所读入的所有扫描线能有效覆盖X轴的最大长度node[1].len .这里特别要注意如果我们读入的扫描线是矩形的下位边,那么我们就使得该范围的标记lazy位+1,如果是上位边,那么该范围的cnt就-1.所以如果cnt=0时,表示该节点控制的范围没有被覆盖,只要cnt!=0 就表示该节点控制的几块区间仍然被覆盖.</p>
<p>tips: 可以将线段树的node节点中增加len2,len3。。。之前的len表示的是被覆盖的长度，那么len2表示的就是被覆盖两次的长度, len3表示覆盖3次….</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>树的节点Node结构体和线段Seg结构体部分</p>
<pre><code>struct Node
{
    int L, R;             //保存的是这个节点维护的区间端点
    int lazy;             //这个区间的lazy标记，lazy == 0表示没有被覆盖
    double len;           //这个区间里面被覆盖的长度
};
Node node[8 * MAXN];
struct Seg
{
    double x1, x2;      //这条线段的左右端点的x坐标
    double y;           //这条线段的高
    int flag;           // = 1 表示这条线段是矩形的下底，= -1表示上底
    friend bool operator &lt; (Seg a, Seg b)
    {
        return a.y &lt; b.y;
    }
};</code></pre><p>线段树的建立——built</p>
<pre><code>void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    node[root].lazy = 0;
    node[root].len = 0;
    if(L != R)             //注意[L, R]表示的不是第L个x坐标到第R个x坐标间的区间
                           //而是第L个区间到第R个区间的和区间
    {
        int mid = (L + R) / 2;
        built(ls(root), L, mid);
        built(rs(root), mid + 1, R);
    }
}</code></pre><p>线段树的区间更新——update函数</p>
<pre><code>void update(int root, int L, int R, int flag)
{
    if(node[root].L == L &amp;&amp; node[root].R == R)
    {
        node[root].lazy += flag;             //目前的区间就是我们要处理的区间
        pushUp(root);
        return;
    }
//没有pushDown
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)
        update(ls(root), L, R, flag);
    else if(L &gt; mid)              
        update(rs(root), L, R, flag);
    else
    {
        update(ls(root), L, mid, flag);
        update(rs(root), mid + 1, R, flag); //我改了这里
    }
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)
{
    if(node[root].lazy &gt; 0)
        node[root].len = recX[node[root].R + 1] - recX[node[root].L];
    else if(node[root].L == node[root].R)
        node[root].len = 0; // lazy == 0并且没有后代了
    else
        node[root].len = node[ls(root)].len + node[rs(root)].len;
}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;*</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> Date              : 2019-09-09-16.47.52</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> Question_Number   ：hdu 1255</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"> Question_Name     ：线段树，扫描线法</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> Description       :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> 离散化</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">*&#x2F;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">#include&lt;functional&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">#include&lt;string&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">#include&lt;vector&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">#include&lt;stack&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">#include&lt;bitset&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">#include&lt;cstdlib&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">#include&lt;cmath&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">#include&lt;set&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">#include&lt;list&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">#include&lt;deque&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">#include&lt;map&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">#include&lt;queue&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">#define ls(x)  x &lt;&lt; 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">#define rs(x)  x &lt;&lt; 1 | 1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">#define md(x, y)  (x + y) &#x2F; 2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">const double PI &#x3D; acos(-1.0);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">const double eps &#x3D; 1e-6;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">const int INF &#x3D; 0x3f3f3f3f;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">const int MAXN &#x3D; 1000 + 10;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">int cnt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">double x[2 * MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">struct Node</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    int L, R;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    int lazy;           &#x2F;&#x2F;lazy</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    int cover;          &#x2F;&#x2F;覆盖次数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    double len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">Node node[8 * MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">struct Seg</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    double x1, x2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    double y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    int flag;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    friend bool operator &lt; (Seg a, Seg b)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        return a.y &lt; b.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">Seg seg[2 * MAXN];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">void addSeg(double x1, double y1, double x2, double y2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    cnt ++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].x1 &#x3D; x1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].x2 &#x3D; x2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].y &#x3D; y2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].flag &#x3D; -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    x[cnt] &#x3D; x1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    cnt ++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].x1 &#x3D; x1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].x2 &#x3D; x2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].y &#x3D; y1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    seg[cnt].flag &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    x[cnt] &#x3D; x2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">void built(int root, int L, int R)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">    node[root].L &#x3D; L;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    node[root].R &#x3D; R;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">    node[root].lazy &#x3D; 0;   &#x2F;&#x2F;-1表示减掉一次cover，1表示加上一次cover，0表示无操作</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    node[root].len &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    node[root].cover &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    if(L !&#x3D; R)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        int mid &#x3D; md(L, R);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        built(ls(root), L, mid);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        built(rs(root), mid + 1, R);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">void pushUp(int root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    if(node[root].cover &gt; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        node[root].len &#x3D; x[node[root].R + 1] - x[node[root].L];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">    else if(node[root].L &#x3D;&#x3D; node[root].R)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        node[root].len &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">        node[root].len &#x3D; node[ls(root)].len + node[rs(root)].len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">void pushDown(int root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">    if(node[root].lazy !&#x3D; 0)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">        node[ls(root)].lazy +&#x3D; node[root].lazy;         &#x2F;&#x2F;我改了这里</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">        node[rs(root)].lazy +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">        node[ls(root)].cover +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">        node[rs(root)].cover +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">        node[root].lazy &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">void update(int root, int L, int R, int flag)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">    if(node[root].L &#x3D;&#x3D; L &amp;&amp; node[root].R &#x3D;&#x3D; R)      &#x2F;&#x2F;目前我们要覆盖的部分就是我们所处的</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">        node[root].lazy +&#x3D; flag;                    &#x2F;&#x2F;同样的，[L, R]这个区间的覆盖次数+1, 他的子区间[L, mid] [mid +1, R]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">        node[root].cover +&#x3D; flag;                    &#x2F;&#x2F;的覆盖次数同样要加1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">        pushUp(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">        return;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">    pushDown(root);                                  &#x2F;&#x2F;将flag传下去</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">    int mid &#x3D; md(node[root].L, node[root].R);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">    if(R &lt;&#x3D; mid)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">        update(ls(root), L, R, flag);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">    else if(L &gt; mid)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">        update(rs(root), L, R, flag);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">        update(ls(root), L, mid, flag);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">        update(rs(root), mid + 1, R, flag);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">    pushUp(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">double query(int root)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">    if(node[root].cover &gt;&#x3D; 2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">        return node[root].len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">    if(node[root].L &#x3D;&#x3D; node[root].R)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">        return 0;               &#x2F;&#x2F;说明到叶子节点了，只有返回0了</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">    pushDown(root);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">    double ans1 &#x3D; query(ls(root));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">    double ans2 &#x3D; query(rs(root));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">    return ans1 + ans2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">int binSearch(double k, int n)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">    int L &#x3D; 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">    int R &#x3D; n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">    while(L &lt;&#x3D; R)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">        int mid &#x3D; md(L, R);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">        if(x[mid] &#x3D;&#x3D; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">            return mid;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">        if(x[mid] &gt; k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">            R &#x3D; mid - 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line">            L &#x3D; mid + 1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line">    return -1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">    int t, n;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">    cin &gt;&gt; t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">    while(t--)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">        cnt &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line">            double x1, x2, y1, y2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line">            scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F;题目描述有误，是左下角和右上角</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line">            addSeg(x1, y1, x2, y2);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">        sort(x + 1, x + 1 + cnt);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;将x排序，然后去重</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">        int m &#x3D; unique(x + 1, x + 1 + cnt) - (x + 1);   &#x2F;&#x2F;m为离散化后的x坐标的数目</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F;也就是说，线段树的叶子结点数目为m - 1   因为m个x坐标，将x轴变成了m-1个区间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line">        built(1, 1, m - 1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line">        sort(seg + 1, seg + 1 + cnt);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line">        double ans &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt; cnt; i++)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line">            double h &#x3D; seg[i + 1].y - seg[i].y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line">            int L &#x3D; binSearch(seg[i].x1, m);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line">            int R &#x3D; binSearch(seg[i].x2, m) - 1;&#x2F;&#x2F;这个区间[L, R] 实际上就能表示[x1, x2]了</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line">            update(1, L, R, seg[i].flag);       &#x2F;&#x2F;将[L, R] +flag</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line">            double len &#x3D; query(1);              &#x2F;&#x2F;查询里面cover次数大于2的部分</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F;找到len</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">            &#x2F;&#x2F; len &#x3D; 线段树中被覆盖次数大于1次的部分</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">          &#x2F;&#x2F;  printf(&quot;L &#x3D; %d, R &#x3D; %d, h &#x3D; %.2f, len &#x3D; %.2f \n&quot;, L, R + 1, h, len);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line">            ans +&#x3D; h * len;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">        printf(&quot;%.2f\n&quot;, ans);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/HDU4553%E7%BA%A6%E4%BC%9A%E5%AE%89%E6%8E%92/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/HDU4553%E7%BA%A6%E4%BC%9A%E5%AE%89%E6%8E%92/" itemprop="url">HDU 4553 约会安排</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:27:37+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="约会安排"><a href="#约会安排" class="headerlink" title="约会安排"></a>约会安排</h1><p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65535/32768 K (Java/Others)<br>Total Submission(s): 4544    Accepted Submission(s): 1300<br>*</em></p>
<p>Problem Description　　寒假来了，又到了小明和女神们约会的季节。<br>　　小明虽为屌丝级码农，但非常活跃，女神们常常在小明网上的大段发言后热情回复“呵呵”，所以，小明的最爱就是和女神们约会。与此同时，也有很多基友找他开黑，由于数量实在过于巨大，怎么安排时间便成了小明的一大心事。<br>　　我们已知小明一共有T的空闲时间，期间会有很多女神或者基友来找小明。<br>　　作为一个操作系统曾经怒考71分的大神，小明想到了一个算法，即“首次适应算法”，根据操作系统课本的描述，就是找一段最靠前的符合要求的连续空间分配给每个请求，由此小明做出了一个决定：<br>　　当一个基友来找小明时，小明就根据“首次适应算法”来找一段空闲的时间来和基友约好，如果找到，就说“X,let’s fly”（此处，X为开始时间），否则就说“fly with yourself”；<br>　　当女神来找小明时，先使用一次“首次适应算法”，如果没有找到，小明就冒着木叽叽的风险无视所有屌丝基友的约定，再次使用“无视基友首次适应算法”，两次只要有一次找到，就说“X,don’t put my gezi”（此处，X为开始时间），否则就说“wait for me”<br>　　当然，我们知道小明不是一个节操负无穷的人，如果和女神约会完，还有剩余时间，他还是会和原来约好的基友去dota的。（举个例子：小西（屌丝）和小明约好在1<del>5这个时间单位段内打dota，这时候，女神来和小明预约长度为3的时间段，那么最终就是1</del>3小明去和女神约会，搞定后在4<del>5和小西打dota）<br>　　小明偶尔也会想要学习新知识，此时小明就会把某一个时间区间的所有已经预定的时间全部清空用来学习并且怒吼“I am the hope of chinese chengxuyuan!!”，不过小明一般都是三分钟热度，再有人来预定的话，小明就会按耐不住寂寞把学习新知识的时间分配出去。<br>Input输入第一行为CASE，表示有CASE组测试数据；<br>每组数据以两个整数T，N开始，T代表总共的时间，N表示预约请求的个数；<br>接着的N行，每行表示一个女神或者基友的预约，“NS QT”代表一个女神来找小明约一段长为QT的时间，“DS QT”则代表一个屌丝的长为QT的请求，当然也有可能是小明想学知识了，“STUDY!! L R”代表清空L</del>R区间内的所有请求。</p>
<p>[Technical Specification]<br>1. 1 &lt;= CASE &lt;= 30<br>2. 1 &lt;= T, N &lt;= 100000<br>3. 1 &lt;= QT &lt;= 110000<br>4. 1 &lt;= L &lt;= R &lt;=T<br>Output对于每一个case，第一行先输出“Case C:”代表是第几个case，然后N行，每行对应一个请求的结果(参照描述)。<br>输出样本(可复制此处)：<br>“X,let’s fly”,”fly with yourself”,”X,don’t put my gezi”,”wait for me”,”I am the hope of chinese chengxuyuan!!”  </p>
<p>Sample Input</p>
<p>1<br>5 6<br>DS 3<br>NS 2<br>NS 4<br>STUDY!! 1 5<br>DS 4<br>NS 2</p>
<p>Sample Output</p>
<p>Case 1:<br>1,let’s fly<br>4,don’t put my gezi<br>wait for me<br>I am the hope of chinese chengxuyuan!!<br>1,let’s fly<br>1,don’t put my gezi</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树，不过较普通的线段树而言，这个线段树维护区间里面多了一项就是女神占用的时间信息。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
struct Node
{
    int L, R;
    int Lsum[2], Rsum[2], sum[2];
    int lazy[2];
};
Node node[MAXN * 4];
void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    node[root].Lsum[0] = node[root].Rsum[0] = node[root].sum[0] = R - L + 1;    //总安排
    node[root].Lsum[1] = node[root].Rsum[1] = node[root].sum[1] = R - L + 1;    //给ns的安排
    node[root].lazy[0] = node[root].lazy[1] = -1;                               // -1 表示没有标记
    if(L != R)
    {
        int mid = (node[root].L + node[root].R) / 2;
        built(2 * root, L, mid);
        built(2 * root + 1, mid + 1, R);
    }
}
void pushUp(int root, int com)
{
    node[root].Lsum[com] = node[2 * root].Lsum[com];
    if(node[2 * root].Lsum[com] == node[2 * root].R - node[2 * root].L + 1)
        node[root].Lsum[com] += node[2 * root + 1].Lsum[com];

    node[root].Rsum[com] = node[2 * root + 1].Rsum[com];
    if(node[2 * root + 1].Rsum[com] == node[2 * root + 1].R - node[2 * root + 1].L + 1) //我眼睛瞎了
        node[root].Rsum[com] += node[2 * root].Rsum[com];

    node[root].sum[com] = max(max(node[2 * root].sum[com], node[2 * root + 1].sum[com]), node[2 * root].Rsum[com] + node[2 * root + 1].Lsum[com]);
}
void pushDown(int root, int com)
{
    if(node[root].lazy[com] != -1)
    {
        int v = node[root].lazy[com];
        node[root].lazy[com] = -1;

        node[2 * root].lazy[com] = node[2 * root + 1].lazy[com] = v;
        if(v == 0)
        {
            node[2 * root].Lsum[com] = node[2 * root].Rsum[com] = node[2 * root].sum[com] = 0;
            node[2 * root + 1].Lsum[com] = node[2 * root + 1].Rsum[com] = node[2 * root + 1].sum[com] = 0;
        }
        else
        {
            node[2 * root].Lsum[com] = node[2 * root].Rsum[com] = node[2 * root].sum[com] = node[2 * root].R - node[2 * root].L + 1;
            node[2 * root + 1].Lsum[com] = node[2 * root + 1].Rsum[com] = node[2 * root + 1].sum[com] = node[2 * root + 1].R - node[2 * root + 1].L + 1;
        }

    }
}

void update(int root, int L, int R, int v, int com) // 将L R置为0 or 1
{
    if(node[root].L == L &amp;&amp; node[root].R == R)
    {
        node[root].lazy[com] = v;                   //1表示置为1，1表示空闲，0表示不空闲
        if(v == 0)
            node[root].Lsum[com] = node[root].Rsum[com] = node[root].sum[com] = 0;
        else if(v == 1)
            node[root].Lsum[com] = node[root].Rsum[com] = node[root].sum[com] = R - L + 1;
        return;
    }
    pushDown(root, com);
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)
        update(2 * root, L, R, v, com);
    else if(L &gt; mid)
        update(2 * root + 1, L, R, v, com);
    else
    {
        update(2 * root, L, mid, v, com);
        update(2 * root + 1, mid + 1, R, v, com);
    }
    pushUp(root, com);
}
int query(int root, int G, int com)
{
    if(node[root].sum[com] &lt; G)
        return 0;
    if(node[root].Lsum[com] &gt;= G)
        return node[root].L;

    pushDown(root, com);

    int mid = (node[root].L + node[root].R) / 2;
    if(node[2 * root].sum[com] &gt;= G)
        return query(2 * root, G, com);
    else if(node[2 * root].Rsum[com] + node[2 * root + 1].Lsum[com] &gt;= G)
        return mid - node[2 * root].Rsum[com] + 1;
    else
        return query(2 * root + 1, G, com);
}
int main()
{
    int kase = 0, cas, n, q;
    string s;
    cin &gt;&gt; cas;
    while(cas--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
        printf(&quot;Case %d:\n&quot;, ++ kase);
        built(1, 1, n);
        while(q--)
        {
            cin &gt;&gt; s;
            if(s == &quot;DS&quot;)
            {
                int g;
                scanf(&quot;%d&quot;, &amp;g);           //要找一个G时长的
                int ans = query(1, g, 0);   //0的是总安排
                if(ans == 0)
                    printf(&quot;fly with yourself\n&quot;);
                else
                {
                    printf(&quot;%d,let&apos;s fly\n&quot;, ans);
                    update(1, ans, ans + g - 1, 0, 0);
                }
            }
            else if(s == &quot;NS&quot;)
            {
                int g;
                scanf(&quot;%d&quot;, &amp;g);
                int ans = query(1, g, 0);   //0表示的是所有的时间，1表示的是属于ns的时间
                if(ans == 0)
                {
                    ans = query(1, g, 1);
                    if(ans == 0)
                    {
                        printf(&quot;wait for me\n&quot;);
                        continue;
                    }
                    else
                    {
                        printf(&quot;%d,don&apos;t put my gezi\n&quot;, ans);
                        update(1, ans, ans + g - 1, 0, 0);
                        update(1, ans, ans + g - 1, 0, 1);
                    }
                }
                else
                {
                    printf(&quot;%d,don&apos;t put my gezi\n&quot;, ans);
                    update(1, ans, ans + g - 1, 0, 0);
                    update(1, ans, ans + g - 1, 0, 1);
                }

            }
            else if(s == &quot;STUDY!!&quot;) //清空一个区间...
            {
                int x, y;
                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
                printf(&quot;I am the hope of chinese chengxuyuan!!\n&quot;);
                update(1, x, y, 1, 0);
                update(1, x, y, 1, 1);
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/10/HDU2642Stars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/10/HDU2642Stars/" itemprop="url">HDU 2642 Stars</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-10T22:24:53+08:00">
                2019-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Stars"><a href="#Stars" class="headerlink" title="Stars"></a>Stars</h1><p>*<em>Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 32768/65536 K (Java/Others)<br>Total Submission(s): 2894    Accepted Submission(s): 1182<br>*</em></p>
<p>Problem DescriptionYifenfei is a romantic guy and he likes to count the stars in the sky.<br>To make the problem easier,we considerate the sky is a two-dimension plane.Sometimes the star will be bright and sometimes the star will be dim.At first,there is no bright star in the sky,then some information will be given as “B x y” where ‘B’ represent bright and x represent the X coordinate and y represent the Y coordinate means the star at (x,y) is bright,And the ‘D’ in “D x y” mean the star at(x,y) is dim.When get a query as “Q X1 X2 Y1 Y2”,you should tell Yifenfei how many bright stars there are in the region correspond X1,X2,Y1,Y2.</p>
<p>There is only one case.<br>InputThe first line contain a M(M &lt;= 100000), then M line followed.<br>each line start with a operational character.<br>if the character is B or D,then two integer X,Y (0 &lt;=X,Y&lt;= 1000)followed.<br>if the character is Q then four integer X1,X2,Y1,Y2(0 &lt;=X1,X2,Y1,Y2&lt;= 1000) followed.  </p>
<p>OutputFor each query,output the number of bright stars in one line.  </p>
<p>Sample Input</p>
<p>5<br>B 581 145<br>B 581 145<br>Q 0 600 0 200<br>D 581 145<br>Q 0 600 0 200</p>
<p>Sample Output</p>
<p>1<br>0</p>
<p>Author teddy</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>  二维树状数组。好的博文：<a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></p>
<p>如何理解二维树状数组：</p>
<p>在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。<br>那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。</p>
<p>tree[x]维护的是区间，不过这个区间的长度，端点是与生俱来的（长度为lowbit(x)，右端点为x）</p>
<p>同样的tree[x][y]维护的是一个二维区间，并且这个区间的范围也是与生俱来的。</p>
<p>并且要相信，只要以 x -= x&amp;(-x) 这个操作下去，一定能遍历完x的全部子节点。</p>
<p>只要以 x += x &amp;(-x) 这个操作下去，一定能完整的遍历完x的全部祖先。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-10-15.37.11
 Question_Number   ：hdu 2642
 Question_Name     ：二维树状数组
 Description       :
 二维 就是矩阵
 一维的树状数组c[i] 存的是一些 一条直线上的点
 二维的树状数组c[i][j]
 要明白的一个事情是，父节点包括的点比子节点多。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
int c[MAXN][MAXN];  //我这里开大了
bool sta[MAXN][MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
void update(int x, int y, int d)
{
    for(int i = x; i &lt;= 1001; i += lowbit(i))
        for(int j = y; j &lt;= 1001; j += lowbit(j))
               c[i][j] += d;
}
int query(int x, int y)
{
    int ans = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            ans += c[i][j];
    return ans;
}
int main()
{
    int q, kase = 0;
    string s;
    cin &gt;&gt; q;
    memset(c, 0, sizeof c);
    memset(sta, false, sizeof sta); //我是傻子？
    while(q--)
    {
        cin &gt;&gt; s;

        if(s == &quot;Q&quot;)    //这是查询
        {
            int x1, x2, y1, y2;
            scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;x2, &amp;y1, &amp;y2);
            x1 ++; x2 ++; y1 ++; y2 ++;
            if(x1 &gt; x2)
                swap(x1, x2);
            if(y1 &gt; y2)
                swap(y1, y2);
            int ans = query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
            printf(&quot;%d\n&quot;, ans);
        }
        else
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            if(s == &quot;B&quot;)
            {
                if(sta[x][y])   //已经亮了
                    continue;
                update(x, y, 1);
                sta[x][y] = 1;
            }
            else
            {
                if(sta[x][y] == false)
                    continue;
                update(x, y, -1);
                sta[x][y] = false;
            }
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/16/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/tpaaaaaa.github.io/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/18/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">246</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
