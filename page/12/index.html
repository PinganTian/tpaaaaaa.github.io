<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;12&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/12/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/10/02/LightOJ-1234HarmonicNumber/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/10/02/LightOJ-1234HarmonicNumber/" itemprop="url">LightOJ - 1234 Harmonic Number</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T22:19:01+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数学中，第n个调和数是前n个自然数的倒数之和:</p>
<p>在这个问题中，给你一个数n，你应该求出 <strong>Hn</strong>.注意：这个OJ数组开太大会报Runtime Error.Input</p>
<p>开始输入一个整数 <strong>T (**</strong>≤ 10000)**, 代表样例个数.</p>
<p>每一个样例输入一行，包含一个整数 <strong>n (1 ≤ n ≤ 108)</strong>.Output</p>
<p>对于每个样例输出一行，代表答案<strong>Hn</strong> 。输出的结果与标准答案的相对误差小于 <strong>10-8</strong> ，格式如下.Sample Input</p>
<p>12</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>90000000</p>
<p>99999999</p>
<p>100000000</p>
<p>Sample Output</p>
<p>Case 1: 1.0000000000</p>
<p>Case 2: 1.5000000000</p>
<p>Case 3: 1.8333333333</p>
<p>Case 4: 2.0833333333</p>
<p>Case 5: 2.2833333333</p>
<p>Case 6: 2.4500000000</p>
<p>Case 7: 2.5928571429</p>
<p>Case 8: 2.7178571429</p>
<p>Case 9: 2.8289682540</p>
<p>Case 10: 18.8925358988</p>
<p>Case 11: 18.9978964039</p>
<p>Case 12: 18.9978964139</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>减少数组空间的方法。 我们首先观察到式子不难，but预处理的时候，如果直接用前缀和，显然1e8的数组会爆。那么我们怎么样才能他降下来呢，如果我们每隔100个去求一下和，这样就只要存1e6的数组了，不会爆了。所以可以用这种方法减少空间复杂度。</p>
<p>总结：如果求前缀和开的数组会爆的话，可以考虑分段求和(每100个求和一次…..)。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-15.17.08
 By                : Tpaaaaaa
 Question_Number   ：Harmonic Number LightOJ - 1234
 Question_Name     ：321
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

    因为开1e8的数组会爆
    所以我们可以每隔100个存一下，就只要开1e6的数组了
    小机灵鬼
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e8 + 5;
double a[1000005];
void init()
{
    double ans = 0;
    a[0] = 0;
    for(int i = 1; i &lt; MAXN; i++)
    {
        ans += 1.0/i;
        if(i % 100 == 0)
            a[i/100] = ans; //a[1] 存的是前100
    }
}
int main()
{
    int t, n, kase = 0;
    init();
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        int temp = n / 100;
        double ans = a[temp];
        for(int i = temp * 100 + 1; i &lt;= n;i++)
            ans += 1.0 / i;
        printf(&quot;Case %d: %.10f\n&quot;,++kase, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/10/02/LightOJ-1214LargeDivision/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/10/02/LightOJ-1214LargeDivision/" itemprop="url">LightOJ - 1214 Large Division</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T22:14:02+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给定两个整数a和b，你应该检查a是否可以被b整除。我们知道，当且仅当存在整数c使得a = b * c时，整数a才能被整数b整除。Input</p>
<p>开始会输入一个数字 <strong>T (**</strong>≤ 525)**, 代表了样例数.</p>
<p>每个样例会给两个整数<strong>a (-10200 ≤ a ≤ 10200)</strong> and <strong>b (|b| &gt; 0, b fits into a 32 bit signed integer)</strong>. 数字不会包含前导零.Output</p>
<p>For each case, print the case number first. Then print <strong>‘divisible’</strong> if <strong>a</strong> is divisible by <strong>b</strong>. Otherwise print <strong>‘not divisible’</strong>.Sample Input</p>
<p>6</p>
<p>101 101</p>
<p>0 67</p>
<p>-101 101</p>
<p>7678123668327637674887634 101</p>
<p>11010000000000000000 256</p>
<p>-202202202202000202202202 -101Sample Output</p>
<p>Case 1: divisible</p>
<p>Case 2: divisible</p>
<p>Case 3: divisible</p>
<p>Case 4: not divisible</p>
<p>Case 5: divisible</p>
<p>Case 6: divisible</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>大数取模：模运算 + 秦九韶算法的思想。常见的套路</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-15.33.29
 By                : Tpaaaaaa
 Question_Number   ：Large Division LightOJ - 1214
 Question_Name     ：大数取模
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 300;
char s[MAXN];
bool lpow(char s[], ll mod)
{
    ll res = 0;
    for(int i = 0; i &lt; strlen(s); i++)
    {
        if(s[i] == &apos;-&apos;) continue;
        int now = s[i] - &apos;0&apos;;
        res = (res * 10 + now) % mod;
    }
    if(res == 0)
        return false;
    return true;
}
int main()
{
    int t, kase = 0;
    ll b;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%s %lld&quot;, s, &amp;b);
        if(b &lt; 0) b = -b;
        printf(&quot;Case %d: &quot;, ++kase);
        if(lpow(s,b))
            printf(&quot;not divisible\n&quot;);
        else
            printf(&quot;divisible\n&quot;);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/10/02/LightOJ-1078IntegerDivisibility/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/10/02/LightOJ-1078IntegerDivisibility/" itemprop="url">LightOJ - 1078 Integer Divisibility</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T22:11:53+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给你一个数n，一个数m，你需要找到一个k，表示k个n组成的数字可以被m整除。  </p>
<p>例如给你1和3，那么111可以被3整除，所以k为3.Input</p>
<p>输入一个T &lt;= 300，代表样例数。<br>每个样例会给你两个数m（需要除的数）和n（代表数字由n组成）。Output</p>
<p>对于每种情况，打印案例编号和此倍数的位数。如果有几种解决方案;输出最小的一个。Sample Input</p>
<p>3</p>
<p>3 1</p>
<p>7 3</p>
<p>9901 1</p>
<p>Sample Output</p>
<p>Case 1: 3</p>
<p>Case 2: 6</p>
<p>Case 3: 12</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>模运算配合秦九韶算法。 这种涉及到大数的….位数上的问题的常见的套路。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-19.38.43
 By                : Tpaaaaaa
 Question_Number   ：LJ1078、
 Question_Name     ：模运算
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2;
int main()
{
    int t, kase = 0;
    cin&gt;&gt;t;
    int n, m;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        int ret = n % m;
        int ans = 1;
        while(ret)
        {
            ret =(ret*10 + n % m) % m;
            ans ++;
        }
        printf(&quot;Case %d: %d\n&quot;, ++kase, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/10/02/LightOJ-1116EkkaDokka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/10/02/LightOJ-1116EkkaDokka/" itemprop="url">LightOJ - 1116 Ekka Dokka</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T22:07:56+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ekka and his friend Dokka decided to buy a cake. They both love cakes and that’s why they want to share the cake after buying it. As the name suggested that Ekka is very fond of odd numbers and Dokka is very fond of even numbers, they want to divide the cake such that Ekka gets a share of <strong>N</strong>square centimeters and Dokka gets a share of <strong>M</strong> square centimeters where <strong>N</strong> is odd and <strong>M</strong> is even. Both <strong>N</strong> and <strong>M</strong> are positive integers.</p>
<p>They want to divide the cake such that <strong>N * M = W</strong>, where <strong>W</strong> is the dashing factor set by them. Now you know their dashing factor, you have to find whether they can buy the desired cake or not.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each case contains an integer <strong>W (2 ≤ W &lt; 263)</strong>. And <strong>W</strong> will not be a power of <strong>2</strong>.Output</p>
<p>For each case, print the case number first. After that print <strong>“Impossible”</strong> if they can’t buy their desired cake. If they can buy such a cake, you have to print <strong>N</strong> and <strong>M</strong>. If there are multiple solutions, then print the result where <strong>M</strong> is as small as possible.Sample Input</p>
<p>3</p>
<p>10</p>
<p>5</p>
<p>12Sample Output</p>
<p>Case 1: 5 2</p>
<p>Case 2: Impossible</p>
<p>Case 3: 3 4</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唯一分解定理。首先我们知道如果w是奇数，那么是impossible，因为偶数乘以奇数等于偶数。我们利用唯一分解定理，将输入的数字w分解。可以知道w = 奇数<em>奇数</em>奇数…….*偶数。</p>
<p>其中唯一的偶数就是2的k次方。所以我们只需要求出w分解中的2的k次方，就可以确定最小的偶数M，即可解决问题了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-19.48.47
 By                : Tpaaaaaa
 Question_Number   ：Ekka Dokka LightOJ - 1116
 Question_Name     ：数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 10;
int main()
{
    int t;
    ll w;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%lld&quot;, &amp;w);
        if(w &amp; 1)
            printf(&quot;Case %d: Impossible\n&quot;, kase);
        else
        {
            ll temp = w;
            ll m = 1;
            while(temp % 2 == 0)
            {
                temp &gt;&gt;= 1;
                m &lt;&lt;= 1;
            }
            ll n = w / m;
            printf(&quot;Case %d: %lld %lld\n&quot;, kase, n, m);
        }
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/10/02/LightOJ-1148MadCounting/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/10/02/LightOJ-1148MadCounting/" itemprop="url">LightOJ - 1148 Mad Counting</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-02T22:04:12+08:00">
                2019-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">数论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Mob was hijacked by the mayor of the Town “TruthTown”. Mayor wants Mob to count the total population of the town. Now the naive approach to this problem will be counting people one by one. But as we all know Mob is a bit lazy, so he is finding some other approach so that the time will be minimized. Suddenly he found a poll result of that town where <strong>N</strong> people were asked “How many people in this town other than yourself support the same team as you in the FIFA world CUP 2010?” Now Mob wants to know if he can find the minimum possible population of the town from this statistics. Note that no people were asked the question more than once.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with an integer <strong>N (1 ≤ N ≤ 50)</strong>. The next line will contain <strong>N</strong> integers denoting the replies <strong>(0 to 106)</strong> of the people.Output</p>
<p>For each case, print the case number and the minimum possible population of the town.Sample Input</p>
<p>2</p>
<p>4</p>
<p>1 1 2 2</p>
<p>1</p>
<p>0</p>
<p>Sample Output</p>
<p>Case 1: 5</p>
<p>Case 2: 1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题。懒得分析了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-20.10.50
 By                : Tpaaaaaa
 Question_Number   ：Mad Counting LightOJ - 1148
 Question_Name     ：数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 60;
int a[MAXN];
int main()
{
    int t, n;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        sort(a + 1, a + 1 + n);
        ll sum = 0;
        for(int i = 1; i &lt;= n; )
        {
            int j = 1;
            sum += a[i] + 1;
            while(j &lt;= a[i] &amp;&amp; a[i] == a[i + j])
                j++;
            i = j + i;
        }
        printf(&quot;Case %d: %lld\n&quot;, kase, sum);
    }

    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/26/%5B%E6%80%BB%E7%BB%93%5DTPA%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/26/%5B%E6%80%BB%E7%BB%93%5DTPA%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/" itemprop="url">[总结]TPA的ACM模板</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T14:34:19+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以后学到什么新东西就往里面补充吧。</p>
<h2 id="1-字符串处理"><a href="#1-字符串处理" class="headerlink" title="1 字符串处理"></a>1 字符串处理</h2><h3 id="1-1-KMP"><a href="#1-1-KMP" class="headerlink" title="1.1 KMP"></a>1.1 KMP</h3><p>给定模式串b和文本串a，求b在a中的匹配情况。</p>
<pre><code>/*
  得到模式串b的next数组（串b是默认从下标0开始）
  next[i] 表示串中长度为i的前缀的最长公共前后缀的长度

next数组的应用：
利用next数组求最小循环节
串中长度为m的前缀中的最小循环节的长度为 len[m] = m – next[m]
abcab的最小循环节长度为3，即abc
next[m] = 0意味着自己就是一个循环节，即串没有循环部分。
*/
void getNext(char b[], int nxt[])
{
    int m = strlen(b);
    nxt[0] = -1;        //如果串是从下标1开始，改成nxt[1] = 0;
    int i = 0, j = -1;  //                   int i = 1, j = 0;
    while(i &lt; m)        //                   i &lt;= m
        if(j == -1 || a[i] == a[j])      //  j == 0 || 
            nxt[++i] = ++j;
    else
        j = nxt[j];
}

/*
给出文本串a和模式串b
问模式串在文本串中出现多少次,可重叠
例如：（3对输入上面为串b，下面为串a）
输入：
BAPC
BAPC
AZA
AZAZAZA
VERDI
AVERDXIVYERDIAN
输出：
1
3
0
*/
int kmp(char a[], char b[])
{
    getNext(b, nxt);
    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i],b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum++;
            j = nex[j];
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}

/*
给出文本串a和模式串b
问模式串在文本串中出现多少次,不可重叠
例如 aaaaaa  aa  = 3
*/
int kmp(char a[], char b[])
{
    getNext(b, nxt);              //为什么不报错呀？
    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i], b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum ++;
            j = 0;    //模式串首端
            i ++;     //文本串的下一位
            continue;
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}</code></pre><h3 id="1-2-e-KMP"><a href="#1-2-e-KMP" class="headerlink" title="1.2 e-KMP"></a>1.2 e-KMP</h3><p>定义母串S和子串T，S的长度为n，T的长度为m；</p>
<p>求   字符串S的每一个后缀  与 字符串T  的最长公共前缀；</p>
<pre><code>/*
extend[i]表示T与S[i,n-1]的最长公共前缀,也就是要求出所有extend[i](0&lt;=i&lt;n)
*/
void getExtend(char S[], char T[], int nxt[], int extend[])
{
    int a = 0, p = 0;
    getNext(T, nxt);
    int n = strlen(S);
    int m = strlen(T);
    for(int i = 0; i &lt; n; i++)
    {
        if(i &gt;= p || i + nxt[i - a] &gt;= p)
        {
            if(i &gt;= p)
                p = i;
            while(p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])
                p++;
            extend[i] = p - i;
            a = i;
        }
        else
            extend[i] = nxt[i - a];
    }
}


/*
next[i]表示T[i,m-1]和T的最长公共前缀长度.
*/
void getNext(char T[], int nxt[])
{
    int m = strlen(T);
    int a = 0, p = 0;
    nxt[0] = m;
    for(int i = 1; i &lt; m; i++)
    {
        if(i &gt;= p || i + nxt[i - a] &gt;= p)
        {
            if(i &gt;= p)
                p = i;
            while(p &lt; m &amp;&amp; T[p] == T[p - i])
                p++;
            nxt[i] = p - i;
            a = i;
        }
        else
            nxt[i] = nxt[i - a];
    }
}</code></pre><h3 id="1-3-Manacher"><a href="#1-3-Manacher" class="headerlink" title="1.3      Manacher"></a>1.3      Manacher</h3><p>可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。</p>
<ol>
<li><p>s=”abcd”，最长回文长度为 1；</p>
</li>
<li><p>s=”ababa”，最长回文长度为 5；</p>
</li>
<li><p>s=”abccb”，最长回文长度为 4，即bccb。</p>
<p>/*<br> p[i]数组表示的是<br> 其中p[i]表示以 i 为中心的最长回文的半径</p>
<pre><code>0 1 2 3 4 5 6 7 ....</code></pre><p> s_new=” $ # a # b # b # a # h # o # p # x # p # o # “<br> p[]  =”   1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 2 1”<br> p[i] - 1正好是原字符串中最长回文串的长度。<br> p[i]：原数组前i-1个元素的中心的最长回文半径<br>*/<br>void Manacher()<br>{</p>
<pre><code>int len = Init();
//得到一个新的串，s_new
// len为新串的长度
int id, mx = 0;
for(int i = 1; i &lt; len; i++)
{
    if(i &lt; mx)
        p[i] = min(p[2 * id - i], mx - i);
    else
        p[i] = 1;

    while(s_new[i - p[i]] == s_new[i+p[i]])
        p[i]++;
    if(mx &lt; i + p[i])
    {
        id = i;
        mx = i + p[i];
    }
}</code></pre><p>}</p>
</li>
</ol>
<pre><code>//s=&quot;abbahopxpo&quot;  s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;
int Init()
{
    int len = strlen(s);
    s_new[0] = &apos;$&apos;;
    s_new[1] = &apos;#&apos;;
    int j = 2;
    for(int i = 0; i &lt; len; i++)
    {
        s_new[j++] = s[i];
        s_new[j++] = &apos;#&apos;;
    }
    s_new[j] = &apos;\0&apos;;
    return j;
}</code></pre><h3 id="1-4-Trie树"><a href="#1-4-Trie树" class="headerlink" title="1.4 Trie树"></a>1.4 Trie树</h3><p>解决xor问题</p>
<pre><code>/*
问题：给n个整数A1, A2……An，
 选出两个数进行异或，得到的结果最大是多少？
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5;
int tire[MAXN][2], tot;
void add(int x)
{
    int p = 1;
    //范围2^31,001000110001000 从左边往右边数第一个是第一个加入的
    for(int i = 30; i &gt;= 0; i --)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(!tire[p][now])
            tire[p][now] = ++tot;
        p = tire[p][now];
    }
}
int Search(int x)
{
    int p = 1;
    int ret = 0;
    for(int i = 30; i &gt;= 0; i--)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(tire[p][now ^ 1])
        {
            p = tire[p][now ^ 1];
            ret |= (1 &lt;&lt; i);
        }
        else p = tire[p][now];
    }
    return ret;
}
int main()
{
    int n, x;
    cin &gt;&gt; n;
    tot = 1;        //tot！！！ = 1
    int ans = 0;
    memset(tire, 0, sizeof tire);
    for(int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(x);
        ans = max(ans, Search(x));
    }
    printf(&quot;ans = %d\n&quot;, ans);
    return 0;
}</code></pre><h3 id="1-5-AC自动机"><a href="#1-5-AC自动机" class="headerlink" title="1.5 AC自动机"></a>1.5 AC自动机</h3><p>指针版</p>
<pre><code>/*
题意：第一行输入测试数据的组数，然后输入一个整数n，接下来的n行每行输入一个单词，最后输入一个字符串，问在这个字符串中有多少个单词出现过。
*/
const int INF = 0x3f3f3f3f;
const int MAXN = ;
struct Node
{
    int cnt;
    Node *fail;
    Node *nxt[26];
}*que[MAXN];
char s[MAXN];
char keyword[60];
int head, tail;
Node *root;
void Init(Node *root)
{
    root-&gt;cnt  = 0;
    root-&gt;fail = NULL;
    for(int i = 0; i &lt; 26; i++)
        root-&gt;nxt[i] = NULL;
}
void buildTrie(char keyword[])
{
    Node *p, *q;
    int i, now;
    int len = strlen(keyword);
    p = root;
    for(int i = 0; i &lt; len; i++)
    {
        now = keyword[i] - &apos;a&apos;;
        if(p-&gt;nxt[now] == NULL)
        {
            q = (struct Node *)malloc(sizeof Node);
            Init(q);
            p-&gt;nxt[v] = q;
        }
        p = p-&gt;nxt[now];
    }
    p-&gt;cnt ++;
}
//BFS
void buildAcAutomation(Node *root)
{
    int head = 0, tail = 0;
    que[head++] = root;
    while(head != tail)
    {
        Node *p = NULL;
        Node *temp = que[tail++];
        for(int i = 0; i &lt; 26; i++)
        {
            if(temp-&gt;nxt[i] != NULL)
            {
                if(temp == root)
                    temp-&gt;nxt[i]-&gt;fail = root;
                else
                {
                    p=temp-&gt;fail;
                    while(p!=NULL)
                    {
                        if(p-&gt;nxt[i]!=NULL)
                        {
                            temp-&gt;nxt[i]-&gt;fail = p-&gt;nxt[i];
                        }
                        p = p-&gt;fail;
                    }
                    if(p == NULL)
                        temp-&gt;nxt[i]-&gt;fail = root;
                }
                que[head++] = temp-&gt;nxt[i];
            }
        }
    }
}
int query(Node *root)
{
    int now, sum = 0;
    Node *p = root;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i++)
    {
        now = s[i] - &apos;a&apos;;
        while(p-&gt;nxt[now] == NULL &amp;&amp; p != root)
            p = p-&gt;fail;
        p = p-&gt;nxt[now];
        if(p == NULL)
            p = root;
        Node *temp = p;
        while(temp != root)
        {
            if(temp-&gt;cnt &gt;= 0)
            {
                sum += temp-&gt;cnt;
                temp-&gt;cnt = -1;
            }
            else
                break;
            temp = temp -&gt;fail;
        }
    }
    return sum;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        root = (struct Node*)malloc(sizeof Node);
        Init(root);
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, keyword);
            buildTree(keyword);
        }
        buildAcAutomation(root);
        scanf(&quot;%s&quot;, s);
        printf(&quot;%d\n&quot;, query(root));

    }
    return 0;
}</code></pre><p>数组版</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
// Trie树的结构体
struct Trie
{
    int nxt[MAXN][26], fail[MAXN], edn[MAXN];
    int root, tot;
    //将当前节点初始化
    int newNode()
    {
        tot ++;         //用来记录结点编号的
        for(int i = 0; i &lt; 26; i++)
            nxt[tot][i] = -1;
        edn[tot] = 0;
        return tot;     //返回编号
    }
    void init()
    {
        tot = 0;
        root = newNode();//root一般而言是1
    }
    //往trie树中插入buf
    void add(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            if(nxt[p][now] == -1)
                nxt[p][now] = newNode();

            p = nxt[p][now];
        }
        edn[p]++;
    }
    //AC自动机的构建，也就是fail数组的构建
    void build()
    {
        queue &lt; int &gt; Q;
        fail[root] = root;
        //对根的结点单独处理一哈
        for(int i = 0; i &lt; 26; i++)
        {
            if(nxt[root][i] == -1)
                nxt[root][i] = root;
            else
            {
                fail[nxt[root][i]] = root;
                Q.push(nxt[root][i]);
            }
        }
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for(int i = 0; i &lt; 26; i++)
            {
                if(nxt[now][i] == -1)
                    nxt[now][i] = nxt[fail[now]][i];
                else
                {
                    fail[nxt[now][i]] = nxt[fail[now]][i];
                    Q.push(nxt[now][i]);
                }
            }
        }
    }
    int query(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        int res = 0;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            p = nxt[p][now];
            int temp = p;
            while(temp != root)
            {
                res += edn[temp];
                edn[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};
char buf[2*MAXN];
Trie AC;
int main()
{
    int t;
    int n;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        AC.init();
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            AC.add(buf);
        }
        AC.build();
        scanf(&quot;%s&quot;, buf);
        printf(&quot;%d\n&quot;, AC.query(buf));
    }
    return 0;
}</code></pre><h2 id="2-数学"><a href="#2-数学" class="headerlink" title="2 数学"></a>2 数学</h2><h3 id="2-1-素数"><a href="#2-1-素数" class="headerlink" title="2.1 素数"></a><strong>2.1 素数</strong></h3><h4 id="2-1-1素数筛选（判断-lt-MAXN-的数是否素数）"><a href="#2-1-1素数筛选（判断-lt-MAXN-的数是否素数）" class="headerlink" title="2.1.1素数筛选（判断 &lt;MAXN 的数是否素数）"></a>2.1.1素数筛选（判断 &lt;MAXN 的数是否素数）</h4><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
void init()
{
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
            for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
}</code></pre><h4 id="2-1-2-素数筛选（筛选出小于等于-MAXN-的素数）"><a href="#2-1-2-素数筛选（筛选出小于等于-MAXN-的素数）" class="headerlink" title="2.1.2 素数筛选（筛选出小于等于 MAXN 的素数）"></a>2.1.2 素数筛选（筛选出小于等于 MAXN 的素数）</h4><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
int prime[MAXN], top;
void init()
{
    top = 0;                             // 小于等于MAXN的素数的数目
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
        {
             prime[++top] = i;
             for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
}</code></pre><h3 id="2-2-唯一分解定理"><a href="#2-2-唯一分解定理" class="headerlink" title="2.2 唯一分解定理"></a>2.2 唯一分解定理</h3><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
int prime[MAXN], top;
void init()
{
    top = 0;                             // 小于等于MAXN的素数的数目
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
        {
             prime[++top] = i;
             for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
}
//将大数x进行分解。返回的是质因子的种类数
// factor[i][0] 存的是第i个质因子的值
// factor[i][1] 存的是第i个质因子的指数
// 下标从1开始。
int getFactors(long long x)
{
   fatCnt = 0;
   long long temp = x;
   for(int i = 1; prime[i] * prime[i] &lt;= temp; i++)
   {
       if(temp % prime[i] == 0)
       {
            factor[++fatCnt][0] = prime[i];
            factor[fatCnt][1]   = 0;
            while(temp % prime[i] == 0)
            {
                 factor[fatCnt][1] ++;
                 temp /= prime[i];
            } 
       }
   }
   if(temp != 1)
   {
        factor[++fatCnt][0] = temp;
        factor[fatCnt][1]   = 1;
   }
    return fatCnt;
}</code></pre><h3 id="2-3-扩展欧几里得算法"><a href="#2-3-扩展欧几里得算法" class="headerlink" title="2.3 扩展欧几里得算法"></a>2.3 扩展欧几里得算法</h3><p>求解 ax = gcd(a, b) (mod b);</p>
<p>求 ax + by = gcd(a, b)的解</p>
<pre><code>long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
     if(a == 0 &amp;&amp; b == 0)     return 1;
     if(b == 0)
     {
          x = 1;
          y = 0;
          return a;
     }
     long long temp = exgcd(b, a % b, y, x);
     y -= x * a / b;
     return temp;
}</code></pre><h3 id="2-4-求逆元"><a href="#2-4-求逆元" class="headerlink" title="2.4 求逆元"></a>2.4 求逆元</h3><h4 id="2-4-1扩展欧几里得求逆元"><a href="#2-4-1扩展欧几里得求逆元" class="headerlink" title="2.4.1扩展欧几里得求逆元"></a>2.4.1扩展欧几里得求逆元</h4><pre><code>long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
     if(a == 0 &amp;&amp; b == 0)     return 1;
     if(b == 0)
     {
          x = 1;
          y = 0;
          return a;
     }
     long long temp = exgcd(b, a % b, y, x);
     y -= x * a / b;
     return temp;
}
/*求逆元*/
// ax = 1(mod n)
long long modReverse(long long a, long long n)
{
   long long x, y;
   long long d = exgcd(a, n, x, y);
   if(d == 1)                      //只有gcd(a,n) = 1,互素的情况下才有逆元
        return (x % n + n) % n;
   else
        return -1;                 //没有逆元
}</code></pre><h4 id="2-4-2费马小定理求逆元"><a href="#2-4-2费马小定理求逆元" class="headerlink" title="2.4.2费马小定理求逆元"></a>2.4.2费马小定理求逆元</h4><p>要求： p 为素数, 而且 a 和 p 互质</p>
<p>根据费马小定理，若p为素数，且a和p互质的话，有</p>
<p>a^(p - 1) = 1 (mod p)</p>
<p>所以有 a * a^(p - 2) = 1 (mod p)</p>
<p>即a^(p - 2) 就是a模p的逆元，可以配合快速幂取模</p>
<pre><code>ll qpow(ll x,int k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans*x)%mod;
        x = (x*x)%mod;
        k &gt;&gt;= 1;
    }
    return ans;
}
//打表的方法，阶乘表，逆元表哦
void init()
{
    fac[0] = 1;
    ni[0] = 1; 
    for(int i = 1; i &lt; MAXN; i++)
    {
        //显然mod 与 pri互质
        //因为mod是素数，显然互素。
        fac[i] = fac[i-1] * i % mod;
        ni[i] = qpow(fac[i], mod - 2);
    }
}</code></pre><h3 id="2-7-欧拉函数"><a href="#2-7-欧拉函数" class="headerlink" title="2.7 欧拉函数"></a>2.7 欧拉函数</h3><h4 id="2-7-1-分解质因素求欧拉函数"><a href="#2-7-1-分解质因素求欧拉函数" class="headerlink" title="2.7.1 分解质因素求欧拉函数"></a><strong>2.7.1</strong> 分解质因素求欧拉函数</h4><h4 id="2-7-2-筛法欧拉函数"><a href="#2-7-2-筛法欧拉函数" class="headerlink" title="2.7.2 筛法欧拉函数"></a><strong>2.7.2</strong> 筛法欧拉函数</h4><h4 id="2-7-3-求单个数的欧拉函数"><a href="#2-7-3-求单个数的欧拉函数" class="headerlink" title="2.7.3 求单个数的欧拉函数"></a><strong>2.7.3</strong> 求单个数的欧拉函数</h4><pre><code>//利用公式ϕ(n)=n∏(1−1/p) 其中p是能整除n的素数
ll eular(ll n)
{
    ll ans = n;
    for(int i = 2; i * i &lt;= n; i++)
    {
        if(n % i == 0)
               ans -= ans / i;
               while(n % i == 0)
                   n /= i;
    }
    if(n &gt; 1) ans -= ans / n;  
    return ans;
}</code></pre><h4 id="2-7-4-线性筛（同时得到欧拉函数和素数表）"><a href="#2-7-4-线性筛（同时得到欧拉函数和素数表）" class="headerlink" title="2.7.4 线性筛（同时得到欧拉函数和素数表）"></a><strong>2.7.4</strong> 线性筛（同时得到欧拉函数和素数表）</h4><h4 id="2-8-高斯消元"><a href="#2-8-高斯消元" class="headerlink" title="2.8 高斯消元"></a>2.8 高斯消元</h4><p><strong>2.8.0 高斯消元模板.</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
using namespace std;

const int MAXN=50;



int a[MAXN][MAXN];//增广矩阵
int x[MAXN];//解集
bool free_x[MAXN];//标记是否是不确定的变元



/*
void Debug(void)
{
    int i, j;
    for (i = 0; i &lt; equ; i++)
    {
        for (j = 0; j &lt; var + 1; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}
*/


inline int gcd(int a,int b)
{
    int t;
    while(b!=0)
    {
        t=b;
        b=a%b;
        a=t;
    }
    return a;
}
inline int lcm(int a,int b)
{
    return a/gcd(a,b)*b;//先除后乘防溢出
}

// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，
//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.
int Gauss(int equ,int var)
{
    int i,j,k;
    int max_r;// 当前这列绝对值最大的行.
    int col;//当前处理的列
    int ta,tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;

    for(int i=0;i&lt;=var;i++)
    {
        x[i]=0;
        free_x[i]=true;
    }

    //转换为阶梯阵.
    col=0; // 当前处理的列
    for(k = 0;k &lt; equ &amp;&amp; col &lt; var;k++,col++)
    {// 枚举当前处理的行.
// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(abs(a[i][col])&gt;abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k)
        {// 与第k行交换.
            for(j=k;j&lt;var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0)
        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--;
            continue;
        }
        for(i=k+1;i&lt;equ;i++)
        {// 枚举要删去的行.
            if(a[i][col]!=0)
            {
                LCM = lcm(abs(a[i][col]),abs(a[k][col]));
                ta = LCM/abs(a[i][col]);
                tb = LCM/abs(a[k][col]);
                if(a[i][col]*a[k][col]&lt;0)tb=-tb;//异号的情况是相加
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j] = a[i][j]*ta-a[k][j]*tb;
                }
            }
        }
    }

  //  Debug();

    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i &lt; equ; i++)
    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if (k &lt; var)
    {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i &gt;= 0; i--)
        {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num &gt; 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = var - 1; i &gt;= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j &lt; var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}
int main(void)
{
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    int i, j;
    int equ,var;
    while (scanf(&quot;%d %d&quot;, &amp;equ, &amp;var) != EOF)
    {
        memset(a, 0, sizeof(a));
        for (i = 0; i &lt; equ; i++)
        {
            for (j = 0; j &lt; var + 1; j++)
            {
                scanf(&quot;%d&quot;, &amp;a[i][j]);
            }
        }
//        Debug();
        int free_num = Gauss(equ,var);
        if (free_num == -1) printf(&quot;无解!\n&quot;);
   else if (free_num == -2) printf(&quot;有浮点数解，无整数解!\n&quot;);
        else if (free_num &gt; 0)
        {
            printf(&quot;无穷多解! 自由变元个数为%d\n&quot;, free_num);
            for (i = 0; i &lt; var; i++)
            {
                if (free_x[i]) printf(&quot;x%d 是不确定的\n&quot;, i + 1);
                else printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        else
        {
            for (i = 0; i &lt; var; i++)
            {
                printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><p><strong>2.8.1 解一类开关问题，变成对2取模的01方程组.</strong></p>
<pre><code>bwwb
bbwb
bwwb
bwww
翻一个，周围四个都会变，问全变成w的最少步数.

File_Name         ：Flip Game POJ - 1753 .cpp
const int INF = 0x3f3f3f3f;
const int MAXN = 20;
int a[MAXN][MAXN], b[MAXN][MAXN];
int x[MAXN], free_x[MAXN];
//想象一下是16*16的矩阵哦
//注意是翻成相同面
void getA()
{
    for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++)
        {
            int t = i * 4 + j;
            a[t][t] = 1;
            int up = (i - 1) * 4 + j;
            int down = (i + 1) * 4 + j;
            int left = i * 4 + j - 1;
            int right = i * 4 + j + 1;
            if(i &gt; 0)   a[up][t] = 1;
            if(i &lt; 3)   a[down][t] = 1;
            if(j &gt; 0)   a[left][t] = 1;
            if(j &lt; 3)   a[right][t] = 1; 
        }
}
//n * n的矩阵
//为0，为1都算一遍
//就是将原来的翻转一次即可.
int Gauss(int n)
{
    memset(x, 0, sizeof x);
    memset(free_x, 0, sizeof free_x);
    int col = 0, row = 0;
    int max_r, num = 0;
    for(;col &lt; n &amp;&amp; row &lt; n; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col] &gt; a[max_r][col])   max_r = i;
        if(max_r != row)
            for(int i = col; i &lt;= n; i++)
                swap(a[row][i], a[max_r][i]);
        if(a[row][col] == 0)
        {
            row --;
            free_x[num++] = col;
            continue;
        }
        //开始消
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col])
                for(int j = col; j &lt;= n; j++)
                  a[i][j] ^= a[row][j];
    }
    for(int i = row; i &lt; n; i++)
        if(a[i][col]) return INF;
    int up = 1 &lt;&lt; (n - row);
    int ans = INF;
    for(int i = 0; i &lt; up; i++)
    {
        int cnt = 0;
        int index = i;
        for(int j = 0; j &lt; (n - row); j++)
        {
            x[free_x[j]] = index &amp; 1;
            if(x[free_x[j]]) cnt++;
            index &gt;&gt;= 1;
        }
        //处理完了
        for(int j = row - 1; j &gt;= 0; j--)
        {
            //x[j] = a[j][n];
            int temp = a[j][n];
            for(int l = j + 1; l &lt; n; l++)
                if(a[j][l]) temp ^= x[l];

            x[j] = temp;
            if(x[j])
                cnt++;
        }
        if(cnt &lt; ans)
            ans = cnt;
    }
    return ans;             //我特么是个憨憨
}
int main()
{
    char ch;
    memset(a, 0, sizeof a);
    memset(b, 0, sizeof b);
    getA();
    for(int i = 0; i &lt; 16; i++)
    {
        cin &gt;&gt; ch;
        if(ch == &apos;b&apos;) 
                a[i][16] = 1;    
        else    a[i][16] = 0;
        b[i][16] = a[i][16] ^ 1;
    }
    int ans = Gauss(16);
    memcpy(a, b, sizeof b);
    getA();
    int temp = Gauss(16);
    if(temp &lt; ans)
        ans = temp;

    if(ans &gt;= INF)
        printf(&quot;Impossible\n&quot;);
    else
        printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre><p><strong>2.8.2 解同余方程组.</strong></p>
<pre><code>//解一个模7的同余方程组.
File_Name         ：POJ 2947 Widget Factory.cpp（重新写一个）.cpp
const int INF = 0x3f3f3f3f;
const int MAXN = 310;
const int MOD = 7;
int x[MAXN];
int a[MAXN][MAXN];
int n, m;               //m是方程数，n是变量数
int gcd(int a, int b)
{
    if(b == 0)  return a;
    return gcd(b, a%b);
}
int lcm(int a, int b)
{
    return a/gcd(a, b) * b;
}
int exGcd(int a, int b, int &amp;x, int &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        int d = exGcd(b, a % b, y, x);
        y -= x*a/b;             //????喵喵喵？？？？？
        return d;
    }
}
int getNum(char temp[])
{
    char cmp[7][10] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;};
    for(int i = 0; i &lt; 7; i++)
        if(strcmp(temp, cmp[i]) == 0)
            return i + 1;
    return -1;
}
//equ个方程，val个变量
//
int Gauss(int equ, int var)
{
    memset(x, 0, sizeof x);
    int col, row;
    for(row = 0, col = 0; row &lt; equ &amp;&amp; col &lt; var; col ++, row ++)
    {
        int max_r;
        for(max_r = row; max_r &lt; equ; max_r++)
            if(a[max_r][col])
                break;

        if(max_r == equ)
        {
            row --;
            continue;
        }
        if(max_r != row)
            for(int j = 0; j &lt;= var; j++)
                swap(a[max_r][j], a[row][j]);

        for(int i = row + 1; i &lt; equ; i++)
        {
            if(a[i][col] == 0)  continue;
            int LCM = lcm(a[row][col], a[i][col]);
            int ta = LCM / a[i][col];
            int tb = LCM / a[row][col];
            for(int j = col; j &lt;= var; j++)
                a[i][j] = ((a[i][j] * ta - a[row][j] * tb) % MOD + MOD) % MOD;
        }
    }
    //无解
    //
    for(int i = row; i &lt; equ; i++)
        if(a[i][col])   return -1;
    if(row &lt; var)         return 0;
    for(int i = equ - 1; i &gt;= 0; i--)
    {
        int temp = a[i][var];
        for(int j = i + 1; j &lt; var; j++)
            temp = ((temp - a[i][j] * x[j])%MOD + MOD) % MOD;
        int b = temp;
        int X, Y;
        int d = exGcd(a[i][i], MOD, X, Y);
        X = X * (b / d) % MOD;
        X =(X % (MOD / d) + (MOD / d)) % (MOD / d);
        if(X &lt; 3)   X += 7;
        x[i] = X; 

    }
    return 1;
}
int main()
{   
    int start, fire, k;
    char A[10], B[10];
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n + m )
    {
        memset(a, 0, sizeof a);
        for(int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d %s %s&quot;, &amp;k, A, B);
            start = getNum(A);
            fire  = getNum(B);
            int day = fire - start + 1;
            a[i][n] = (day % MOD + MOD) % MOD;
            for(int j = 0; j &lt; k; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                a[i][temp - 1] = (a[i][temp - 1] + 1) % MOD;
            }
        }
        int ans = Gauss(m, n);              //从第一行开始.
        if(ans == 0)
            printf(&quot;Multiple solutions.\n&quot;);
        else if(ans == -1)
            printf(&quot;Inconsistent data.\n&quot;);
        else
        {
            printf(&quot;%d&quot;, x[0]);
            for(int i = 1; i &lt; n; i++)
                printf(&quot; %d&quot;, x[i]);
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}</code></pre><h3 id="2-9求组合数"><a href="#2-9求组合数" class="headerlink" title="2.9求组合数"></a>2.9求组合数</h3><p>2.9.1组合数取模问题</p>
<p>数据量不大于10e6的情况下，可以考虑使用打表法，打出fac表和逆元表</p>
<p><strong>注意开4e6的数组会爆32mb的内存。</strong></p>
<p>那么打逆元表的方法又有两种，一种是利用扩展欧几里得算法求逆元，一种是用费马小定理+快速幂求逆元。</p>
<pre><code>//用的是扩展欧几里得求逆元.
ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        ll temp = exgcd(b, a%b, y, x);
        y -= x * (a / b);
        return temp;
    }
}
void init()//考虑取模
{
    dp[0] = 1;
    dp[1] = 0;              //WA的原因
    dp[2] = 1;
    dp[3] = 2;
    for(int i = 4; i &lt; MAXN; i++)
        dp[i] = ( (i - 1) * ((dp[i - 1] + dp[i - 2]) % MOD)) % MOD;

    //求出fac表和逆表
    fac[0] = 1;
    ni[0] = 1;
    ll x, y;
    for(int i = 1; i &lt; MAXN; i++)
    {
        fac[i] = (fac[i - 1] * i) % MOD;
        exgcd(fac[i], MOD, x, y);
        ni[i] = (x % MOD + MOD) % MOD;
    }
}
ll C(int N, int M)
{
    return ((fac[N] * ni[M]) % MOD * ni[N - M]) % MOD;
}

//用的是费马小定理.
//求的是x的k次方模mod
ll qpow(ll x,int k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans*x)%mod;
        x = (x*x)%mod;
        k &gt;&gt;= 1;
    }
    return ans;
}
//打表的方法，阶乘表，逆元表哦
void init()
{
    fac[0] = 1; //存的是阶乘模mod
    ni[0] = 1;  //在存的是这个阶乘的值对模的逆元表
    for(int i = 1; i &lt; MAXN; i++)   //????????EXM？？？？？？？？？改了这里
    {
        //显然mod 与 pri互质
        //因为mod是素数，显然互素。
        fac[i] = fac[i-1] * i % mod;
        //printf(&quot;fac[i] = %d\n&quot;, fac[i]);
        //qpow是快速幂取模
        ni[i] = qpow(fac[i], mod - 2);
    }
}</code></pre><p><strong>2、数据量大的情况下，考虑卢卡斯定理。</strong></p>
<pre><code>//返回a^b次模MOD
ll qpow(ll a, ll b)
{
    ll ans = 1;
    while(b)
    {
        if(b &amp; 1)   
            ans = (ans * a) % MOD;
        a = (a * a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}
// 返回x模MOD的逆元
ll inv(ll x)
{
    return qpow(x, MOD - 2);
}
// 返回组合数C(a, b)
ll C(ll a, ll b)
{
    if(a &lt; b) return 0;
    ll up = 1, down = 1;    //分子分母
    for(int i = a - b + 1; i &lt;= a; i++)
        up = up * i % MOD;
    for(int i = 1; i &lt;= b; i++)
        down = down * i % MOD;
    return up * inv(down) % MOD;
}
ll lucas(ll a, ll b)
{
    if(b == 0)  return 1;
    return C(a % MOD, b % MOD) * lucas(a / MOD, b / MOD) % MOD;
}</code></pre><h4 id="2-9-2-隔板法"><a href="#2-9-2-隔板法" class="headerlink" title="2.9.2 隔板法"></a><strong>2.9.2 隔板法</strong></h4><p><strong>一般问题1</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为1</p>
<p><strong>一般问题2</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为0</p>
<p><strong>一般问题3</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中 x[i] 至少为 v[i].</p>
<h4 id="2-9-3错排公式"><a href="#2-9-3错排公式" class="headerlink" title="2.9.3错排公式"></a>2.9.3错排公式</h4><p>错排公式</p>
<p>dp[n] 表示的是将n个元素错排的方法数</p>
<p>可知 dp[n] = (n-1)dp[n-2] + (n-1)dp[n-1];</p>
<p>dp[0] = 1; dp[1] = 0; dp[2] = 1; dp[3] = 2;</p>
<h3 id="2-10-FFT"><a href="#2-10-FFT" class="headerlink" title="2.10 FFT"></a>2.10 FFT</h3><pre><code>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#define space putchar(&apos; &apos;)
#define enter putchar(&apos;\n&apos;)
using namespace std;
typedef long long ll;
template &lt;class T&gt;
void read(T &amp;x){
    char c;
    bool op = 0;
    while(c = getchar(), c &lt; &apos;0&apos; || c &gt; &apos;9&apos;)
    if(c == &apos;-&apos;) op = 1;
        x = c - &apos;0&apos;;
    while(c = getchar(), c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)
        x = x * 10 + c - &apos;0&apos;;
    if(op) x = -x;
}
template &lt;class T&gt;
void write(T x){
    if(x &lt; 0) putchar(&apos;-&apos;), x = -x;
    if(x &gt;= 10) write(x / 10);
    putchar(&apos;0&apos; + x % 10);
}
const int N = 1000005;
const double PI = acos(-1);
typedef complex &lt;double&gt; cp;
char sa[N], sb[N];
int n = 1, lena, lenb, res[N];
cp a[N], b[N], omg[N], inv[N];
void init(){
    for(int i = 0; i &lt; n; i++){
        omg[i] = cp(cos(2 * PI * i / n), sin(2 * PI * i / n));
        inv[i] = conj(omg[i]);
    }
}
void fft(cp *a, cp *omg){
    int lim = 0;
    while((1 &lt;&lt; lim) &lt; n) lim++;
    for(int i = 0; i &lt; n; i++){
        int t = 0;
        for(int j = 0; j &lt; lim; j++)
            if((i &gt;&gt; j) &amp; 1) t |= (1 &lt;&lt; (lim - j - 1));
        if(i &lt; t) swap(a[i], a[t]); // i &lt; t 的限制使得每对点只被交换一次（否则交换两次相当于没交换）
    }
    for(int l = 2; l &lt;= n; l *= 2){
        int m = l / 2;
    for(cp *p = a; p != a + n; p += l)
        for(int i = 0; i &lt; m; i++){
            cp t = omg[n / l * i] * p[i + m];
            p[i + m] = p[i] - t;
            p[i] += t;
        }
    }
}
int main(){
    scanf(&quot;%s%s&quot;, sa, sb);
    lena = strlen(sa), lenb = strlen(sb);
    while(n &lt; lena + lenb) n *= 2;
    for(int i = 0; i &lt; lena; i++)
        a[i].real(sa[lena - 1 - i] - &apos;0&apos;);
    for(int i = 0; i &lt; lenb; i++)
        b[i].real(sb[lenb - 1 - i] - &apos;0&apos;);
    init();
    fft(a, omg);
    fft(b, omg);
    for(int i = 0; i &lt; n; i++)
        a[i] *= b[i];
    fft(a, inv);
    for(int i = 0; i &lt; n; i++){
        res[i] += floor(a[i].real() / n + 0.5);
        res[i + 1] += res[i] / 10;
        res[i] %= 10;
    }
    for(int i = res[lena + lenb - 1] ? lena + lenb - 1: lena + lenb - 2; i &gt;= 0; i--)
        putchar(&apos;0&apos; + res[i]);
    enter;
    return 0;
}</code></pre><p>加速多项式乘法，大数乘法</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FO(x) {freopen(#x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(#x&quot;.out&quot;,&quot;w&quot;,stdout);}
#define pa pair&lt;int,int&gt;
#define mod 1000000007
#define ll long long
#define mk make_pair
#define pb push_back
#define fi first
#define se second
#define cl(x) memset(x,0,sizeof x)
#ifdef Devil_Gary
#define bug(x) cout&lt;&lt;(#x)&lt;&lt;&quot; &quot;&lt;&lt;(x)&lt;&lt;endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#else
#define bug(x)
#define debug(...)
#endif
const int INF = 0x7fffffff;
const int N=3e6+5;
/*
char *TT,*mo,but[(1&lt;&lt;15)+2];
#define getchar() ((TT==mo&amp;&amp;(mo=(TT=but)+fread(but,1,1&lt;&lt;15,stdin),TT==mo))?-1:*TT++)//*/
inline int read(){
    int x=0,rev=0,ch=getchar();
    while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;){if(ch==&apos;-&apos;)rev=1;ch=getchar();}
    while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-&apos;0&apos;;ch=getchar();}
    return rev?-x:x;
}
const int Mod=100;
int ans,K,ls;
int M,l,r[N];
char ss[N];

vector&lt;int&gt;s,g,f;
const double pi = acos(-1.0);
struct Cp{
    double x,y;
    Cp (double _x=0, double _y=0) {x=_x,y=_y;}
    Cp operator + (const Cp&amp; rhs) {return Cp(x+rhs.x,y+rhs.y);}
    Cp operator - (const Cp&amp; rhs) {return Cp(x-rhs.x,y-rhs.y);}
    Cp operator * (const Cp&amp; rhs) {return Cp(x*rhs.x-y*rhs.y,x*rhs.y+y*rhs.x);}
}A[N],B[N],x,w,w0;
inline void FFT(Cp *A,int f) {
    int i,j,k;
    for(i=0;i&lt;M;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]);
    for(i=1;i&lt;M;i&lt;&lt;=1) {
        w.x=cos(pi/i),w.y=sin(pi/i)*f;
        for(j=0;j&lt;M;j+=i&lt;&lt;1) {
            w0.x=1,w0.y=0;
            for(k=0;k&lt;i;++k) {
                x=A[j+k];
                A[j+k]=x+(w0*A[i+j+k]);
                A[i+j+k]=x-(w0*A[i+j+k]);
                w0=w0*w;
            }
        }
    }
    if(f==-1) for(i=0;i&lt;M;++i) A[i].x/=M;
}

void stretch(vector&lt;int&gt;&amp;a){
    int p=0,la=a.size();
    for (int i=0;i&lt;la||p;++i) {
        if(i&gt;=la) a.pb(0);
        ll cur=a[i]+p;
        a[i]=cur%Mod;
        p=cur/Mod;
    }
}
bool cmp(vector&lt;int&gt;a){
    int la=a.size(),lb=s.size();
    if(la&lt;lb) return 0;
    if(la&gt;lb) return 1;
    for(int i=la-1;~i;i--) {
        if(a[i]&lt;s[i]) return 0;
        if(a[i]&gt;s[i]) return 1;
    } 
    return 1;
}
bool work(int x){
    vector&lt;int&gt;h;
    for(int i=0;i&lt;g.size();i++) h.pb(g[i]*x);
    stretch(h);
//  for(int i=0;i&lt;h.size();i++) cout&lt;&lt;h[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    return cmp(h);
}
void solve2(){
    for(int i=0;i&lt;g.size();i++) g[i]=g[i]*3;
    stretch(g); 
}
//calc 3^n
vector&lt;int&gt; solve(vector&lt;int&gt;a,vector&lt;int&gt;b){
    int la=a.size(),lb=b.size();
//  for(int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
//  for(int i=0;i&lt;b.size();i++) cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
//  bug(la),bug(lb);
    for(M=1,l=0;M&lt;=la+lb;M&lt;&lt;=1,l++);
    for(int i=0;i&lt;a.size();i++) A[i].x=a[i],A[i].y=0; 
    for(int i=0;i&lt;b.size();i++) B[i].x=b[i],B[i].y=0; 
    for(int i=1;i&lt;M;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));
    FFT(A,1),FFT(B,1);
    for(int i=0;i&lt;M;i++) A[i]=A[i]*B[i];
    FFT(A,-1);
    vector&lt;int&gt;z(la+lb-1);
    for(int i=0;i&lt;=la+lb-2;i++) z[i]=(int)(A[i].x+0.5);
    for(int i=0;i&lt;M;i++) A[i].x=B[i].x=A[i].y=B[i].y=0;
//  for(int i=0;i&lt;z.size();i++) cout&lt;&lt;z[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    return z;
}
void calc(){
    f.pb(3),g.pb(1);
    while(K){
        if(K&amp;1) g=solve(g,f),stretch(g);
        K&gt;&gt;=1,f=solve(f,f),stretch(f);
    }
}
int tt[10]={0,1,2,3,4,5,5,6,6,6};
int main(){
#ifdef Devil_Gary
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
#endif
    scanf(&quot;%s&quot;,ss),ls=strlen(ss),reverse(ss,ss+ls);
    if(ls==1){
        int zjq=ss[0]-&apos;0&apos;; return cout&lt;&lt;tt[zjq]&lt;&lt;endl,0;
    }
    for(int i=0;i&lt;ls;i+=2) {
        int x=ss[i]-&apos;0&apos;;
        if(i+1&lt;ls) x+=(ss[i+1]-&apos;0&apos;)*10;
//      if(i+2&lt;ls) x+=(ss[i+2]-&apos;0&apos;)*100;
        s.pb(x);
    }
    K=(ls-1)*(double)(log(10)/log(3)),--K,ans+=K*3,calc();
    int ans2=ans;
//  for(int i=0;i&lt;s.size();i++) cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    for(;;ans+=3,solve2()){
//      for(int i=0;i&lt;g.size();i++) cout&lt;&lt;g[i]&lt;&lt;&quot; &quot;;bug(ans),cout&lt;&lt;endl; 
        if(work(2)) {ans+=2;break;}
        else if(work(3)) {ans+=3;break;}
        else if(work(4)) {ans+=4;break;}
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}

int bit_rev(int t,int n){
    int res=0;
    for (int i=0;i&lt;n;i++) res|=(t&gt;&gt;(n-i-1)&amp;1)&lt;&lt;i;
    return res;
}
void fft(cd *a,int n,int rev){
    int len=1&lt;&lt;n;
    static cd y[N*4];
    for (int i=0;i&lt;len;i++) y[i]=a[bit_rev(i,n)];
    for (int d=1;d&lt;len;d&lt;&lt;=1){
        cd wn=exp(cd(0,PI*rev/d));
        for (int k=0;k&lt;len;k+=(d&lt;&lt;1)){
            cd w=cd(1,0);
            for (int i=k;i&lt;k+d;i++,w*=wn){
                cd u=y[i],v=w*y[i+d];
                y[i]=u+v;
                y[i+d]=u-v;
            }
        }
    }
    if (rev==-1)
    for (int i=0;i&lt;len;i++) y[i]/=len;
    for (int i=0;i&lt;len;i++) a[i]=y[i];
}
void mul(int *a,int la,int *b,int lb,int *c,int &amp;lc){
    int len=1,n=0;
    static cd t1[N*4],t2[N*4];
    for (;len&lt;la*2 || len&lt;lb*2;len&lt;&lt;=1,++n);
    for (int i=0;i&lt;len;i++){
        t1[i]=cd(i&lt;la ? a[i] : 0,0);
        t2[i]=cd(i&lt;lb ? b[i] : 0,0);
    }
    fft(t1,n,1);
    fft(t2,n,1);
    for (int i=0;i&lt;len;i++) t1[i]*=t2[i];
    fft(t1,n,-1);
    lc=len-1;
    for (int i=0;i&lt;len;i++) c[i]=(int)(t1[i].real()+0.5);
}</code></pre><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-2-RMQ"><a href="#3-2-RMQ" class="headerlink" title="3.2 RMQ"></a>3.2 RMQ</h3><p>一维</p>
<pre><code>// dp[i][j] 保存的是[i, i + 2^j - 1] 这个区间里面的最小值
void rmq_init()  // 作用是初始化dp数组， 题目给的数组是arr[1] ... arr[N]
{
    for(int i=1;i&lt;=N;i++)
        dp[i][0]=arr[i];//初始化
    for(int j=1;(1&lt;&lt;j)&lt;=N;j++)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]);

}

//rmq(l, r) 的作用是查询区间[l, r]中的最小值
int rmq(int l,int r)
{
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);
}</code></pre><p>二维</p>
<pre><code>//maxv[a][b][c][d] 保存的是（a,b）为左上角，右下角（a + 2^c - 1, b + 2^d - 1）
//这个矩形区域的最大值
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int Log=12;
const int N=610;
const int inf=1e9;
int n,m,Q;
int maxv[Log][Log][N][N];
int pre[N],val[N][N]; 
void init(){
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)maxv[0][0][i][j]=val[i][j];
    pre[2]=pre[3]=1;
    for(int i=4,up=max(n,m);i&lt;=up;i++)pre[i]=pre[i&gt;&gt;1]+1;
    int up1=pre[n]+1,up2=pre[m]+1;
    for(int l1=0;l1&lt;=up1;l1++){
        for(int l2=0;l2&lt;=up2;l2++){
            if(!l1&amp;&amp;!l2) continue;
            for(int i=1;(i+(1&lt;&lt;l1)-1)&lt;=n;i++){
                for(int j=1;(j+(1&lt;&lt;l2)-1)&lt;=m;j++){
                    if(l2)maxv[l1][l2][i][j]=max(maxv[l1][l2-1][i][j],maxv[l1][l2-1][i][j+(1&lt;&lt;(l2-1))]);
                    else maxv[l1][l2][i][j]=max(maxv[l1-1][l2][i][j],maxv[l1-1][l2][i+(1&lt;&lt;(l1-1))][j]);
                }
            }
        }
    }
}
int query(int x1,int y1,int x2,int y2){
    int p=pre[x2-x1+1],q=pre[y2-y1+1];
    int ans=-inf;
    ans=max(maxv[p][q][x1][y1],maxv[p][q][x1][y2-(1&lt;&lt;q)+1]);
    ans=max(ans,max(maxv[p][q][x2-(1&lt;&lt;p)+1][y1],maxv[p][q][x2-(1&lt;&lt;p)+1][y2-(1&lt;&lt;q)+1]));
    return ans;
}
int x1,x2,y1,y2;
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;val[i][j]);
    init();
    for(int i=1;i&lt;=Q;i++){
        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
        printf(&quot;%d\n&quot;,query(x1,y1,x2,y2));
    }
    return 0;
}</code></pre><h3 id="3-3-树链剖分"><a href="#3-3-树链剖分" class="headerlink" title="3.3 树链剖分"></a>3.3 树链剖分</h3><p>3.3.1 基于点权，查询单点值，修改路径的上的点权</p>
<pre><code>f[u]保存结点u的父亲节点
d[u]保存结点u的深度值
size[u]保存以u为根的子树节点个数
son[u]保存重儿子
rk[u]保存当前
dfs标号在树中所对应的节点
top[u]保存当前节点所在链的顶端节点
id[u]保存树中每个节点剖分以后的新编号（DFS的执行顺序）
void dfs1(int u,int fa,int depth)    //当前节点、父节点、层次深度
{
    f[u]=fa;
    d[u]=depth;
    size[u]=1;    //这个点本身size=1，子树的大小要包括自己哦
    for(int i=head[u]; i != -1;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        dfs1(v,u,depth+1);    //层次深度+1
        size[u]+=size[v];    //子节点的size已被处理，用它来更新父节点的size
        if(size[v]&gt;size[son[u]])
            son[u]=v;    //选取size最大的作为重儿子
    }
}
//外部进入
dfs1(root,0,1);
//第二次dfs
void dfs2(int u,int t)    //当前节点、重链顶端
{
    top[u]=t;
    id[u]=++cnt;    //标记dfs序
    rk[cnt]=u;      //序号cnt对应节点u
    if(!son[u])     //没有子节点
        return;
    dfs2(son[u],t);
/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续，
一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[u]&amp;&amp;v!=f[u])
            dfs2(v,v);    //一个点位于轻链底端，那么它的top必然是它本身
    }
}
//sum函数
int sum(int x,int y)
{
    int ans=0,fx=top[x],fy=top[y];
    while(fx!=fy)    //两点不在同一条重链
    {
        if(d[fx]&gt;=d[fy]) //要让父节点深度大的点先跳，这里是x先跳
        {
            ans+=query(id[fx],id[x],rt);    //线段树区间求和，处理这条重链的贡献
            x=f[fx],fx=top[x];    //将x设置成原链头的父亲结点，走轻边，继续循环
        }
        else
        {
            ans+=query(id[fy],id[y],rt);
            y=f[fy],fy=top[y];
        }
    }
    //循环结束，两点位于同一重链上，但两点不一定为同一点，所以我们还要统计这两点之间的贡献
    if(id[x]&lt;=id[y])
        ans+=query(id[x],id[y],rt);
    else
        ans+=query(id[y],id[x],rt);
    return ans;
}</code></pre><p>3.3.2 基于边权，修改单条边权，查询路径边权最大值</p>
<pre><code> //将边权转移到点权上，然后变成了树链剖分的模板题
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int cnt, tot;
int e[MAXN][3], dep[MAXN], head[MAXN], f[MAXN], top[MAXN], dfn[MAXN], siz[MAXN], son[MAXN], rk[MAXN];
struct Node
{
    int l, r;
    ll sum;
}node[MAXN * 4];

struct Edge
{
    int v, next;
} edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}
//线段树的单点修改
//将k位置的值，变成c
inline void pushUp(int rt)
{
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}
//返回的是编号u点到v点的路径权值和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉
    return ret;

}
void init()
{
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;

}
int main()
{
    int n, m, a, b, c;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt; n; i ++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);
        built(1, 1, n);
        //两次dfs后，我们得到了dfs序
        //我们对dfs序建立线段树
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }
        while(m--)
        {
            int op, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
            if(op == 0)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                update(1, dfn[u], b);
            }
            else //查询a到b的费用
            {
                ll ans = sum(a, b);
                //sum返回的是a到b的权值和
                printf(&quot;%lld\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre><h3 id="3-6-主席树"><a href="#3-6-主席树" class="headerlink" title="3.6 主席树"></a>3.6 主席树</h3><p>3.6.1 静态区间第 <strong>k</strong> 大</p>
<pre><code>/*
给定一个长度为n的序列，有m个询问，每次查询区间第K大的元素。
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int n, m, x, y, k, cnt;
int a[MAXN], lisan[MAXN];
int root[MAXN];
struct Node
{
    int L, R;
    //记录的是地址
    //要明白，
    //这个模板是憨憨，误导别人
    int sum;
};
Node node[20 * MAXN];
int binSearch(int x, int n)
{
    int L = 1;
    int R = n;
    while(L &lt;= R)
    {
        int mid = md(L, R);
        if(lisan[mid] == x)
            return mid;
        else if(lisan[mid] &gt; x)
            R = mid - 1;
        else
            L = mid + 1;
    }
}
void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];
    root = cnt;
    node[cnt].sum ++;

    if(L == R)
        return;

    int mid = md(L, R);
    if(pos &lt;= mid)
        update(pos, node[root].L, L, mid);
    else
        update(pos, node[root].R, mid + 1, R);
}
int query(int i, int j, int k, int L, int R)
{
    //
    if(L == R)
        return L;   //要继续深刻理解一下

    int d = node[node[j].L].sum - node[node[i].L].sum;

    int mid = md(L, R);
    if(k &lt;= d)
        return query(node[i].L, node[j].L, k, L, mid);
    else
        return query(node[i].R, node[j].R, k - d, mid + 1, R);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            lisan[i] = a[i];
        }
        sort(lisan + 1, lisan + 1 + n);
        int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
        //1.离散化
        root[0] = 0;
        node[0].L = node[0].R = node[0].sum = 0;
        cnt = 0;
        //2.初始化
        for(int i = 1; i &lt;= n; i++)
        {
            root[i] = root[i - 1];
            int pos = binSearch(a[i], q);
            update(pos, root[i], 1, q);
        }
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
            int pos = query(root[x - 1], root[y], k, 1, q);
            printf(&quot;%d\n&quot;, lisan[pos]);
        }
    }
    return 0;
}</code></pre><h3 id="3-9-替罪羊树"><a href="#3-9-替罪羊树" class="headerlink" title="3.9 替罪羊树"></a>3.9 替罪羊树</h3><pre><code>/*您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1.插入xx数
2.删除xx数(若有多个相同的数，因只删除一个)
3.查询xx数的排名(排名定义为比当前数小的数的个数+1+1。若有多个相同的数，因输出最小的排名)
4.查询排名为xx的数
5.求xx的前驱(前驱定义为小于xx，且最大的数)
6.求xx的后继(后继定义为大于xx，且最小的数)
*/
//AC的板子
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#define md(x, y)  (x + y) / 2
using namespace std;
const int MAXN = 1e5 + 10;
int cnt = 0, root;
vector &lt; int &gt; vec;
const double alpha = 0.75;
struct Node
{
    int l, r, val;
    int siz, fac;
    bool exist;
};
Node tzy[MAXN];
void newnode(int &amp;now, int val)
{
    now = ++cnt;
    tzy[now].l = tzy[now].r = 0;
    tzy[now].val = val;
    tzy[now].siz = tzy[now].fac = 1;
    tzy[now].exist = true;
}
bool imbalance(int now)
{
    if(max(tzy[tzy[now].l].siz, tzy[tzy[now].r].siz ) &gt; tzy[now].siz * alpha
       || tzy[now].siz - tzy[now].fac &gt; tzy[now].siz * 0.3 )
        return true;
        return false;
}
//将now为根的子树重建，首先用中序遍历
void ldr(int now)
{
    if(!now)
        return;
    ldr(tzy[now].l);
    if(tzy[now].exist)
        vec.push_back(now);
    ldr(tzy[now].r);
}
void lift(int l, int r, int &amp;now)
{
    if(l == r)
    {
        now = vec[l];
        tzy[now].l = tzy[now].r = 0;
        tzy[now].siz = tzy[now].fac = 1;
        return;
    }
    int mid = md(l, r);
    while(l &lt; mid &amp;&amp; tzy[vec[mid]].val == tzy[vec[mid - 1]].val)
        mid --;
    now = vec[mid];
    if(l &lt; mid)
        lift(l, mid - 1, tzy[now].l);
    else
        tzy[now].l = 0;
    lift(mid + 1, r, tzy[now].r);
    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;
    tzy[now].fac = tzy[tzy[now].l].fac + tzy[tzy[now].r].fac + 1;

}
int getrank(int val)
{
    int now = root;
    int rankk = 1;
    while(now)
    {
        if(val &lt;= tzy[now].val)
            now = tzy[now].l;
        else
        {
            rankk += tzy[now].exist + tzy[tzy[now].l].fac;
            now = tzy[now].r;
        }
    }
    return rankk;
}
int getnum(int rak)
{
    int now = root;
    while(now)
    {
        if(tzy[now].exist &amp;&amp; tzy[tzy[now].l].fac + tzy[now].exist == rak)
            break;
        else if(tzy[tzy[now].l].fac &gt;= rak)
            now = tzy[now].l;
        else
        {
            rak -= tzy[tzy[now].l].fac + tzy[now].exist;
            now = tzy[now].r;
        }

    }
    return tzy[now].val;
}
void update(int now, int ori)
{
    if(!now)
        return;
    if(tzy[ori].val &lt; tzy[now].val)
        update(tzy[now].l, ori);
    else
        update(tzy[now].r, ori);

    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;

}
void rebuilt(int &amp;now)
{
    vec.clear();
    ldr(now);
    if(vec.empty())
    {
        now = 0;
        return;
    }
    lift(0, vec.size() - 1, now);
}
void check(int &amp;now, int ori)
{
    if(now == ori)
        return;
        //该点不平衡,将其重构，更新
    if(imbalance(now))
    {
        rebuilt(now);
        update(root, now);
        return;
    }
    if(tzy[ori].val &lt; tzy[now].val)
        check(tzy[now].l, ori);
    else
        check(tzy[now].r, ori);
}
//在now这个位置插入val
void del(int now, int val)
{
    if(tzy[now].exist&amp;&amp;tzy[now].val == val)
    {
        tzy[now].exist = false;
        tzy[now].fac --;
        check(root, now);
        return;
    }
    tzy[now].fac --;
    if(val &lt; tzy[now].val)
        del(tzy[now].l, val);
    else
        del(tzy[now].r, val);
}
void add(int &amp;now, int val)
{
    if(now == 0)
    {
        newnode(now, val);//插入完成
        check(root, now); //从根节点开始往下找，看看是不是存在不平衡的点
        return;
    }
    tzy[now].siz++;
    tzy[now].fac++;
    if(val &lt; tzy[now].val)
        add(tzy[now].l, val);
    else
        add(tzy[now].r, val);
}

int main()
{
    cnt = 0;
    root = 0;
    int t, x, opt;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
        switch(opt)
        {
            case 1:
                add(root, x);
                break;
            case 2:
                del(root, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getrank(x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getnum(x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getnum(getrank(x) - 1));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getnum(getrank(x + 1)));
        }
    }
}</code></pre><h2 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6.动态规划"></a>6.动态规划</h2><h3 id="6-2-背包问题"><a href="#6-2-背包问题" class="headerlink" title="6.2 背包问题"></a>6.2 背包问题</h3><p><strong>01背包</strong></p>
<pre><code>//volume 为物品体积，weight为物品价值.
void ZeroOnePack(int volume, int weight)
{
    for(int j =  maxV; j&gt;= volume; j--)
        dp[j] = max(dp[j], dp[j - volume] + weight);
}</code></pre><p><strong>完全背包</strong></p>
<pre><code>void CompletePack(int volume, int weight)
{
    for(int j = volume; j &lt;= maxV; j++)
        dp[j] = max(dp[j], dp[j - volume] + weight);
}</code></pre><p><strong>多重背包：二进制优化成01背包.</strong></p>
<pre><code>void MultiplePack(int volume, int weight, int amount)
{
     if(volume * amount &gt;= maxV) CompletePack(volume, weight);
     else 
     {
          int k = 1;
          while(k &lt; amount)
          {
                ZeroOnePack(k * volume, k * weight);
                amount -= k;
                k &lt;&lt;= 1;
          }
          ZeroOnePack(amount * volume, amount * weigth);
     }

}</code></pre><p><strong>分组背包</strong>,每组最多选一个</p>
<pre><code>for(int k = 1; k &lt;= k; k++)
    for(int j = V; j &gt;= 0; j--)
         for( item i in group k)
              dp[j] = max{dp[j], dp[j - ci] + wi};</code></pre><p>HDU3535 Are You Busy</p>
<p>将01背包，每组至少选一个的背包问题，每组最多选一个的背包问题结合在一起。</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXT = 110;
int dp[MAXN][MAXT];
int main()
{
    int n, T, c, g;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;T) != EOF)
    {
        memset(dp, -1, sizeof dp);
        memset(dp[0], 0, sizeof dp[0]);
        for(int k = 1; k &lt;= n; k++)
        {
            int s, m;
            scanf(&quot;%d%d&quot;, &amp;m, &amp;s);
            if(s == 0)                      //至少选一个
            {
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);
                    for(int j = T; j &gt;= c; j--)
                    {
                        if(dp[k][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k][j - c] + g);
                        if(dp[k - 1][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - c] + g);
                    }
                }
            }
            else if(s == 1)             //最多选一个
            {     
                memcpy(dp[k], dp[k - 1], sizeof dp[k - 1]);
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);

                    for(int j = T; j &gt;= c; j--)
                        if(dp[k - 1][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - c] + g);
                }
            }
            else
            {
                memcpy(dp[k], dp[k - 1], sizeof dp[k - 1]);
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);
                    for(int j = T; j &gt;= c; j--)
                        if(dp[k - 1][j - c] != -1)                          //这是能够发生转移的前提.
                            dp[k][j] = max(dp[k][j], dp[k][j - c] + g);     //但实际的转移是发生在本组内部.
                }
            }

        }
        printf(&quot;%d\n&quot;, dp[n][T]);
    }
    return 0;
}</code></pre><p><strong>求第k个最优解.</strong> HDU 2639 Bone CollectorII</p>
<pre><code>/*
dp[i][j][k] 表示考虑前i个变量，使得和为j的第k优解
得到状态转移
dp[i][j] = merge(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
merge归并排序
妙呀,前i个变量的前k优解，就是由转移向他的两个状态的各自的前k优解再比试一下
得到的前k优解
}
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
const int MAXM = 1e3 + 10;
const int MAXK = 30 + 10;
int n, v, k;
int w[MAXN], c[MAXN];
int dp[MAXN][MAXM][MAXK];
int A[MAXK], B[MAXK];
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;k);    //第k优解，v是背包容量，n是物件种类
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;w[i]); //物品价值
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]); //物品体积
        memset(dp, 0, sizeof dp);   
        for(int i = 1; i &lt;= n; i++)
            for(int j = 0; j &lt;= v; j++)
                if(j &gt;= c[i])           //两种转移方法
                {
                    for(int o = 1; o &lt;= k; o++)
                    {
                        A[o] = dp[i - 1][j][o];
                        B[o] = dp[i - 1][j - c[i]][o] + w[i];
                    }
                    int x = 1, y = 1, z = 1;
                    A[k + 1] = B[k + 1] = -1;//??
                    while(z &lt;= k &amp;&amp; (x &lt;= k || y &lt;= k))
                    {
                        if(A[x] &gt; B[y])
                            dp[i][j][z] = A[x++];
                        else
                            dp[i][j][z] = B[y++];
                        if(dp[i][j][z] != dp[i][j][z - 1])
                            z++;
                    }
                }
                else memcpy(dp[i][j], dp[i - 1][j], sizeof dp[i - 1][j]);


        printf(&quot;%d\n&quot;, dp[n][v][k]);
    }
    return 0;
}</code></pre><h3 id="6-3树形DP"><a href="#6-3树形DP" class="headerlink" title="6.3树形DP"></a>6.3树形DP</h3><p>HDU1520 没有上司的舞会</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 6e3 + 10;
const int MAXM = MAXN;
int happy[MAXN], dp[MAXN][2];
int in[MAXN], ou[MAXN], cnt, head[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs(int rt)
{
    dp[rt][0] = 0;
    dp[rt][1] = happy[rt];
    if(ou[rt] == 0) return;

    for(int i = head[rt]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        dfs(v);
        dp[rt][0] += max(dp[v][1], dp[v][0]);
        dp[rt][1] += dp[v][0];
    }
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        cnt = 0;
        memset(head, -1, sizeof head);
        memset(ou, 0, sizeof ou);
        memset(in, 0, sizeof in);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;happy[i]);
        //k - &gt; l
        int l, k;
        while(scanf(&quot;%d%d&quot;, &amp;l, &amp;k) &amp;&amp; l + k)
        {
            addEdge(k, l);
            in[l]++;
            ou[k]++;
        }
        int i;
        for(i = 1; i &lt;= n; i++) if(in[i] == 0) break;
        dfs(i);             //i是根
        int ans = max(dp[i][0], dp[i][1]);      //0为不去，1为去
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><p>HDU2196 Computer</p>
<pre><code>求树上某个点到其他点的最远距离.
二次扫描换根法
第一次由下往上，得到各个小根对于其子树的情况. 由下往上
第二次由上往下，得到以各个小根为主根的情况.   由上往下.
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int n, cnt;
ll f[MAXN][3];
int t[MAXN][2], head[MAXN];
struct Edge
{
    int v, next;
    ll w;
}edge[MAXN * 2];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dp(int u, int fa)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        ll w = edge[i].w;
        if(v == fa) continue;
        dp(v, u);
        if(f[u][0] &lt; f[v][0] + w)
        {
            t[u][0] = v; 
            f[u][1] = f[u][0];
            f[u][0] = f[v][0] + w;
        }
        else if(f[u][1] &lt; f[v][0] + w)
        {
            f[u][1] = f[v][0] + w;
            t[u][1] = v;
        }
    }
}
void dfs(int u, int fa)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        int w = edge[i].w;
        if(v == fa) continue;
        if(t[u][0] != v)    
            f[v][2] = max(f[u][0], f[u][2]) + w;
        else
            f[v][2] = max(f[u][1], f[u][2]) + w;
        dfs(v, u);     
    }
}
int main()
{

    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        for(int v = 2; v &lt;= n; v++)
        {
            int u; ll w;
            scanf(&quot;%d%lld&quot;, &amp;u, &amp;w);
            addEdge(u, v, w);
            addEdge(v, u, w);
        }
        memset(f, 0, sizeof f);
        memset(t, 0, sizeof t);
        dp(1,0);                //首先从下往上，求出f[i][0]和f[i][1].
        //以第1个电脑为根.
        //设dp[i]表示第i个节点的到数的其他点的最远距离是dp[i]
        //那么设第i个节点的两个子节点为u,v
        f[1][2] = f[1][1];
        dfs(1, 0);              //其次从上往下dfs
        for(int i = 1; i &lt;= n; i++)
            printf(&quot;%lld\n&quot;, max(f[i][0], f[i][2]));
    }
    return 0;
}</code></pre><h2 id="7-博弈"><a href="#7-博弈" class="headerlink" title="7.博弈"></a>7.博弈</h2><p>三大经典博弈：</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/25/%5BC++primer%5D%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/25/%5BC++primer%5D%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/" itemprop="url">[C++primer]第十六章模板与泛型编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-25T14:19:19+08:00">
                2019-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><pre><code>template &lt;typename T&gt;
int conmpare(const T &amp;v1, const T &amp;v2)
{
   if(v1 &lt;  v2)  return -1;
   if(v1 == v2)  return  0;
   return 1;
}</code></pre><p><strong>模板参数列表：</strong></p>
<pre><code>&lt;typename T&gt;</code></pre><p><strong>模板参数</strong></p>
<pre><code>T</code></pre><p><strong>模板实参</strong></p>
<p>当我们在调用一个函数模板时候，编译器通常用函数实参来为我们推断模板实参。当我们调用compare的时候，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：</p>
<pre><code>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;</code></pre><p>实参类型为int，编译器为推断出模板实参为int，并将它绑定到T上。</p>
<p><strong>实例化</strong></p>
<p>编译器用推断出的模板参数来为我们实例化一个特定版本的函数。</p>
<p>这些编译器生成的版本通常被称为模板的实例</p>
<p><strong>模板类型参数</strong></p>
<p><strong>类型参数（T）前必须使用关键字class 或者 typename（在模板参数列表中，这两个关键字的含义相同）</strong></p>
<p><strong>非类型模板参数</strong></p>
<p>一个非类型参数表示一个值而非一个类型。</p>
<p>当一个模板被实例化时，非类型模板参数被一个用户提供的或编译器推断的值所代替。这些值必须是常数表达式。</p>
<pre><code>template &lt;unsigned N, unsigned M&gt;
int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])
{
     return strcmp(p1, p2);
}
//调用
compare(&quot;hi&quot;, &quot;world&quot;);</code></pre><p>调用时，编译器会使用字面常数的大小来代替N,M。从而实例化模板。</p>
<p><strong>在模板定义中，模板非类型参数是一个常数值。在需要常数表达式的地方，可以使用非类型参数，例如指定数组大小</strong></p>
<p>另：</p>
<pre><code>int conmpare(const T &amp;v1, const T &amp;v2)</code></pre><p>模板中的函数参数是const的引用，使得我们保证了函数可以用于不能拷贝的类型。</p>
<p><strong>模板编译</strong></p>
<p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本，编译器才生成代码。</p>
<p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明，也包括定义。</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><pre><code>template &lt;typename T&gt; class Blob
{
   public:
   private:
}</code></pre><p>显式模板参数</p>
<pre><code>vector &lt; int &gt; vec;</code></pre><p>我们已经多次见到，在使用一个类模板的时候，我们必须提供额外的信息( &lt; int &gt;)。这些额外的信息就是显式模板实参。</p>
<p><strong>一个类模板的每个实例都是一个独立的类。</strong></p>
<p>可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型的名字用作其模板参数。相反的，我们通常将模板自己的参数当做被使用模板的实参。</p>
<pre><code>template &lt;typename ElemType&gt; class LinkList
{
    protected:
        Node&lt;ElemType&gt; *head;        //链表的头指针
        int length;                 //链表的长度
    public:
...
}
//在LinkList这个模板类的定义中，使用了Node这个模板类</code></pre><p>类模板的成员函数本身是一个普通函数。但是，类模板的每一个实例都有其自己的版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。</p>
<p>与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪一个类。而且，从一个模板生成的类的名字中必须带有包含其模板参数。当我们定义一个成员函数时，模板实参与模板形参相同。</p>
<p>但有一个例外，就是在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<pre><code>#pragma once
template&lt;class ElemType&gt;
//在第index位置插入e,成功返回1，失败返回0
int LinkList&lt;ElemType&gt;::InsertElem(int index, const ElemType &amp;e)
{
   .....
}</code></pre><p>如果一个成员函数没有被使用，则他不会被实例化。也就是说即使某些函数不符合要求，如果没有被调用，我们仍然可以用该类型实例化的类。</p>
<p>跳过类模板和友元（P588）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5D%E5%BF%AB%E9%80%9F%E5%B9%82+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5D%E5%BF%AB%E9%80%9F%E5%B9%82+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/" itemprop="url">[算法]快速幂 + 矩阵快速幂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T20:12:24+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快速幂模板</p>
<pre><code>//求a^b % MOD
int quickMod(int a,int b)
{
    int ans = 1;
    while (b)
    {
        if (b&amp;1)
            ans = ans * a % MOD;
        a = a*a % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}</code></pre><p>矩阵快速幂模板</p>
<p>一键三连的操作</p>
<p>1、矩阵定义 2、矩阵乘法 3、矩阵快速幂</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;string.h&gt;  
#include&lt;algorithm&gt;  
using namespace std;  
//*******************************************************//
const int siz = ??;           //矩阵的大小.
const int MOD = ??;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    int mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5DAC%E8%87%AA%E5%8A%A8%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5DAC%E8%87%AA%E5%8A%A8%E6%9C%BA/" itemprop="url">[算法]AC自动机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-23T09:45:48+08:00">
                2019-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模板HDU2222</p>
<p>静态开点800ms+，动态300+</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-23-09.18.58
 By                : Tpaaaaaa
 Question_Number   ：ac
 Question_Name     ：自动机
 Description       :

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
// Trie树的结构体
struct Trie
{
    int nxt[MAXN][26], fail[MAXN], edn[MAXN];
    int root, tot;
    //将当前节点初始化
    int newNode()
    {
        tot ++;         //用来记录结点编号的
        for(int i = 0; i &lt; 26; i++)
            nxt[tot][i] = -1;
        edn[tot] = 0;
        return tot;     //返回编号
    }
    void init()
    {
        tot = 0;
        root = newNode();//root一般而言是1
    }
    //往trie树中插入buf
    void add(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            if(nxt[p][now] == -1)
                nxt[p][now] = newNode();

            p = nxt[p][now];
        }
        edn[p]++;
    }
    //AC自动机的构建，也就是fail数组的构建
    void build()
    {
        queue &lt; int &gt; Q;
        fail[root] = root;
        //对根的结点单独处理一哈
        for(int i = 0; i &lt; 26; i++)
        {
            if(nxt[root][i] == -1)
                nxt[root][i] = root;
            else
            {
                fail[nxt[root][i]] = root;
                Q.push(nxt[root][i]);
            }
        }
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for(int i = 0; i &lt; 26; i++)
            {
                if(nxt[now][i] == -1)
                    nxt[now][i] = nxt[fail[now]][i];
                else
                {
                    fail[nxt[now][i]] = nxt[fail[now]][i];
                    Q.push(nxt[now][i]);
                }
            }
        }
    }
    int query(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        int res = 0;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            p = nxt[p][now];
            int temp = p;
            while(temp != root)
            {
                res += edn[temp];
                edn[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};
char buf[2*MAXN];
Trie AC;
int main()
{
    int t;
    int n;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        AC.init();
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            AC.add(buf);
        }
        AC.build();
        scanf(&quot;%s&quot;, buf);
        printf(&quot;%d\n&quot;, AC.query(buf));
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/22/%5B%E7%AE%97%E6%B3%95%5D%E6%89%A9%E5%B1%95KMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/22/%5B%E7%AE%97%E6%B3%95%5D%E6%89%A9%E5%B1%95KMP/" itemprop="url">[算法]扩展KMP</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-22T10:02:29+08:00">
                2019-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考博客：<a href="https://segmentfault.com/a/1190000008663857" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008663857</a></p>
<p>讲的真好。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/11/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/tpaaaaaa.github.io/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/13/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">246</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">115</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
