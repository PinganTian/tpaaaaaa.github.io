<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;24&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/24/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/25/HDU-3873InvadetheMars/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/25/HDU-3873InvadetheMars/" itemprop="url">HDU - 3873 Invade the Mars</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T16:01:02+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>It’s now the year 21XX,when the earth will explode soon.The evil U.S. decided to invade the Mars to save their lives.<br>But the childlike Marsmen never keeps any army,because war never take place on the Mars.So it’s very convenient for the U.S. to act the action.<br>Luckily,the Marsmen find out the evil plan before the invadation,so they formed a defense system.The system provides enchantment for some citys,and the enchantment generator for city A maybe set in city B,and to make things worse,both city B and C and more will provide echantment for city A.<br>The satelite of U.S. has got the map of the Mars.And they knows that when they enter a city,they can destory all echantment generator in this city at once,and they can enter a city only if they has destoryed all enchantment generator for this city,but troops can stay at the outside of the city and can enter it at the moment its echantment is destoryed.Of course the U.S. army will face no resistance because the Mars keep no army,so troops can invade in many way at the same time.<br>Now the U.S. will invade the Mars,give you the map,your task is to calculate the minimium time to enter the capital of the Mars. </p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>Dijkstral 的 本质BFS，这题目是将Dijstral变形。明白什么样的点可以入队，出队后又需要进行哪些操作</p>
<p>保护点问题，带有限制的最短路。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-24-15.16.38
 Question_Number   ：HDU - 3873
 Question_Name     ：invade the mars
 Description       : n个点，m条边
                     进入一点的前提是，某些点要已经进入过了
                     求1到n的最短距离，
                     每个点都有一个值
                     这个值是对应其所有的发生器都被销毁的时间
                     emmm
                     pro[x] 表示保护x的所有城市被攻占的最早时间
                     dist[x] 表示到达x的最早时间
                     首先将起点入队，然后起点出队，所有起点保护的
                     城市的保护值 - 1,如果某个点的保护值减为0 了
                     说明这个城市没有保护了，并且我们已经到达城外了
                     那么这个城的最短时间就是max(pro[x], dis[x]);
                     然后将这个城入队
                     然后将所有起点相连的点的dist更新
                     如果更新的这个点的保护值也为0了
                     说明就直接入侵了，那么这个点就可以入队了

                     能够入队的点  是已经入侵了的点。然后去更新出队的点，包括其保护的点，以及其相连的点
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
//const int INF = 0x3f3f3f3f;
const long long  INF = 1ll&lt;&lt;55; //这
const int MAXN = 3000 + 10;
const int MAXM = 7e4 + 10;
int cnt = 0,n,m;
bool vis[MAXN];
int head[MAXN], in[MAXN];
ll dis[MAXN], pro[MAXN];
vector &lt; int &gt; prot[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
typedef pair &lt;ll , int&gt; P;
void Dijkstral(int s)
{
    for(int i = 1; i &lt;= n; i++)
        dis[i] = INF, pro[i] = 0;
    memset(vis, false, sizeof vis);
    priority_queue&lt; P, vector &lt; P &gt;, greater&lt; P &gt; &gt; Q;//一个优先队列
    dis[s] = 0;
    Q.push(P(dis[s],s ));   //first 权值，second 编号，因为默认比较前一个
    while(!Q.empty())
    {
        P now = Q.top();
        Q.pop();
        int u = now.second;
        if(vis[u])
            continue;
        vis[u] = true;
        for(int i = 0; i &lt; prot[u].size(); i++)     //这是他所保护的
        {
            int v = prot[u][i];
            in[v] --;
            pro[v] = max(pro[v], dis[u]);           //pro[v] 表示保护v的城市被全部消灭的最短时间
                                                    // dis[u] 就是u被消灭的时间（此时u已经是被消灭了）
            if(in[v] == 0 &amp;&amp; dis[v] != INF)         //但是dis[v] 指的是到达v的时间\or最大保护时长
            {
                dis[v] = max(dis[v], pro[v]);       //比较的是到达时间和保护城市被灭的时间的最大值
                Q.push(P(dis[v],v));
            }
        }
        for(int i = head[u]; i != -1; i = edge[i].next) //这是他所相连接的
        {
            Edge e = edge[i];
            int v = e.to;
            int w = e.cost;
            if(dis[v] &gt; dis[u] + w)                     //
            {
                dis[v] = max(pro[v],dis[u] + w);        //
                if(in[v] == 0)
                {
                    Q.push(P(dis[v], v));
                }
            }
        }
    }

}
int main()
{
    int T,ai,bi,ci,li;
    cin &gt;&gt; T;
    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
            prot[i].clear();
        memset(in, 0, sizeof in);
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;ai,&amp;bi,&amp;ci);
            addEdge(ai,bi,ci);
        //    addEdge(bi,ai,ci); 这是单向的，弟弟
        }
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;,&amp;temp);
            in[i] = temp;               //保护i的城市数目为temp;
            for(int j = 1; j &lt;= temp; j++)
            {
                scanf(&quot;%d&quot;,&amp;li);
                prot[li].push_back(i);//li这座城市保护的城市加一个i
            }
        }
        Dijkstral(1);
 //       printf(&quot;here?&quot;);
        //cout &lt;&lt; dis[n] &lt;&lt; endl;
        printf(&quot;%I64d\n&quot;,dis[n]);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Dijkstral的本质是BFS</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/25/HDU-2433Travel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/25/HDU-2433Travel/" itemprop="url">HDU - 2433 Travel</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T15:52:09+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><pre><code>One day, Tom traveled to a country named BGM. BGM is a small country, but there are N (N &lt;= 100) towns in it. Each town products one kind of food, the food will be transported to all the towns. In addition, the trucks will always take the shortest way. There are M (M &lt;= 3000) two-way roads connecting the towns, and the length of the road is 1.   
Let SUM be the total distance of the shortest paths between all pairs of the towns. Please write a program to calculate the new SUM after one of the M roads is destroyed. </code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>求最大路径树，删边的方法，剪枝的方法，重边的处理，Dij本质是BFS；</p>
<p>可用numEdge[u][v] 记录u到v的边有多少条，如果删掉了一条边，则numEdge[u][v] –, 如果 == 0 则说明没有边了。used[k][i][j] 表示的是以k为根个最短路径树中从有没有从i到j的这条边。因为如果删掉的边不在最短路径树上，最短路径树的边权和不会发生改变，然后删掉边后，numEdge任然大于0，说明可以走重边，那么最短路径树的边权和也不会发生改变，如果减完之后为0了，说明最短路径树会发生改变，因此重新计算一遍最短路径树。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-25-09.18.41
 Question_Number   ：HDU 2433
 Question_Name     ：travel
 Description       : n个点，m个无向边，长度为1，SUM为所有最短路之和
                     计算某条路删掉后的SUM；
                     计算每个点i为起点的最短路径树，求出树路径之和
                     总的SUM 就是这个路径数和相加;
                     删掉一条边，如果这条边是这个路径树上的一条边，那么从小算一遍，否则不变
                     而且可能有大量重边
                     用的Dij，但因为边长都为1，所以变成了BFS了
                     用bfs
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXM = 3000+10;
int cnt, n, m;
int numEdge[MAXN][MAXN], dis[MAXN], sumTree[MAXN], head[MAXN];
bool used[MAXN][MAXN][MAXN], vis[MAXN];

struct Edge
{
    int from, to, cost, next; //用cost来记录能不能过，1 废了，这个不好用
    //表示可以，0表示不行
    Edge(int from = 0, int to = 0, int cost = 0, int next = 0):from(from), to(to), cost(cost), next(next){}
};
Edge edge[2*MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++ ;
    edge[cnt].to = b;
    edge[cnt].from = a;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
int bfs(int s, int com)   //返回一个最小路径树的值
                 // 如果存在不连通，返回INF
{
    memset(dis, INF, sizeof dis);   //到各点的距离，
    memset(vis, false ,sizeof vis);
    queue &lt; int &gt; Q;    //用BFS的思想来处理;
    Q.push(s);          //起点入栈
    dis[s] = 0;
    vis[s] = true;
    while(!Q.empty())
    {
        int u = Q.front();  //出队
        Q.pop();
        for(int i = head[u]; i != -1; i = edge[i].next) //枚举与u相连的边
        {
            int v = edge[i].to;
 //           if(edge[i].cost == 0)                         //这条边已经被删掉了,或者这个点已经访问过了
   //             continue;
            if(numEdge[u][v] &lt;= 0 || vis[v])
                continue;
            if(com)
            {
                used[s][u][v] = true;
                used[s][v][u] = true;
            }

            if(vis[v] == false)
            {
       //          printf(&quot;s = %d u = %d, v = %d, dis[%d] = %d\n&quot;,s,u,v,v,dis[u] + 1);
                dis[v] = dis[u] + 1;
                vis[v] = true;
                Q.push(v);
            }
        }
    }
    int SUM = 0;
    for(int i = 1; i &lt;= n; i++)
    {
        int temp = dis[i];
        if(temp == INF)
            return INF;
        else
            SUM += temp;
    }
    return SUM;
}
int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        cnt = 0;    //边的数目，最后cnt = 2m;
        memset(numEdge, 0, sizeof numEdge);
        memset(head, -1, sizeof head);
        memset(used, false, sizeof used);
        for(int i = 1; i &lt;= m; i++)
        {
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            addEdge(u,v,1); // 编号1,2是一对边
            addEdge(v,u,1); //
            numEdge[u][v] ++;
            numEdge[v][u] ++;
        }
        bool flag = true;   //如果原图已经不连通了，就直接全输出INF，flag标记为false
        for(int i = 1; i &lt;= n; i++)
        {
            sumTree[i] = bfs(i,1);    //sumTree[i] 表示第i个路径树的值为bfs(i);
            if(sumTree[i] == INF)   //有一个树不连通
            {
                for(int j = 1; j &lt;= m; j++)
                    printf(&quot;INF\n&quot;);
                flag = false;
                break;
            }
        }
      //  int ans = 0;
       // for(int i = 1; i &lt;= n; i++)
       //     printf(&quot;sumTree[%d] = %d\n&quot;,i,sumTree[i]);
      //  printf(&quot;ans = %d\n&quot;, ans);
        if(flag)                    //原来是联通的。
            for(int i = 1; i &lt; 2*m; i += 2) //枚举删掉每一条边
            {
                bool fla = true;        //用来记录删除后是或否联通，如果删除后不连通，输出INF，否则输出SUM
                int u = edge[i].from;   //
                int v = edge[i].to;
                int SUM = 0;
                for(int j = 1; j &lt;= n &amp;&amp; fla; j++) //遍历每个路径树
                {
                    if(used[j][u][v] == false &amp;&amp; used[j][v][u] == false)//这个路径树没用过这条边，则直接加
                        SUM += sumTree[j];
                    else if(numEdge[u][v] &gt; 1 || numEdge[v][u] &gt; 1)      //路劲树用过这条边，但是有重边，所以还是直接加
                        SUM += sumTree[j];
                    else
                    {
                        //edge[i].cost = 0;       //删掉这条边
                        //edge[i + 1].cost = 0;
                        numEdge[u][v]--;
                        numEdge[v][u]--;
                        int temp = bfs(j,0);
                        numEdge[u][v]++;
                        numEdge[v][u]++;
                        edge[i].cost = 1;
                        edge[i+1].cost = 1;
                        if(temp == INF)         //
                        {
                            SUM = INF;
                            fla = false;
                            break;
                        }
                        else SUM += temp;

                    }

                }
                if(fla == false)
                    printf(&quot;INF\n&quot;);
                else
                    printf(&quot;%d\n&quot;,SUM);
            }


    }
    return 0;
}
/*
 4 5
 1 2
 2 3
 3 4
 1 4
 1 3
*/</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：重边多的情况，考虑numEdge的表示方法。删边就直接numEdge–; ==0就是没边了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/25/HDU-2833WuKong/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/25/HDU-2833WuKong/" itemprop="url">HDU - 2833 WuKong</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T15:19:11+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>Alice每天往返于A、B，Bob每天往返于C、D。他们很忙所以每次都会挑选最短的路线，尽管如此他们仍想增加见面的机会。他们认为两个人所选路线的公共点越多见面机会越多。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>求两条最短路的最多公共点。分析这些公共点的性质。</p>
<p>①这些点肯定是连续的。</p>
<p>证法： 设最短路1 为s1 到 s2，最短路2为e1 到 e2; 如果这两条最短路上有4个公共点，分别为A,B,C,D； 并且A,B连续， C,D连续。 因此说明这两条最短路都要经过点A和点D， 那么可知 起点到终点的最短路 = 起点到A的最短路 + A到D的最短路 + D到终点的最短路。 所以两条最短路的一部分都是A到D的最短路。那么要使得两条最短路的公共点更多，所以肯定二者的这一部分（A到D的最短路）肯定是一条相同路，所以A到D上的点都是公共点，即A,B,,,C,D这一串连续点都是公共点。</p>
<p>②这些点(i 到 j)在最短路(s1 到 s2)上的数学语言是 mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2]</p>
<p>因此我们可以枚举一对点[i,j] 如果这一段[i,j]既在最短路1上（根据性质②），又在最短路2上，那么取 从i到j的最短路的最多点数dp[i][j] 和ans 相比较，最后取ans即可</p>
<p>dp[i][j] 表示考虑前k个点，从i到j的最短路中经历最多的点数。在floyd里面改改就行</p>
<pre><code>for(int k = 1; k &lt;= n ; k++)
     for(int i = 1; i &lt;= n; i++)
         for(int j = 1; j &lt;= n; j++)
         {
             if(mp[i][j] &gt; mp[i][k] + mp[k][j])
             {
                 mp[i][j] = mp[i][k] + mp[k][j];
                 dp[i][j] = dp[i][k] + dp[k][j] - 1;
             }
             else if(mp[i][j] == mp[i][k] + mp[k][j])
                 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] - 1);

         }
  for(int i = 1; i &lt;= n; i++)    //枚举一段
     for(int j = i; j &lt;= n; j++)
         if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2])
         {
             //这意味着枚举的这一段[i,j] 都是二者最短路上的一段
             ans = max(ans, dp[i][j]);
         }</code></pre><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-25-10.54.33
 Question_Number   ：HDU - 2833
 Question_Name     ：WuKong
 Description       : 图中两对点的最短路径的公共点最多
                     每对点可能存在多个最短路。
                     我们知道，我们可以先求出最短路的dis数组
                     如果dis[v] = dis[u] + e.w
                     说[u,v] 这条边是最短路中的；
                     我们首先把第一对点中所有在最短路上的点标记出来
                     哇，好巧妙啊呀！！！！
                     dp[i][j] 表示这个图中，从i点到j点的最短路上最多有多少个点
                     mp[i][j] 表示图中i到j的最短路长度
                     for(int k = 1; k &lt;= n ; k++)
                        for(int i = 1; i &lt;= n; i++)
                            for(int j = 1; j &lt;= n; j++)
                            {
                                if(mp[i][j] &gt; mp[i][k] + mp[k][j])
                                {
                                    mp[i][j] = mp[i][k] + mp[k][j];
                                    dp[i][j] = dp[i][k] + dp[k][j] - 1;
                                }
                                else if(mp[i][j] == mp[i][k] + mp[k][j])
                                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] - 1);

                            }
                     for(int i = 1; i &lt;= n; i++)    //枚举一段
                        for(int j = i; j &lt;= n; j++)
                            if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2])
                            {
                                //这意味着枚举的这一段[i,j] 都是二者最短路上的一段
                                ans = max(ans, dp[i][j]);
                            }
                    //妙哉

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 300 + 10;
int mp[MAXN][MAXN], dp[MAXN][MAXN], n, m;
void floyd()
{
    for(int k = 1; k &lt;= n; k++)
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
            {
             //   if( i == j || i == k || j == k)
               //       continue;                   //这个剪枝反而复杂了。
               if(mp[i][j] &gt; mp[i][k] + mp[k][j])
               {
                   mp[i][j] = mp[i][k] + mp[k][j];
                   dp[i][j] = dp[i][k] + dp[k][j] - 1;
               }
               else if(mp[i][j] == mp[i][k] + mp[k][j])
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] -1 );
            }
}
int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; n+m)
    {
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
            {
                 mp[i][j] = ( i == j ? 0 : INF);
                 dp[i][j] = (i == j ? 1 : 2);
            }


        for(int i = 1; i &lt;= m; i++)
        {
            int a,b,c;
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            mp[a][b] = mp[b][a] = min(c ,mp[a][b]);//有可能有重边
        }
        floyd();
        int ans = 0;
        int s1,s2,e1,e2;
        scanf(&quot;%d%d%d%d&quot;,&amp;s1,&amp;s2,&amp;e1,&amp;e2);
        for(int i = 1; i &lt;= n; i++)
            for(int j = i; j &lt;= n; j++) //枚举一段[i,j];
                if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2] == mp[e1][e2])
                    ans = max(ans, dp[i][j]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：要深刻理解题意，简化题目</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/25/HDU-3768Shopping/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/25/HDU-3768Shopping/" itemprop="url">HDU - 3768 Shopping</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-25T14:49:38+08:00">
                2019-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" itemprop="url" rel="index">
                    <span itemprop="name">动态规划</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>You have just moved into a new apartment and have a long list of items you need to buy. Unfortunately, to buy this many items requires going to many different stores. You would like to minimize the amount of driving necessary to buy all the items you need. </p>
<p>Your city is organized as a set of intersections connected by roads. Your house and every store is located at some intersection. Your task is to find the shortest route that begins at your house, visits all the stores that you need to shop at, and returns to your house. </p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>有n个点，但只有S个点必须去的，所以我们只需计算出这S个点彼此的最短距离mp[i][j],将这S个点和起点0形成一个新的图。因为内存有限，floyd开不了，就可以对每个S点求一次最短路。</p>
<p>得到新的mp数组后（新的图），此时的问题就是已知一个图，求从起点出发，遍历完所有的点，之后回到起点的最短路径。我们可以用 <strong>刷表法 + 状态压缩</strong> 解决</p>
<p>dp[i][s1] 表示目前在点i处，已经遍历完的点为s1(状态压缩)。那么这个点可以转移到与他相连的其他点（点j）</p>
<p>则状态转移方程为：dp[j][s1 | (1 &lt;&lt; j - 1 ）] = min(dp[j][s1 | (1 &lt;&lt; j - 1)], dp[i][s1] + mp[i][j] ); 然后用刷表法 从dp[0][0]刷</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>当时精神状态不好，写的稀乱</p>
<pre><code>/*
 Date              : 2019-08-25-13.17.19
 Question_Number   ：HDU - 3768
 Question_Name     ：Shopping
 Description       : n个点，m个无向边，起点 为0
                   ：有s个点必须去，去完之后回起点0
                   跟那个啥很像（博客）
                   floyd + 刷表法？首先求出每对点之间的最短距离
                   dp[i][s1]表示目前在i位置，s1表示已经访问过的购买点  的最短距离
                   dp[0][0] = 0;
                   对于每个i，根据他相连的边，可以知道他下一步可以去v位置
                   如果v位置是购买点，dp[v][s1 | shop[v]] min(,dp[i][s1] + mp[i][v])
                   如果v位置不是购买点, dp[v][s1] = min(,dp[v][s1] + mp[i][v]);
                    爆空间了,.
                   这代码写的贼丑

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100000 + 10;
int n, m, cnt;
int mp[11][11], dp[20][(1 &lt;&lt; 10) + 5], loc[MAXN], head[MAXN];
int shop[11];
int dis[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXN* 2];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
void floyd()
{
    for(int k = 0; k &lt; n; k++)
        for(int i = 0; i &lt; n; i++)
            for(int j = 0; j &lt; n; j++)
                mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
}
void spfa(int s)
{
    queue &lt; int &gt; Q;
    memset(dis, INF, sizeof dis);
    memset(vis, false ,sizeof vis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            int w = edge[i].cost;
            if(dis[v] &gt; dis[u] + w)
            {
                dis[v] = dis[u] + w;
                if(vis[v] == false)
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int T;
    cin &gt;&gt;T;

    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        // 编号 0 .. n-1
        memset(mp, INF, sizeof mp);
        cnt = 0;
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            int A,B,C;
            scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C);
          //  mp[A][B] = mp[B][A] = min(C, mp[A][B]);
            addEdge(A,B,C);
            addEdge(B,A,C);
        }

        int S;
        scanf(&quot;%d&quot;,&amp;S);
        memset(loc, -1, sizeof loc);//loc = -1表示该点没有商店
        for(int i = 1; i &lt;= S; i++)
        {
            int temp;
            scanf(&quot;%d&quot;,&amp;temp);
            shop[i] = temp; //第i个shop在temp这个位置
            loc[temp] = i;  //temp这个位置有第i个shop
        }
     //   printf(&quot; i am here\n&quot;);
        spfa(0);
        for(int i = 1; i &lt;= S; i++)
            mp[0][i] = mp[i][0] = dis[shop[i]];

        for(int i = 1; i &lt; S ; i++)
        {
            spfa(shop[i]);
            for(int j = i + 1; j &lt;= S;j ++)
                mp[i][j] = mp[j][i] = dis[shop[j]];
        }
//        printf(&quot;mp[1][3]  = %d\n&quot;,mp[1][3]);
        memset(dp, INF, sizeof dp);
        dp[0][0] = 0;
        int ans = INF;
        for(int s1 = 0; s1 &lt; (1 &lt;&lt; S); s1++)    //当前状态
            for(int i = 0; i &lt;= S; i++)          //当前位于的商店编号
            {
                int now = dp[i][s1];
                if(now == INF)
                    continue;                   //说明没有被刷到过
          //      printf(&quot; i = %d, s1 = %d\n&quot;, i , s1);
                if(s1 == (1 &lt;&lt; S) - 1 )
                {
                    ans = min(ans, now + mp[i][0]);
            //        printf(&quot; ?? &quot;);
                }

                for(int j = 0; j &lt;= S; j++)      //枚举下一个点
                {
                    if(mp[i][j] == INF || i == j)   //没有边 or 相同了
                        continue;
            //        printf(&quot; j = %d\n&quot;,j);
                    int &amp;nxt = dp[j][s1 | (1 &lt;&lt; j - 1)];
                    nxt = min(nxt, now + mp[i][j]);

                }
            }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>①：学会根据题目来获得一个简化的图</strong>。</p>
<p><strong>②：刷表法</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/24/POJ-2449Remmarguts'Date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/24/POJ-2449Remmarguts'Date/" itemprop="url">POJ - 2449 Remmarguts' Date</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-24T11:03:07+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个n个点，m条边的有向图 求s到t的第k短路</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>k短路问题。spfa + A* + Dijktral 。模板题，见下面代码中的描述</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-09.44.19
 Question_Number   ：POJ - 2449
 Question_Name     ：Remmarguts&apos; Date
 Description       : n 个点，m条有向边，求s到t的第k短路
                    k短路问题： 单源点最短路跑 反向边 + A*
                    算法步骤：
                    1、以原终点t为源点，求解t到所有点的最短距离
                    2、新建一个优先队列，将源点s放入队列中
                    3、从优先队列中弹出f(p) 距离最小的点p，如果点p
                        就是t，则计算t出队的次数，如果当前为t的第k次出队
                        ，则当前路径的长度就是s到t的第k短路的长度，算法结束
                        否则遍历与p相连的所有的边，将扩展出来的p的邻接点信息
                        加入到优先队列中
                    定义估价函数 f[i] = d[i] + dis[i]
                    其中 d[i] 表示起点到i点的路径长度, dis[i] 表示i到终点的路径长度
                    则f[i] 表示一条起点到终点经过i这个点的路径的长度
                    具体实现步骤（更新博客）：
                    1、存两个图，一个正图，一个反图，用反图跑一边（SPFA or Dij）记录每一个点到最后一个点的最短距离dis[]
                    2、

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1000 + 10;
const int MAXM = 1e5 + 10;
int cnt1 = 0, cnt2 = 0,n,m,s,t,k;
int head1[MAXN], head2[MAXN], dis[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to),cost(cost),next(next){}
};  // 用链式前向星存图
Edge edge1[MAXM];
Edge edge2[MAXM];
struct Node
{
    int to, g, f;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.f == b.f)
            return a.g &gt; b.g;
        return a.f &gt; b.f;
    }
};
void addEdge1(int a, int b, int c)
{
    cnt1 ++;
    edge1[cnt1].cost = c;
    edge1[cnt1].to = b;
    edge1[cnt1].next = head1[a];
    head1[a] = cnt1;
}
void addEdge2(int a, int b, int c)
{
    cnt2 ++;
    edge2[cnt2].cost = c;
    edge2[cnt2].to = b;
    edge2[cnt2].next = head2[a];
    head2[a] = cnt2;
}
void spfa(int s)            //对图二进行操作哦
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(dis, INF, sizeof dis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while( !Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head2[u]; i != -1; i = edge2[i].next)
        {
            int v = edge2[i].to;
            if(dis[v] &gt; dis[u] + edge2[i].cost)
            {
                dis[v] = dis[u] + edge2[i].cost;
                if(!vis[v])
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int Astar()
{
    Node now, e;
    int cnt = 0;    //记录终点出队多少次了
    priority_queue&lt; Node &gt; Q;
    if(s == t)
        k ++;       // WA的原因
    if(dis[s] == INF)
        return -1;          //说明终点和起点不连通，不存在k短路
    e.to = s;               //将起点压入队列中
    e.g = 0;                // g函数表示的是起点到该点的距离
    e.f = e.g + dis[e.to];  //估价函数f
    Q.push(e);
    while( !Q.empty())
    {
        e = Q.top();
        Q.pop();
        if(e.to == t)       //为终点了
            cnt ++;
        if(cnt == k)
                return e.g; //已经的第k条边了，则返回g
        int u = e.to;
        for(int i = head1[u]; i != -1; i = edge1[i].next)
        {
            now.to = edge1[i].to;
            now.g  = e.g + edge1[i].cost;
            now.f  = now.g + dis[now.to];
            Q.push(now);
            //if(now.g &gt; T) return -1;
        }
    }
    return -1;
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(head1, -1, sizeof head1);
    memset(head2, -1, sizeof head2);
    cnt1 = cnt2 = 0;
    int a,b,c;
    for(int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        addEdge1(a,b,c);    //在第一个图中存边
        addEdge2(b,a,c);    //在第二个图中存入反向边
    }
    cin &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    spfa(t);                //以原终点t为起点
    int ans = Astar();      //返回的是k短路的长度
    cout &lt;&lt; ans;
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/24/HDU-1839DelayConstrainedMaximumCapacityPath/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/24/HDU-1839DelayConstrainedMaximumCapacityPath/" itemprop="url">HDU - 1839 Delay Constrained Maximum Capacity Path</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-24T10:58:17+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>考虑一个包含 N 个顶点的无向图，编号从 1 到 N，并包含 M 条边。编号为 1 的顶点对应了一个矿藏，可从中提取珍稀的矿石。编号为 N 的顶点对应了一个矿石加工厂。每条边有相应的通行时间 (以时间单位计)，以及相应的运载量 (以矿石单位计)。现决定使用一条路径，将从矿藏中提取的矿石运送到加工厂。这条路径应当具有尽可能高的运载量，以便并行运输尽可能多的矿石。路径的运载量等于它的各边的最小运载量。然而，这些矿石很敏感，一旦从矿藏中提取出来，就会在 T 个时间单位之后开始分解，除非在这个时间截止之前到达工厂。因此，所选路径的总通行时间 (各条边的通行时间之和) 应当小于或等于 T。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这是带有限制条件的最短路，常用二分，见下面代码里面的Description.</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-16.44.26
 Question_Number   ：HDU - 1839
 Question_Name     ：Delay Constrained Maximum Capacity Path
 Description       : n个点，m个边，边有两个长度和流量两个属性
                     求1到n 的路径中最小流量最大的路径
                     并且这条路径的长度 要小于or等于T；
                     有限制条件的最短路 + 二分下限
                     最多能运的货物取决于路径上边的最小容量，所以二分容量，再用最短路判断时限即可。
                     最短路里面多加一个判断保证走的边都能满足当前容量
                     二分一个流量，将图中比这个流量小的边去掉，求一次最短路
                     看看到终点的长度是否超过T，如果超过了
                     那么二分向下走，
                     如果没有超过T，就向上走。
                     用Dij吧因为没有负权值边
                     //原来时间翻倍的原因是cin 呀 o(╥﹏╥)o
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2*(5e4 + 10);
int cnt = 0, minFlow, n, m, t;
int head[MAXN], d[MAXN];
bool inq[MAXN];
int flo[MAXM];      //将边长录入并且排序哦
typedef pair &lt;int ,int &gt; P;
struct Edge
{
    int to, cost, flow, next;
    Edge(int to = 0, int cost = 0, int flow = 0, int next = 0)
    :to(to), cost(cost), flow(flow), next(next){}
};
Edge edge[MAXM];
void addEdge(int A, int B, int C, int D)
{
    cnt ++;
    edge[cnt].to = B;
    edge[cnt].flow = C;
    edge[cnt].cost = D;
    edge[cnt].next = head[A];
    head[A] = cnt;
}
void Dijkstra(int s)        // 这是链式前向星的写法
{
    priority_queue &lt;P, vector &lt;P&gt;, greater &lt;P&gt; &gt; que; // 见注释①
    memset(d, INF, sizeof d);
    memset(inq, false ,sizeof inq);
    d[s] = 0;                                         // 将起点的d赋值为0
    que.push(P(0,s));                                 //first 为值， second为编号
    while( !que.empty())
    {
        P now = que.top();
        que.pop();
        int u = now.second;                             //u记录的是弹出点的编号
        if(inq[u])
            continue;
        inq[u] = true;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            if(edge[i].flow &lt; minFlow)
                continue;
            Edge e = edge[i];                        //e存的是与u连接的边
            if(d[e.to] &gt; d[u] + e.cost)                //进行松弛操作
            {
                d[e.to] = d[u] + e.cost;
                que.push(P(d[e.to], e.to));
             }
         }
    }

}
int main()
{
    int x, A, B, C, D;
    cin &gt;&gt; x;
    while(x--)
    {
        cnt = 0;
        memset(head, -1, sizeof head);
        //cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; //n个点，m个边
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);
        for(int i = 1; i &lt;= m; i++)
        {
    //        cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;
            scanf(&quot;%d%d%d%d&quot;,&amp;A,&amp;B,&amp;C,&amp;D);
            flo[i] = C;     //编号1 .. m
            addEdge(A,B,C,D);
            addEdge(B,A,C,D);
        }
        sort(flo + 1, flo + 1 + m);
        //按从小到大排序，编号1..m;
  //      printf(&quot;flo[1] = %d, flow[m] = %d\n&quot;,flo[1],flo[m]);
        int l = 1;
        int r = m;
        int mid = 0;
 //       int mid = (l + r) / 2;      //中间
        // [l,r]  l = 1  r = 5
        // mid = 3;  [1,2] [4,5];
        // l = 1, r = 2;
        // mid = 1, mid = 4;
        // [2,2]
        int ans = 0;
        while(l &lt;= r)
        {
            mid = (l + r) / 2;          //这个存的是位于mid位置的值
            minFlow = flo[mid];         // now 存的是流量，所以流量小于now的边全部去掉,去计算1到n的最短路，如果小于T，则记录ans = max(now)
        //    printf(&quot;l = %d,r = %d, mid = %d,midFlow = %d\n&quot;,l,r,mid,minFlow);
            Dijkstra(1);   // 并且二分向上走，如果大于T，则二分向下走
          //  printf(&quot;d[n] = %d\n&quot;,d[n]);

            if(d[n] &lt;= t)       //你也算个人才，弟弟
            {
               // printf(&quot;i am here\n&quot;);
                ans = max(ans, minFlow);
                l = mid + 1;
            }
            else
                r = mid - 1;
        }
        printf(&quot;%d\n&quot;,ans);

    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：cin 在大量输入的情况下不推荐使用！！！</p>
<p>②：二分好神奇。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/24/HDU-1595findthelongestoftheshortest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/24/HDU-1595findthelongestoftheshortest/" itemprop="url">HDU - 1595 find the longest of the shortest</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-24T10:53:31+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有一城市，这个城市有n个地点和m条连接他们的路，点的编号是从1到n，小X住在1，他想去n。但是最近正在维修公路，也就是说这m条路有且只有一条是坏的，但是小X不知道是哪一条，一条很关键的路坏了路程就会增加很多，所以小X想知道从1到n <em>最</em>坏<em>情</em>况* 下的路程。你能帮助他吗?</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>在原图中用spfa求一遍最短路。那么要坏路，肯定是要坏这条最短路上的路（因为坏其他的路，此时的最短路还是原最短路）。所以我们可以枚举每一条最短路上的边，然后将其赋值INF（意思路坏了），然后再求一遍spfa就可以了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-14.43.16
 Question_Number   ：HDU - 1595
 Question_Name     ：Find the longest of the shortest
 Description       : 这条路肯定是在原来的最短路径上面，
                     因为如果不在，那最短路就是原来的最短路
                     所以只需要枚举最短路上的每一段路即可
                     // 补充一下链式前向星的一个作用
                     // 是可以处理重边的情况
                     所以步骤就是求一遍最短路
                     枚举路径上面每一段路，删掉
                     就是将枚举的路的cost = INF;

                     然后再求一遍最短路
                     将cost 改回去，循环往复
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1010;
const int MAXM = MAXN * MAXN / 2;
int n, m, cnt;
int head[MAXN], pre[MAXN], d[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost ,next;
    Edge(int to = 0, int cost = 0,int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to   = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a]        = cnt;
}
void Change(int u, int v, int cost)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        Edge &amp;e = edge[i];  //这里憨憨了
        if(e.to == v)
        {
            e.cost = cost;
            break;
        }
    }
}
int getCost(int u, int v)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        Edge e = edge[i];
        if(e.to == v)
        {
            return e.cost;
        }
    }
    return -1;

}
void spfa(int s)
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(d, INF, sizeof d);
    d[s] = 0;
    vis[s] = true;
    memset(pre, -1, sizeof pre);
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(d[v] &gt; d[u] + edge[i].cost)
            {
                pre[v] = u;
                d[v] = d[u] + edge[i].cost;
                if(vis[v] == false)
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        // n个点，m个边，起点1，终点n
        cnt = 0;
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            addEdge(a,b,c);
            addEdge(b,a,c);
        }
        spfa(1);        //起点1，存路径
        int ans = -1;    //
        int v = n;   //这是终点
        while(pre[v] != -1)  //往前找
        {
            int u = pre[v]; //得到一条边 u --- v
            int temp = getCost(u,v);
            Change(u,v,INF);    //将这条边的cost 改成INF;
            Change(v,u,INF);
            spfa(1);
            ans = max(d[n],ans);
            Change(u,v,temp);
            Change(v,u,temp);
            v = u;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>继续努力</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/24/HDU-1599findthemincostroute/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/24/HDU-1599findthemincostroute/" itemprop="url">HDU - 1599 find the mincost route</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-24T10:47:39+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>杭州有N个景区，景区之间有一些双向的路来连接，现在8600想找一条旅游路线，这个路线从A点出发并且最后回到A点，假设经过的路线为V1,V2,….VK,V1,那么必须满足K&gt;2,就是说至除了出发点以外至少要经过2个其他不同的景区，而且不能重复经过同一个景区。现在8600需要你帮他找一条这样的路线，并且花费越少越好。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>解最小环问题。可以用floyd求最小环模板。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-15.23.09
 Question_Number   ：HDU - 1599
 Question_Name     ：find the mincost route
 Description       : 旅行商是整个图所有点都走一圈
                     前提是一个图就是一个连通分量
                     然而这个问题是
                     这图中有许多联通分量，求某个连通分量中的
                     最小环。
                     可以用floyd 求最小环（更新博客！）
                     floyd 也是一种DP的思想
                     so ...
                     floyd里面有的数组 dp[k][i][j] 意思是
                     从i 到 j，且通过的点属于[1..k]的最短路径长度;
                     dp[0][i][j] 为原图的邻接矩阵
                     对于第k个点，有两种情况：
                     第一种情况是：不经过k点，则
                     dp[k][i][j] 可以从 dp[k-1][i][j] 转移过来
                     第二种情况是：经过k点，则
                     dp[k][i][j] = dp[k-1][i][k] + dp[k-1][k][j];
                     然后用滚动数组优化成我们熟知的模样。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0xfffffff;  //呵呵。我爱你
const int MAXN = 100 + 10;
int mp[MAXN][MAXN];
int dp[MAXN][MAXN];
int main()
{
    int n,m,a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                mp[i][j] = (i == j ? 0 : INF); 

        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            if( c &lt; mp[a][b])   // 重边的情况
                mp[a][b] = mp[b][a] = c;
        }
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                dp[i][j] = mp[i][j];    // 已知dp[0][i][j] 实际上为原图的邻接矩阵
        int ans = INF;
        for(int k = 1; k &lt;= n; k++)
        {
            for(int i = 1; i &lt; k; i++)
                for(int j = i+1; j &lt; k; j++)
                            ans = min(ans,dp[i][j] + mp[i][k] + mp[k][j]);  
// 此时等号左边的ans 表示的是考虑前k个点 时候的最小环长度
// 所以等号右边的ans 表示的是前k - 1个点时候的最小环的权值
// 对于第k个点，我们有两种情况，一种是这个点在环上，一种是该点不在
// 所以我们可以枚举每一对点，然后让其和第k个点连成一个环，判断这个环是否小于目前ans
// 我们枚举两个点i,j 并且二点都要属于[1,k-1]，所以此时的dp[i][j] 就是前k-1个点的情况下的从i到j的最小路长度
// 将这个最短路 再加上到k这个点的两条边，就是要进行判断的环了
            for(int i = 1; i &lt;= n; i++)
                for(int j = 1; j &lt;= n; j++)
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
        }

        if(ans != INF)
            printf(&quot;%d\n&quot;,ans);
        else
            printf(&quot;It&apos;s impossible.\n&quot;);
    }

    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：const int INF = 0x3f3f3f3f；会WA的原因是因为有可能INF加了多次，然后溢出了。所以应该 const int INF = 0xfffffff; or 在处理dp时候判断一下是否小于INF；（这是个好习惯）</p>
<p>②：可能有重边的情况。</p>
<p>③：理解好floyd是一种DP哦！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/24/HDU-3339InAction%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF+%E8%83%8C%E5%8C%85%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/24/HDU-3339InAction%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF+%E8%83%8C%E5%8C%85%EF%BC%89/" itemprop="url">HDU - 3339 In Action（最短路+背包）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-24T10:27:24+08:00">
                2019-08-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p> 自1945年以来，当美国的曼哈顿项目小组引爆了第一颗核弹时，全球的核武器数量急剧增加。<br> 如今，FZU的一个名叫AekdyCoin的疯狂男孩拥有核武器，想要毁灭我们的世界。幸运的是，我们神秘的间谍网络已经得到了他的计划。现在，我们需要阻止它。<br> 但这项艰巨的任务显然并不容易。首先，我们知道，核武器的操作系统由一些连接的电站组成，它们构成了一个庞大而复杂的电网。每个电站都有它的功率值。要启动核武器，它必须消耗电网一半的电力。所以首先，我们需要将一半以上的能量分散。我们的坦克已经为我们在基地的行动做好了准备(ID是0)，我们必须在路上驾驶它们。至于发电站，只有当我们的坦克停在那里时，我们才能控制它们。1单位距离花费1单位油。我们有足够的坦克使用。<br> 现在我们的指挥官想知道这次行动的最小石油成本。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>Description : n + 1个点，起点为0,<br>因为我们有足够多的坦克.并且每个坦克到一个点后就停在哪里了<br>所以我们要求的是起点 到各个点的最短路长度之和<br>意思是占领某些点后，使得这些点的功率总和大于原总功率的一半<br>因此我们先求出起点到每个点的最短路径dis<br>因此对于每个点，我们有两个属性<br>一个是dis， 一个是pow<br>我们要使得pow和这个值大于一半的情况下使得dis最小<br>dp[i][j]// 表示考虑前i个点，pow和为j的情况下的最短距离之和<br>最后我们求出的是 min(dp[n][j]) j &gt; 总pow/2;<br>对于每个点我们有两种情况，选or不选<br>dp[i][j] = min(dp[i-1][j],dp[i-1][j-pow[i]] + dis[i]);<br>就变成了一个背包问题（更新博客）<br>优化成一维<br>memset(INF);<br>for(int i = 1; i &lt;= n; i++) //那么问题来，考虑前i个，最大的pow和就是前i个的pow之和 // 最少的pow和就是0 for(int j = powSum[i]; j &gt;= 0;j–)<br>{<br>if(j - pow[i] &gt;= 0)<br>dp[j] = min(dp[j], dp[j - pow[i]]+dis[i]);<br>}</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-10.28.17
 Question_Number   ：HDU - 3339
 Question_Name     ：In Action
 Description       : n + 1个点，起点为0,
                     因为我们有足够多的坦克.并且每个坦克到一个点后就停在哪里了
                     所以我们要求的是起点 到各个点的最短路长度之和
                     意思是占领某些点后，使得这些点的功率总和大于原总功率的一般
                     因此我们先求出起点到每个点的最短路径dis
                     因此对于每个点，我们有两个属性
                     一个是dis， 一个是pow
                     我们要使得pow和这个值大于一半的情况下使得dis最小
                     dp[i][j]// 表示考虑前i个点，pow和为j的情况下的最短距离之和
                     最后我们求出的是 min(dp[n][j]) j &gt; 总pow/2;
                     对于每个点我们有两种情况，选or不选
                     dp[i][j] = min(dp[i-1][j],dp[i-1][j-pow[i]] + dis[i]);
                     就变成了一个背包问题（更新博客）
                     优化成一维
                     memset(INF);
                     for(int i = 1; i &lt;= n; i++)    //那么问题来，考虑前i个，最大的pow和就是前i个的pow之和
                                                    //                       最少的pow和就是0
                        for(int j = powSum[i]; j &gt;= 0;j--)
                        {
                            if(j - pow[i] &gt;= 0)
                                dp[j] = min(dp[j], dp[j - pow[i]]+dis[i]);
                        }


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100 + 10;  //点数
const int MAXM = 10000 + 10;//  一定要注意边数   和无向边的时候要开两倍
const int MAXT = 4*MAXM * 100;
int cnt,n,m;
int head[MAXN], dis[MAXN], powSum[MAXN], powNum[MAXN], dp[MAXT];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to),cost(cost),next(next){}
};  // 用链式前向星存图
Edge edge[MAXM * 2];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].cost = c;
    edge[cnt].to = b;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
void spfa(int s)            //对图二进行操作哦
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(dis, INF, sizeof dis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while( !Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(dis[v] &gt; dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                if(!vis[v])
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int t,a,b,c;
    cin &gt;&gt; t;
    while( t --)
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    //总点数为n+1  编号 0 ... n 起点n
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            addEdge(a,b,c);
            addEdge(b,a,c);
        }
        spfa(0);            //求出dis数组
        powSum[0] = 0;      // powSum[ i ] 存的是前i个点的pow和，总的pow和就是pow[n];
        for(int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; powNum[i];  //记录每个点的pow
            powSum[i] = powSum[i-1] + powNum[i];
        }
        memset(dp, INF, sizeof dp);
        // dp[0][j] 表示的是考虑0个，最短路径和
        // dp[0][0] 考虑前0个，pow和为0;
        dp[0] = 0;
        for(int i = 1; i &lt;= n; i++)     //考虑前i个到...前n个
            for(int j = powSum[i]; j - powNum[i] &gt;= 0; j--) //我改了这里哦
            {
                    dp[j] = min(dp[j], dp[j - powNum[i]]+dis[i]);
            }
        int ans = INF;

        int start = powSum[n] / 2 + 1;
        for(int i = start ; i &lt;= powSum[n]; i++)
            if(dp[i] &lt; ans)
                ans = dp[i];

        if(ans &lt; INF)
            cout &lt;&lt; ans;
        else
            cout &lt;&lt; &quot;impossible&quot;;
        cout &lt;&lt; endl;

    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：题目告诉你边的MAXM,但因为是无向边，所以你实际存图的数量应该开到 2*MAXM，不然会报WA or RE！！</p>
<p>②：要对一些经典的DP模型了如指掌。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/23/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/23/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98/" itemprop="url">[算法]最小环问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-23T16:21:42+08:00">
                2019-08-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
                  , 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/%E6%A8%A1%E6%9D%BF/" itemprop="url" rel="index">
                    <span itemprop="name">模板</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>解法：floyd实际上也是一种DP。改一改dp方程就ok了<em>；</em>Dijkstral也可以解</em></p>
<h3 id="最小环："><a href="#最小环：" class="headerlink" title="最小环："></a>最小环：</h3><p><strong>最小环</strong>：从一个点出发,经过一条简单路径回到起点成为环.图的最小环就是所有环 中长度最小的. 例题见HDU - 1599 find the mincost route</p>
<h3 id="如何求最小环"><a href="#如何求最小环" class="headerlink" title="如何求最小环"></a>如何求最小环</h3><h4 id="解法一：用Dijkstral算法"><a href="#解法一：用Dijkstral算法" class="headerlink" title="解法一：用Dijkstral算法"></a>解法一：用Dijkstral算法</h4><pre><code>任意一个最小环环的权值，我们都可以看成**两个有边相连的结点i、j的直接距离（边长）加上i、j间不包含边(边i-&gt;j)的最短路径（用Dij求出）**。求最短路径我们第一个想到的就**Dijkstra算法**。</code></pre><p>解法就是：枚举所有边，<strong>每次删去一条边(u, v)</strong>，然后从u开始跑Dijkstra（用堆或者c++中优先队列优化的）<strong>求u到v的距离再加上(u, v)的权值</strong>，枚举完所有边就得出答案了，复杂度为O(m * n * logn)。。</p>
<h4 id="解法二：Floyd算法"><a href="#解法二：Floyd算法" class="headerlink" title="解法二：Floyd算法"></a>解法二：Floyd算法</h4><pre><code>for(int i = 1; i &lt;= n; i++)
    for(int j = 1; j &lt;= n; j++)
        dp[i][j] = mp[i][j];    // 已知dp[0][i][j] 实际上为原图的邻接矩阵，并且注意dp[i][i] = INF 不是0哦
int ans = INF;
for(int k = 1; k &lt;= n; k++)
{
    for(int i = 1; i &lt; k; i++)
        for(int j = 1; j &lt; i; j++)                              // i &lt; k   j &lt; i 这情况下的dp[i][j] 才纯正
            ans = min(ans,dp[i][j] + mp[i][k] + mp[k][j]);    //这时候的dp[i][j] 实际上是 dp[k-1][i][j]，上一个状态的
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][i]);
}</code></pre><h4 id="解法三：最小生成树（留坑）"><a href="#解法三：最小生成树（留坑）" class="headerlink" title="解法三：最小生成树（留坑）"></a>解法三：最小生成树（留坑）</h4><p>我们先求所给图的最小生成树，可以保证<strong>最小环就是由最小生成树上的边再加上一条非生成树上的边构成的</strong>，依次枚举所有边，每次加上一条边后，求出由其构成的环的权值，最后求最小值就解决了图的最小环问题。</p>
<p>再说说具体怎么求每次的环的权值，我们把图变成了一颗树，假设我们枚举了一条边(u, v)， 我们只需要<strong>在生成树上求出u到v的距离再加上(u, v)这一条边的权值就算是求出环的权值了</strong>，至于求u到v的距离，用最近公共祖先(LCA)可以解决，求出u和v到其公共祖先的距离之和就是u到v的距离了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/23/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/25/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
