<!DOCTYPE html>




<html class="theme-next pisces" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/tpaaaaaa.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/tpaaaaaa.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/tpaaaaaa.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/tpaaaaaa.github.io/images/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/tpaaaaaa.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/tpaaaaaa.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="个人blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Tian&#39;s Blog">
<meta property="og:url" content="https:&#x2F;&#x2F;tpaaaaaa.github.io&#x2F;page&#x2F;20&#x2F;index.html">
<meta property="og:site_name" content="Tian&#39;s Blog">
<meta property="og:description" content="个人blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tpaaaaaa.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://tpaaaaaa.github.io/page/20/"/>





  <title>Tian's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/tpaaaaaa.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tian's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">对未来真正的慷慨，在于把一切都献给现在.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tpaaaaaa.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/tpaaaaaa.github.io/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tpaaaaaa.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tpaaaaaa.github.io/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" target="_blank" rel="noopener" onclick="return false;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/03/HDU-3062Party/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/03/HDU-3062Party/" itemprop="url">HDU - 3062 Party</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-03T21:51:28+08:00">
                2019-09-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n对夫妻被邀请参加一个聚会，因为场地的问题，每对夫妻中只有1人可以列席。在2n 个人中，某些人之间有着很大的矛盾（当然夫妻之间是没有矛盾的），有矛盾的2个人是不会同时出现在聚会上的。有没有可能会有n 个人同时列席？</p>
<h3 id="input："><a href="#input：" class="headerlink" title="input："></a>input：</h3><p>n： 表示有n对夫妻被邀请 (n&lt;= 1000)<br>m： 表示有m 对矛盾关系 ( m &lt; (n - 1) * (n -1)) </p>
<p>在接下来的m行中，每行会有4个数字，分别是 A1,A2,C1,C2<br>A1,A2分别表示是夫妻的编号<br>C1,C2 表示是妻子还是丈夫 ，0表示妻子 ，1是丈夫<br>夫妻编号从 0 到 n -1 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>裸的2-SAT模板，点都帮你分好了，就借此题来分析一下用强连通分量解2-SAT问题的代码吧</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>数据录入部分</p>
<pre><code>for(int i = 1; i &lt;= m; i++)    // 存在m个矛盾关系
{
    int a1, a2, c1, c2;        //意思是第a1 和 a2对夫妻之间有矛盾
                               // 值得是c1 和 c2 有矛盾
    scanf(&quot;%d%d%d%d&quot;, &amp;a1, &amp;a2, &amp;c1, &amp;c2);
    a1 = 2 * a1 + c1;         // 这个a1存的是图中那个点的编号
    a2 = 2 * a2 + c2;         // 意思是a1 和 a2 不能相连
    addEdge(a1, a2^1);        // 那么a1 只能和 a2的相对点联合
    addEdge(a2, a1^1);        // a2只能和a1的相对点联合
}
if(solve())
    printf(&quot;YES\n&quot;);
else
    printf(&quot;NO\n&quot;);</code></pre><p>一般的裸题就直接一遍录入一遍建图即可，但某些需要二分的题目，就是先二分条件，然后再在这个条件下建图，去跑一边2-SAT看看能不能成立。</p>
<p>solve函数部分</p>
<pre><code>bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)  // 要清楚真正的图中的点数，点的编号等
        if(dfn[i] == 0)
            Tarjan(i);           //对每个点进行缩点
    for(int i = 0; i &lt; n; i++)
        if(belong[i*2] == belong[i*2 + 1])  //如果一个点和他的相对点相连通了，说明违背了题目中的选了妻子不能选丈夫，选了丈夫不能选妻子的条件，所以不满足条件
            return false;
    return true;
}</code></pre><p>Tarjan部分</p>
<pre><code>void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++dfsClock;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }

    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/02/%5B%E7%AE%97%E6%B3%95%5D2-SAT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/02/%5B%E7%AE%97%E6%B3%95%5D2-SAT/" itemprop="url">[算法]2-SAT</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-02T21:37:35+08:00">
                2019-09-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博客连接：</p>
<p><a href="https://www.cnblogs.com/cjjsb/p/9771868.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjjsb/p/9771868.html</a></p>
<h2 id="何为SAT问题"><a href="#何为SAT问题" class="headerlink" title="何为SAT问题:"></a>何为SAT问题:</h2><blockquote>
<p>SAT是适定性(Satisfiability)问题的简称 。一般形式为k-适定性问题，简称 k-SAT。</p>
</blockquote>
<p>可以证明，当k&gt;2k&gt;2时，k-SAT是<strong>NP完全</strong>的。因此一般讨论的是k=2k=2的情况，即2-SAT问题。</p>
<p>我们通俗的说，就是给你<strong>nn个变量aiai</strong>，每个变量<strong>能且只能</strong>取0/10/1的值。同时给出若干条件，形式诸如(not)aiopt(not) aj=0/1(not)aiopt⁡(not) aj=0/1，其中optopt表示and,or,xorand,or,xor中的一种</p>
<p>而求解2-SAT的解就是求出满足所有限制的一组a</p>
<h2 id="如何将2-SAT问题转化为图论问题"><a href="#如何将2-SAT问题转化为图论问题" class="headerlink" title="如何将2-SAT问题转化为图论问题:"></a>如何将2-SAT问题转化为图论问题:</h2><p>首先我们考虑将2-SAT问题往图论的方向靠，我们发现每个点<strong>要么取0，要么取1</strong>。因此对于ai，我们建两个点<strong>2i−1与2i</strong>分别表示ai取0和1</p>
<p>然后我们考虑建边来表示这些关系，我们令一条<strong>有向边</strong>的意义：x→y表示如果选择了x就必须选y</p>
<p>那么我们可以举一些简单的例子来总结下连边的规律（用i′表示i的反面）：</p>
<ul>
<li>i,j<strong>不能</strong>同时选：选了i就要选j′，选j就要选i′。故i→j′,j→i′。一般操作即为ai or aj = 1</li>
<li>i,ji,j<strong>必须</strong>同时选：选了ii就要选jj，选jj就要选ii。故i→j,j→ii→j,j→i。一般操作即为aixoraj=0aixor⁡aj=0</li>
<li>i,ji,j<strong>任选（但至少选一个）</strong>选一个：选了ii就要选j′j′，选jj就要选i′i′，选i′i′就要选jj，选j′j′就要选ii。故i→j′,j→i′,i′→j,j′→ii→j′,j→i′,i′→j,j′→i。一般操作即为aioraj=1aior⁡aj=1</li>
<li>ii<strong>必须</strong>选：直接i′→ii′→i，可以保证无论怎样都选ii。一般操作为给出的ai=1ai=1或aiandaj=1aiand⁡aj=1</li>
</ul>
<p>建好图然后就是考虑怎么用图论的方式解决2-SAT了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/01/HDU-1878%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/01/HDU-1878%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/" itemprop="url">HDU - 1878  欧拉回路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-01T22:14:55+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>现给定一个有向图，问是否存在欧拉回路？</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要想使用连通有向图存在欧拉回路的条件，首先要<strong>证明给定的有向图是连通的。</strong></p>
<p><strong>注意：有向图的连通和强连通不同，可以将有向图暂时看成无向图，如果这个无向图连通，则这个有向图也连通。</strong></p>
<p>好吧，题目给的是无向图，我看错了，但是以上任然成立。</p>
<p>有向图的连通性，可以用并查集来求即可，（众所周知也可以用warshall算法（传递关系闭包算法）来求一个关系矩阵）。如果最后 i == findRoot(i) 的点只有一个，那么说明这个图是连通的。</p>
<p>证明完连通性后就可以利用 之前博客里面的条件求解了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/01/poj1041John'strip/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/01/poj1041John'strip/" itemprop="url">poj 1041 John's trip</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-01T15:05:03+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>判断无向图是不是欧拉图，如果是则求出欧拉回路。欧拉回路输出时候要字典序最小。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先已知无向图是连通的，因此要判断连通的无向图是不是欧拉图，我们只需要看每个点的度是不是偶数即可。</p>
<p>如果是欧拉图，那么我们就用基本（套圈）法求出欧拉回路即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是录入部分，题目比较奇葩，不给你N和M。</p>
<pre><code>    while(scanf(&quot;%d%d&quot;, &amp;x, &amp;y) &amp;&amp; x + y)
    {
        init();
        scanf(&quot;%d&quot;, &amp;z);
        degree[x]++;                //x的度加1
        degree[y]++;             
        m ++;                       //m记录边数
        n = max(x, y);              //n记录点数
        edge[z].x = x;
        edge[z].y = y;
        edge[z].del = false;        //del = true 表示这个边已经访问过了
        while(scanf(&quot;%d%d&quot;, &amp;x, &amp;y) &amp;&amp; x + y)
        {
            scanf(&quot;%d&quot;, &amp;z);
            edge[z].x = x;
            edge[z].y = y;
            edge[z].del = false;
            n = max(x, y);
            m ++;
            degree[x]++;
            degree[y]++;
        }
.............</code></pre><p>接下来是从任意一个点开始用dfs求欧拉回路</p>
<pre><code>void dfs(int u)                    //套圈法求欧拉回路
{
    for(int i = 1; i &lt;= m; i++)    //枚举与u相连的没有访问过的边，随便哪一条都行
    {
        int x = edge[i].x;
        int y = edge[i].y;
        if((x == u || y == u) &amp;&amp; edge[i].del == false)
        {
            edge[i].del = true;   //将这个边标记为已访问过
            if(x == u)
                dfs(y);           // 从下一个点开始dfs
            else
                dfs(x);
            vec.push_back(i);    // 最后会重新绕回到起点，所以逆序将边存入，之前从某点到起点的点，变成起点到的第一个点。
        }

    }

}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/09/01/%5B%E7%AE%97%E6%B3%95%5D%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/09/01/%5B%E7%AE%97%E6%B3%95%5D%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98/" itemprop="url">[算法]欧拉路径问题与欧拉回路问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-01T10:52:33+08:00">
                2019-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>博客链接：<a href="https://www.cnblogs.com/shao0099876/p/7366852.html" target="_blank" rel="noopener">https://www.cnblogs.com/shao0099876/p/7366852.html</a></p>
<p>求解欧拉回路的算法：<a href="https://www.cnblogs.com/Ash-ly/p/5397702.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ash-ly/p/5397702.html</a></p>
<h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a><strong>一、基本概念：</strong></h3><p><strong>欧拉路</strong>：欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且<strong>图中每条边通过的且只通过一次</strong>。</p>
<p><strong>欧拉回路:</strong>欧拉回路是指起点和终点相同的欧拉路。</p>
<h2 id="二、存在欧拉路和欧拉回路的条件"><a href="#二、存在欧拉路和欧拉回路的条件" class="headerlink" title="二、存在欧拉路和欧拉回路的条件:"></a><strong>二、存在欧拉路和欧拉回路的条件:</strong></h2><p>1.<strong>无向连通图</strong>存在欧拉路的条件：</p>
<blockquote>
<p><strong>所有点度都是偶数，或者恰好有两个点度是奇数，则有欧拉路。</strong>若有奇数点度，则奇数点度点一定是欧拉路的起点和终点，否则可取任意一点作为起点。</p>
</blockquote>
<p>2.<strong>有向连通图</strong>存在欧拉路的条件：</p>
<ul>
<li><strong>每个点的入度等于出度，则存在欧拉回路</strong>（任意一点有度的点都可以作为起点）</li>
<li><strong>除两点外，所有入度等于出度。</strong>这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉路。取出度大者为起点，入度大者为终点。</li>
</ul>
<p><strong>3.有向连通图</strong>存在欧拉回路的条件</p>
<p>图连通，所有的顶点<strong>出度=入度</strong>。</p>
<p><strong>4.无向连通图</strong>存在欧拉回路的条件</p>
<p>图连通，所有顶点都是<strong>偶数度</strong>。</p>
<hr>
<h2 id="三、无向图欧拉路径的求解方法"><a href="#三、无向图欧拉路径的求解方法" class="headerlink" title="三、无向图欧拉路径的求解方法"></a>三、无向图欧拉路径的求解方法</h2><p>　　欧拉路径的求解方法一般是使用深度优先搜索（以下简称DFS）来做。</p>
<p>　　首先我们需要确定搜索的起点。<strong>如果度数全为偶数</strong>，由欧拉回路在无向图中存在的充要条件（图中顶点度数全为偶数）可知，搜索结果必定为一条环，<strong>所以用任何一个顶点当做起点都可以得到一条欧拉路径</strong>。<strong>如果有两个奇度数顶点</strong>，那么欧拉路径必<strong>定以一个顶点作为出发点，以另一个顶点作为终点</strong>。因此从两个顶点中选一个出来即可。关于这一点可以解释为：欧拉路径如果要经过所有的边，对于度数为偶数的点必定是“到达-&gt;离开”这样的访问形式，不会在此停留（也就是中间点），这可以解释两个奇度数顶点的情况，<strong>全偶度数顶点的情况可以理解为奇度数的出发点与奇度数的终点重合为同一个偶度数的点。</strong></p>
<p>　　欧拉路径在无向图中的求解可以用“过河拆桥”来形容。通过定义我们可以得到：<strong>如果我们经过了一条边，那么在以后的搜索过程中我们不能再次经过这条边，因此要把这条边删除掉，使得搜索的过程中不会出现重复的情况。</strong>计算过程如下：</p>
<p>　　1.用图的数据初始化顶点，vis标记设为false。</p>
<p>　　2.按上述方法寻找起点，同时排除不合法情况。</p>
<p>　　3.从起点开始DFS，每次访问到顶点x的时候，将vis标记设为true，枚举x的邻接边，如果边没有被删除（del标记为false），那么就删除这条边（del设为true），同时找到下一个顶点，也删除这条边（无向图），DFS下一顶点，直到无法扩展，将顶点压栈。最后得到的栈按顺序出栈得到的序列就是顶点的访问顺序。</p>
<p>　　4.检查顶点的访问情况，如果有<strong>没有访问到的顶点</strong>就说明图<strong>不是连通图</strong>，不是合法情况。</p>
<h2 id="四、有向图欧拉路径求解方法"><a href="#四、有向图欧拉路径求解方法" class="headerlink" title=" 四、有向图欧拉路径求解方法"></a> 四、有向图欧拉路径求解方法</h2><p>　　与无向图欧拉路径求解方法类似，但是有以下改动：</p>
<p>　　1.如果顶点的入度和出度均相等，情况同无向图全偶度数顶点。如果顶点中有一个 出度 - 入度 = 1，有一个 入度 - 出度 = 1，那么用 入度 - 出度 = 1的顶点作为起点</p>
<p>　　2.删除边的时候只需要从起点删除一次即可</p>
<h2 id="update：-下面找到的是更好的博文"><a href="#update：-下面找到的是更好的博文" class="headerlink" title="update： 下面找到的是更好的博文"></a>update： 下面找到的是更好的博文</h2><p>求解欧拉回路的算法：<a href="https://www.cnblogs.com/Ash-ly/p/5397702.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ash-ly/p/5397702.html</a></p>
<p><strong>基本(套圈)法</strong>：</p>
<p>首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，<strong>所停止的点必然也是起点</strong>(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，<strong>然后停止时，走过的路径形成了一个圈</strong>，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p>
<p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p>
<p><strong>下面用图描述一遍：</strong></p>
<p><img src="http://localhost/wp-content/uploads/2019/09/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-2.png" alt=""></p>
<p><img src="http://localhost/wp-content/uploads/2019/09/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-3.png" alt=""></p>
<p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p>
<p>第一步：v1 – v9</p>
<p>第二步：v9 – v8</p>
<p>第三步：v8 – v10</p>
<p>第四步：v10 – v1</p>
<p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p>
<p>第五步: v10 – v3</p>
<p>第六步: v3 – v2</p>
<p>第七步: v2 – v4</p>
<p>第八步: v4 – v10</p>
<p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p>
<p>第九步：v8 – v6</p>
<p>第十步：v6 –v7</p>
<p>第十一步：v7– v8</p>
<p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p>
<p><strong>具体实现与分析:</strong></p>
<p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p>
<p>代码已经测试数据</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;

const int MAXV = 100 + 7;
const int MAXE = 100 * 100 + 7;
int head[MAXV];
int V, E;

typedef struct EdgeNode
{
    int to;
    int w;
    int next;
}edgeNode;
edgeNode Edges[MAXE];

bool visit[2 * MAXE];
stack&lt;int&gt; stv;
queue&lt;int&gt; quv;//点集
queue&lt;int&gt; que;//边集

void EulerDFS(int now)
{
    printf(&quot;Now = %d\n&quot;, now);
    stv.push(now);//每访问一个点，就把该点压入栈
   // printf(&quot;stack 中\n&quot;);

    printf(&quot;\n&quot;);
    for(int k = head[now]; k != -1; k = Edges[k].next)
    {
        if(!visit[k])
        {
            visit[k] = true;            //有向图每条边保存了两次，也要标记两次
            if(k &amp; 1)
                visit[k + 1] = true;
            else
                visit[k - 1] = true;
            EulerDFS(Edges[k].to);
            que.push(k);//回溯时记录
            printf(&quot;插入了\n&quot;);
            printf(&quot;%d号边\n&quot;, k);
            printf(&quot;%d &lt; - &gt; %d&quot;, now, Edges[k].to);
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;栈顶元素为\n&quot;);
    printf(&quot;%d\n&quot;, stv.top());
    quv.push(stv.top());//记录点
    stv.pop();
}

int main()
{
    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);
    memset(head, -1, sizeof(head));
    for(int i = 1; i &lt;= E; i++)
    {
        int u, v, w;
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        Edges[2 * i - 1].to = v;                //双向储存边
        Edges[2 * i - 1].w = w;
        Edges[2 * i - 1].next = head[u];
        head[u] = 2 * i - 1;
        Edges[2 * i].to = u;
        Edges[2 * i].w = w;
        Edges[2 * i].next = head[v];
        head[v] = 2 * i;
    }
    memset(visit, false, sizeof(visit));
    EulerDFS(1);
    return 0;
}
/ * 
10 11
1 9 1
1 10 2
9 8 3
10 8 4
10 3 5
3 2 6
2 4 7
10 4 8
8 6 9
6 7 10
8 7 11

*/</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/31/HDU-3072IntelligenceSystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/31/HDU-3072IntelligenceSystem/" itemprop="url">HDU - 3072  Intelligence System</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T21:33:06+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>After a day, ALPCs finally complete their ultimate intelligence system, the purpose of it is of course for ACM … …<br>Now, kzc_tc, the head of the Intelligence Department (his code is once 48, but now 0), is sudden obtaining important information from one Intelligence personnel. That relates to the strategic direction and future development of the situation of ALPC. So it need for emergency notification to all Intelligence personnel, he decides to use the intelligence system (kzc_tc inform one, and the one inform other one or more, and so on. Finally the information is known to all).<br>We know this is a dangerous work. Each transmission of the information can only be made through a fixed approach, from a fixed person to another fixed, and cannot be exchanged, but between two persons may have more than one way for transferring. Each act of the transmission cost Ci (1 &lt;= Ci &lt;= 100000), the total cost of the transmission if inform some ones in our ALPC intelligence agency is their costs sum.<br>Something good, if two people can inform each other, directly or indirectly through someone else, then they belong to the same branch (kzc_tc is in one branch, too!). This case, it’s very easy to inform each other, so that the cost between persons in the same branch will be ignored. The number of branch in intelligence agency is no more than one hundred.<br>As a result of the current tensions of ALPC’s funds, kzc_tc now has all relationships in his Intelligence system, and he want to write a program to achieve the minimum cost to ensure that everyone knows this intelligence.<br>It’s really annoying! </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用tarjan缩点得到DAG图后，知道DAG图肯定无环，并且连通的（ Believe kzc_tc’s working! There always is a way for him to communicate with all other intelligence personnel. ），所以我们就用求最小树形图的朱刘算法一次循环即可，即得到最小弧集合，然后判断是否成树和是否有环，显然已经成树，并且无环，所以此时的最小弧集合就是最小树形图，然后我们要求的是最小树形图的权值，所以我们直接将每个点的最小入弧的权值相加即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-10.42.14
 Question_Number   ：hdu 3072
 Question_Name     ：tarjan 强连通
 Description       ：
                     最小树形图？？
                     用tarjan缩点求出强连通子图
                     我们可以知道这个图肯定没有环路
                     并且这个图肯定是联通的。
                     然后求这个图的最小树型图
                     朱刘算法
                     如果一个图没有环路，并且已经联通了
                     那么它的树形图就是最短弧集合

                     首先将每个点的最小的入边保留下来
                     最短弧集合
                     如果得到的是一棵树，则棵树就是最小树形图

                     如果这个图联通，并且无环，那么
                     对于最后一个节点A，他最小的入弧所连的点为B，
                     接下来判断B的最小入弧所连的点，肯定不是A（不然就形成了环），因此为C
                     同理C的最小入弧所连的点，肯定不是A或B，（会形成环）因此肯定为剩余节点中的D
                     一路下来，直到第一个节点root。

                      题目的意思是，n个点，编号 0 .. n - 1
                      以0号点为root的树的权值
                      因为题目说 如果是同一个branch，那么他们之间的联系free
                      因此将同一个branch的人，用tarjan缩成一个点。
                      又因为题目保证联通，所以缩完之后，就是从0
                      所在的那个连通分量到各个联通分量形成的树的最小值。
                      那么我们只要找到每个联通分量的入边最小的权值
                      将这些权值加起来就可以啦。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
const int MAXM = 1e5 + 10;
const int MAXB = 100 + 10;
int n, m, tot, sum ,cnt;
bool vis[MAXN];
int head[MAXN], low[MAXN], dfn[MAXN], belong[MAXN];
int cost[MAXB];
stack &lt; int &gt; st;
struct Edge
{
    int u, v, w, next;
};
Edge edge[MAXM];
void addEdge(int u, int v, int w)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[v], low[u]);
        }
        else if(vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            belong[temp] = sum;
            vis[temp] = false;
            st.pop();
        }
        belong[u] = sum;
        vis[u] = false;
        st.pop();
    }

}
void init()
{
    cnt = sum = tot = 0;
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(vis, false, sizeof vis);
    memset(head, -1, sizeof head);
    memset(belong, 0, sizeof belong);
    memset(cost, INF, sizeof cost);
    while(!st.empty())
        st.pop();
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v, w;
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            addEdge(u, v, w); // u - &gt; v cost =w;
        }
        for(int i = 0; i &lt; n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int i = 0; i &lt; n; i++)
            for(int j = head[i]; j != -1; j = edge[j].next)
            {
                int u = i;
                int v = edge[j].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                {
                    cost[b] = min(cost[b], edge[j].w);
                }
            }
        int ans = 0;
        int expt = belong[0];//0 所在的入边就不考虑了
        for(int i = 1; i &lt;= sum; i++)
            if(i != expt)
                ans += cost[i];
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/31/POJ-1236NetworkofSchools/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/31/POJ-1236NetworkofSchools/" itemprop="url">POJ - 1236 Network of Schools</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T21:20:10+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一些学校连接到了一个计算机网络。网络中的学校间有如下约定：每个学校维护一个列表，当该学校收到软件或信息后将会转发给列表中的所有学校（也就是接收方列表）。需要注意的是如果B学校在A学校的接收方列表中，A学校<strong>不一定</strong>会出现在B学校的接收方列表中。<br>你现在的任务是写出一个程序来计算必须收到一份软件来使网络中的所有学校都能收到软件的学校的数量的最小值（<strong>此为子任务A</strong>）。作为一个远期目标，我们希望给任意一个学校发送一份软件都能使网络中的所有学校都收到软件。为了实现这个目标，我们或许需要在一些学校的接收方列表中添加新项。 你现在需要计算出至少需要添加多少新项才能实现这个远期目标（<strong>此为子任务B</strong>）。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan缩点得到DAG图后，要想遍历图上的所有点，则必须从起点开始，所以起点的数目就是必须要访问点的数目。</p>
<p>为了要使DAG图成为一个强连通图，我们可以将同一条topo链上的起点和终点连在一起，因此需要添边的数目为max(起点的数目 , 终点的数目)。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-13.17.38
 Question_Number   ：poj 1236
 Question_Name     ：强连通？？
 Description       :
    DAG图，有向无环图（有向树）
    要明白DAG图的性质。。
    入度为0的点，就是起点。
    出度为0的点，就是终点。
    test A 要想遍历所有点，肯定要从起点开始
    设起点有x个， 终点y个
    则最少要从x个点出发
    test A  入度为0的点的数目

    test B 将一个DAG图要加多少边才能变成强连通图
    易知，要将起点和终点联系在一起。
    因此要填的边的数目是
    max(x, y);

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100 + 10;
const int MAXM = MAXN * MAXN;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], in[MAXN], ou[MAXN];
bool vis[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(in, 0, sizeof in);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        init();
        for(int u = 1; u &lt;= n; u++)
        {
            int v;
            while(scanf(&quot;%d&quot;, &amp;v) &amp;&amp; v)
                addEdge(u, v);
         //   printf(&quot;?&quot;);
        }
      //  printf(&quot;??&quot;);
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int u = 1; u &lt;= n; u ++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                {
                    ou[a] ++;
                    in[b] ++;
                }
            }
        int ans1 = 0, ans2 = 0;
        for(int i = 1; i &lt;= sum; i++)
        {
            if(in[i] == 0)
                ans1 ++;
            if(ou[i] == 0)
                ans2 ++;
        }
        //如果原本就是强连通的图，那么ans1 == ans2 == 0;
        if(sum == 1)
            printf(&quot;1\n0\n&quot;);
        else
            printf(&quot;%d\n%d\n&quot;, ans1, max(ans1, ans2));
    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/31/POJ-2553TheBottomofaGraph/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/31/POJ-2553TheBottomofaGraph/" itemprop="url">POJ - 2553 The Bottom of a Graph</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T21:16:30+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求点A，点A的性质：点A能到的点， 这些点也能到达A。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan求缩点后的DAG图，因为点A能到的点，那个点也能到A，说明这些点和A构成了一个强连通分量，点A除了能到这些点之外，就再也不能到其他点了，也就是说这个强连通分量的出度为0。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-14.42.33
 Question_Number   ：poj2553
 Question_Name     ：强连通
 Description       :
 sink的意思是  点A能到的所有点， 所有的这些点也能到达A
                强连通？？ 用Tarjan
                然后遍历点
                    再遍历与这个点相连的边，得到另一个点
                        如果另一个点与这个点在同一个强连通分量中
                        则ok
                // 以上这个方法，显然行不通..
                我们可以将强连通分量中的边全部删掉
                然后求出出度为0 的点即可

                我们用Tarjan求连通分量
                然后出栈的时候
                 对于栈顶元素，我们将他连到的栈中的点的边去掉
                以上思路又错了
                是用tarjan缩点，然后找出出度为0的强连通分量。
                将这个强连通分量中的点全部输出。
                缩点的思想要掌握！！
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5000 + 10;
const int MAXM = MAXN * MAXN;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], ou[MAXN];
bool vis[MAXN];
int arr[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
    memset(arr, 0, sizeof arr);
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        scanf(&quot;%d&quot;, &amp;m);
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
            addEdge(u, v); // u - &gt; v;
        }
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);

        for(int u = 1; u &lt;= n; u ++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                    ou[a] ++;
            }
        int all = 0;
        for(int i = 1; i &lt;= sum; i++)
        {
            if(ou[i] == 0)  //i是出度为0的强连通分量
            {
                for(int j = 1; j &lt;= n; j++)
                    if(belong[j] == i)
                    {
                        arr[++all] = j;
                    }
            }
        }
        sort(arr + 1, arr + 1 + all);
        for(int i = 1; i &lt;= all; i++)
            printf(&quot;%d &quot;, arr[i]);
        printf(&quot;\n&quot;);

    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/31/POJ-2186PopularCows/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/31/POJ-2186PopularCows/" itemprop="url">POJ - 2186 Popular Cows</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T21:01:11+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求所给有向图中，所有点都能到达的点。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan进行缩点，得到DAG图，如果存在唯一一个强连通分量，其出度为0，说明其他所有的强联通分量都能够到达它。也就是说，其他强联通分量中的点都能到达这个强连通分量中的任意一点，并且这个强连通分量中的任意两点都能互达。因此这个强连通分量中的点就是所谓的最受欢迎的cow。输出这个强连通分量中点的数目即可。如果这个强连通分量不唯一，说明这些强连通分量之间不能互达，也就是没有任何一个点满足条件，则输出数目为0；</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-15.20.21
 Question_Number   ：poj 2186
 Question_Name     ：强连通分量
 Description       :
                     图中所有的点都能到A
                     自己能到自己。
                     强连通缩点，得到DAG图
                     然后枚举每个终点？？，用floyd求连通性？？？
                     最多有1e4个数，3次肯定超了
                    对每个点用Dij，看看能不能连通
                    Dij的复杂度是O(E+VlgV)，最坏情况(5n);
                    然后枚举点n
                    所以最坏情况(5n^2)
                    貌似刚好。
                    我好蠢
                          先用tarjan求出每个强连通分量，
                          再缩点，统计每个点的出度，如果有且只有1个出度为0的点，
                          就输出这个点包含的节点数，否则输出0.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 5e4 + 10;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], ou[MAXN];
bool vis[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
 //   memset(arr, 0, sizeof arr);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= m; i ++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v); // u - &gt; v
        }
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int u = 1; u &lt;= n; u++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if( a != b )
                    ou[a]++;
            }
        int sum0 = 0;
        int temp;
        for(int i = 1; i &lt;= sum; i++)
            if(ou[i] == 0)
            {
                sum0++;
                temp = i;
            }

        int ans = 0;
        if(sum0 == 1)
            for(int i = 1; i &lt;= n; i++)
                if(belong[i] == temp)
                    ans++;
        printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://tpaaaaaa.github.io/tpaaaaaa.github.io/2019/08/31/POJ-2762Goingfromutovorfromvtou/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="我玩维恩不学q">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/tpaaaaaa.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tian's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/tpaaaaaa.github.io/2019/08/31/POJ-2762Goingfromutovorfromvtou/" itemprop="url">POJ - 2762 Going from u to v or from v to u?</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-31T20:53:04+08:00">
                2019-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tpaaaaaa.github.io/categories/%E5%9B%BE%E8%AE%BA/" itemprop="url" rel="index">
                    <span itemprop="name">图论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个图，问你这个图中的任意两个点A , B，存不存在A到B <strong>或者</strong> B到A的路径。如果任意一对点都存在，则输出Yes，否则输出No</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先，我们用Tarjan将图进行缩点简化，得到一个DAG图。但对于DAG图，topo排序得到的序列不一定唯一。对于topo排序期间的入度为0的点的数目大于1，（假设数目为2，并将这两点设为A,B） 说明A,B在topo序列中的地位是一样的，然而点在topo排序中的关系是<strong>：在topo排序中排在后面点，无法到达排到前面的点，排在前面的点，能够到达后面的点</strong>。 因此A，B这两点 既从A不能到达B，也不能从B到A，因此不符合条件。</p>
<p>所以整题的思路是，用Tarjan将图缩点，成DAG图，对DAG图进行topo排序， 如果排序期间入度为0的点的数目大于1，则return false， 否则到最后return true。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是根据Tarjan建立新图的代码</p>
<pre><code>for(int u = 1; u &lt;= n; u++)
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        int a = belong[u];
        int b = belong[v];
        if(a != b)
        {
            if(mp[a][b] == false)   // 在新图中这条边已经存在过了
            {
                mp[a][b] = true;
                in[b] ++;
            }
        }
    }</code></pre><p>对新DAG图进行topo排序</p>
<pre><code>bool topo()
{
    queue &lt; int &gt; Q;
    for(int i = 1; i &lt;= sum; i++)
        if(in[i] == 0)
            Q.push(i);
    while(!Q.empty())
    {
        if(Q.size() &gt; 1)
            return false;
        int u = Q.front();
        Q.pop();
        for(int v = 1; v &lt;= sum; v ++)   //这是新的图，mp存的是新图
        {
            if(mp[u][v])
            {
                in[v] -- ;
                if(in[v] == 0)
                    Q.push(v);
            }

        }
    }
    return true;
}</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
 <nav class="pagination">
   <a class="extend prev" rel="prev" href="/tpaaaaaa.github.io/page/19/"><i class="fa fa-angle-left" aria-label="accessibility.prev_page"></i></a><a class="page-number" href="/tpaaaaaa.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/19/">19</a><span class="page-number current">20</span><a class="page-number" href="/tpaaaaaa.github.io/page/21/">21</a><span class="space">&hellip;</span><a class="page-number" href="/tpaaaaaa.github.io/page/25/">25</a><a class="extend next" rel="next" href="/tpaaaaaa.github.io/page/21/"><i class="fa fa-angle-right" aria-label="accessibility.next_page"></i></a>
 </nav>

          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/tpaaaaaa.github.io/images/avatar.gif"
                alt="我玩维恩不学q" />
            
              <p class="site-author-name" itemprop="name">我玩维恩不学q</p>
              <p class="site-description motion-element" itemprop="description">个人blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/tpaaaaaa.github.io/archives">
              
                  <span class="site-state-item-count">245</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/tpaaaaaa.github.io/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tpaaaaaa.github.io/tags/index.html">
                  <span class="site-state-item-count">113</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">我玩维恩不学q</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/tpaaaaaa.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/tpaaaaaa.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/tpaaaaaa.github.io/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

</body>
</html>
