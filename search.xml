<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>YAML语法</title>
    <url>/tpaaaaaa.github.io/2020/02/12/YAML%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="YAML-语法"><a href="#YAML-语法" class="headerlink" title="YAML 语法"></a>YAML 语法</h1><h3 id="What-is-YAML"><a href="#What-is-YAML" class="headerlink" title="What is YAML"></a>What is YAML</h3><p>YAML 是 “YAML Ain’t a Markup Language”（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）。</p>
<p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。</p>
<p>YAML 的配置文件后缀为 <strong>.yml</strong></p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进不允许使用tab，只允许空格</li>
<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>
<li>‘#’表示注释</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>YAML 支持以下几种数据类型：</p>
<ul>
<li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li>
<li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li>
<li>纯量（scalars）：单个的、不可再分的值</li>
</ul>
<h3 id="YAML对象"><a href="#YAML对象" class="headerlink" title="YAML对象"></a>YAML对象</h3><p>对象键值对：</p>
<p>​    可使用冒号结构表示 <strong>key: value</strong>，<strong>冒号后面要加一个空格</strong>。</p>
<p>​    也可以使用 <strong>key:{key1: value1, key2: value2, …}</strong>。</p>
<p>​    还可以使用缩进表示层级关系；</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">1.key:</span> <span class="string">value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">2.</span><span class="string">key:&#123;key1:</span> <span class="string">value1,</span> <span class="attr">key2:</span> <span class="string">value2,</span> <span class="string">...&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">3.key:</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">child-key1:</span> <span class="string">value1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="attr">child-key2:</span> <span class="string">value2</span></span></pre></td></tr></table></figure>

<h3 id="YAML数组"><a href="#YAML数组" class="headerlink" title="YAML数组"></a>YAML数组</h3><p>以 <strong>-</strong> 开头的行表示构成一个数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- A</span></pre></td></tr><tr><td class="code"><pre><span class="line">- B</span></pre></td></tr><tr><td class="code"><pre><span class="line">- C</span></pre></td></tr></table></figure>

<p>个相对复杂的例子：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">companies:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">id:</span> <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">name:</span> <span class="string">company1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">price:</span> <span class="string">200W</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">id:</span> <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">name:</span> <span class="string">company2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="attr">price:</span> <span class="string">500W</span></span></pre></td></tr></table></figure>

<p>意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。</p>
<p>数组和对象可以构成复合结构，例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">languages:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="string">Ruby</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="string">Perl</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="bullet">-</span> <span class="string">Python</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">websites:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">YAML:</span> <span class="string">yaml.org</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">Ruby:</span> <span class="string">ruby-lang.org</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">Python:</span> <span class="string">python.org</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">Perl:</span> <span class="string">use.perl.org</span></span></pre></td></tr></table></figure>

<h3 id="YAML纯量"><a href="#YAML纯量" class="headerlink" title="YAML纯量"></a>YAML纯量</h3><p>纯量是最基本的，不可再分的值，包括：</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>使用一个例子来快速了解纯量的基本使用：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">boolean:</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="literal">TRUE</span>  <span class="comment">#true,True都可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="literal">FALSE</span>  <span class="comment">#false，False都可以</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">float:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="number">3.14</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="number">6.8523015e+5</span>  <span class="comment">#可以使用科学计数法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">int:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="number">123</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">0b1010_0111_0100_1010_1110</span>    <span class="comment">#二进制表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">null:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">nodeName:</span> <span class="string">'node'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="attr">parent:</span> <span class="string">~</span>  <span class="comment">#使用~表示null</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">string:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">哈哈</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">'Hello world'</span>  <span class="comment">#可以使用双引号或者单引号包裹特殊字符</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="string">newline</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="string">newline2</span>    <span class="comment">#字符串可以拆成多行，每一行会被转化成一个空格</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">date:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span> <span class="number">2018</span><span class="number">-02</span><span class="number">-17</span>    <span class="comment">#日期必须使用ISO 8601格式，即yyyy-MM-dd</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">datetime:</span> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="bullet">-</span>  <span class="number">2018</span><span class="number">-02</span><span class="string">-17T15:02:31+08:00</span>    <span class="comment">#时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区</span></span></pre></td></tr></table></figure>

<h3 id="YAML引用"><a href="#YAML引用" class="headerlink" title="YAML引用"></a>YAML引用</h3><p><strong>&amp;</strong> 锚点和 ***** 别名，可以用来引用:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">development:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span></pre></td></tr></table></figure>

<p>相当于:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">development:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">database:</span> <span class="string">myapp_development</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="attr">test:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">database:</span> <span class="string">myapp_test</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">adapter:</span>  <span class="string">postgres</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="attr">host:</span>     <span class="string">localhost</span></span></pre></td></tr></table></figure>

<p><strong>&amp;</strong> 用来建立锚点（defaults），<strong>&lt;&lt;</strong> 表示合并到当前数据，***** 用来引用锚点。</p>
]]></content>
      <categories>
        <category>YAML</category>
      </categories>
      <tags>
        <tag>YAML语法</tag>
      </tags>
  </entry>
  <entry>
    <title>XML语法</title>
    <url>/tpaaaaaa.github.io/2020/02/12/XML%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="XML语法"><a href="#XML语法" class="headerlink" title="XML语法"></a>XML语法</h1><h3 id="What-is-XML"><a href="#What-is-XML" class="headerlink" title="What is XML"></a>What is XML</h3><ul>
<li>XML 指可扩展标记语言（<strong>EX</strong>tensible <strong>M</strong>arkup <strong>L</strong>anguage）</li>
<li>XML 是一种<strong>标记语言</strong>，很类似 HTML</li>
<li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li>
<li>XML 标签没有被预定义。您需要<strong>自行定义标签</strong>。</li>
<li>XML 被设计为具有<strong>自我描述性</strong>。</li>
<li>XML 是 <strong>W3C 的推荐标准</strong></li>
</ul>
<h3 id="XML-与-HTML-的主要差异"><a href="#XML-与-HTML-的主要差异" class="headerlink" title="XML 与 HTML 的主要差异"></a>XML 与 HTML 的主要差异</h3><p>XML 不是 HTML 的替代。</p>
<p>XML 和 HTML 为不同的目的而设计：</p>
<p>XML 被设计为传输和存储数据，其焦点是数据的内容。</p>
<p>HTML 被设计用来显示数据，其焦点是数据的外观。</p>
<p><strong>HTML 旨在显示信息，而 XML 旨在传输信息。</strong></p>
]]></content>
      <categories>
        <category>XML</category>
      </categories>
      <tags>
        <tag>XML语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习</title>
    <url>/tpaaaaaa.github.io/2020/02/11/Git%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="Git学习"><a href="#Git学习" class="headerlink" title="Git学习"></a>Git学习</h1><h2 id="What-is-Git"><a href="#What-is-Git" class="headerlink" title="What is Git"></a>What is Git</h2><p><strong>Git是目前世界上最先进的分布式版本控制系统</strong></p>
<p>​        <strong>集中式</strong>和<strong>分布式</strong>版本控制系统有什么区别呢？    </p>
<p>​        <strong>集中式版本控制系统，版本库是集中存放在中央服务器的</strong>。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>​        <strong>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库</strong></p>
<p>​        <strong>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多</strong></p>
<p>​        <strong>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</strong></p>
<h2 id="What-is-repository"><a href="#What-is-repository" class="headerlink" title="What is repository"></a>What is repository</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个<strong>目录里面的所有文件都可以被Git管理起来</strong>，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir learngit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ cd learngit</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ pwd</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;Users&#x2F;michael&#x2F;learngit</span></pre></td></tr></table></figure>

<p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span></pre></td></tr><tr><td class="code"><pre><span class="line">Initialized empty Git repository in &#x2F;Users&#x2F;michael&#x2F;learngit&#x2F;.git&#x2F;</span></pre></td></tr></table></figure>

<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。</p>
<p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪<strong>文本文件的改动</strong>，比如<strong>TXT文件，网页，所有的程序代码</strong>等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p><strong>windows别用自带的记事本</strong></p>
<h2 id="Commite-files-to-repository"><a href="#Commite-files-to-repository" class="headerlink" title="Commite files to repository"></a>Commite files to repository</h2><p>在仓库目录下新建一个readme.txt文件</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span></pre></td></tr></table></figure>

<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;wrote a readme file&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 1 file changed, 2 insertions(+)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> create mode 100644 readme.txt</span></pre></td></tr></table></figure>

<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是<strong>本次提交的说明</strong>，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git add file2.txt file3.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add 3 files.&quot;</span></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m</code>，完成。</li>
</ol>
<h2 id="command-git-status-git-diff"><a href="#command-git-status-git-diff" class="headerlink" title="command: git status, git diff"></a>command: git status, git diff</h2><p>修改readme.txt文件，改成如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span></pre></td></tr><tr><td class="code"><pre><span class="line">Git is free software.</span></pre></td></tr></table></figure>

<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span></pre></td></tr><tr><td class="code"><pre><span class="line">On branch master</span></pre></td></tr><tr><td class="code"><pre><span class="line">Changes not staged for commit:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	modified:   readme.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span></pre></td></tr></table></figure>

<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>我们也可以用<code>git diff</code>这个命令看看具体修改了什么内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span></pre></td></tr><tr><td class="code"><pre><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">index 46d49bf..9247db6 100644</span></pre></td></tr><tr><td class="code"><pre><span class="line">--- a&#x2F;readme.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">+++ b&#x2F;readme.txt</span></pre></td></tr><tr><td class="code"><pre><span class="line">@@ -1,2 +1,2 @@</span></pre></td></tr><tr><td class="code"><pre><span class="line">-Git is a version control system.</span></pre></td></tr><tr><td class="code"><pre><span class="line">+Git is a distributed version control system.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Git is free software.</span></pre></td></tr></table></figure>

<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h2 id="command-git-reset-git-log-git-reflog"><a href="#command-git-reset-git-log-git-reflog" class="headerlink" title="command: git reset, git log, git reflog"></a>command: git reset, git log, git reflog</h2><p>不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，<strong>这个快照在Git中被称为<code>commit</code>。</strong>一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span></pre></td></tr><tr><td class="code"><pre><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    append GPL</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit e475afc93c209a690c39c13a46716e8fa000c366</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri May 18 21:03:36 2018 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    add distributed</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0</span></pre></td></tr><tr><td class="code"><pre><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Date:   Fri May 18 20:59:18 2018 +0800</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    wrote a readme file</span></pre></td></tr></table></figure>

<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline</span></pre></td></tr><tr><td class="code"><pre><span class="line">1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL</span></pre></td></tr><tr><td class="code"><pre><span class="line">e475afc93c209a690c39c13a46716e8fa000c366 add distributed</span></pre></td></tr><tr><td class="code"><pre><span class="line">eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file</span></pre></td></tr></table></figure>

<p>类似<code>1094adb...</code>的是<code>commit id</code>（版本号）</p>
<p>在Git中，用<code>HEAD</code>表示当前版本</p>
<p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at e475afc add distributed</span></pre></td></tr></table></figure>

<p>找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard 1094a</span></pre></td></tr><tr><td class="code"><pre><span class="line">HEAD is now at 83b0afe append GPL</span></pre></td></tr></table></figure>

<p>版本号没必要写全，前几位就可以了，Git会自动去找。</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span></pre></td></tr><tr><td class="code"><pre><span class="line">e475afc HEAD@&#123;1&#125;: reset: moving to HEAD^</span></pre></td></tr><tr><td class="code"><pre><span class="line">1094adb (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: append GPL</span></pre></td></tr><tr><td class="code"><pre><span class="line">e475afc HEAD@&#123;3&#125;: commit: add distributed</span></pre></td></tr><tr><td class="code"><pre><span class="line">eaadf4e HEAD@&#123;4&#125;: commit (initial): wrote a readme file</span></pre></td></tr></table></figure>

<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>现在总结一下：</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h2 id="Definition-Working-Directory-Repository"><a href="#Definition-Working-Directory-Repository" class="headerlink" title="Definition: Working Directory, Repository"></a>Definition: Working Directory, Repository</h2><p><strong>工作区（Working Directory）</strong></p>
<p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区</p>
<p><strong>版本库（Repository）</strong></p>
<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p>工作区&gt;&gt;&gt;&gt;暂存区&gt;&gt;&gt;&gt;仓库</p>
<p>git add把文件从工作区&gt;&gt;&gt;&gt;暂存区，git commit把文件从暂存区&gt;&gt;&gt;&gt;仓库，</p>
<p>git diff查看工作区和暂存区差异，</p>
<p>git diff –cached查看暂存区和仓库差异，</p>
<p>git diff HEAD 查看工作区和仓库的差异，</p>
<p>git add的反向命令git checkout，撤销工作区修改，即把暂存区最新版本转移到工作区，</p>
<p>git commit的反向命令git reset HEAD，就是把仓库最新版本转移到暂存区。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title>废物的学期总结——大二上</title>
    <url>/tpaaaaaa.github.io/2020/02/09/%E5%BA%9F%E7%89%A9%E7%9A%84%E5%AD%A6%E6%9C%9F%E6%80%BB%E7%BB%93%E2%80%94%E2%80%94%E5%A4%A7%E4%BA%8C%E4%B8%8A/</url>
    <content><![CDATA[<h1 id="废物的学期总结——大二上"><a href="#废物的学期总结——大二上" class="headerlink" title="废物的学期总结——大二上"></a>废物的学期总结——大二上</h1><p>转专业去计算机的第一个学期，GPA崩了呀兄弟。</p>
<p>今天刚考完最后两门，概率论和大物B。都是一个小时写完，but后一个小时都检查出不少错误，果然是没有掌握好，还好没有提前交卷。</p>
<p>这学期算是废物的一个学期吧。草草总结一下：</p>
<h2 id="生活方面"><a href="#生活方面" class="headerlink" title="生活方面"></a>生活方面</h2><p>有一说一，余区的确挺美的，绿化做的不错（鸟特别多！！余区真的不是鸟不拉屎的地方，因为鸟屎真的真的超多），主楼也挺美的。屠猪馆虽然跟南湖没法比，但我觉得排武理第二应该没问题（西院和东院的图书馆都不怎么样）。屠猪馆五楼的管理员大叔也超好，每天8点开馆，他总是7点40就把5楼自习室打开了，而且他也是个书迷，他桌上一堆书，一边拿着水壶吃面，一边看书哈哈哈。</p>
<p>寝室里没热水，只能去接水or去澡堂，但海虹公寓属实敞亮，在寝室里面勉勉强强打打羽毛球也不是不可能的哈哈哈。</p>
<p>如果寝室里有热水的话，那么我认为最好的寝室就是海虹了/可惜没。</p>
<p>食堂中规中矩吧，没网上说的那么好吃（酱香鸭和黄焖鸡米饭好吃，并列第一；牛肉汤也好吃，排第二吧；自助里面的大鸡腿好吃，第三），但武理的食堂也都不怎么样，但南湖又建了新食堂（羡慕呀，里头还有电影院，早知道当时就填软工了，QAQ。</p>
<p>余区小，节奏慢，每天花在路上的时间不多，也算是一个优点吧。</p>
<h2 id="学习方面"><a href="#学习方面" class="headerlink" title="学习方面"></a>学习方面</h2><p>首先肯定是吐槽，这里的老师的授课水平真的和马区有较大差距，主要是这边专业少，大部分学院只是把授课的老师放在这边，导致没啥子竞争，老师自己也佛系。</p>
<p>电工电子实验的那个男老师我真的祝他 <strong>新年快乐</strong>。这B老师居然还是自动化学院的。</p>
<p>理学院的老师都不怎么样//都是老头老太在余区养老，还好之后就没啥子理学院的课了。</p>
<p>不明白别人学一学期甚至一学年的数据结构，埋土大学六个星期就结课，某东老师给分还贼低，89.1四个学分呀兄弟，能不能别扣平时分呀，你六个星期4个学分，你要我期末复习还要赶7个实验报告我真的痛苦呀。</p>
<p>本学院的老师授课水平也不怎么样，但感觉管的好严呀，严的不是过程，严的是验收。</p>
<p>多线程的巩老师很有个性哟，算是我目前余区最喜欢的老师之一（还有乒乓球的老师，还有跨文化交际的李老师），虽然没系统的学Java，但莫名其妙选了他的多线程实验，感觉自己还是有不少收获的。验收的时候也是超级严格：每个人上去展示程序，选一个模块，一行代码一行代码，一个变量一个变量解释。<del>这比必修还麻烦</del></p>
<p><em>可惜没选上巩老师的离散结构，也没选上李老师的英文影视赏析，乒乓球也没开中级班//////QAQ这也太惨了</em></p>
<p>这学期换了一种学习方式（大概就是自己太懒了把课都堆到期末补了，美其名曰新的学习方式），感觉大学里面期末笔试成绩高是有套路的，无脑看PPT和刷往年的题目就可了，貌似又回到了高中的应试的样子（仅限水课哟，重要的专业课可不能这样糊弄）。</p>
<p>收获了一个满绩——数字逻辑(3学分)  曹老师我男神，教课虽然捞，但给分高呀。</p>
<p>update:大物(5学分)也水了个满绩，运气好而已.</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>· 自习果然还是要去屠猪馆，去航海楼or主楼的效率都不高，下学期注意了！！！</p>
<p>· 老师差别很大，尤其是给分（我是俗人），选课一定要排雷呀兄弟。</p>
<p>· 不要翘课，这边的老师真特么喜欢扣平时分，一翘课就玩完了。</p>
<p>· 实验课不能划水呀，越划GPA就越没地方抠出来了。</p>
<p>· 应付考试的方法：考前确定好范围，看老师的PPT，看其他老师的PPT，刷题，刷以前的题目。</p>
<p>· 慎选课，选课一时爽，期末火葬场。</p>
<p>· 英语六级绝壁炸了，感觉在那里填了两个小时彩票。</p>
<h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><p>成绩都出来了，本以为会炸穿。好像没那么炸，大物满绩属实舒服hhhhh</p>
<p>寒假闹肺炎，不能回学校，在家里也学不进去，连代码都不想敲，只能看看网课骗骗自己.</p>
<p><strong>我现在要做的是走出舒适区，看网课划划水虽然不累，但也只是在安慰自己而已</strong></p>
<p>加油吧，已经放了一个月的假了，不能再浪了.</p>
<p>(补：武汉政府属实垃圾，祝抗疫前线安好)</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>学期总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习——Requests库</title>
    <url>/tpaaaaaa.github.io/2020/02/03/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Requests%E5%BA%93/</url>
    <content><![CDATA[<h1 id="Python学习——Requests库"><a href="#Python学习——Requests库" class="headerlink" title="Python学习——Requests库"></a>Python学习——Requests库</h1><p>用户文档:<a href="https://requests.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">https://requests.readthedocs.io/zh_CN/latest/</a></p>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><p>导入Requests模块</p>
<p>​    <code>step1： import requests</code></p>
<p>​    <code>step2:  r = requests.get(url)</code></p>
<p>其中 r 为 <strong>Response</strong> 对象</p>
<p>Other Example for HTTP 请求类型:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.put(<span class="string">'http://httpbin.org/put'</span>, data = &#123;<span class="string">'key'</span>:<span class="string">'value'</span>&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.delete(<span class="string">'http://httpbin.org/delete'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.head(<span class="string">'http://httpbin.org/get'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.options(<span class="string">'http://httpbin.org/get'</span>)</span></pre></td></tr></table></figure>

<p><em>[补充]关于HTTP请求:</em></p>
<p><em>根据 HTTP 标准，HTTP 请求可以使用多种请求方法。</em></p>
<p><em>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</em></p>
<p><em>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</em></p>
<h3 id="传递URL参数"><a href="#传递URL参数" class="headerlink" title="传递URL参数"></a>传递URL参数</h3><p>场景：google搜索某关键字</p>
<p>Requests 允许你使用 <code>params</code>关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递<code>key1=value1</code> 和 <code>key2=value2</code> 到 <code>httpbin.org/get</code> ，那么你可以使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>payload = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">"http://httpbin.org/get"</span>, params=payload)</span></pre></td></tr></table></figure>

<p>则此时实际的url为<code>http://httpbin.org/get?key2=value2&amp;key1=value1</code></p>
<p>你还可以将一个列表作为值传入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: [&#39;value2&#39;, &#39;value3&#39;]&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;payload)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; print(r.url)</span></pre></td></tr><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;value1&amp;key2&#x3D;value2&amp;key2&#x3D;value3</span></pre></td></tr></table></figure>



<p><strong>Example for this:</strong></p>
<p>百度：<code>https://www.baidu.com/s?wd=关键字</code></p>
<p>故：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kv = &#123;<span class="string">'wd'</span>: <span class="string">'你要搜的问的题'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">r =  requests.get(<span class="string">'https://www.baidu.com/s'</span>, params = kv)`</span></pre></td></tr></table></figure>

<p>Bilibili: <code>https://search.bilibili.com/all?keyword=关键字</code></p>
<p>故:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kv = &#123;<span class="string">'keyword'</span>: <span class="string">'你要搜的问的题'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">r =  requests.get(<span class="string">'https://search.bilibili.com/all'</span>, params = kv)`</span></pre></td></tr></table></figure>

<h3 id="响应内容"><a href="#响应内容" class="headerlink" title="响应内容"></a>响应内容</h3><p>能读取服务器响应的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> requests</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'https://api.github.com/events'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.text</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">u'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...</span></span></pre></td></tr></table></figure>

<p>Requests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。</p>
<p>请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 <code>r.text</code> 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用<code>r.encoding</code> 属性来改变它：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'utf-8'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.encoding = <span class="string">'ISO-8859-1'</span></span></pre></td></tr></table></figure>

<h2 id="二进制响应内容"><a href="#二进制响应内容" class="headerlink" title="二进制响应内容"></a>二进制响应内容</h2><p>你也能以字节的方式访问请求响应体，对于非文本请求：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.content</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">b'[&#123;"repository":&#123;"open_issues":0,"url":"https://github.com/...</span></span></pre></td></tr></table></figure>

<p>Requests 会自动为你解码 <code>gzip</code> 和 <code>deflate</code> 传输编码的响应数据。</p>
<p>例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = Image.open(BytesIO(r.content))</span></pre></td></tr></table></figure>

<h2 id="定制请求头"><a href="#定制请求头" class="headerlink" title="定制请求头"></a>定制请求头</h2><p>如果你想为请求添加 HTTP 头部，只要简单地传递一个 <code>dict</code>（列表） 给 <code>headers</code> 参数就可以了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>url = <span class="string">'https://movie.douban.com/'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>headers = &#123;<span class="string">'user-agent'</span>: <span class="string">'Mozilla/5.0'</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(url, headers=headers)</span></pre></td></tr></table></figure>

<h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>我们可以检测响应状态码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = requests.get(<span class="string">'http://httpbin.org/get'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">200</span></span></pre></td></tr></table></figure>

<p>为方便引用，Requests还附带了一个内置的状态码查询对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.status_code == requests.codes.ok</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="literal">True</span></span></pre></td></tr></table></figure>

<p>如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过<a href="https://requests.readthedocs.io/zh_CN/latest/api.html#requests.Response.raise_for_status" target="_blank" rel="noopener"><code>Response.raise_for_status()</code></a> 来抛出异常：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r = requests.get(<span class="string">'http://httpbin.org/status/404'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.status_code</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="number">404</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bad_r.raise_for_status()</span></pre></td></tr><tr><td class="code"><pre><span class="line">Traceback (most recent call last):</span></pre></td></tr><tr><td class="code"><pre><span class="line">  File <span class="string">"requests/models.py"</span>, line <span class="number">832</span>, <span class="keyword">in</span> raise_for_status</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">raise</span> http_error</span></pre></td></tr><tr><td class="code"><pre><span class="line">requests.exceptions.HTTPError: <span class="number">404</span> Client Error</span></pre></td></tr></table></figure>

<p>但是，由于我们的例子中 <code>r</code> 的 <code>status_code</code> 是 <code>200</code> ，当我们调用 <code>raise_for_status()</code> 时，得到的是：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.raise_for_status()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="literal">None</span></span></pre></td></tr></table></figure>

<p>一切都挺和谐哈。</p>
<h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>我们可以查看以一个 Python 字典形式展示的服务器响应头：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'content-encoding'</span>: <span class="string">'gzip'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'transfer-encoding'</span>: <span class="string">'chunked'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'connection'</span>: <span class="string">'close'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'server'</span>: <span class="string">'nginx/1.0.4'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'x-runtime'</span>: <span class="string">'148ms'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'etag'</span>: <span class="string">'"e1ca502697e5c9317743dc078f67693f"'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">'content-type'</span>: <span class="string">'application/json'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html" target="_blank" rel="noopener">RFC 2616</a>， HTTP 头部是大小写不敏感的。</p>
<p>因此，我们可以使用任意大写形式来访问这些响应头字段：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers[<span class="string">'Content-Type'</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'application/json'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>r.headers.get(<span class="string">'content-type'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">'application/json'</span></span></pre></td></tr></table></figure>

<p>它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 <a href="http://tools.ietf.org/html/rfc7230#section-3.2" target="_blank" rel="noopener">RFC 7230</a>:</p>
<blockquote>
<p>A recipient MAY combine multiple header fields with the same field name into one “field-name: field-value” pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.</p>
<p>接收者可以合并多个相同名称的 header 栏位，把它们合为一个 “field-name: field-value” 配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。</p>
</blockquote>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Requests库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python学习——Beautiful Soup</title>
    <url>/tpaaaaaa.github.io/2020/02/01/Python%E5%AD%A6%E4%B9%A0%E2%80%94%E2%80%94Beautiful%20Soup/</url>
    <content><![CDATA[<h1 id="Python学习——Beautiful-Soup"><a href="#Python学习——Beautiful-Soup" class="headerlink" title="Python学习——Beautiful Soup"></a>Python学习——Beautiful Soup</h1><h2 id="对象的种类"><a href="#对象的种类" class="headerlink" title="对象的种类"></a>对象的种类</h2><p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种:</p>
<p> <code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> .</p>
<h3 id="Tag类"><a href="#Tag类" class="headerlink" title="Tag类"></a>Tag类</h3><p><code>Tag</code> 对象与XML或HTML原生文档中的tag相同:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup = BeautifulSoup(<span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag = soup.b</span></pre></td></tr><tr><td class="code"><pre><span class="line">type(tag)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># &lt;class 'bs4.element.Tag'&gt;</span></span></pre></td></tr></table></figure>

<p>例如一个HTML <code>&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;</code></p>
<p><code>&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;</code>是一个标签tag</p>
<h4 id="Name"><a href="#Name" class="headerlink" title="Name"></a>Name</h4><p>每个标签tag都有自己的名字</p>
<p><code>&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;</code>这个tag的名字是b</p>
<p>可用<code>tag.name</code>获得</p>
<p>如果改变了tag的name,那将影响所有通过当前Beautiful Soup对象生成的HTML文档:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag.name &#x3D; &quot;blockquote&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;blockquote class&#x3D;&quot;boldest&quot;&gt;Extremely bold&lt;&#x2F;blockquote&gt;</span></pre></td></tr></table></figure>

<h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>一个tag可能有很多个属性. tag <code>&lt;b class=&quot;boldest&quot;&gt;</code> 有一个 “class” 的属性,值为 “boldest” .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag[&#39;class&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;boldest&#39;</span></pre></td></tr></table></figure>

<p>也可以直接”点”取属性, 比如: <code>.attrs</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag.attrs</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &#123;u&#39;class&#39;: u&#39;boldest&#39;&#125;</span></pre></td></tr></table></figure>

<p>tag的属性可以被添加,删除或修改. 再说一次, tag的属性操作方法与字典一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag[&#39;class&#39;] &#x3D; &#39;verybold&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag[&#39;id&#39;] &#x3D; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;blockquote class&#x3D;&quot;verybold&quot; id&#x3D;&quot;1&quot;&gt;Extremely bold&lt;&#x2F;blockquote&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">del tag[&#39;class&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">del tag[&#39;id&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;blockquote&gt;Extremely bold&lt;&#x2F;blockquote&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">tag[&#39;class&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"># KeyError: &#39;class&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(tag.get(&#39;class&#39;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># None</span></pre></td></tr></table></figure>

<h3 id="NavigableString-类"><a href="#NavigableString-类" class="headerlink" title="NavigableString 类"></a>NavigableString 类</h3><p>字符串常被包含在tag内.Beautiful Soup用 <code>NavigableString</code> 类来包装tag中的字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag.string</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;Extremely bold&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">type(tag.string)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span></pre></td></tr></table></figure>

<p><strong>一个 <code>NavigableString</code> 字符串与Python中的Unicode字符串相同</strong></p>
<p>通过 <code>unicode()</code>方法可以直接将 <code>NavigableString</code> 对象转换成Unicode字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unicode_string &#x3D; unicode(tag.string)</span></pre></td></tr><tr><td class="code"><pre><span class="line">unicode_string</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;Extremely bold&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">type(unicode_string)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;type &#39;unicode&#39;&gt;</span></pre></td></tr></table></figure>

<p>tag中包含的字符串不能编辑,但是可以被替换成其它的字符串,用 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#replace-with" target="_blank" rel="noopener">replace_with()</a> 方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tag.string.replace_with(&quot;No longer bold&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;blockquote&gt;No longer bold&lt;&#x2F;blockquote&gt;</span></pre></td></tr></table></figure>

<h3 id="BeautifulSoup类"><a href="#BeautifulSoup类" class="headerlink" title="BeautifulSoup类"></a>BeautifulSoup类</h3><p><code>BeautifulSoup</code> 对象表示的是一个文档的全部内容.大部分时候,可以把它<strong>当作 <code>Tag</code> 对象</strong></p>
<p>因为 <code>BeautifulSoup</code> 对象并不是真正的HTML或XML的tag,所以它没有name和attribute属性.但有时查看它的 <code>.name</code> 属性是很方便的,所以 <code>BeautifulSoup</code> 对象包含了一个值为 “[document]” 的特殊属性 <code>.name</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.name</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;[document]&#39;</span></pre></td></tr></table></figure>

<h3 id="Comment类"><a href="#Comment类" class="headerlink" title="Comment类"></a>Comment类</h3><p><code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象</p>
<p><code>Tag</code> , <code>NavigableString</code> , <code>BeautifulSoup</code> 几乎覆盖了html和xml中的所有内容,但是还有一些特殊对象.容易让人担心的内容是文档的注释部分:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markup &#x3D; &quot;&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;&#x2F;b&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">soup &#x3D; BeautifulSoup(markup)</span></pre></td></tr><tr><td class="code"><pre><span class="line">comment &#x3D; soup.b.string</span></pre></td></tr><tr><td class="code"><pre><span class="line">type(comment)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;class &#39;bs4.element.Comment&#39;&gt;</span></pre></td></tr></table></figure>

<h2 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h2><h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><p><strong>一个Tag可能包含多个字符串或其它的Tag</strong>,这些都是这个Tag的子节点.Beautiful Soup提供了许多操作和遍历子节点的属性.</p>
<p>注意: Beautiful Soup中字符串节点不支持这些属性,因为字符串没有子节点</p>
<h3 id="tag的名字"><a href="#tag的名字" class="headerlink" title="tag的名字"></a>tag的名字</h3><p>操作文档树最简单的方法就是告诉它你想获取的tag的name.如果想获取 <head> 标签,只要用 <code>soup.head</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.head</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.title</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr></table></figure>

<p>这是个获取tag的小窍门,可以在文档树的tag中多次调用这个方法.下面的代码可以获取<body>标签中的第一个<b>标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.body.b</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;</span></pre></td></tr></table></figure>

<p>通过点取属性的方式只能获得当前名字的第一个tag:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.a</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;</span></pre></td></tr></table></figure>

<p>如果想要得到所有的<a>标签,或是通过名字得到比一个tag更多的内容的时候,就需要用到 Searching the tree 中描述的方法,比如: find_all()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&#39;a&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<h3 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h3><p>tag的 <code>.contents</code> 属性可以将tag的子节点（如果他的下面没有子tag，那么它的<code>NavigableString</code> 会存入list中）以列表的方式输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head_tag &#x3D; soup.head</span></pre></td></tr><tr><td class="code"><pre><span class="line">head_tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;head&gt;&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">head_tag.contents</span></pre></td></tr><tr><td class="code"><pre><span class="line">[&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">title_tag &#x3D; head_tag.contents[0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">title_tag</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">title_tag.contents</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [u&#39;The Dormouse&#39;s story&#39;]</span></pre></td></tr></table></figure>

<p>字符串没有 <code>.contents</code> 属性,因为字符串没有子节点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">text &#x3D; title_tag.contents[0]</span></pre></td></tr><tr><td class="code"><pre><span class="line">text.contents</span></pre></td></tr><tr><td class="code"><pre><span class="line"># AttributeError: &#39;NavigableString&#39; object has no attribute &#39;contents&#39;</span></pre></td></tr></table></figure>

<p><code>BeautifulSoup</code> 对象本身一定会包含子节点,也就是说<html>标签也是 <code>BeautifulSoup</code> 对象的子节点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(soup.contents)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.contents[0].name</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;html&#39;</span></pre></td></tr></table></figure>

<p>通过tag的 <code>.children</code> 生成器（有迭代器）,可以对tag的子节点进行循环:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for child in title_tag.children:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(child)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # The Dormouse&#39;s story</span></pre></td></tr></table></figure>

<h3 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h3><p><code>.contents</code> 和 <code>.children</code> 属性仅包含tag的直接子节点.例如,<head>标签只有一个直接子节点<title></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head_tag.contents</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr></table></figure>

<p>但是<title>标签也包含一个子节点:字符串 “The Dormouse’s story”,这种情况下字符串 “The Dormouse’s story”也属于<head>标签的子孙节点. <code>.descendants</code> 属性可以对所有tag的子孙节点进行递归循环 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id86" target="_blank" rel="noopener">[5]</a> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for child in head_tag.descendants:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(child)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # The Dormouse&#39;s story</span></pre></td></tr></table></figure>

<p>上面的例子中, <head>标签只有一个子节点,但是有2个子孙节点:<head>节点和<head>的子节点, <code>BeautifulSoup</code> 有一个直接子节点(<html>节点),却有很多子孙节点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">len(list(soup.children))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">len(list(soup.descendants))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># 25</span></pre></td></tr></table></figure>

<h3 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h3><p>如果tag只有一个 <code>NavigableString</code> 类型子节点,那么这个tag可以使用 <code>.string</code> 得到子节点:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title_tag.string</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;The Dormouse&#39;s story&#39;</span></pre></td></tr></table></figure>

<p>如果一个tag仅有一个子节点,那么这个tag也可以使用 <code>.string</code> 方法,输出结果与当前唯一子节点的 <code>.string</code> 结果相同:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head_tag.contents</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">head_tag.string</span></pre></td></tr><tr><td class="code"><pre><span class="line"># u&#39;The Dormouse&#39;s story&#39;</span></pre></td></tr></table></figure>

<p>如果tag包含了多个子节点,tag就无法确定 <code>.string</code> 方法应该调用哪个子节点的内容, <code>.string</code> 的输出结果是 <code>None</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.html.string)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># None</span></pre></td></tr></table></figure>

<h2 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h2><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>最简单的过滤器是字符串.在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容,下面的例子用于查找文档中所有的<b>标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&#39;b&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;]</span></pre></td></tr></table></figure>

<p>如果传入字节码参数,Beautiful Soup会当作UTF-8编码,可以传入一段Unicode 编码来避免Beautiful Soup解析编码出错</p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>如果传入正则表达式作为参数,Beautiful Soup会通过正则表达式的 <code>match()</code> 来匹配<strong>标签</strong>，每个标签都是独立的一行。下面例子中找出所有以b开头的<strong>标签</strong>,这表示<body>和<b>标签都应该被找到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span></pre></td></tr><tr><td class="code"><pre><span class="line">for tag in soup.find_all(re.compile(&quot;^b&quot;)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(tag.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># body</span></pre></td></tr><tr><td class="code"><pre><span class="line"># b</span></pre></td></tr></table></figure>

<p>下面代码找出所有名字中包含”t”的标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for tag in soup.find_all(re.compile(&quot;t&quot;)):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(tag.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># html</span></pre></td></tr><tr><td class="code"><pre><span class="line"># title</span></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>如果传入列表参数,Beautiful Soup会将与列表中任一元素匹配的内容返回.下面代码找到文档中所有<a>标签和<b>标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all([&quot;a&quot;, &quot;b&quot;])</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<h4 id="True"><a href="#True" class="headerlink" title="True"></a>True</h4><p><code>True</code> 可以匹配任何值,下面代码查找到所有的tag,但是不会返回字符串节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for tag in soup.find_all(True):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    print(tag.name)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># html</span></pre></td></tr><tr><td class="code"><pre><span class="line"># head</span></pre></td></tr><tr><td class="code"><pre><span class="line"># title</span></pre></td></tr><tr><td class="code"><pre><span class="line"># body</span></pre></td></tr><tr><td class="code"><pre><span class="line"># p</span></pre></td></tr><tr><td class="code"><pre><span class="line"># b</span></pre></td></tr><tr><td class="code"><pre><span class="line"># p</span></pre></td></tr><tr><td class="code"><pre><span class="line"># a</span></pre></td></tr><tr><td class="code"><pre><span class="line"># a</span></pre></td></tr><tr><td class="code"><pre><span class="line"># a</span></pre></td></tr><tr><td class="code"><pre><span class="line"># p</span></pre></td></tr></table></figure>

<h4 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h4><p>如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id85" target="_blank" rel="noopener">[4]</a> ,如果这个方法返回 <code>True</code> 表示当前元素匹配并且被找到,如果不是则反回 <code>False</code></p>
<p>下面方法校验了当前元素,如果包含 <code>class</code> 属性却不包含 <code>id</code> 属性,那么将返回 <code>True</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def has_class_but_no_id(tag):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return tag.has_attr(&#39;class&#39;) and not tag.has_attr(&#39;id&#39;)</span></pre></td></tr></table></figure>

<p>将这个方法作为参数传入 <code>find_all()</code> 方法,将得到所有<p>标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(has_class_but_no_id)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;p class&#x3D;&quot;story&quot;&gt;Once upon a time there were...&lt;&#x2F;p&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;p class&#x3D;&quot;story&quot;&gt;...&lt;&#x2F;p&gt;]</span></pre></td></tr></table></figure>

<p>返回结果中只有<p>标签没有<a>标签,因为<a>标签还定义了”id”,没有返回<html>和<head>,因为<html>和<head>中没有定义”class”属性.</p>
<h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h3><p>find_all( <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id32" target="_blank" rel="noopener">name</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#css" target="_blank" rel="noopener">attrs</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#recursive" target="_blank" rel="noopener">recursive</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#text" target="_blank" rel="noopener">text</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#keyword" target="_blank" rel="noopener">**kwargs</a> )</p>
<p><code>find_all()</code> 方法搜索当前tag的所有tag<strong>子孙节点</strong>,并判断是否符合过滤器的条件.这里有几个例子:</p>
<h4 id="name参数"><a href="#name参数" class="headerlink" title="name参数"></a>name参数</h4><p><code>name</code> 参数可以查找所有名字为 <code>name</code> 的tag,字符串对象会被自动忽略掉.</p>
<p>简单的用法如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;title&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr></table></figure>

<p>重申: 搜索 <code>name</code> 参数的值可以使任一类型的 <strong><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id25" target="_blank" rel="noopener">过滤器</a> ,字符串,正则表达式,列表,方法或是 <code>True</code> .</strong></p>
<h4 id="keyword参数"><a href="#keyword参数" class="headerlink" title="keyword参数"></a>keyword参数</h4><p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索,如果包含一个名字为 <code>id</code> 的参数,Beautiful Soup会搜索每个tag的”id”属性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(id&#x3D;&#39;link2&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p>如果传入 <code>href</code> 参数,Beautiful Soup会搜索每个tag的”href”属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(href&#x3D;re.compile(&quot;elsie&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p>搜索指定名字的属性时可以使用的参数值包括 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id27" target="_blank" rel="noopener">字符串</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id28" target="_blank" rel="noopener">正则表达式</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id29" target="_blank" rel="noopener">列表</a>, <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#true" target="_blank" rel="noopener">True</a> .</p>
<p>下面的例子在文档树中查找所有包含 <code>id</code> 属性的tag,无论 <code>id</code> 的值是什么:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(id&#x3D;True)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p>使用多个指定名字的参数可以同时过滤tag的多个属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(href&#x3D;re.compile(&quot;elsie&quot;), id&#x3D;&#39;link1&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;three&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_soup &#x3D; BeautifulSoup(&#39;&lt;div data-foo&#x3D;&quot;value&quot;&gt;foo!&lt;&#x2F;div&gt;&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">data_soup.find_all(data-foo&#x3D;&quot;value&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># SyntaxError: keyword can&#39;t be an expression</span></pre></td></tr></table></figure>

<p>但是可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的tag:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data_soup.find_all(attrs&#x3D;&#123;&quot;data-foo&quot;: &quot;value&quot;&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;div data-foo&#x3D;&quot;value&quot;&gt;foo!&lt;&#x2F;div&gt;]</span></pre></td></tr></table></figure>

<h4 id="按CSS搜索"><a href="#按CSS搜索" class="headerlink" title="按CSS搜索"></a>按CSS搜索</h4><p>按照CSS类名搜索tag的功能非常实用,但标识CSS类名的关键字 <code>class</code> 在Python中是保留字,使用 <code>class</code> 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 <code>class_</code> 参数搜索有指定CSS类名的tag:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, class_&#x3D;&quot;sister&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p><code>class_</code> 参数同样接受不同类型的 <code>过滤器</code> ,字符串,正则表达式,方法或 <code>True</code> :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(class_&#x3D;re.compile(&quot;itl&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;p class&#x3D;&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#39;s story&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def has_six_characters(css_class):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return css_class is not None and len(css_class) &#x3D;&#x3D; 6</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find_all(class_&#x3D;has_six_characters)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<p>tag的 <code>class</code> 属性是 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id12" target="_blank" rel="noopener">多值属性</a> .按照CSS类名搜索tag时,可以分别搜索tag中的每个CSS类名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css_soup &#x3D; BeautifulSoup(&#39;&lt;p class&#x3D;&quot;body strikeout&quot;&gt;&lt;&#x2F;p&gt;&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">css_soup.find_all(&quot;p&quot;, class_&#x3D;&quot;strikeout&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;p class&#x3D;&quot;body strikeout&quot;&gt;&lt;&#x2F;p&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">css_soup.find_all(&quot;p&quot;, class_&#x3D;&quot;body&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;p class&#x3D;&quot;body strikeout&quot;&gt;&lt;&#x2F;p&gt;]</span></pre></td></tr></table></figure>

<p>搜索 <code>class</code> 属性时也可以通过CSS值完全匹配:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css_soup.find_all(&quot;p&quot;, class_&#x3D;&quot;body strikeout&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;p class&#x3D;&quot;body strikeout&quot;&gt;&lt;&#x2F;p&gt;]</span></pre></td></tr></table></figure>

<p>完全匹配 <code>class</code> 的值时,如果CSS类名的顺序与实际不符,将搜索不到结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, attrs&#x3D;&#123;&quot;class&quot;: &quot;sister&quot;&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;tillie&quot; id&#x3D;&quot;link3&quot;&gt;Tillie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<h4 id="text参数"><a href="#text参数" class="headerlink" title="text参数"></a>text参数</h4><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容.与 <code>name</code> 参数的可选值一样, <code>text</code> 参数接受 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id27" target="_blank" rel="noopener">字符串</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id28" target="_blank" rel="noopener">正则表达式</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id29" target="_blank" rel="noopener">列表</a>, <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#true" target="_blank" rel="noopener">True</a> . 看例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(text&#x3D;&quot;Elsie&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [u&#39;Elsie&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find_all(text&#x3D;[&quot;Tillie&quot;, &quot;Elsie&quot;, &quot;Lacie&quot;])</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find_all(text&#x3D;re.compile(&quot;Dormouse&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">[u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">def is_the_only_string_within_a_tag(s):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &quot;&quot;Return True if this string is the only child of its parent tag.&quot;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return (s &#x3D;&#x3D; s.parent.string)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find_all(text&#x3D;is_the_only_string_within_a_tag)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [u&quot;The Dormouse&#39;s story&quot;, u&quot;The Dormouse&#39;s story&quot;, u&#39;Elsie&#39;, u&#39;Lacie&#39;, u&#39;Tillie&#39;, u&#39;...&#39;]</span></pre></td></tr></table></figure>

<p>虽然 <code>text</code> 参数用于搜索字符串,还可以与其它参数混合使用来过滤tag.Beautiful Soup会找到 <code>.string</code> 方法与 <code>text</code> 参数值相符的tag.下面代码用来搜索内容里面包含“Elsie”的<a>标签:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, text&#x3D;&quot;Elsie&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; class&#x3D;&quot;sister&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<h4 id="limit参数"><a href="#limit参数" class="headerlink" title="limit参数"></a>limit参数</h4><p><code>find_all()</code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 <code>limit</code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code>limit</code> 的限制时,就停止搜索返回结果.</p>
<p>文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;, limit&#x3D;2)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;elsie&quot; id&#x3D;&quot;link1&quot;&gt;Elsie&lt;&#x2F;a&gt;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">#  &lt;a class&#x3D;&quot;sister&quot; href&#x3D;&quot;http:&#x2F;&#x2F;example.com&#x2F;lacie&quot; id&#x3D;&quot;link2&quot;&gt;Lacie&lt;&#x2F;a&gt;]</span></pre></td></tr></table></figure>

<h4 id="recursive-参数"><a href="#recursive-参数" class="headerlink" title="recursive 参数"></a>recursive 参数</h4><p>调用tag的 <code>find_all()</code> 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 <code>recursive=False</code> .</p>
<p>一段简单的文档:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   The Dormouse&#39;s story</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> &lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure>

<p>是否使用 <code>recursive</code> 参数的搜索结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.html.find_all(&quot;title&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.html.find_all(&quot;title&quot;, recursive&#x3D;False)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># []</span></pre></td></tr></table></figure>

<h3 id="find-all-的简写方式"><a href="#find-all-的简写方式" class="headerlink" title="find_all()的简写方式"></a>find_all()的简写方式</h3><p><code>find_all()</code> 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. <code>BeautifulSoup</code> 对象和 <code>tag</code> 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 <code>find_all()</code> 方法相同,下面两行代码是等价的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&quot;a&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">soup(&quot;a&quot;)</span></pre></td></tr></table></figure>

<p>这两行代码也是等价的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.title.find_all(text&#x3D;True)</span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.title(text&#x3D;True)</span></pre></td></tr></table></figure>

<h3 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h3><p>find( <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id32" target="_blank" rel="noopener">name</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#css" target="_blank" rel="noopener">attrs</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#recursive" target="_blank" rel="noopener">recursive</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#text" target="_blank" rel="noopener">text</a> , <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#keyword" target="_blank" rel="noopener">**kwargs</a> )</p>
<p><code>find_all()</code> 方法将返回文档中符合条件的所有tag,尽管有时候我们只想得到一个结果.比如文档中只有一个<body>标签,那么使用 <code>find_all()</code>方法来查找<body>标签就不太合适, 使用 <code>find_all</code> 方法并设置 <code>limit=1</code> 参数不如直接使用 <code>find()</code> 方法.下面两行代码是等价的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.find_all(&#39;title&#39;, limit&#x3D;1)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># [&lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find(&#39;title&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr></table></figure>

<p>唯一的区别是 <code>find_all()</code> 方法的返回结果是值<strong>包含一个元素的列表</strong>,而 <code>find()</code> 方法直接返回结果.</p>
<p><code>find_all()</code> 方法没有找到目标是返回空列表, <code>find()</code> 方法找不到目标时,返回 <code>None</code> .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(soup.find(&quot;nosuchtag&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line"># None</span></pre></td></tr></table></figure>

<p><code>soup.head.title</code> 是 <a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html#id17" target="_blank" rel="noopener">tag的名字</a> 方法的简写.这个简写的原理就是多次调用当前tag的 <code>find()</code> 方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">soup.head.title</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">soup.find(&quot;head&quot;).find(&quot;title&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"># &lt;title&gt;The Dormouse&#39;s story&lt;&#x2F;title&gt;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Beautiful Soup</tag>
      </tags>
  </entry>
  <entry>
    <title>1D/1D动态规划优化</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1D1D%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>优秀博文： <a href="https://blog.bill.moe/1d1d-DP-optimization-notes/" target="_blank" rel="noopener">https://blog.bill.moe/1d1d-DP-optimization-notes/</a></p>
<p>所谓1D/1D动态规划，指的是状态数为O(n)，每一个状态决策量为O(n)的动态规划方程，直接求解的时间复杂度O(n2)。但是，绝大多数的方程通过合理的组织与优化都是可以直接优化到O(nlog⁡n)乃O(n)的时间复杂度的。<br>优化方法包括：</p>
<ul>
<li>单调队列优化至O(n)</li>
<li>斜率优化至O(nlog⁡n)或O(n)</li>
<li>决策单调性优化至O(nlogn)</li>
</ul>
<h2 id="斜率优化："><a href="#斜率优化：" class="headerlink" title="斜率优化："></a>斜率优化：</h2><p><a href="https://blog.flyinthesky.win/sz%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/" target="_blank" rel="noopener">https://blog.flyinthesky.win/sz%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1087: [SCOI2005]互不侵犯King</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1087%5BSCOI2005%5D%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　在N×N的棋盘里面放K个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上<br>左下右上右下八个方向上附近的各一个格子，共8个格子。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　只有一行，包含两个数N，K （ 1 &lt;=N &lt;=9, 0 &lt;= K &lt;= N * N）</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　方案数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>3 2</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>16</p>
<p>分析：</p>
<p>棋盘上的DP，通常可以考虑一行一行的决策.</p>
<p>代码：</p>
<pre><code>/*
Date              : 2019-12-01    19:17:53
By                : Tpaaaaaa
File_Name         ：1087SCOI2005互不侵犯King.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 15;
ll dp[MAXN][1000][MAXN*MAXN];
int n, K;
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;K) != EOF)
    {
        memset(dp, 0, sizeof dp);
        dp[0][0][0] = 1;
        for(int i = 1; i &lt;= n; i++)
            for(int j = 0; j &lt; (1&lt;&lt;n); j++)
                for(int k = 0; k &lt;= K; k++)
                {
                    dp[i][j][k] = 0;
                    if(j &amp; (j &gt;&gt; 1)) continue;//看本行j状态行不行.
                    int cnt = 0;                //本行放了多少个
                    int temp = j;
                    while(temp)
                    {
                        if(temp&amp;1) cnt++;
                        temp &gt;&gt;= 1;
                    }
                    if(cnt &gt; k) continue;            //本行放的数目大于k了，不可能.
                    for(int o = 0; o &lt; (1&lt;&lt;n); o++)
                        if((j &gt;&gt; 1)&amp;o || (j &lt;&lt; 1)&amp;o || j&amp;o)    continue;
                        else
                        {
                            dp[i][j][k] += dp[i - 1][o][k - cnt];
                        }

                    //然后枚举下一个状态.
                }
        ll ans = 0;
        for(int i = 0; i &lt; (1 &lt;&lt; n); i++)
            ans += dp[n][i][K];
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1031: [JSOI2007]字符加密Cipher</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1031%5BJSOI2007%5D%E5%AD%97%E7%AC%A6%E5%8A%A0%E5%AF%86Cipher/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　喜欢钻研问题的JS同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。例如下图，可以读作：</p>
<p><img src="https://www.lydsy.com/JudgeOnline/images/1031/1.jpg" alt=""></p>
<p>JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0把它们按照字符串的大小排序：07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　输出一行，为加密后的字符串。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>JSOI07</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>I0O7SJ</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>对于100%的数据字符串的长度不超过100000。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>后缀数组入门题.模板</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-02    22:55:20
By                : Tpaaaaaa
File_Name         ：1031JSOI2007字符加密Cipher.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
char s[MAXN];
int rk[2][MAXN], sa[2][MAXN];
int v[MAXN];                //为什么是MAXN？？
int k, n;
void calcsa(int sa[MAXN], int rk[MAXN], int SA[MAXN], int RK[MAXN])
{
    for(int i = 1; i &lt;= n; i++)
        v[rk[sa[i]]] = i;
    for(int i = n; i &gt;= 1; i--)
        if(sa[i] &gt; k)
            SA[v[rk[sa[i] - k]]--] = sa[i] - k;
    for(int i = n - k + 1; i &lt;= n; i++)
        SA[v[rk[i]]--] = i;
    for(int i = 1; i &lt;= n; i++)
        RK[SA[i]] = RK[SA[i - 1]] + (rk[SA[i - 1]] != rk[SA[i]] || rk[SA[i - 1] + k] != rk[SA[i] + k]);

}
void work(char s[])
{
    int p = 0, q = 1;
    for(int i = 1; i &lt;= n; i++) v[s[i]]++;
    for(int i = 1; i &lt;= 256; i++)   v[i] += v[i - 1];
    for(int i = 1; i &lt;= n; i++)
        sa[p][v[s[i]]--] = i;
    for(int i = 1; i &lt;= n; i++)
        rk[p][sa[p][i]] = rk[p][sa[p][i-1]] + (s[sa[p][i-1]] != s[sa[p][i]]);
    k = 1;
    while(k &lt; n)
    {
        calcsa(sa[p], rk[p], sa[q], rk[q]);
        p^=1;
        q^=1;
        k&lt;&lt;=1;
    }/*
    for(int i = 1; i &lt;= n; i++)
    {
        printf(&quot;%d &quot;, sa[p][i]);
    }
    printf(&quot;\n&quot;);*/
    for(int i = 1; i &lt;= n; i++)
    {
        if(sa[p][i] &lt;= n / 2)
            printf(&quot;%c&quot;, s[sa[p][i] + n / 2 - 1]);
    }

}
int main()
{
    scanf(&quot;%s&quot;, s + 1);
    n = strlen(s + 1);
    for(int i = 1; i &lt;= n; i++)
    {
        s[i + n] = s[i];
    }
    n *= 2;
    work(s);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1015: [JSOI2008]星球大战starwar</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1015%5BJSOI2008%5D%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98starwar/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的<br>机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直<br>接或间接地连接。 但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划<br>地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首<br>领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每<br>一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则<br>这两个星球在同一个连通块中）。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　输入文件第一行包含两个整数，N (1  &lt; =  N  &lt; =  2M) 和M (1  &lt; =  M  &lt; =  200,000)，分别表示星球的<br>数目和以太隧道的数目。星球用 0 ~ N-1的整数编号。接下来的M行，每行包括两个整数X, Y，其中（0 &lt; = X &lt;&gt;<br>Y 表示星球x和星球y之间有“以太”隧道，可以直接通讯。接下来的一行为一个整数k，表示将遭受攻击的星球的<br>数目。接下来的k行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这k个数互不相同，且都在0到n-1的范<br>围内。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>第一行是开始时星球的连通块个数。接下来的K行，每行一个整数，表示经过该次打击后现存星球<br>的连通块个数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>8 13<br>0 1<br>1 6<br>6 5<br>5 0<br>0 6<br>1 2<br>2 3<br>3 4<br>4 5<br>7 1<br>7 2<br>7 6<br>3 6<br>5<br>1<br>6<br>3<br>5<br>7</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>1<br>1<br>1<br>2<br>3<br>3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>离线处理。将一个一个删点，变成一个一个填点，所以逆序处理询问，填点过程用并查集实现。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    14:41:03
By                : Tpaaaaaa
File_Name         ：1015JSOI2008星球大战starwar.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

离线处理，从后往前.
就相当于填边.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXM = 2e5 + 10;
const int MAXN = 4e5 + 10;
int id[MAXN];
vector &lt;int&gt; vec[MAXN];
bool limit[MAXN];
int pre[MAXN], ans[MAXN];
struct Edge
{
    int e;
    int u, v;
}edge[MAXM];
int getRoot(int u)
{
    if(pre[u] == u) return u;
    else return pre[u] = getRoot(pre[u]);
}
int main()
{
    int n, m;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) !=EOF)
    {
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            edge[i].u = u;
            edge[i].v = v;          //这是边.
            vec[u].push_back(i);
            vec[v].push_back(i);
        }
        //首先初始状态是没有哪些被删除的点的图.
        //此时的连通分量的数目，就是该图的连通分量的数目减去被删除的点的数目.
        //每一次从后往前添加一个点，就把与之相连的边填上(前提是连的那个点存在)
        //理论上来说，如果该点有边，那么至少会减少一个连通分量
        //所以总的减少的连通分量数就是填边的时候，两点的根节点不同的时候，就++
        //最后减一次他自己.
        int k;
        memset(limit, false, sizeof limit);
        scanf(&quot;%d&quot;, &amp;k);
        for(int i = 1; i &lt;= k; i++)
        {
            int u;
            scanf(&quot;%d&quot;, &amp;u);
            id[i] = u;
            limit[u] = true;                //u点要删除.
        }
        int col = 0;                        //初始的连通分量.
        //枚举边.
        for(int i = 0; i &lt; n; i++) 
            pre[i] = i;
        for(int i = 1; i &lt;= m; i++)
        {
            if(limit[edge[i].v] || limit[edge[i].u])    //这个边已经被删了.
                continue;
            int fa = getRoot(edge[i].v);
            int fb = getRoot(edge[i].u);
            if(fa != fb)
                pre[fa] = fb;
        }
        for(int i = 0; i &lt; n; i++)
            if(!limit[i] &amp;&amp; pre[i] == i) col++;
        ans[k + 1] = col;
        for(int i = k; i &gt;= 1; i--)
        {
            int u = id[i];                     //当前要添加的
            limit[u] = false;                       //恢复
            int ret = 0;
            for(int j = 0; j &lt; vec[u].size(); j++)  //枚举与他相邻的点
            {   
                int v;
                if((v = edge[vec[u][j]].v) == u)
                    v = edge[vec[u][j]].u;
                if(limit[v])    continue;           //该点还不存在.
                int fa = getRoot(u);
                int fb = getRoot(v);
                if(fa != fb)                        //合并两个连通分量，总数减少
                {
                    ret++;
                    pre[fa] = fb;
                }
            }
            ret = ret - 1;
            ans[i] = ans[i + 1] - ret;
        }

        for(int i = 1; i &lt;= k + 1; i++)
            printf(&quot;%d\n&quot;, ans[i]);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1013: [JSOI2008]球形空间产生器sphere</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1013%5BJSOI2008%5D%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8sphere/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　有一个球形空间产生器能够在n维空间中产生一个坚硬的球体。现在，你被困在了这个n维球体中，你只知道球<br>面上n+1个点的坐标，你需要以最快的速度确定这个n维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　第一行是一个整数n(1&lt;=N=10)。接下来的n+1行，每行有n个实数，表示球面上一点的n维坐标。每一个实数精确到小数点<br>后6位，且其绝对值都不超过20000。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　有且只有一行，依次给出球心的n维坐标（n个实数），两个实数之间用一个空格隔开。每个实数精确到小数点<br>后3位。数据保证有解。你的答案必须和标准输出一模一样才能够得分。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>2<br>0.0 0.0<br>-1.0 1.0<br>1.0 0.0</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>0.500 1.500</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><p>　　提示：给出两个定义：1、 球心：到球面上任意一点距离都相等的点。2、 距离：设两个n为空间上的点A, B  </p>
<p>的坐标为(a1, a2, …, an), (b1, b2, …, bn)，则AB的距离定义为：dist = sqrt( (a1-b1)^2 + (a2-b2)^2 +   </p>
<p>… + (an-bn)^2 )</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>高斯消元解浮点方程。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    14:10:08
By                : Tpaaaaaa
File_Name         ：1013JSOI2008球形空间产生器sphere.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

//有n个方程
(2x1 - 2x2)x  + (2y1 - 2y2)y + (2z1 - 2z2) = (x1^2 + y1^2 + z1^2) - (x2^2 + y2^2 + z2^2).


所以得到
 (2x1 - 2x2)  (2y1 - 2y2)  (2z1 - 2z2) 
 (2x1 - 2x3)  (2y1 - 2y3)  (2z1 - 2z3)
 (2x1 - 2x4)  (2y1 - 2y4)  (2z1 - 2z4)
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 20;

double a[MAXN][MAXN];
double X[MAXN][MAXN];
int equ,var;//equ个方程,var个变量
double x[MAXN];//解集
bool free_x[MAXN];
int n;
int sgn(double x)
{
    return (x&gt;eps)-(x&lt;-eps);
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(0表示无解，1表示唯一解，大于1表示无穷解，并返回自由变元的个数)
int gauss()
{
    equ=n,var=n;//多少个方程，多少个变量
    int i,j,k;
    int max_r; // 当前这列绝对值最大的行.
    int col; // 当前处理的列.
    double temp;
    int free_x_num;
    int free_index;
    // 转换为阶梯阵.
    col=0; // 当前处理的列.
    memset(free_x,true,sizeof(free_x));
    for(k=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++)
    {
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(sgn(fabs(a[i][col])-fabs(a[max_r][col]))&gt;0)
                max_r=i;
        }
        if(max_r!=k)
        { // 与第k行交换.
            for(j=k;j&lt;var+1;j++)
                swap(a[k][j],a[max_r][j]);
        }
        if(sgn(a[k][col])==0)
        { // 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--; continue;
        }
        for(i=k+1;i&lt;equ;i++)
        { // 枚举要删去的行.
            if (sgn(a[i][col])!=0)
            {
                temp=a[i][col]/a[k][col];
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j]=a[i][j]-a[k][j]*temp;
                }
            }
        }
    }

    for(i=k;i&lt;equ;i++)
    {
        if (sgn(a[i][col])!=0)
            return 0;
    }
    if(k&lt;var)
    {
        for(i=k-1;i&gt;=0;i--)
        {
            free_x_num=0;
            for(j=0;j&lt;var;j++)
            {
                if (sgn(a[i][j])!=0&amp;&amp;free_x[j])
                    free_x_num++,free_index=j;
            }
            if(free_x_num&gt;1) continue;
            temp=a[i][var];
            for(j=0;j&lt;var;j++)
            {
                if(sgn(a[i][j])!=0&amp;&amp;j!=free_index)
                    temp-=a[i][j]*x[j];
            }
            x[free_index]=temp/a[i][free_index];
            free_x[free_index]=0;
        }
        return var-k;
    }

    for (i=var-1;i&gt;=0;i--)
    {
        temp=a[i][var];
        for(j=i+1;j&lt;var;j++)
        {
            if(sgn(a[i][j])!=0)
                temp-=a[i][j]*x[j];
        }
        x[i]=temp/a[i][i];

    }
    return 1;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n + 1; i++)
        {
            for(int j = 1; j &lt;= n; j++)
            {
                scanf(&quot;%lf&quot;, &amp;X[i][j]);
            }
        }
        for(int i = 2; i &lt;= n + 1; i++)
        {
            a[i - 2][n] = 0.0;
            for(int j = 1; j &lt;= n; j++)
            {
                a[i - 2][j - 1] = 2*X[1][j] - 2*X[i][j];
                a[i - 2][n] += X[1][j]*X[1][j] - X[i][j]*X[i][j];
            }
        }
        gauss();
        /*for(int i = 0; i &lt; n; i++)
        {
            for(int j = 0; j &lt;= n; j++)
                printf(&quot;%.2lf &quot;, a[i][j]);
            printf(&quot;\n&quot;);
        }*/
        for(int i = 0; i &lt; n; i++)
            printf(&quot;%.3lf &quot;,x[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1003: [ZJOI2006]物流运输</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1003%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　物流公司要把一批货物从码头A运到码头B。由于货物量比较大，需要n天才能运完。货物运输过程中一般要转<br>停好几个码头。物流公司通常会设计一条固定的运输路线，以便对整个运输过程实施严格的管理和跟踪。由于各种<br>因素的存在，有的时候某个码头会无法装卸货物。这时候就必须修改运输路线，让货物能够按时到达目的地。但是<br>修改路线是一件十分麻烦的事情，会带来额外的成本。因此物流公司希望能够订一个n天的运输计划，使得总成本<br>尽可能地小。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　第一行是四个整数n（1&lt;=n&lt;=100）、m（1&lt;=m&lt;=20）、K和e。n表示货物运输所需天数，m表示码头总数，K表示<br>每次修改运输路线所需成本。接下来e行每行是一条航线描述，包括了三个整数，依次表示航线连接的两个码头编<br>号以及航线长度（&gt;0）。其中码头A编号为1，码头B编号为m。单位长度的运输费用为1。航线是双向的。再接下来<br>一行是一个整数d，后面的d行每行是三个整数P（ 1 &lt; P &lt; m）、a、b（1&lt; = a &lt; = b &lt; = n）。表示编号为P的码<br>头从第a天到第b天无法装卸货物（含头尾）。同一个码头有可能在多个时间段内不可用。但任何时间都存在至少一<br>条从码头A到码头B的运输路线。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　包括了一个整数表示最小的总成本。总成本=n天运输路线长度之和+K*改变运输路线的次数。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>5 5 10 8<br>1 2 1<br>1 3 3<br>1 4 2<br>2 3 2<br>2 4 4<br>3 4 1<br>3 5 2<br>4 5 2<br>4<br>2 2 3<br>3 1 1<br>3 3 3<br>4 4 5  </p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>32<br>//前三天走1-4-5，后两天走1-3-5，这样总成本为(2+2)*3+(3+2)*2+10=32</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>先通过SPFA求出cost[i][j] 表示的是从第i天到第j天，用同一个路线的最小代价，也就是在第i天到第j天都开放的港口组成的最短路乘上天数(j - i + 1)。</p>
<p>然后设dp[i]表示前i天的最小总代价.</p>
<p>可知dp[i] = min{dp[k] + cost[k + 1][j] + K},其中 0 &lt; k &lt; i;</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    11:05:35
By                : Tpaaaaaa
File_Name         ：1003ZJOI2006物流运输.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 25;
const int MAXM = MAXN * MAXN * 2;
int n, m, e, k, cnt;
int head[MAXN];
int dp[110];
bool limit[MAXN][110];
bool vis[MAXN];
int mp[MAXN][MAXN];
int cost[110][110], dis[MAXN];
struct Edge
{
    int v, w, next;
}edge[10000];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
//u在这个期间[s, t]不能用.
inline bool check(int u, int s, int t)
{
    for(int i = s; i &lt;= t; i++)
        if(limit[u][i]) return false;
    return true;
}
void bellman_ford(int s, int t)
{
    queue&lt; int &gt; q;
    memset(vis,false,sizeof vis);
    for(int i = 1; i &lt;= m; i++)
        dis[i] = INF;
    dis[1] = 0;
    q.push(1);
    vis[1] = true;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false ;    //可以多次入队哦
//  这是用vector邻接表存的图
        for(int i = 1; i &lt;= m; i++)
        {
            if(i == u|| mp[u][i] &gt;= INF || check(i, s, t) == false) continue;
//  需要更新的点 的前提是 其前继是之前已经更新过了的emmm有点废话
            if(dis[i] &gt; dis[u] + mp[i][u])
            {
                dis[i]   = dis[u] + mp[i][u];
                if(vis[i] == false)
                {
                    vis[i] = true;
                    q.push(i);
                }
             } 
         } 
    }


}
int main()
{
    while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;e) != EOF)
    {
        //n为天数，m为点数，k为修改成本，e为边
        memset(mp, INF, sizeof mp);
        for(int i = 1; i &lt;= e; i++)
        {
            int u, v, w;
            scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
            mp[v][u] = mp[u][v] = min(mp[u][v], w);
        }
        int d;
        memset(limit, false, sizeof limit);
        scanf(&quot;%d&quot;, &amp;d);
        for(int i = 1; i &lt;= d; i++)
        {
            int p, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;p, &amp;a, &amp;b);    
            for(int j = a; j &lt;= b; j++) limit[p][j] = true; //limit表示该天不能使用
        }
        //求出每一天的最短路的cost
        //cost[i] 表示第i天的最短路的费用.
        //先用spfa求出cost[i][j]
        //表示的是从第i天到j天，用同一方法的最小花费.
        //等于第i到j天，一直没有关门的港口组成的最短路代价乘上(j - i + 1)天数.
        for(int i = 1; i &lt;= n; i++)
            for(int j = i; j &lt;= n; j++)
            {
                bellman_ford(i, j);
                if(dis[m] &lt; INF)
                    cost[i][j] = dis[m] * (j - i + 1);
                else 
                    cost[i][j] = INF;
            }
        //dp[i]表示前i天的代价.
        for(int i = 1; i &lt;= n; i++)
        {
            dp[i] = cost[1][i];
            for(int j = 1; j &lt; i; j++)
                dp[i] = min(dp[i], dp[j] + k + cost[j + 1][i]);
        }
        printf(&quot;%d\n&quot;, dp[n]);
    }
    //fileclose;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1026: [SCOI2009]windy数</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1026%5BSCOI2009%5Dwindy%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　windy定义了一种windy数。不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。 windy想知道，<br>在A和B之间，包括A和B，总共有多少个windy数？</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　包含两个整数，A B。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　一个整数</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>【输入样例一】<br>1 10<br>【输入样例二】<br>25 50</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>【输出样例一】<br>9<br>【输出样例二】<br>20</p>
<h2 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>数位DP模板题.要注意的是，当limit == true 和 lead == true的时候，不要读取和记录dp值，因为这时候都是有限制的。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-12-01    19:40:40
By                : Tpaaaaaa
File_Name         ：1026SCOI2009windy数.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
dp[i][j][limit]表示考虑前i位，且第i位是j的情况下的方案数.有没有限制.


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
ll dp[50][50][2][2];
int dig[50];
ll dfs(int step, int lst, bool zero, bool lim)
{
    if(!step)   return !zero;           //如果是0的话，不算
    if(dp[step][lst][zero][lim] != -1)  //记忆化搜索
        return dp[step][lst][zero][lim];    
    int up = lim ? dig[step] : 9;       //up
    ll res = 0;
    for(int i = 0; i &lt;= up; i++)
    {
        if(abs(i - lst) &lt; 2 &amp;&amp; !zero) continue; //前导0
        res += dfs(step - 1, i, zero &amp;&amp; !i, lim &amp;&amp; i == dig[step]);
    }
    return dp[step][lst][zero][lim] = res;
}
ll solve(ll x)
{
    int len = 0;
    while(x)
    {
        dig[++len] = x%10;
        x/=10;
    }
    dp[len][0][true][true] = -1;
    ll res = dfs(len, 0, true, true); 
    return res;
}
int main()
{
    ll a, b;
    while(scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b) != EOF)
    {
        memset(dp, -1, sizeof dp);
        printf(&quot;%lld\n&quot;, solve(b) - solve(a - 1));
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>1036: [ZJOI2008]树的统计Count</title>
    <url>/tpaaaaaa.github.io/2019/12/03/1036%5BZJOI2008%5D%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1Count/</url>
    <content><![CDATA[<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>　　一棵树上有n个节点，编号分别为1到n，每个节点都有一个权值w。我们将以下面的形式来要求你对这棵树完成<br>一些操作： I. CHANGE u t : 把结点u的权值改为t II. QMAX u v: 询问从点u到点v的路径上的节点的最大权值 I<br>II. QSUM u v: 询问从点u到点v的路径上的节点的权值和 注意：从点u到点v的路径上的节点包括u和v本身</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>　　输入的第一行为一个整数n，表示节点的个数。接下来n – 1行，每行2个整数a和b，表示节点a和节点b之间有<br>一条边相连。接下来n行，每行一个整数，第i行的整数wi表示节点i的权值。接下来1行，为一个整数q，表示操作<br>的总数。接下来q行，每行一个操作，以“CHANGE u t”或者“QMAX u v”或者“QSUM u v”的形式给出。<br>对于100％的数据，保证1&lt;=n&lt;=30000，0&lt;=q&lt;=200000；中途操作中保证每个节点的权值w在-30000到30000之间。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>　　对于每个“QMAX”或者“QSUM”的操作，每行输出一个整数表示要求输出的结果。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><p>4<br>1 2<br>2 3<br>4 1<br>4 2 1 3<br>12<br>QMAX 3 4<br>QMAX 3 3<br>QMAX 3 2<br>QMAX 2 3<br>QSUM 3 4<br>QSUM 2 1<br>CHANGE 1 5<br>QMAX 3 4<br>CHANGE 3 6<br>QMAX 3 4<br>QMAX 2 4<br>QSUM 3 4</p>
<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><p>4<br>1<br>2<br>2<br>10<br>6<br>5<br>6<br>5<br>16</p>
<p>分析：</p>
<p>树链剖分模板题.</p>
<pre><code>/*
Date              : 2019-11-30    13:13:04
By                : Tpaaaaaa
File_Name         ：1036ZJOI2008树的统计Count.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 3e4 + 10;
int n;
int cnt, tot;
int head[MAXN], siz[MAXN], dep[MAXN], son[MAXN], fa[MAXN], top[MAXN];
int id[MAXN], rk[MAXN];
ll w[MAXN];
struct Edge
{
    int v, next;
}edge[MAXN * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    int l, r;
    ll mx;
    ll sum;        //区间和，区间最大值.
}node[MAXN * 4];
void init()
{
    memset(head, -1, sizeof head);
    cnt = tot = 0;
}
void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    id[u] = ++tot;
    rk[tot] = u;            //这就是dfn序.
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; son[u] != v)
            dfs2(v, v);
    }
}
inline void pushUp(int rt)
{
    node[rt].mx = max(node[ls(rt)].mx, node[rs(rt)].mx);
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void build(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    if(l == r)
    {
        node[rt].sum = w[rk[l]];
        node[rt].mx = w[rk[l]];
        return;
    }
    else 
    {
        node[rt].sum = 0;
        node[rt].mx = -INF;       
        int mid = md(l, r);
        build(ls(rt), l, mid);
        build(rs(rt), mid + 1, r);
        pushUp(rt);
    }
}
ll query(int rt, int l, int r, int op)
{
    if(node[rt].l &gt;= l &amp;&amp; node[rt].r &lt;= r)
    {
        if(op == 0) return node[rt].sum;
        else        return node[rt].mx;
    }
    int mid = md(node[rt].l, node[rt].r);
    ll ret;
    if(op == 0) ret = 0;
    else        ret = -INF;
    if(l &lt;= mid)    
    {
        if(op == 0) ret += query(ls(rt), l, r, op);
        else ret = max(ret, query(ls(rt), l, r, op));
    }
    if(r &gt; mid)
    {
        if(op == 0) ret += query(rs(rt), l, r, op);
        else ret = max(ret, query(rs(rt), l, r, op));
    }
    return ret;
}
ll mx(int u, int v)
{
    ll ans = -INF;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])   swap(u, v);
        ans = max(ans, query(1, id[top[u]], id[u], 1));
        u = fa[top[u]];

    }
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ans = max(ans, query(1, id[u], id[v], 1));
    return ans;
}

//询问权值和.
//单点更新.
void update(int rt, int t, ll v)
{
    if(node[rt].l == node[rt].r &amp;&amp; node[rt].l == t)
    {
        node[rt].mx = v;
        node[rt].sum = v;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(t &lt;= mid)
        update(ls(rt), t, v);
    else
        update(rs(rt), t, v);

    pushUp(rt);

}
ll sum(int u, int v)
{
    ll ans = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])   swap(u, v);
        ans += query(1, id[top[u]], id[u], 0);
        u = fa[top[u]];

    }
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ans += query(1, id[u], id[v], 0);
    return ans;
}
int main()
{
    fileopen;
        scanf(&quot;%d&quot;, &amp;n);
        init();
        for(int i = 1; i &lt; n; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);addEdge(v, u);
        }
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%lld&quot;, &amp;w[i]);  
        fa[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        build(1, 1, n);             //建树.   
        int q;
        scanf(&quot;%d&quot;, &amp;q);
        char s[10];
        while(q--)
        {
            scanf(&quot;%s&quot;, s);
            if(s[0] == &apos;C&apos;)
            {
                int u;
                ll t;
                scanf(&quot;%d%lld&quot;, &amp;u, &amp;t);
                update(1, id[u], t);         //单点更新.
            }
            else if(s[1] == &apos;M&apos;)            //询问最大值.
            {
                //.....//树链剖分.
                int u, v;
                scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
                printf(&quot;%lld\n&quot;, mx(u, v));
            }
            else                            //询问路径权值和.
            {
                int u, v;
                scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
                printf(&quot;%lld\n&quot;, sum(u, v));
            }   

        }
    fileclose;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>后缀数组</title>
    <url>/tpaaaaaa.github.io/2019/12/01/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>好的博文： <a href="https://blog.sengxian.com/algorithms/suffix-array" target="_blank" rel="noopener">https://blog.sengxian.com/algorithms/suffix-array</a></p>
<p>好的模板： <a href="https://blog.csdn.net/clover_hxy/article/details/51173982" target="_blank" rel="noopener">https://blog.csdn.net/clover_hxy/article/details/51173982</a></p>
<p>第二篇链接：<a href="https://blog.csdn.net/ruoruo_cheng/article/details/52269746" target="_blank" rel="noopener">https://blog.csdn.net/ruoruo_cheng/article/details/52269746</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>KMP 字符串匹配算法，它可以在 O(m + n)<em>O</em>(<em>m</em>+<em>n</em>) 的时间内完成对模版串的匹配。然而，对于多模版串的匹配，每一次都要预处理，十分不高效。这时有 AC 自动机的出现，虽然可以多模匹配，但每次匹配仍然要遍历整个字符串，对于很长很长的字符串，例如 DNA 信息，有上亿的数据，这时候每一次查询遍历就不太科学了。这时就要预处理文本串。</p>
<h2 id="一些约定¶"><a href="#一些约定¶" class="headerlink" title="一些约定¶"></a>一些约定<a href="https://oi-wiki.org/string/sa/#_1" target="_blank" rel="noopener">¶</a></h2><p>字符串相关的定义请参考 <a href="https://oi-wiki.org/string/basic/" target="_blank" rel="noopener">字符串基础</a> 。</p>
<p>字符串下标从  开始。</p>
<p>“ 后缀  “ 代指以第  个字符开头的后缀。</p>
<h2 id="后缀数组是什么？¶"><a href="#后缀数组是什么？¶" class="headerlink" title="后缀数组是什么？¶"></a>后缀数组是什么？<a href="https://oi-wiki.org/string/sa/#_2" target="_blank" rel="noopener">¶</a></h2><p>后缀数组（Suffix Array）主要是两个数组：  和  。</p>
<p>其中，  表示将所有后缀排序后第  小的后缀的编号。  表示后缀  的排名。</p>
<p>这两个数组满足性质：  。</p>
<p>后缀数组示例：</p>
<p><a href="https://wenku.baidu.com/view/5b886b1ea76e58fafab00374.html" target="_blank" rel="noopener"><img src="https://oi-wiki.org/string/images/sa1.png" alt=""></a></p>
<p>另一篇比较好的</p>
<p>后缀数组（Suffix Array）是某一字符串的所有后缀按照字典序的一个排列。本文数组的索引从0开始。称s[j..len(s)-1]为后缀j。sa[i] = j，表示原串的所有后缀按字典序排列，排在第i个的是后缀j。一个字符串的后缀数组是唯一的。</p>
<p>sa根据排名查后缀编号，与之对应的是rank数组，根据后缀编号查排名。sa[i] = j &lt;=&gt; rank[j] = i。</p>
<p>给后缀排序有什么作用呢？一个字符串的所有子串，都可以表示为它某个后缀的前缀。对于一个有序的序列，我们可以二分查找。设文本串的长度为n，模板串的长度为m。直接二分，可以做到O(n lg n)+O(m lg n)的时间复杂度。用height数组进行优化，则可以做到O(n lg n)+O(m+lg n)。height是后缀数组中相邻两个后缀的最长公共前缀。</p>
<p>后缀数组的构造<br>从上一段可以看出，我们能用O(n lg n)的时间构造一个字符串的后缀数组——倍增算法。存在O(n)的算法，在OI中似乎不常用。</p>
<p>给数排序有很多方法。基于比较的排序，最快可做到O(n lg n)，理论上不能进一步优化。在我们的模型中，数之间的比较是O(1)的，然而，字符串的比较是O(n)的。所以，我们得另辟蹊径。</p>
<p>除了基于比较的排序，我们还有计数排序、基数排序等。字符串的集合太大，计数排序不可行。但是字符集往往很小，我们应该试试基于计数排序的基数排序。每次计数排序用时O(n)，进行n轮计数排序，总共是O(n^2)，仍然不理想。</p>
<p>字典序有什么特性？把s和t都拆成[0..i]，[i+1..len-1]两截，则s &lt; t &lt;=&gt; (s[0..i] &lt; t[0..i]) 或 (s[0..i] = t[0..i] 且 s[i+1..len(s)-1] &lt; t[i+1..len(t)-1])。从中看出两点：一，我们可以递归或者递推地比较两个字符串；二，这和二元组之间的比较很像！</p>
<p>设sa_k为只取每个后缀的前缀k得到的“后缀数组”，rank_k类似。我们能根据它们计算出sa_2k和rank_2k。图示如下：</p>
<p>取二元组(rank_k[i], rank_k[i+k])为后缀i的关键字排序，就得到了sa_2k。相当于rank_k能帮助我们快速地比较两个后缀。再根据sa_2k计算出rank_2k。如果i+k越界怎么办？我采用的方法是令它的rank等于-1。后面，我们将看到，置rank[n]=-1即可。</p>
<p>如果用快速排序，至此，我们已经得到O(n lg^2 n)构造后缀数组的算法。</p>
<p>rank的取值范围是0~n-1，统计一下每个rank对应多少个后缀是可接受的，能不能用先前提到的基数排序呢？基数排序从低位到高位循环，每一趟以这一位为关键字采用某种稳定排序算法（如计数排序）排序，最后就得到了有序的序列。以上面banana例子中k=4时的二元组为例：</p>
<p>Pretty cool !</p>
<p>一种简单的实现方法是，以rank_k[i+k]为关键字，对所有后缀计数排序，得到pre。再以rank_k[i]为关键字，对pre计数排序，得到sa_2k。</p>
<p>有没有可以优化的地方？</p>
<p>sa_k是什么？以rank_k[i]为关键字，对所有后缀排序的结果。现在取rank_k[i+k]为关键字，对于那些满足i+k &lt; n的后缀，它们的先后顺序保持不变，而对于那些i+k &gt;= n的后缀，根据上面的约定，其第二关键字等于-1，应该排在pre的最前面。所以，我们可以直接从sa_k得到pre。</p>
<p>开始写代码吧。以下代码仅作说明之用，为了叙述方便打乱了顺序。</p>
<h1 id="include"><a href="#include" class="headerlink" title="include"></a>include</h1><h1 id="include-1"><a href="#include-1" class="headerlink" title="include"></a>include</h1><p>void build_SA(char s[], int n)<br>{<br>memset(b, 0, sizeof(int)*SIGMA_SIZE);<br>for (int i = 0; i &lt; n; ++i) ++b[s[i]-‘a’]; for (int i = 1; i &lt; SIGMA_SIZE; ++i) b[i] += b[i-1]; for (int i = n-1; i &gt;= 0; –i)<br>sa[–b[s[i]-‘a’]] = i;<br>int m = rank[sa[0]] = 0;<br>for (int i = 1; i &lt; n; ++i) rank[sa[i]] = m += s[sa[i]] != s[sa[i-1]]; ++m; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 这一段求出sa_1和rank_1。假定SIGMA_SIZE &gt; MAX_N。如果字符集比较大，std::sort即可，不影响渐近的运行时间。m是不同rank的种数。</p>
<pre><code>int *&amp;pre = t;
for (int k = 1; m &lt; n; k *= 2, ++m) {
    for (int i = 0, p = k; i &lt; n; ++i)
        if (sa[i] &gt;= k)
            pre[p++] = sa[i]-k;
    for (int i = 0; i &lt; k; ++i)
        pre[i] = n-k+i;</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>这一段求出pre。t是一个指针，定义为全局变量。</p>
<p>int b[MAX_N], buff[2][MAX_N+1], *t = buff[0];<br>1<br>接下来根据第一关键字计数排序。</p>
<pre><code>memset(b, 0, sizeof(int)*m);
for (int i = 0; i &lt; n; ++i)
    ++b[rank[i]];
for (int i = 1; i &lt; m; ++i)
    b[i] += b[i-1];
for (int i = n-1; i &gt;= 0; --i)
    sa[--b[rank[pre[i]]]] = pre[i];</code></pre><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>至此，已求出新的sa。接着，我们来计算rank。</p>
<pre><code>    m = r[sa[0]] = 0;
    for (int i = 1; i &lt; n; ++i)
        r[sa[i]] = m += rank[sa[i]] != rank[sa[i-1]] || rank[sa[i]+k] != rank[sa[i-1]+k];
    swap(r, rank);
}</code></pre><p>1<br>2<br>3<br>4<br>5<br>r是一个中间“数组”。这时pre数组已经没用了，所以它们可以共用一块内存。rank也定义为指针。</p>
<pre><code>int *&amp;pre = t, *&amp;r = t;</code></pre><p>1<br>现在可以看到定义数组指针的用意。无须copy，无须memcpy，swap即可。DP里搞滚动数组也可以借鉴这个技巧。</p>
<p>int b[MAX_N], sa[MAX_N], buff[2][MAX_N+1], *t = buff[0], *rank = buff[1];<br>1<br>别忘了在for k外面加上这句！</p>
<pre><code>rank[n] = r[n] = -1;</code></pre><p>1<br>两个后缀i、j，设i &lt; j。若j+k &lt;= n，则rank[i+k]和rank[j+k]有定义。若j+k &gt; n，则必有rank[j] &lt; rank[i]，根据短路法则，无须再比较rank[i+k]和rank[j+k]。</p>
<p>最后，还有：</p>
<p>}<br>1<br>最长公共前缀<br>设后缀sa[i]和sa[j]的最长公共前缀为LCP(i, j)，有定理：LCP(i, j) = min{height[k] | min{i, j} &lt; k &lt;= max{i, j}}。</p>
<p>一开始，刘汝佳告诉我这很显然，我是拒绝的。然而现在我也想建议大家使用显然法……</p>
<p>还是证一下吧。先证一个引理，设i &lt; k &lt;= j，则LCP(i, j) = min{LCP(i, k), LCP(k, j)}。当k = j时显然成立。以下说明k &lt; j时的情形。</p>
<p>设LCP(i, k)=a，LCP(j, k)=b，LCP(i, j)=c，sa[i]=x，sa[j]=y，sa[k]=z，不妨设a &lt;= b。那么，s[x..x+a-1] = s[z..z+a-1]，s[z..z+b-1] = s[y..y+b-1]，由传递性，s[x..x+a-1] = s[y+a-1..y+a-1]，故LCP(i, j) &gt;= a。由字典序的定义，后缀数组中i~k项后缀的前c个字符相等，故a &gt;= LCP(i, j)。证毕。</p>
<p>结合这个引理和数学归纳法，上述定理成立。</p>
<p>所以说height数组很重要啦。有了它，再求求RMQ，任意两后缀的最长公共前缀就搞定了。</p>
<p>上面这个定理有个推论，帮我们线性时间求height：height[rank[i]] &gt;= height[rank[i-1]]-1。后缀i和i-1，拿掉i-1的第一个字符，二者就相等了。考虑sa[rank[i-1]-1]=p-1，则后缀p-1&lt;后缀i-1。如果它俩的第一个字符相等，那么，有后缀p &lt; 后缀i，由定理，有height[rank[i-1]]-1 = LCP(sa[p], sa[i]) &lt;= height[rank[i]]。如果它俩的第一个字符不等，则height[rank[i-1]] = 0，显然成立。推论得证。</p>
<p>height[rank[i]]相对于前一项只能增加或减1，最多累计减少(n-1)个1，且height[rank[i]] &lt;= n。于是，按照height[rank[0]], height[rank[1]], height[rank[2]], …的顺序愉快地递推吧！</p>
<p>UOJ #35是一道模板题，我的代码：<a href="http://uoj.ac/submission/93286。" target="_blank" rel="noopener">http://uoj.ac/submission/93286。</a></p>
<p>写在最后<br>后缀数组最初是从兄弟学校的MYJ学长那里学的。研究了一下刘汝佳老师的代码，然后默写了一遍……UOJ #35始终是0分，CodeVS的模板题过了。那时我还没发现UOJ可以看一部分数据啊……我自己也不太清楚自己在写什么，这就是照着别人代码打的坏处。但是自己写不出来啊。于是这个数据结构和莫队算法等等在今年1~4月于匆忙中囫囵吞枣的知识一样，属于不可用的。</p>
<p>这次是自己重新写的，但心底里对于以前的代码还是有个模糊的印象。根据刘汝佳老师的代码修改的。有两个地方比我更优：一是他通过共用pre和r（原代码变量名不一样），只用4n的空间；二是引入m变量。</p>
<p>本文参考了刘汝佳、陈锋编著的《算法竞赛入门经典训练指南》和国家集训队2004年许智磊前辈的《后缀数组》一文。</p>
<p>模板</p>
<pre><code>#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#define N 200003
using namespace std;
char ch[200003];
int a[N],v[N],sa[2][N],rk[2][N];//sa[i]表示排名为i的后缀的起点下标，rk[i]表示第i位的后缀的优先级
//之所以有两维是因为2^k是由两段2^k-1推来的，所以两维分别表示的是两段 
int n,m,k;
void calcsa(int sa[N],int rank[N],int SA[N],int Rank[N])
{
     for(int i=1;i&lt;=n;++i)v[rank[sa[i]]]=i;//v[i]表示排名为i的后缀，最靠后的位置在哪一位
     for(int i=n;i&gt;=1;--i)
         if(sa[i]&gt;k)
             SA[v[rank[sa[i]-k]]--]=sa[i]-k;
     for(int i=n-k+1;i&lt;=n;++i)
         SA[v[rank[i]]--]=i;
     for(int i=1;i&lt;=n;++i)
         Rank[SA[i]]=Rank[SA[i-1]]+(rank[SA[i-1]]!=rank[SA[i]]||rank[SA[i-1]+k]!=rank[SA[i]+k]);//双关键字排序
}
void work()
{
    int p=0,q=1;
    for (int i=1;i&lt;=n;i++) v[a[i]]++;//统计每个字符出现了多少次 
    for (int i=1;i&lt;=256;i++) v[i]+=v[i-1];//统计出前缀和即可知道每个字符在串中的排名 
    for (int i=1;i&lt;=n;i++)
     sa[p][v[a[i]]--]=i;//因为每个字符不一定只出现了一次，但是不同的后缀不能用同样的排名，所以每次--，有效的防止了重复，并且保证了后面长度短的后缀排名更靠前 
    for (int i=1;i&lt;=n;i++)//rk 与sa 互为逆运算，知道另一个就可以O(n)求出另一个 
     rk[p][sa[p][i]]=rk[p][sa[p][i-1]]+(a[sa[p][i-1]]!=a[sa[p][i]]);//如果相邻两个相同，那么他们的优先级也是相同的 
    k=1;//字符串的初始长度，因为是双关键字计数排序，所以刚开始sa[q]为0，相当于只看第一个关键字 
    while (k&lt;n)
    {
        calcsa(sa[p],rk[p],sa[q],rk[q]);
        p^=1; q^=1; k&lt;&lt;=1;
    }
    for (int i=1;i&lt;=n;i++)
     {
         printf(&quot;%d &quot;,sa[p][i]);
     } 
    printf(&quot;\n&quot;);
    for (int i=1;i&lt;=n;i++)//sa[p]中存储的就是最终后缀数组的排名 
    {
        if (sa[p][i]&lt;=n/2)
         printf(&quot;%c&quot;,ch[sa[p][i]+n/2-1]);//这里是为什么呢?以样例为例展环为链后为JSOI07JSOI07 ，那么根据排名sa[p]最终会变成 0077IIJJOOSS,因为是读最后一列，所以是sa[p][i]+n/2-1，即当前点的前一位，因为是环嘛，划一划就明白了。 
    }
}
int main()
{
    scanf(&quot;%s&quot;,ch+1);
    int len=strlen(ch+1);
    for (int i=1;i&lt;=len;i++)//展环为链 
    {
        a[i]=int(ch[i]);
        a[i+len]=a[i];
        ch[i+len]=ch[i];
    }
    n=len&lt;&lt;1;
    work();
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>最大流最小割</title>
    <url>/tpaaaaaa.github.io/2019/12/01/%E6%9C%80%E5%A4%A7%E6%B5%81%E6%9C%80%E5%B0%8F%E5%89%B2/</url>
    <content><![CDATA[<p>在最优化理论中，<strong>最大流最小割定理</strong>提供了对于一个网络流，<strong>从源点到目标点的最大的流量</strong>等于<strong>最小割的每一条边的和</strong>。即对于一个如果移除其中任何一边就会断开源点和目标点的边的集合的边的容量的总和。</p>
<p>因此<strong>求最小割：</strong></p>
<p>方法一：用最大流最小割定理，用网络流的dinic 算法解出最大流即可.</p>
<p>方法二：可以求出对偶图，然后求对偶图的最短路即可。</p>
<p>原图里面的封闭的面，在其对偶图里面就是点，横跨两个面的边的权值，就是对偶图连接两个点的边的权值.见例题BZOJ1001</p>
<p>代码：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;
typedef long long ll;
int n,m;
int ne;
const int N=1000010;
struct data
{
    int to,next,v;
}e[N&lt;&lt;3];
int head[N];
int h[N],q[N],ans;
inline void add(int u,int v,int w)
{
    ne++;
    e[ne].to=v;
    e[ne].v=w;
    e[ne].next=head[u];
    head[u]=ne;
}
inline bool BFS()
{
    int now,i;
    memset(h,-1,sizeof(h));
    int t=0,w=1;
    q[t]=1;
    h[1]=0;
    while(t&lt;w)
    {
        now=q[t];
        t++;
        i=head[now];
        while(i)
        {
            if(e[i].v&amp;&amp;h[e[i].to]&lt;0)
            {
                q[w++]=e[i].to;
                h[e[i].to]=h[now]+1;
            }
            i=e[i].next;
        }
    }
    if(h[n*m]==-1)
        return false;
    return true;
}
inline int DFS(int x,int f)
{
    if(x==n*m)
        return f;
    int i=head[x];
    int w,used=0;
    while(i)
    {
        if(e[i].v&amp;&amp;h[e[i].to]==h[x]+1)
        {
            w=f-used;
            w=DFS(e[i].to,min(w,e[i].v));
            e[i].v-=w;
            e[i+1].v+=w;
            used+=w;
            if(used==f)
                return f;
        }
        i=e[i].next;
    }
    if(!used)
        h[x]=-1;
    return used;
}
inline void dinic()
{
    while(BFS())
    {
        ans+=DFS(1,0x7f7f7f7f);
    }
}
int inline get(int x, int y)
{
    return (x - 1)*m + y;
}
main(){
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){
        //init();
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt; m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j), get(i,j+1),temp);
                //add(get(i,j+1), get(i,j), 0);
                add(get(i,j+1), get(i,j), temp); 
                //add(get(i,j), get(i,j+1),0);
            }
        }
        for(int i = 1; i &lt; n; i++)
        {
            for(int j = 1; j &lt;= m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j), get(i+1,j), temp);
                //add(get(i+1,j),get(i,j),0);
                add(get(i+1,j),get(i,j),temp);
                //add(get(i,j), get(i+1,j), 0);
            }
        }
        for(int i = 1; i &lt; n; i++)
        {
            for(int j = 1; j &lt; m; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                add(get(i,j),get(i+1,j+1),temp);
                //add(get(i+1,j+1),get(i,j),0);
                add(get(i+1,j+1),get(i,j),temp);
                //add(get(i,j),get(i+1,j+1),0);
            }
        }   
        dinic();
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>BZOJ真nm孤儿评测机</title>
    <url>/tpaaaaaa.github.io/2019/11/30/BZOJ%E7%9C%9Fnm%E5%AD%A4%E5%84%BF%E8%AF%84%E6%B5%8B%E6%9C%BA/</url>
    <content><![CDATA[<p>调了一晚上改成cin变成scanf就可以了???我的时间不重要吗？？？一晚上就写了那道破题。md神经病</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]矩阵树定理</title>
    <url>/tpaaaaaa.github.io/2019/11/30/%5B%E7%AE%97%E6%B3%95%5D%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>原文地址 <a href="http://old.orzsiyuan.com/articles/algorithm-Matrix-Tree-Theorem/" target="_blank" rel="noopener">http://old.orzsiyuan.com/articles/algorithm-Matrix-Tree-Theorem/</a></p>
<p>另一篇比较好的： <a href="https://leflacon.github.io/9548c271/" target="_blank" rel="noopener">https://leflacon.github.io/9548c271/</a></p>
<blockquote>
<p>矩阵树定理用于计算无向图生成树个数，和基尔霍夫矩阵的行列式密切相关。</p>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="基尔霍夫矩阵"><a href="#基尔霍夫矩阵" class="headerlink" title="基尔霍夫矩阵"></a>基尔霍夫矩阵</h3><p>在了解矩阵树定理前，我们先学习一下基尔霍夫矩阵的求法。</p>
<p>我们记基尔霍夫矩阵为 ​K​（Kirchhoff​Kirchhoff​ 的缩写），并直接计算出无向图 ​G​ 的度数矩阵 D​ 和邻接矩阵 ​A​，那么我们同通过 K=D−A​就可以计算出基尔霍夫矩阵。</p>
<p>也就是说：</p>
<p>无向图的基尔霍夫矩阵: 对角线上表示每个点的度数,若ij之间有边则矩阵ij处为-1<br>无向图的生成树的数目为: 任意一个n-1阶主子式的行列式的绝对值.</p>
<h3 id="主子式"><a href="#主子式" class="headerlink" title="主子式"></a>主子式</h3><p>取出矩阵 A 的 k 行和 k 列组成的新矩阵 A′ 叫做 A 的 k 阶主子式。</p>
<hr>
<h2 id="矩阵树定理"><a href="#矩阵树定理" class="headerlink" title="矩阵树定理"></a>矩阵树定理</h2><p>矩阵树定理用于求解一个无向图的生成数个数，<strong>允许有重边和自环</strong>。</p>
<p>对于一个图G来说，G的<strong>「度数矩阵」</strong><code>D[G]</code>是一个<code>n*n</code>的矩阵，当<code>i≠j</code>时，<code>dij=0</code>，当<code>i=j</code>时，dij等于vi的度数</p>
<p>G的<strong>「邻接矩阵」</strong><code>A[G]</code>是一个<code>n*n</code>的矩阵，如果vi，vj之间有边直接相连，<code>dij=1</code>，否则为0</p>
<p>G的<strong>「Kirchhoff矩阵」</strong>（基尔霍夫矩阵/拉普拉斯算子）<code>C[G]</code>为<code>C[G]=D[G]-A[G]</code></p>
<p>如果G是一棵树，那么它的基尔霍夫矩阵C的任一个n-1阶主子式的行列式均为1<strong>「Matrix-Tree定理」（生成树定理）</strong>：G的所有不同的生成树的个数等于其基尔霍夫矩阵<code>C[G]</code>任何一个n-1阶主子式的行列式的绝对值</p>
<h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>由于笔者能力有限（太菜了不会证明），这里推荐一篇博客：<a href="https://blog.csdn.net/werkeytom_ftd/article/details/54914530" target="_blank" rel="noopener">生成树计数问题——矩阵树定理及其证明 - WerKeyTom_FTD</a></p>
<h3 id="求解"><a href="#求解" class="headerlink" title="求解"></a>求解</h3><p>构造基尔霍夫矩阵，并求出其任何一个 n−1 阶主子式的行列式即可。行列式的具体求法详见<a href="https://orzsiyuan.com/articles/algorithm-Determinant/" target="_blank" rel="noopener">「算法笔记」行列式</a>。</p>
<p><strong>时间复杂度</strong>：O(n3logn)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #312 (Div. 2)(done)</title>
    <url>/tpaaaaaa.github.io/2019/11/28/CodeforcesRound#312(Div.2)(done)/</url>
    <content><![CDATA[<h2 id="C-Amr-and-Chemistry"><a href="#C-Amr-and-Chemistry" class="headerlink" title="C - Amr and Chemistry"></a><a href="https://codeforces.com/contest/558/problem/C" target="_blank" rel="noopener">C - Amr and Chemistry</a></h2><p>数的最短路(自己取的名字).</p>
<pre><code>/*
Date              : 2019-11-24    10:55:11
By                : Tpaaaaaa
File_Name         ：C-andChemistry.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5;
int n;
int cnt[MAXN + 10], step[MAXN + 10];
void solve(int x)
{
    int temp = x;
    int s = 0;
    while(temp &lt;= MAXN)             //往左移.
    {
        cnt[temp]++;
        step[temp] += s;
        temp &lt;&lt;= 1;
        s++;
    }
    s = 1;
    temp = x;
    while(temp &gt; 1)
    {
        if(temp &amp; 1)
        {
            int cc = temp;
            cc &gt;&gt;= 1;
            int ss = 0;
            while(cc &lt;= MAXN)
            {
                cnt[cc]++;
                step[cc] += s + ss;
                ss++;
                cc &lt;&lt;= 1;
            }
            temp &gt;&gt;= 1;
            s++;
        }
        else
        {
            temp &gt;&gt;= 1;
            cnt[temp]++;
            step[temp] += s;
            s++;
        }

    }

}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int ans = INF;
        memset(cnt, 0, sizeof cnt);
        memset(step, 0, sizeof step);
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            solve(temp);
        }
        for(int i = 1; i &lt;= MAXN; i++)
            if(cnt[i] == n)
                ans = min(ans, step[i]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><h2 id="E-A-Simple-Task"><a href="#E-A-Simple-Task" class="headerlink" title="E - A Simple Task"></a><a href="https://codeforces.com/contest/558/problem/E" target="_blank" rel="noopener">E - A Simple Task</a></h2><p>线段树 + 计数排序的思想.</p>
<pre><code>/*
Date              : 2019-11-28    17:12:33
By                : Tpaaaaaa
File_Name         ：EASimpleTask.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
线段树 + 计数排序的思想.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int n, q;
int cnt[30];
struct Node
{
    int L, R;             //节点维护的区间是[L, R]
    int sum;              //维护的区间上的一些信息,这个字母的数目
    int lazy;             //懒标记，0为全置0,1为全置1. -1为无标记
};
Node node[4 * MAXN][30];
void built(int root, int L, int R, int i)
{
    node[root][i].L = L;
    node[root][i].R = R;
    node[root][i].sum = 0;
    node[root][i].lazy = -1;
    if(L != R)
    {
        int mid = md(L, R);
        built(ls(root), L, mid, i);
        built(rs(root), mid + 1, R, i);
    }
}
void pushDown(int root, int i)
{
    if(node[root][i].lazy != -1)
    {
        node[ls(root)][i].lazy = node[rs(root)][i].lazy = node[root][i].lazy;
        if(node[root][i].lazy == 0)
        {
            node[rs(root)][i].sum = 0;
            node[ls(root)][i].sum = 0;
        }
        else
        {
            node[rs(root)][i].sum = node[rs(root)][i].R - node[rs(root)][i].L + 1;
            node[ls(root)][i].sum = node[ls(root)][i].R - node[ls(root)][i].L + 1;
        }
        node[root][i].lazy = -1;

    }
}
void pushUp(int root, int i)
{
    node[root][i].sum = node[ls(root)][i].sum + node[rs(root)][i].sum;
}
void update(int root, int L, int R, int v, int i)
{
    if(node[root][i].L == L &amp;&amp; node[root][i].R == R)
    {
        node[root][i].lazy = v;
        if(v == 1)
            node[root][i].sum = R - L + 1;
        else 
            node[root][i].sum = 0;
        return;
    }
    pushDown(root, i);
    int mid = md(node[root][i].L, node[root][i].R);
    if(R &lt;= mid)
        update(ls(root), L, R, v, i);
    else if(L &gt; mid)
        update(rs(root), L, R, v, i);
    else
    {
        update(ls(root), L, mid, v, i);
        update(rs(root), mid + 1, R, v, i);
    }
    pushUp(root, i);

}
int query(int rt, int l, int r, int i)
{
    if(node[rt][i].L == l &amp;&amp; node[rt][i].R == r)
        return node[rt][i].sum;
    int mid = md(node[rt][i].L, node[rt][i].R);
    pushDown(rt, i);
    if(r &lt;= mid)
        return query(ls(rt), l, r, i);
    else if(l &gt; mid)
        return query(rs(rt), l, r, i);
    else
    {
        return query(ls(rt), l, mid, i) + query(rs(rt), mid + 1, r, i);
    }

}
char s[MAXN];
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;q) != EOF)
    {
        for(int i = 1; i &lt;= 26; i++)
            built(1, 1, n, i);           //建立26个线段树
        scanf(&quot;%s&quot;, s);
        for(int i = 0; i &lt; n; i++)
        {
            char temp;
            temp = s[i];
            update(1, i + 1, i + 1, 1, temp - &apos;a&apos; + 1);
        }
        //printf(&quot;??&quot;);
        for(int i = 1; i &lt;= q; i++)
        {
            int l, r, k;
            scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;k);
            for(int j = 1; j &lt;= 26; j++)
            {
                cnt[j] = query(1, l, r, j);
                update(1, l, r, 0, j);
                //printf(&quot;cnt[%d] = %d\n&quot;, j, cnt[j]);
            }
            if(k == 1)
            {
                int ret = l;
                for(int j = 1; j &lt;= 26; j++)
                {
                    if(cnt[j] &gt; 0)
                    {
                        update(1, ret, ret + cnt[j] - 1, 1, j);
                        ret += cnt[j];
                    }
                }                
            }
            else
            {
                int ret = l;
                for(int j = 26; j &gt;= 1; j--)
                {
                    if(cnt[j] &gt; 0)
                    {
                        update(1, ret, ret + cnt[j] - 1, 1, j);
                        ret += cnt[j];
                    }
                }     
            }

        }  
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= 26; j++)
            {
                if(query(1, i, i, j))
                {
                    printf(&quot;%c&quot;, &apos;a&apos; + j - 1);
                    break;
                }
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><p>D. Guess Your Way Out! II  </p>
<hr>
<p>WA了85点，不想改了。累了累了</p>
<pre><code>/*
Date              : 2019-11-28    19:59:57
By                : Tpaaaaaa
File_Name         ：DGuessYourWayOutII.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
int h, q;
typedef pair&lt;ll, int&gt; P;
struct Ques
{
    int j;
    ll l, r;
    int an;
}ques[100000 + 10];
struct Edge
{
    ll l, r;   //区间[]
    ll sum = 0;    //区间长度, r - l + 1;
}ans;
//返回a与b区间求交
Edge mul(Edge a, Edge b)
{
    Edge temp;
    temp.l = max(a.l, b.l);
    temp.r = min(a.r, b.r);
    temp.sum = temp.r - temp.l + 1;
    return temp;
}
//左右区间
ll getleft(ll u, int i, int h)
{
    return u * pow(2, h - i);
}
ll getright(ll u, int i, int h)
{
    while(i &lt; h)
    {
        u = u * 2 + 1;
        i++;
    }
    return u;
}
vector &lt;Edge&gt; vec;
vector &lt;P&gt; v;
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;h, &amp;q) != EOF)
    {
        vec.clear();
        v.clear();
        ans.l = pow(2, h - 1);
        ans.r = pow(2, h) - 1;
        ans.sum = ans.l;
        int flag = 0;
        for(int i = 1; i &lt;= q ;i++)
        {
            scanf(&quot;%d%lld%lld%d&quot;, &amp;ques[i].j, &amp;ques[i].l, &amp;ques[i].r, &amp;ques[i].an);
        }
        for(int i = 1; i &lt;= q; i++)
        {
            if(ques[i].an == 0) continue;
            int j = ques[i].j;
            ll l = ques[i].l;
            ll r = ques[i].r;

            ll lef = getleft(l, j, h);
            ll rig = getright(r, j, h);
            Edge temp;
            temp.l = lef; 
            temp.r = rig;
            temp.sum = rig - lef + 1;
            ans = mul(ans, temp);
            if(ans.sum &lt;= 0)            //说明不可能.
            {
                flag = -1;              //-1表示cheated.
                break;
            }
        }
        if(flag != -1)
        {
            for(int i = 1; i &lt;= q; i++)
            {
                if(ques[i].an == 1) continue;
                int j = ques[i].j;
                ll l = ques[i].l;
                ll r = ques[i].r;
                ll lef = getleft(l, j, h);
                ll rig = getright(r, j, h);
                v.push_back(P(lef, 1));
                v.push_back(P(rig, -1));
            }
            sort(v.begin(), v.end());
            int sta = 0;
            ll bef = pow(2, h - 1);
            for(int i = 0; i &lt; v.size(); i++)
            {
                if(sta == 0)
                {
                    Edge temp;
                    temp.l = bef;
                    temp.r = v[i].first - 1;

                    temp.sum = temp.r - temp.l + 1;
                    Edge tem = mul(ans, temp);
                    if(tem.sum &gt; 0)
                        vec.push_back(tem);
                }
                sta += v[i].second;
                bef = v[i].first + 1;
            }
            if(sta == 0)
            {
                Edge temp;
                temp.l = bef;
                temp.r = pow(2, h) - 1;

                temp.sum = temp.r - temp.l + 1;
                Edge tem = mul(ans, temp);
                if(tem.sum &gt; 0)
                    vec.push_back(tem);
            }
        }

        int sum = 0;
        //将全域覆盖完了，这就是game cheated
        //也就是vec.size() == 0
        //如果没有询问,则是条件不足
        if(flag == -1 || (vec.size() == 0 &amp;&amp; ans.sum &gt; 0))
            printf(&quot;Game cheated!\n&quot;);
        else
        {
            ll tempans = -1;
            for(int i = 0; i &lt; vec.size(); i++)
            {
                if(vec[i].sum &gt; 0)   
                {
                    sum += vec[i].sum;
                    tempans = vec[i].l;
                }
            }/*
            if(h == 1 &amp;&amp; q == 0)
            {
                printf(&quot;1\n&quot;);
            }*/
            if(sum &gt; 1 || sum &lt; 0)
                printf(&quot;Data not sufficient!\n&quot;);
            else if(sum == 1)
            {
                printf(&quot;%lld\n&quot;, tempans);
            }
            else if(sum == 0)
            {
                printf(&quot;Game cheated!\n&quot;);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>分块</title>
    <url>/tpaaaaaa.github.io/2019/11/27/%E5%88%86%E5%9D%97/</url>
    <content><![CDATA[<p>原文<a href="https://blog.csdn.net/XianHaoMing/article/details/52201698" target="_blank" rel="noopener">https://blog.csdn.net/XianHaoMing/article/details/52201698</a></p>
<p>先简单介绍一下分块算法。<br>分块算法是一种很常见的根号算法，一般它的时间复杂度会带根号。<br>分块和线段树的区别在于，<strong>分块算法可以维护一些线段树维护不了的东西</strong>，例如单调队列等，<strong>线段树能维护的东西必须能够进行信息合并</strong>，而分块则不需要。不过，它们也有共同点，分块和线段树一样，分块需要支持<strong>类似标记合并</strong>的东西。<br>简单来说，分块算法就是<strong>优化过后的暴力</strong>。</p>
<p>现在讲一下这种算法的实现。<br>这种算法会将序列（序列长度为N）进行分块，通常设置一个上限K，每一块有至多K个元素。在序列分块问题上，一般会严格要求每个块都要有K个元素，这样就会分成约<strong>NK块</strong>。（最后一个块除外）</p>
<p>我们一般都会设K=N−−√，这样块数也就只有NK=N−−√块数可能多一。<br>通常实现时，我们用bei表示<strong>第i个位置所属的块</strong>。对于每个块都进行信息维护。</p>
<p><strong>单点修改</strong>时，我们一般先将对应块的<strong>标记下传</strong>，<strong>再暴力</strong>更新被修改块的状态。<br>时间复杂度O(n−−√)。</p>
<p>如果是<strong>区间[**</strong>L,<strong>**R]修改</strong>的话，对于<strong>被[**</strong>L,<strong>**R]整块跨过的块直接打标记</strong>，<strong>两端剩余的部分暴力重构块的状态</strong>即可。<br>中间最多经过n−−√块，两边暴力修改也是n−−√次的，所以时间复杂度为O(n−−√)。</p>
<p>至于<strong>询问操作</strong>，和区间修改类似，对于中间跨过的整块，<strong>直接利用块保存的信息统计答案</strong>，两端剩余部分任然可以暴力扫描统计。<br>时间复杂度和区间修改一样，也是O(n−−√)。</p>
<p>如果<strong>询问次数为**</strong>m<strong>，那总的时间</strong>复杂度即为<strong><strong>O(</strong></strong>mn−−√)**。</p>
<p>这就是最简单的分块思想，虽然思路很简单，但实现起来，本人觉得有点复杂。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Dilworth定理</title>
    <url>/tpaaaaaa.github.io/2019/11/26/Dilworth%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>声明：此文转载，方便自己以后分类查看Dilworth定理优化“序列的不下降子序列最少划分数首先是定义。<br>偏序关系是满足自反性、反对称性、传递性的二元关系。可以用&lt;=表示。<br>自反性：x&lt;=x成立。<br>反对称性：a&lt;=b 且 b&lt;=a &lt;=&gt; a=b<br>传递性：a&lt;=b 且 b&lt;=c ==&gt; a&lt;=c<br>满足上述三条性质的二元关系是偏序关系，配备偏序关系的集合称为偏序集。<br>显然数集上的“小于或等于”是偏序关系，但是偏序关系不只可以在数集上。<br>可比：a与b可比，当且仅当a&lt;=b 或 b&lt;=a。</p>
<p>设全集U是一个偏序集。<br>链：U的子集，<strong>满足其中任意两个元素（不相同）可比</strong>。<br>反链：U的子集，<strong>满足其中任意两个元素（不相同）不可比</strong>。<br>比如，有限数集S上的最长链的长度等于|S|，最长反链长度为1.<br>将U分拆成很多子集称作划分。姑且把子集全为链的划分叫做链划分，全为反链叫反链划分。<br>有两个互相对偶的定理：<br><strong>U的链划分使用的最少集合数，等于它的最大反链长度。（1）</strong><br><strong>U的反链划分使用的最少集合数，等于它的最大链长度。（2）</strong><br>其中某一个叫做Dilworth定理……我记不清了……<br>如果我说的不清楚，请参阅任意一本组合数学的入门书籍。<br>那么，罗嗦了半天，来到那个问题：给定一个全为实数的序列，每次在其中选出一个不下降子序列并将其删掉。求删完整个序列所需要的选择子序列的次数。<br>比如说，1 2 4 3 5这个序列，最少要两次，第一次1 2 3 5.<br>虽然序列与集合不同，但这很可能与最少划分有关。不管怎么说，打算用Dilworth定理相关内容解决本题。<br>首先要把序列转化成集合。不同点在于序列中元素有序。考虑使用有序数对（p，v）表示原序列中的一个数。p表示位置，v表示数值。<br>从集合中任意取出两个元素，如何能确定前者不比后者大呢？考虑关系&lt;=:p1&lt;=v1&amp;&amp;p2&lt;=v2。这相当于先把两个元素按照原序列中的位置排序，再比较数值大小。这个关系是偏序关系。如此一来，两个元素可比，等价于在原序列中，他们是不下降的。<br>根据（1），原题所求的次数，等于原序列的最长下降子序列的长度。<br>如果是求下降子序列的最小划分，相当于是求最小反链划分，等于最长不下降子序列的长度。</p>
<p>//</p>
<p>参考：<a href="http://blog.csdn.net/acdreamers/article/details/7626671" target="_blank" rel="noopener">http://blog.csdn.net/acdreamers/article/details/7626671</a></p>
<p>Dilworth定理：对于一个偏序集，最少链划分等于最长反链长度。<br>Dilworth定理的对偶定理：对于一个偏序集，其最少反链划分数等于其最长链的长度。</p>
<p>也就是说把一个数列划分成最少的最长不升子序列的数目就等于这个数列的最长上升子序列的长度。</p>
<p>下面来说说这个定理是怎么来的：</p>
<p>偏序集的定义：偏序是在集合X上的二元关系≤（这只是个抽象符号，不是“小于或等于”，它满足自反性、反对称性和传递<br>性）。即，对于X中的任意元素a,b和c，有:</p>
<p>(1)自反性：a≤a;<br>(2)反对称性：如果a≤b且b≤a，则有a=b;<br>(3)传递性：如果a≤b且b≤c，则a≤c 。</p>
<p>带有偏序关系的集合称为偏序集。<br>令(X,≤)是一个偏序集，对于集合中的两个元素a、b，如果有a≤b或者b≤a，则称a和b是可比的，否则a和b不可比。<br>在这个例子(反链)中元素Ri&lt;=Rj是指(i&lt;=j) and (ai&gt;=aj)</p>
<p>一个反链A是X的一个子集，它的任意两个元素都不能进行比较。<br>一个链C是X的一个子集，它的任意两个元素都可比。</p>
<p>【定理】<br>在X中，对于元素a，如果任意元素b，都有a≤b，则称a为极小元。<br>定理1：令（X,≤）是一个有限偏序集，并令r是其最大链的大小。则X可以被划分成r个但不能再少的反链。</p>
<p>其对偶定理称为Dilworth定理：<br>令（X,≤）是一个有限偏序集，并令m是反链的最大的大小。则X可以被划分成m个但不能再少的链。<br>虽然这两个定理内容相似，但第一个定理证明要简单一些。此处就只证明定理1。</p>
<p>证明：设p为最少反链个数<br>(1)先证明X不能划分成小于r个反链。由于r是最大链C的大小，C中任两个元素都可比，因此C中任两个元素都不能属于同一反<br>链。所以p&gt;=r。<br>(2)设X1＝X，A1是X1中的极小元的集合。从X1中删除A1得到X2。注意到对于X2中任意元素a2，必存在X1中的元素a1，使得<br>a1&lt;=a2。令A2是X2中极小元的集合，从X2中删除A2得到X3……，最终会有一个Xk非空而Xk+1为空。于是A1,A2,…,Ak就是X的 反链的划分，同时存在链a1&lt;=a2&lt;=…&lt;=ak，其中ai在Ai内。由于r是最长链大小，因此r&gt;=k。由于X被划分成了k个反链，因此<br>r&gt;=k&gt;=p。<br>(3)因此r=p，定理1得证。</p>
<p>【解决】<br>要求最少的覆盖，按照Dilworth定理<br>最少链划分 = 最长反链长度</p>
<p>题意：给定一系列方形，已知其中一个方形的长和宽都小于另一个方形的时候，这两个方形可以嵌套，若干个方形的嵌套成为一个嵌套组。问最少用多少个嵌套组可以将这些方形全部处理完毕。</p>
<p>思路：就是Dilworth的应用。注意排序的时候第一维从小到大，如果相同，第二维从大到小。然后求第二维的最长不增子序列长度（注意二分查找时的区别）。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #369(Div.2)(no)</title>
    <url>/tpaaaaaa.github.io/2019/11/24/CodeforcesRound#369(Div.2)(no)/</url>
    <content><![CDATA[<h2 id="C-Coloring-Trees"><a href="#C-Coloring-Trees" class="headerlink" title="C - Coloring Trees"></a><a href="https://vjudge.net/problem/CodeForces-711C" target="_blank" rel="noopener">C - Coloring Trees</a></h2><h2 id="D-Directed-Roads"><a href="#D-Directed-Roads" class="headerlink" title="D - Directed Roads"></a><a href="https://vjudge.net/problem/CodeForces-711D" target="_blank" rel="noopener">D - Directed Roads</a></h2><h2 id="E-ZS-and-The-Birthday-Paradox"><a href="#E-ZS-and-The-Birthday-Paradox" class="headerlink" title="E - ZS and The Birthday Paradox"></a><a href="https://vjudge.net/problem/CodeForces-711E" target="_blank" rel="noopener">E - ZS and The Birthday Paradox</a></h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #312 (Div. 2)（done）</title>
    <url>/tpaaaaaa.github.io/2019/11/24/CodeforcesRound#312(Div.2)%EF%BC%88done%EF%BC%89/</url>
    <content><![CDATA[<h2 id="B-Amr-and-The-Large-Array"><a href="#B-Amr-and-The-Large-Array" class="headerlink" title="B - Amr and The Large Array"></a><a href="https://vjudge.net/problem/CodeForces-558B" target="_blank" rel="noopener">B - Amr and The Large Array</a></h2><pre><code>/*
Date              : 2019-11-24    09:59:43
By                : Tpaaaaaa
File_Name         ：BAmrTheLargeArray.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 5;
int cnt[MAXN], las[MAXN], fri[MAXN];
int n, temp, mm;
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        mm = 0;
        memset(cnt, 0, sizeof cnt);
        memset(fri, 0, sizeof fri);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;temp);
            cnt[temp]++;            //出现次数
            mm = max(cnt[temp], mm);
            if(!fri[temp])   fri[temp] = i;
            las[temp] = i;
        }
        int ans = INF;
        int ansl, ansr;
        for(int i = 1; i &lt;= 1000000; i++)
            if(cnt[i] == mm &amp;&amp; las[i] - fri[i] &lt; ans)
            {
                ansl = fri[i];
                ansr = las[i];
                ans = las[i] - fri[i];
            }
        printf(&quot;%d %d\n&quot;, ansl, ansr);
    }
    return 0;
}</code></pre><h2 id="C-Amr-and-Chemistry"><a href="#C-Amr-and-Chemistry" class="headerlink" title="C - Amr and Chemistry"></a><a href="https://vjudge.net/problem/CodeForces-558C" target="_blank" rel="noopener">C - Amr and Chemistry</a></h2><p>数的最短路：某个数A通过乘k或者整除k变成B的最少步数。</p>
<p>k一般为2；那么我们将A用二进制表示，乘2就相当于位运算中的&lt;&lt;，整除2就相当于位运算中的&gt;&gt;。所以我们对于数A，我们可以标记他能到达的数，并得到他到这些数的最短步骤。之后枚举每个数，看这个数的cnt[] == n？ 如果等于，说明输入中每个数都能到达它，然后更新最小的代价和.</p>
<pre><code>/*
Date              : 2019-11-24    10:55:11
By                : Tpaaaaaa
File_Name         ：C-andChemistry.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5;
int n;
int cnt[MAXN + 10], step[MAXN + 10];
void solve(int x)
{
    int temp = x;
    int s = 0;
    while(temp &lt;= MAXN)             //往左移.
    {
        cnt[temp]++;
        step[temp] += s;
        temp &lt;&lt;= 1;
        s++;
    }
    s = 1;
    temp = x;
    while(temp &gt; 1)
    {
        if(temp &amp; 1)
        {
            int cc = temp;
            cc &gt;&gt;= 1;
            int ss = 0;
            while(cc &lt;= MAXN)
            {
                cnt[cc]++;
                step[cc] += s + ss;
                ss++;
                cc &lt;&lt;= 1;
            }
            temp &gt;&gt;= 1;
            s++;
        }
        else
        {
            temp &gt;&gt;= 1;
            cnt[temp]++;
            step[temp] += s;
            s++;
        }

    }

}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int ans = INF;
        memset(cnt, 0, sizeof cnt);
        memset(step, 0, sizeof step);
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            solve(temp);
        }
        for(int i = 1; i &lt;= MAXN; i++)
            if(cnt[i] == n)
                ans = min(ans, step[i]);
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><h2 id="D-Randomizer"><a href="#D-Randomizer" class="headerlink" title="D - Randomizer"></a><a href="https://vjudge.net/problem/CodeForces-559D" target="_blank" rel="noopener">D - Randomizer</a></h2><h2 id="E-Gerald-and-Path"><a href="#E-Gerald-and-Path" class="headerlink" title="E - Gerald and Path"></a><a href="https://vjudge.net/problem/CodeForces-559E" target="_blank" rel="noopener">E - Gerald and Path</a></h2>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #542（Div.2）（）</title>
    <url>/tpaaaaaa.github.io/2019/11/24/CodeforcesRound#542%EF%BC%88Div.2%EF%BC%89%EF%BC%88%EF%BC%89/</url>
    <content><![CDATA[<h2 id="B-Two-Cakes"><a href="#B-Two-Cakes" class="headerlink" title="B - Two Cakes"></a><a href="https://vjudge.net/problem/CodeForces-1130B" target="_blank" rel="noopener">B - Two Cakes</a></h2><p>贪心</p>
<pre><code>/*
Date              : 2019-11-23    20:34:27
By                : Tpaaaaaa
File_Name         ：B-TwoCakes.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int pie[MAXN];
int x[MAXN][3];
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(pie, 0, sizeof pie);
        for(int i = 0; i &lt; 2 * n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            pie[temp]++;
            x[temp][pie[temp]] = i; //x[i][1 2] 表示第1/2个 i层的位置.
         }
        ll ret = 0;
        x[0][1] = x[0][2] = 0;
        for(int i = 1; i &lt;= n; i++)    
        {
            int temp = abs(x[i][1] - x[i - 1][2]) + abs(x[i][2] - x[i - 1][1]);
            temp = min(temp, abs(x[i][1] - x[i - 1][1]) + abs(x[i][2] - x[i - 1][2]));
            ret += temp;
        }
        printf(&quot;%lld\n&quot;, ret);
    }
    return 0;
}</code></pre><h2 id="C-Connect"><a href="#C-Connect" class="headerlink" title="C - Connect"></a><a href="https://vjudge.net/problem/CodeForces-1130C" target="_blank" rel="noopener">C - Connect</a></h2><p>先对图染色，我直接枚举了所有的桥。</p>
<pre><code>/*
Date              : 2019-11-23    20:56:10
By                : Tpaaaaaa
File_Name         ：C-Connect.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 60;
int mp[MAXN * MAXN];
int vis[MAXN * MAXN];
int n;
int dir[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
inline get(int x, int y)
{
    return (x - 1) * n + y;
}
inline int getx(int u)
{
    return (u - 1)/n + 1;
}
inline int gety(int u)
{
    return u - (getx(u) - 1) * n;
}
void dfs(int u, int c)
{
    int x = getx(u);
    int y = gety(u);
    vis[u] = c;
    //printf(&quot;x = %d, y = %d\n&quot;, x, y);
    for(int i = 0; i &lt; 4; i++)
    {
        int tempx = x + dir[i][0];
        int tempy = y + dir[i][1];
        if(tempx &lt; 1 || tempy &lt; 1 || tempx &gt; n || tempy &gt; n)
            continue;
        int v = get(tempx, tempy);
        if(!vis[v] &amp;&amp; mp[v] == 0)
            dfs(v, c);
    }
}

int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int x1, y1, x2, y2;
        memset(vis, 0, sizeof vis);
        scanf(&quot;%d%d&quot;, &amp;x1, &amp;y1);
        scanf(&quot;%d%d&quot;, &amp;x2, &amp;y2);
        int t1 = get(x1, y1);
        int t2 = get(x2, y2);
        //printf(&quot;t1 = %d, t2 = %d\n&quot;, t1, t2);
        for(int i = 1; i &lt;= n * n; i++)
            scanf(&quot;%1d&quot;, &amp;mp[i]);
        int cnt = 0;
        for(int i = 1; i &lt;= n * n; i++)
        {
            if(!vis[i] &amp;&amp; mp[i] == 0) 
            {
                cnt++;
                dfs(i, cnt);
            }
        }
        int cost;
        if(vis[t1] == vis[t2])
        {
            cost = 0;
        }
        else
        {
            int col1 = vis[t1];
            int col2 = vis[t2];
            int ret = INF;
            for(int i = 1; i &lt;= n * n; i++)
                if(vis[i] == col1)
                {
                    for(int j = 1; j &lt;= n * n; j++)
                        if(vis[j] == col2)
                            ret = min(ret, (getx(i) - getx(j)) * (getx(i) - getx(j)) + (gety(i) - gety(j)) * (gety(i) - gety(j)));
                }
            cost = ret;
        }
        printf(&quot;%d\n&quot;, cost);

    }
    return 0;
}</code></pre><h2 id="D-Toy-Train-Simplified"><a href="#D-Toy-Train-Simplified" class="headerlink" title="D - Toy Train (Simplified)"></a><a href="https://vjudge.net/problem/CodeForces-1130D1" target="_blank" rel="noopener">D - Toy Train (Simplified)</a></h2><p>容易发现，一个点上有k个糖，一定要经过这个点k次。</p>
<p>也就是对于某个点：起点到这个点，然后以该点为起点进行(k-1)次绕行，然后去送最后一颗糖。</p>
<p>所以我们尽量使得最后一颗糖的距离最近。</p>
<pre><code>/*
Date              : 2019-11-23    21:39:50
By                : Tpaaaaaa
File_Name         ：DToyTrainSimplified.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5010;
int pri[MAXN];              //最远的目的.
int sum[MAXN];              //tony的数目
// u -&gt; v 
int n, m;
inline get(int u, int v)
{
    return (v - u + n) % n;
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        memset(pri, INF, sizeof pri);
        memset(sum, 0, sizeof sum);
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            sum[u]++;
            pri[u] = min(pri[u], get(u, v));
        }
        for(int i = 1; i &lt;= n; i++)
        {
            int ret = 0;
            int m1 = 0;
            int m2 = 0;
            //sum[i]--;
            for(int j = 1; j &lt;= n; j++)
                if(sum[j] &gt; 0)
                {
                    m1 = sum[j];
                    m2 = get(i, j) + pri[j];
                    ret = max(ret, (m1 - 1) * n + m2);
                }
            printf(&quot;%d &quot;, ret);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><h2 id="E-Toy-Train"><a href="#E-Toy-Train" class="headerlink" title="E - Toy Train"></a><a href="https://vjudge.net/problem/CodeForces-1130D2" target="_blank" rel="noopener">E - Toy Train</a></h2><p>同上题</p>
<h2 id="F-Wrong-Answer"><a href="#F-Wrong-Answer" class="headerlink" title="F - Wrong Answer"></a><a href="https://vjudge.net/problem/CodeForces-1130E" target="_blank" rel="noopener">F - Wrong Answer</a></h2><p>构造。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #596（G）</title>
    <url>/tpaaaaaa.github.io/2019/11/24/CodeforcesRound#596%EF%BC%88G%EF%BC%89/</url>
    <content><![CDATA[<h2 id="C-TV-Subscriptions-Hard-Version"><a href="#C-TV-Subscriptions-Hard-Version" class="headerlink" title="C - TV Subscriptions (Hard Version)"></a><a href="https://vjudge.net/problem/CodeForces-1247B2" target="_blank" rel="noopener">C - TV Subscriptions (Hard Version)</a></h2><p>这种询问序列上的区间信息最优，且区间的长度固定了，那么可以用滑动窗口法，遍历一遍序列即可.</p>
<pre><code>/*
Date              : 2019-11-24    13:40:37
By                : Tpaaaaaa
File_Name         ：B1TVSubscriptionsEasyVersion.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
const int MAXM = 1e6 + 10;
int a[MAXN];
int vis[MAXM];
int main()
{
    int t;
    int n, k, d;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;k, &amp;d);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        int ans = INF;
        int cnt = 0;
        memset(vis, 0, sizeof vis);
        for(int j = 1; j &lt;= d; j++)
        {
            if(vis[a[j]] == 0)
                cnt++;
            vis[a[j]]++;
        }
        ans = cnt;
        for(int i = 2; i &lt;= n - d + 1; i++)
        {
            int st = i;
            int ed = i + d - 1;
            vis[a[st - 1]]--;
            if(vis[a[st - 1]] == 0)
            {
                cnt--;
            }

            vis[a[ed]]++;
            if(vis[a[ed]] == 1)
            {
                cnt++;
            }

            ans = min(ans, cnt);
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><h2 id="D-p-binary"><a href="#D-p-binary" class="headerlink" title="D - p-binary"></a><a href="https://vjudge.net/problem/CodeForces-1246A" target="_blank" rel="noopener">D - p-binary</a></h2><p>思路：</p>
<p>直接枚举答案，答案不会很大。i能够成为解的条件是，n - i*p的二进制表示中1的数目get(n - i * p)小于等于i，i小于等于n</p>
<p>也就是 get(n - i * p) &lt;= i &lt;= n - i * p;</p>
<pre><code>/*
Date              : 2019-11-24    14:04:50
By                : Tpaaaaaa
File_Name         ：Cbinary.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
inline int get(int u)
{
    int ret = 0;
    while(u &gt; 0)
    {
        if(u&amp;1) ret++;
        u &gt;&gt;= 1;
    }
    return ret;
}
int main()
{
    int n, p;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;p) != EOF)
    {
        int t = n;
        int ans = -1;
        for(int i = 1; i &lt;= 100; i++)
        {
            t = n - i * p;
            if(t &lt;= 0)  break;
            if(i &gt;= get(t) &amp;&amp; i &lt;= t)
            {
                ans = i;
                break;
            }

        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><h2 id="E-Power-Products"><a href="#E-Power-Products" class="headerlink" title="E - Power Products"></a><a href="https://vjudge.net/problem/CodeForces-1246B" target="_blank" rel="noopener">E - Power Products</a></h2><p><strong>某个数能表示成n = x^p的形式，说明这个数质因子分解后每个质因子的指数模p为0</strong></p>
<p>这题目是一对数(a, b)，使得a * b = x ^ p， 那么首先处理输入的每个数的质因子分解，将他们指数模p，那么对于任意的a，存在一个b使得 a * b = x^p，然后看这个b是不是存在输入中即可.查找就用map实现</p>
<pre><code>/*
Date              : 2019-11-25    11:22:21
By                : Tpaaaaaa
File_Name         ：PowerProducts.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

//将输入的序列质因数分解，然后将其指数对k取模.
//对于每一个数，有一个属于他的序列，记录的是他的质因数分解后的底数和指数模k(非0).
之后枚举每一个数，得到他的序列，然后用k减去他的序列的second，得到的新的序列（取非0），
然后去hash表中看一下这个序列有没有，如果有，就说找到hash&lt;&gt;对了.
最后总数除以2即可.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 5;
int n, k, tot;
bool Isprim[MAXN];
int pri[MAXN], a[MAXN];
typedef pair&lt;int, int&gt; P;
map &lt;vector&lt;P&gt;, int&gt; mp;
void init()
{
    memset(Isprim, true, sizeof Isprim);
    tot = 0;
    for(int i = 2; i &lt; 1e4; i++)
        if(Isprim[i])
        {
            pri[++tot] = i;
            for(int j = 2 * i; j &lt; 1e3; j += i)
                Isprim[j] = false;
        }
}
vector&lt;P&gt; get(int x)
{
    vector &lt;P&gt; vec;
    for(int i = 1; pri[i]*pri[i] &lt;= x; i++)
    {
        if(x % pri[i] == 0)
        {
            int cnt = 0;
            while(x % pri[i] == 0)
            {
                cnt++;
                x /= pri[i];
            }
            cnt = cnt % k;
            if(cnt)
            {
                vec.push_back(P(pri[i], cnt));

            }
        }
    }
    if(x &gt; 1)   vec.push_back(P(x,1));
    return vec;
}
vector&lt;P&gt; getMod(int x)
{
    vector &lt;P&gt; vec;
    for(int i = 1; pri[i]*pri[i] &lt;= x; i++)
    {
        if(x % pri[i] == 0)
        {
            int cnt = 0;
            while(x % pri[i] == 0)
            {
                cnt++;
                x /= pri[i];
            }
            cnt = cnt % k;
            if(cnt)
            {
                vec.push_back(P(pri[i],k - cnt));

            }
        }
    }
    if(x &gt; 1)   vec.push_back(P(x,k - 1));
    return vec;
}
int main()
{
    init();
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k)!=EOF)
    {
        mp.clear();
        for(int i = 1; i &lt;= n; i++) 
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            mp[get(a[i])]++;
        }
        ll ans = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x = a[i];
            vector&lt;P&gt; vec1 = getMod(x);
            vector&lt;P&gt; vec2 = get(x);
            ans += mp[vec1];
            if(vec1 == vec2)
                ans--;
        }
        printf(&quot;%lld\n&quot;, ans/2);
    }
    return 0;
}</code></pre><h2 id="F-Rock-Is-Push"><a href="#F-Rock-Is-Push" class="headerlink" title="F - Rock Is Push"></a><a href="https://vjudge.net/problem/CodeForces-1246C" target="_blank" rel="noopener">F - Rock Is Push</a></h2><p>dp[i][j][0] 表示从(i - 1, j )到(i, j)的方案数</p>
<p>dp[i][j][1] 表示从(i, j - 1) 到(i, j)的方案数</p>
<pre><code>/*
Date              : 2019-11-25    19:57:23
By                : Tpaaaaaa
File_Name         ：RockIsPush.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e3 + 5;
const int MOD = 1e9+7;
int n, m;
ll dp[MAXN][MAXN][2];
ll sumdp[MAXN][MAXN][2];
int sum[MAXN][MAXN][2];
char s[MAXN];
int Binsearch(int i, int j, int v, int op)
{
    if(op == 0)
    {
        int l = 1, r = n;
        while(l &lt;= r)
        {
            int mid = (l + r) / 2;
            if(sum[mid][j][0] &gt;= v)
                r = mid - 1;
            else
            {
                l = mid + 1;
            }
        }
        return l;
    }
    else
    {
        int l = 1, r = m;
        while(l &lt;= r)
        {
            int mid = (l + r) / 2;
            if(sum[i][mid][1] &gt;= v)
            {
                r = mid - 1;
            }
            else 
            {
                l = mid + 1;
            }
        }
        return l;
    }

}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        memset(sum, 0, sizeof sum);
        memset(sumdp, 0, sizeof sumdp);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%s&quot;, s);
            for(int j = 0; j &lt; m; j++)
            {
                sum[i][j + 1][0] = sum[i - 1][j + 1][0];
                sum[i][j + 1][1] = sum[i][j][1];
                if(s[j] == &apos;R&apos;)
                {
                    sum[i][j + 1][0]++;
                    sum[i][j + 1][1]++;
                }
            }
        }

        memset(dp, 0, sizeof dp);
        for(int i = 1; i &lt;= n - sum[n][1][0]; i++) sumdp[i][1][1] = dp[i][1][0] = 1;
        for(int i = 1; i &lt;= m - sum[1][m][1]; i++) sumdp[1][i][0] = dp[1][i][1] = 1;

        for(int i = 2; i &lt;= n; i++)
            for(int j = 2; j &lt;= m; j++)
            {
                int k = Binsearch(i, j, sum[n][j][0] - (n - i), 0);       //找第一个大于等于的
                dp[i][j][0] = (sumdp[i - 1][j][0] - sumdp[k - 1][j][0] + MOD) % MOD;
                k = Binsearch(i, j, sum[i][m][1] - (m - j) , 1);
                dp[i][j][1] = (sumdp[i][j - 1][1] - sumdp[i][k - 1][1] + MOD) % MOD;
                sumdp[i][j][0] = (sumdp[i - 1][j][0] + dp[i][j][1]) % MOD;
                sumdp[i][j][1] = (sumdp[i][j - 1][1] + dp[i][j][0]) % MOD;
            }
        if(n == 1 &amp;&amp; m == 1 &amp;&amp; sum[1][1][0] == 0)
            printf(&quot;%d\n&quot;, 1);
        else printf(&quot;%lld\n&quot;, (dp[n][m][1] + dp[n][m][0]) % MOD);
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/CodeForces-1246D" target="_blank" rel="noopener">G - Tree Factory</a>  </p>
<hr>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #592 (Div. 2) ()</title>
    <url>/tpaaaaaa.github.io/2019/11/22/CodeforcesRound#592(Div.2)()/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #466 (Div. 2)(done)</title>
    <url>/tpaaaaaa.github.io/2019/11/22/CodeforcesRound#466(Div.2)(done)/</url>
    <content><![CDATA[<h2 id="A-Points-on-the-line"><a href="#A-Points-on-the-line" class="headerlink" title="A - Points on the line"></a><a href="https://vjudge.net/problem/CodeForces-940A" target="_blank" rel="noopener">A - Points on the line</a></h2><p>水题.</p>
<h2 id="B-Our-Tanya-is-Crying-Out-Loud"><a href="#B-Our-Tanya-is-Crying-Out-Loud" class="headerlink" title="B - Our Tanya is Crying Out Loud"></a><a href="https://vjudge.net/problem/CodeForces-940B" target="_blank" rel="noopener">B - Our Tanya is Crying Out Loud</a></h2><p>水题，贪心一下。</p>
<p>这些题目，一定要仔细分析，分析出题目的特性。一定要动笔，别望着屏幕想，那实际上就是在发呆.</p>
<h2 id="C-Phone-Numbers"><a href="#C-Phone-Numbers" class="headerlink" title="C - Phone Numbers"></a><a href="https://vjudge.net/problem/CodeForces-940C" target="_blank" rel="noopener">C - Phone Numbers</a></h2><p>同样分析一下就知道规律了.</p>
<h2 id="D-Alena-And-The-Heater"><a href="#D-Alena-And-The-Heater" class="headerlink" title="D - Alena And The Heater"></a><a href="https://vjudge.net/problem/CodeForces-940D" target="_blank" rel="noopener">D - Alena And The Heater</a></h2><p>分析，按他意思来.</p>
<pre><code>/*
Date              : 2019-11-22    16:43:37
By                : Tpaaaaaa
File_Name         ：DAlenaAndTheHeater.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 1e9;
const int MAXN = 1e5 + 10;
int n;
int a[MAXN];
int b[MAXN];
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        int r = INF;
        int l = -INF;
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%1d&quot;, &amp;b[i]);
        for(int i = 5; i &lt;= n; i++)
        {
            if(b[i - 1] == 1 &amp;&amp; b[i - 2] == 1 &amp;&amp; b[i - 3] == 1 &amp;&amp; b[i - 4] == 1)
            {
                int minn = INF;
                minn = min(minn, a[i]);
                minn = min(minn, a[i - 1]);
                minn = min(minn, a[i - 2]);
                minn = min(minn, a[i - 3]);
                minn = min(minn, a[i - 4]);
                if(b[i] == 0)
                    r = min(r, minn - 1);
                else
                    r = max(r, minn);                    

            }
            else if(b[i - 1] == 0 &amp;&amp; b[i - 2] == 0 &amp;&amp; b[i - 3] == 0 &amp;&amp; b[i - 4] == 0)
            {

                    int maxx = -INF;
                    maxx = max(maxx, a[i]);
                    maxx = max(maxx, a[i - 1]);
                    maxx = max(maxx, a[i - 2]);
                    maxx = max(maxx, a[i - 3]);
                    maxx = max(maxx, a[i - 4]);
                    if(b[i] == 1)
                        l = max(l, maxx + 1); 
                    else 
                        l = min(l, maxx);      
            }
        }
        printf(&quot;%d %d\n&quot;, l, r);
    }
    return 0;
}</code></pre><h2 id="E-Cashback"><a href="#E-Cashback" class="headerlink" title="E - Cashback"></a><a href="https://vjudge.net/problem/CodeForces-940E" target="_blank" rel="noopener">E - Cashback</a></h2><p>DP。</p>
<p>这种线性上的关系，要往DP上面想。还有就是multiset的使用。</p>
<pre><code>c++语言中，multiset是&lt;set&gt;库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在O(logn)的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。</code></pre><p>我们可以用multiset来快速得到一个区间里面的最大值.窗口移动的时候随时取得最大值可以靠他.</p>
<pre><code>/*
Date              : 2019-11-22    15:09:22
By                : Tpaaaaaa
File_Name         ：ECashback.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
multiset &lt;ll&gt; h;
multiset &lt;ll&gt; :: iterator it;
ll n, c, a[MAXN], dp[MAXN], sum[MAXN];
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;c) != EOF)
    {
        sum[0] = 0;
        h.clear();
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            sum[i] = sum[i - 1] + a[i];
        }
        dp[0] = 0;
        for(int i = 1; i &lt;= c; i++)
        {
            dp[i] = dp[i - 1] + a[i];
            h.insert(a[i]);
        }  
        dp[c] = dp[c] - *(h.begin());
        for(int i = c + 1; i &lt;= n; i++)
        {
            it = h.find(a[i - c]);
            h.erase(it);
            h.insert(a[i]);
            it = h.begin();
            ll ext = *it;
            dp[i] = min(dp[i - 1] + a[i], dp[i - c] + (sum[i] - sum[i - c]) - ext);
        }
        printf(&quot;%lld\n&quot;, dp[n]);

    }
    return 0;
}</code></pre><h2 id="F-Machine-Learning"><a href="#F-Machine-Learning" class="headerlink" title="F - Machine Learning"></a><a href="https://vjudge.net/problem/CodeForces-940F" target="_blank" rel="noopener">F - Machine Learning</a></h2><p>带修莫队+离散化.这种序列的区间询问问题，如果在该序列上，已知[l, r]的情况，能在O(1)时间中得到[l, r + 1] [l, r - 1] [l - 1,r] [l + 1, r]的信息，那么就可以考虑使用莫队.</p>
<p>时间复杂度大概是O(n*sqrt(m) + m*logm)</p>
<p>带修莫队的时间复杂度大概是O(n^5/3);</p>
<pre><code>/*
Date              : 2019-11-25    08:57:46
By                : Tpaaaaaa
File_Name         ：MachineLearning.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
int block;
int n, m, numQ, numC, op;
//  用来求mex 记录某个数出现的次数
int sum[MAXN],     cnt[MAXN], ans[MAXN], a[MAXN];
int temp[MAXN], tempNum;    //离散化数组
struct Node                 //询问
{
    int l, r;
    int time;
    int id;                 //每个询问都有他的区间，时间点，和编号.
}q[MAXN];
bool cmp(Node a, Node b)
{
    return (a.l/block)^(b.l/block)?a.l&lt;b.l:((a.r/block)^(b.r/block)?a.r&lt;b.r:a.time&lt;b.time);
}
struct Change               //修改
{
    int pos, col;           
}c[MAXN];
//在区间里面添加x
//cnt[x] 表示x在这个区间里面出现的次数
//sum[y] 表示y这个数是否出现.
void add(int x)
{
    sum[cnt[x]]--;
    cnt[x]++;
    sum[cnt[x]]++;
}
void del(int x)
{
    sum[cnt[x]]--;
    cnt[x]--;
    sum[cnt[x]]++;
}
void change(int i, int t)
{
    if(c[t].pos &gt;= q[i].l &amp;&amp; c[t].pos &lt;= q[i].r)
    {
        del(a[c[t].pos]);
        add(c[t].col);
    }
    swap(a[c[t].pos], c[t].col);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m)!=EOF)
    {
        tempNum = 0;
        numQ = numC = 0;
        memset(cnt, 0, sizeof cnt);
        memset(sum, 0, sizeof sum);
        block = pow(n, 0.666666);      
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            temp[++tempNum] = a[i];
        }
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d&quot;, &amp;op);
            if(op == 1)
            {
                ++numQ;
                scanf(&quot;%d%d&quot;, &amp;q[numQ].l, &amp;q[numQ].r);
                q[numQ].time = numC;
                q[numQ].id = numQ;
            }
            else
            {
                ++numC;
                scanf(&quot;%d%d&quot;, &amp;c[numC].pos, &amp;c[numC].col);
                temp[++tempNum] = c[numC].col;
            }
        }
        //离散化.
        sort(temp + 1, temp + 1 + tempNum);
        tempNum = unique(temp + 1, temp + 1 + tempNum) - (temp);
        for(int i = 1; i &lt;= n; i++)
            a[i] = lower_bound(temp + 1, temp + 1 + tempNum, a[i]) - (temp + 0);
        for(int i = 1; i &lt;= numC; i++)
            c[i].col = lower_bound(temp + 1, temp + 1 + tempNum, c[i].col) - (temp + 0);
        //离散化结束.
        //对讯问排序
        sort(q + 1, q + 1 + numQ, cmp);
        int l = 1, r = 0, time = 0;
        for(int i = 1; i &lt;= numQ; i++)
        {
            int ql = q[i].l, qr = q[i].r, qtime = q[i].time;
            while(l &lt; ql)   del(a[l++]);
            while(l &gt; ql)   add(a[--l]);
            while(r &lt; qr)   add(a[++r]);
            while(r &gt; qr)   del(a[r--]);
            while(qtime &gt; time) change(i, ++time);
            while(qtime &lt; time) change(i, time--);
            ans[q[i].id] = 1;           //从1开始，0已经被占了.
            while(sum[ans[q[i].id]] &gt; 0)
            {
                ans[q[i].id]++;
            }
        }
        for(int i = 1; i &lt;= numQ; i++)
            printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>STL</title>
    <url>/tpaaaaaa.github.io/2019/11/22/STL/</url>
    <content><![CDATA[<h2 id="multiset用法总结"><a href="#multiset用法总结" class="headerlink" title="multiset用法总结"></a>multiset用法总结</h2><pre><code>c++语言中，multiset是&lt;set&gt;库中一个非常有用的类型，它可以看成一个序列，插入一个数，删除一个数都能够在O(logn)的时间内完成，而且他能时刻保证序列中的数是有序的，而且序列中可以存在重复的数。</code></pre><h2 id="map用法总结"><a href="#map用法总结" class="headerlink" title="map用法总结"></a>map用法总结</h2><p>Map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据 处理能力，由于这个特性，它完成有可能在我们处理一对一数据的时候，在编程上提供快速通道。这里说下map内部数据的组织，map内部自建一颗红黑树(一 种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的，后边我们会见识到有序的好处。</p>
<p><strong>1、map简介</strong></p>
<p>map是一类关联式容器。它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。</p>
<p>对于迭代器来说，可以修改实值，而不能修改key。</p>
<p><strong>2、map的功能</strong></p>
<p>自动建立Key － value的对应。key 和 value可以是任意你需要的类型。</p>
<p><strong>根据key值快速查找记录，查找的复杂度基本是Log</strong>(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次。</p>
<p>快速插入Key -Value 记录。</p>
<p>快速删除记录</p>
<p>根据Key 修改value记录。</p>
<p>遍历所有记录。</p>
<p>3、<a href="https://www.cnblogs.com/magisk/p/8809922.html" target="_blank" rel="noopener">C++ bitset 用法</a></p>
<p>C++的 bitset 在 bitset 头文件中，它是一种类似数组的结构，它的每一个元素只能是０或１，每个元素仅用１bit空间。</p>
<pre><code>bitset&lt;4&gt; bitset1;　　//无参构造，长度为４，默认每一位为０

bitset&lt;8&gt; bitset2(12);　　//长度为８，二进制保存，前面用０补充

string s = &quot;100101&quot;;
bitset&lt;10&gt; bitset3(s);　　//长度为10，前面用０补充

char s2[] = &quot;10101&quot;;
bitset&lt;13&gt; bitset4(s2);　　//长度为13，前面用０补充

cout &lt;&lt; bitset1 &lt;&lt; endl;　　//0000
cout &lt;&lt; bitset2 &lt;&lt; endl;　　//00001100
cout &lt;&lt; bitset3 &lt;&lt; endl;　　//0000100101
cout &lt;&lt; bitset4 &lt;&lt; endl;　　//0000000010101</code></pre><p>C++ STL中最基本以及最常用的类或容器无非就是以下几个：</p>
<ul>
<li>string</li>
<li>vector</li>
<li>set</li>
<li>list</li>
<li>map</li>
</ul>
<h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><p>首先看看我们C语言一般怎么使用字符串的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">char* s1 &#x3D; &quot;Hello SYSU!&quot;; &#x2F;&#x2F;创建指针指向字符串常量，这段字符串我们是不能修改的</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;想要创建 可以修改的字符串，我们可以使用数组分配空间</span></pre></td></tr><tr><td class="code"><pre><span class="line">char s2[20] &#x3D; &quot;Hello SYSU!&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;或者这样</span></pre></td></tr><tr><td class="code"><pre><span class="line">char s3[] &#x3D; &quot;Hello SYSU!&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;当然我们也可以动态分配内存</span></pre></td></tr><tr><td class="code"><pre><span class="line">char* s4 &#x3D; (char*)malloc(20）;</span></pre></td></tr><tr><td class="code"><pre><span class="line">gets(s4);</span></pre></td></tr></table></figure>

<p>C++ 标准库中的string表示可变长的字符串，它在头文件string里面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr></table></figure>

<p>用string初始化字符串分两类：用“=”号就是拷贝初始化，否则就是直接初始化。</p>
<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170725977-1802373773.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1;&#x2F;&#x2F;初始化字符串，空字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s2 &#x3D; s1; &#x2F;&#x2F;拷贝初始化，深拷贝字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s3 &#x3D; &quot;I am Yasuo&quot;; &#x2F;&#x2F;直接初始化，s3存了字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s4(10, &#39;a&#39;); &#x2F;&#x2F;s4存的字符串是aaaaaaaaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s5(s4); &#x2F;&#x2F;拷贝初始化，深拷贝字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s6(&quot;I am Ali&quot;); &#x2F;&#x2F;直接初始化</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s7 &#x3D; string(6, &#39;c&#39;); &#x2F;&#x2F;拷贝初始化，cccccc</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170743602-467536077.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s1;&#x2F;&#x2F;初始化字符串，空字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s2 &#x3D; s1; &#x2F;&#x2F;拷贝初始化，深拷贝字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s3 &#x3D; &quot;I am Yasuo&quot;; &#x2F;&#x2F;直接初始化，s3存了字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s4(10, &#39;a&#39;); &#x2F;&#x2F;s4存的字符串是aaaaaaaaaa</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s5(s4); &#x2F;&#x2F;拷贝初始化，深拷贝字符串</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s6(&quot;I am Ali&quot;); &#x2F;&#x2F;直接初始化</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s7 &#x3D; string(6, &#39;c&#39;); &#x2F;&#x2F;拷贝初始化，cccccc</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;string的各种操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s8 &#x3D; s3 + s6;&#x2F;&#x2F;将两个字符串合并成一个</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s3 &#x3D; s6;&#x2F;&#x2F;用一个字符串来替代另一个字符串的对用元素</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cin &gt;&gt; s1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s1 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s2 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s3 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s4 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s5 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s6 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s7 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s8 &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; &quot;s7 size &#x3D; &quot; &lt;&lt; s7.size() &lt;&lt; endl; &#x2F;&#x2F;字符串长度，不包括结束符</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; (s2.empty() ? &quot;This string is empty&quot; : &quot;This string is not empty&quot;) &lt;&lt; endl;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(&quot;pause&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170758758-2074743989.png" alt="img"></p>
<h3 id="string的IO操作"><a href="#string的IO操作" class="headerlink" title="string的IO操作"></a>string的IO操作</h3><p>使用cin读入字符串时，遇到空白就停止读取。比如程序输入的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;     Hello   World&quot;</span></pre></td></tr></table></figure>

<p>那么我们得到的字符串将是”Hello”，前面的空白没了，后面的world也读不出来。</p>
<p>如果我们想把整个hello world读进来怎么办？那就这样做</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;s1&gt;&gt;s2;</span></pre></td></tr></table></figure>

<p>hello存在s1里，world存在s2里了。</p>
<p>有时我们想把一个句子存下来，又不想像上面那样创建多个string来存储单词，怎么办？</p>
<p>那就是用getline来获取一整行内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">getline(cin, str);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span></pre></td></tr></table></figure>

<p>当把string对象和字符面值及字符串面值混在一条语句中使用时，必须确保+的两侧的运算对象至少有一个是string</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string s1 &#x3D; s2 + &quot;, &quot;; &#x2F;&#x2F;正确</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s3 &#x3D; &quot;s &quot; + &quot;, &quot;; &#x2F;&#x2F;错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s4 &#x3D; &quot;hello&quot; + &quot;, &quot; + s1; &#x2F;&#x2F;错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">string s5 &#x3D; s1 + &quot;hello &quot; + &quot;, &quot;; &#x2F;&#x2F;改一下顺序，s1放前头，正确了，注意理解&#x3D;号右边的运算顺序</span></pre></td></tr></table></figure>

<h3 id="处理string中的字符"><a href="#处理string中的字符" class="headerlink" title="处理string中的字符"></a>处理string中的字符</h3><p>访问字符串的每个字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; s3.size(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; s3[i] &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s3[i] &#x3D; &#39;s&#39;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>在C语言中我都是用下标或者指针来访问数组元素，而在C++里，有个新奇的东西叫做迭代器iterator，我们可以使用它来访问容器元素。</p>
<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170813805-608759904.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str(&quot;hi sysu&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">for (string::iterator it &#x3D; str.begin(); it !&#x3D; str.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们也可以是使用const_iterator使得访问元素时是能读不能写，这跟常量指针意思差不多。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string str2(&quot;hi sysu&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">for (string::const_iterator it &#x3D; str2.begin(); it !&#x3D; str2.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; *it &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *it &#x3D; &#39;l&#39;; &#x2F;&#x2F;这是错误的，不能写</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170831649-461472172.png" alt="img"></p>
<p>string还有一些很好用的函数，比如找子串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string sq(&quot;heoolo sdaa ss&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cout &lt;&lt; s.find(&quot;aa&quot;, 0) &lt;&lt; endl; &#x2F;&#x2F;返回的是子串位置。第二个参数是查找的起始位置，如果找不到，就返回string::npos</span></pre></td></tr><tr><td class="code"><pre><span class="line">if (s.find(&quot;aa1&quot;, 0) &#x3D;&#x3D; string::npos)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; &quot;找不到该子串！&quot; &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>C++ STL中的verctor好比是C语言中的数组，但是vector又具有数组没有的一些高级功能。与数组相比，vector就是一个可以不用再初始化就必须制定大小的边长数组，当然了，它还有许多高级功能。</p>
<p>要想用vector首先得包含头文件vector。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span></pre></td></tr></table></figure>

<p>怎么初始化？</p>
<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170846961-452229016.png" alt="img"></p>
<p>如果vector的元素类型是int，默认初始化为0；如果vector元素类型为string，则默认初始化为空字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;father&gt; v2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt; &gt;;  &#x2F;&#x2F;注意空格。这里相当于二维数组int a[n][n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v5 &#x3D; &#123; 1,2,3,4,5 &#125;; &#x2F;&#x2F;列表初始化,注意使用的是花括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v6 &#x3D; &#123; &quot;hi&quot;,&quot;my&quot;,&quot;name&quot;,&quot;is&quot;,&quot;lee&quot; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v7(5, -1); &#x2F;&#x2F;初始化为-1,-1,-1,-1,-1。第一个参数是数目，第二个参数是要初始化的值</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v8(3, &quot;hi&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v9(10); &#x2F;&#x2F;默认初始化为0</span></pre></td></tr><tr><td class="code"><pre><span class="line">vector&lt;int&gt; v10(4); &#x2F;&#x2F;默认初始化为空字符串</span></pre></td></tr></table></figure>

<p>如何向vector添加元素？</p>
<p>请使用push_back加入元素，并且这个元素是被加在数组尾部的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; 20; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v1.push_back(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>vector其他的操作</p>
<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170900399-1317226831.png" alt="img"></p>
<p>访问和操作vector中的每个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (int i &#x3D; 0; i &lt; v1.size(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v1[i] &#x3D; 100;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; v1[i] &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>注意：只能对已存在的元素进行赋值或者修改操作，如果是要加入新元素，务必使用push_back。push_back的作用有两个：告诉编译器为新元素开辟空间、将新元素存入新空间里。</p>
<p>比如下面的代码是错误的，但是编译器不会报错，就像是数组越界。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; vec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">vec[0] &#x3D; 1;  &#x2F;&#x2F;错误！</span></pre></td></tr></table></figure>

<p>当然我们也可以选择使用迭代器来访问元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector&lt;string&gt; v6 &#x3D; &#123; &quot;hi&quot;,&quot;my&quot;,&quot;name&quot;,&quot;is&quot;,&quot;lee&quot; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">for (vector&lt;string&gt;::iterator iter &#x3D; v6.begin(); iter !&#x3D; v6.end(); iter++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;下面两种方法都行</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; (*iter).empty() &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; iter-&gt;empty() &lt;&lt; endl; </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>上面是正向迭代，如果我们想从后往前迭代该如何操作？<br>使用反向迭代器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (vector&lt;string&gt;::reverse_iterator iter &#x3D; v6.rbegin(); iter !&#x3D; v6.rend(); iter++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>vector最常用的增删操作</p>
<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170914508-1325887310.png" alt="img"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;vector&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void showvector(vector&lt;T&gt; v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (vector&lt;T&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout &lt;&lt; *it;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vector&lt;string&gt; v6 &#x3D; &#123; &quot;hi&quot;,&quot;my&quot;,&quot;name&quot;,&quot;is&quot;,&quot;lee&quot; &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v6.resize(3);  &#x2F;&#x2F;重新调整vector容量大小</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v6);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    vector&lt;int&gt; v5 &#x3D; &#123; 1,2,3,4,5 &#125;; &#x2F;&#x2F;列表初始化,注意使用的是花括号</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; v5.front() &lt;&lt; endl; &#x2F;&#x2F;访问第一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; v5.back() &lt;&lt; endl; &#x2F;&#x2F;访问最后一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.pop_back(); &#x2F;&#x2F;删除最后一个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.push_back(6); &#x2F;&#x2F;加入一个元素并把它放在最后</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.insert(v5.begin()+1,9); &#x2F;&#x2F;在第二个位置插入新元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.erase(v5.begin() + 3);  &#x2F;&#x2F;删除第四个元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.insert(v5.begin() + 1, 7,8); &#x2F;&#x2F;连续插入7个8</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    v5.clear(); &#x2F;&#x2F;清除所有内容</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showvector(v5);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(&quot;pause&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170927321-678572314.png" alt="img"></p>
<p>注意：虽然vertor对象可以动态增长，但是也或有一点副作用：已知的一个限制就是不能再范围for循环中向vector对象添加元素。另外一个限制就是任何一种可能改变vector对象容量的操作，不如push_back，都会使该迭代器失效。</p>
<p>总而言之就是：但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素！</p>
<p>C++中push_back和insert两个有什么区别?</p>
<p>顾名思义push_back把元素插入容器末尾，insert把元素插入任何你指定的位置。<br>不过push_back速度一般比insert快。如果能用push_back尽量先用push_back。</p>
<h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>set跟vector差不多，它跟vector的唯一区别就是，set里面的元素是有序的且唯一的，只要你往set里添加元素，它就会自动排序，而且，如果你添加的元素set里面本来就存在，那么这次添加操作就不执行。要想用set先加个头文件set。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;set&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void showset(set&lt;T&gt; v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (set&lt;T&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout &lt;&lt; *it;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    set&lt;int&gt; s1&#123;9,8,1,2,3,4,5,5,5,6,7,7 &#125;; &#x2F;&#x2F;自动排序，从小到大,剔除相同项</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showset(s1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    set&lt;string&gt; s2&#123; &quot;hello&quot;,&quot;sysy&quot;,&quot;school&quot;,&quot;hello&quot; &#125;; &#x2F;&#x2F;字典序排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showset(s2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s1.insert(9); &#x2F;&#x2F;有这个值了，do nothing</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showset(s1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s2.insert(&quot;aaa&quot;); &#x2F;&#x2F;没有这个字符串，添加并且排序</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showset(s2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(&quot;pause&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170939664-2054900441.png" alt="img"></p>
<h1 id="list"><a href="#list" class="headerlink" title="list"></a>list</h1><p>list就是链表，在C语言中我们想使用链表都是自己去实现的，实现起来倒不难，但是如果有现成的高效的链表可以使用的话，我们就不需要重复造轮子了。STL就提供了list容器给我们。</p>
<p>list是一个双向链表，而单链表对应的容器则是foward_list。</p>
<p>list即双向链表的优点是插入和删除元素都比较快捷，缺点是不能随机访问元素。</p>
<p>初始化方式就大同小异了，跟vector基本一样。要想用list先加个头文件list。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;list&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">template &lt;typename T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void showlist(list&lt;T&gt; v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (list&lt;T&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout &lt;&lt; *it;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    list&lt;int&gt; l1&#123; 1,2,3,4,5,5,6,7,7 &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showlist(l1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    list&lt;double&gt; l2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    list&lt;char&gt; l3(10);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    list&lt;int&gt; l4(5, 10); &#x2F;&#x2F;将元素都初始化为10</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showlist(l4);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(&quot;pause&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602170954446-909787830.png" alt="img"></p>
<p>值得注意的是，list容器不能调用algorithm下的sort函数进行排序，因为sort函数要求容器必须可以随机存储，而list做不到。所以，list自己做了一个自己用的排序函数，用法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list&lt;int&gt; l1&#123; 8,5,7,6,1,2,3,4,5,5,6,7,7 &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">l1.sort();</span></pre></td></tr></table></figure>

<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>map运用了哈希表地址映射的思想，也就是key-value的思想，来实现的。</p>
<p>首先给出map最好用也最最常用的用法例子，就是用字符串作为key去查询操作对应的value。</p>
<p>要使用map得先加个头文件map。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;map&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include &lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">void showmap(map&lt;string, int&gt; v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (map&lt;string, int&gt;::iterator it &#x3D; v.begin(); it !&#x3D; v.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot;  &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;  &#x2F;&#x2F;注意用法，不是用*it来访问了。first表示的是key，second存的是value</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    map&lt;string, int&gt; m1; &#x2F;&#x2F;&lt;&gt;里的第一个参数表示key的类型,第二个参数表示value的类型</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1[&quot;Kobe&quot;] &#x3D; 100;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1[&quot;James&quot;] &#x3D; 99;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1[&quot;Curry&quot;] &#x3D; 98;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    string s(&quot;Jordan&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1[s] &#x3D; 90;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; m1[&quot;Kobe&quot;] &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; m1[&quot;Jordan&quot;] &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; m1[&quot;Durant&quot;] &lt;&lt; endl; &#x2F;&#x2F;不存在这个key，就显示0</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1.erase(&quot;Curry&quot;);&#x2F;&#x2F;通过关键字来删除</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showmap(m1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1.insert(pair&lt;string, int&gt;(&quot;Harris&quot;, 89)); &#x2F;&#x2F;也可以通过insert函数来实现增加元素</span></pre></td></tr><tr><td class="code"><pre><span class="line">    showmap(m1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1.clear(); &#x2F;&#x2F;清空全部</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    system(&quot;pause&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><img src="https://images2015.cnblogs.com/blog/1093303/201706/1093303-20170602171006649-580201339.png" alt="img"></p>
<p>如果想看看某个存不存在某个key，可以用count来判断</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (m1.count(&quot;Lee&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; &quot;Lee is in m1!&quot; &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">else</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; &quot;Lee do not exist!&quot; &lt;&lt; endl;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>用迭代器来访问元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (map&lt;string, int&gt;::iterator it &#x3D; m1.begin(); it !&#x3D; m1.end(); it++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cout &lt;&lt; it-&gt;first&lt;&lt;&quot;  &quot;&lt;&lt;it-&gt;second &lt;&lt; endl;  &#x2F;&#x2F;注意用法，不是用*it来访问了。first表示的是key，second存的是value</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>CodeForces - 987（no）</title>
    <url>/tpaaaaaa.github.io/2019/11/18/CodeForces-987%EF%BC%88no%EF%BC%89/</url>
    <content><![CDATA[<h2 id="C-Three-displays"><a href="#C-Three-displays" class="headerlink" title="C - Three displays"></a><a href="https://vjudge.net/problem/CodeForces-987C" target="_blank" rel="noopener">C - Three displays</a></h2><pre><code>/*
Date              : 2019-11-17    15:35:00
By                : Tpaaaaaa
File_Name         ：CThreedisplays.cpp
Description       : 
dp[i][1 2 3] 表示以i结尾的j个display的最低价格

有转移式 dp[i][j] = min{dp[k][j - 1]  其中 k &lt; i 且 s[k] &lt; s[i]} + c[i];

dp[i][1] = c[i];
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 3e3 + 10;
int n;
ll dp[MAXN][5];
ll s[MAXN], c[MAXN];
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%lld&quot;, &amp;s[i]);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%lld&quot;, &amp;c[i]);
        memset(dp, INF, sizeof dp);
        dp[1][1] = c[1];
        for(int i = 2; i &lt;= n; i++)
            for(int j = 1; j &lt;= 3; j++)
            {
                if(j == 1)  
                {
                    dp[i][1] = c[i];
                    continue;
                }
                dp[i][j] = INF;
                ll temp = INF;
                for(int k = j - 1; k &lt;= i - 1; k++)
                    if(s[k] &lt; s[i])
                        temp = min(temp, dp[k][j - 1]);
                dp[i][j] = min(dp[i][j], temp + c[i]);
            }
        ll ans = INF;
        for(int i = 3; i &lt;= n; i++)
            ans = min(ans, dp[i][3]);
        if(ans &lt; INF)   printf(&quot;%lld\n&quot;, ans);
        else printf(&quot;-1\n&quot;);
    }
    return 0;
}</code></pre><h2 id="D-Fair"><a href="#D-Fair" class="headerlink" title="D - Fair"></a><a href="https://vjudge.net/problem/CodeForces-987D" target="_blank" rel="noopener">D - Fair</a></h2><p>首先枚举物品种类。对于i类物品，我们将能够产出i类物品的城镇放入队列中，然后开始BFS，求出各个城镇距离i类物品最近的距离。</p>
<p>之后就对于每个城镇，设这个城镇产x，我们将dis[x]置为无穷多，然后将他的dis数组排一下序，取前两个之和即可.</p>
<pre><code>/*
Date              : 2019-11-17    17:01:01
By                : Tpaaaaaa
File_Name         ：FairCodeForces987D.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
const int MAXM = 105;
int n, m, s, k, cnt = 0;
int dis[MAXN][MAXM];
int goo[MAXN], head[MAXN];
struct Edge
{
    int v, next;
}edge[MAXN * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}

//当前在u点，求的是dis[u][t]
//距离t类物品的最短距离
int dfs(int fa, int u, int t)
{
    //printf(&quot;??&quot;);
    if(dis[u][t] != -1) return dis[u][t];
    if(goo[u] == t) return dis[u][t] = 0;
    int ret = INF;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == fa) continue;
        ret = min(ret, dfs(u, v, t) + 1);
    }
    return dis[u][t] = ret;
}
queue &lt;int&gt; q;
int main()
{
    while(scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;s) != EOF)
    {
        memset(head, -1, sizeof head);
        memset(dis, INF, sizeof dis);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;goo[i]);
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            addEdge(v, u);
        }
        for(int j = 1; j &lt;= k; j++)
        {
            for(int i = 1; i &lt;= n; i++)
                if(goo[i] == j)
                {
                    dis[i][j] = 0;
                    q.push(i);
                } 
            while(!q.empty())
            {
                int u = q.front();
                q.pop();
                for(int i = head[u]; i != -1; i = edge[i].next)
                {
                    int v = edge[i].v;
                    if(dis[v][j] &gt; dis[u][j] + 1)
                    {
                        dis[v][j] = dis[u][j] + 1;
                        q.push(v);
                    }
                }
            }
        }/*
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= k; j++)
                printf(&quot;%d &quot;, dis[i][j]);
            printf(&quot;\n&quot;);
        }*/
        for(int i = 1; i &lt;= n; i++)
            {
                dis[i][goo[i]] = INF;
                sort(dis[i] + 1, dis[i] + 1 + k);
                int ret = 0;
                for(int j = 1; j &lt;= s - 1; j++)
                    ret += dis[i][j];
                printf(&quot;%d &quot;, ret);
            }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><h2 id="E-Petr-and-Permutations"><a href="#E-Petr-and-Permutations" class="headerlink" title="E - Petr and Permutations"></a><a href="https://vjudge.net/problem/CodeForces-987E" target="_blank" rel="noopener">E - Petr and Permutations</a></h2><p><strong>置换的性质：</strong>任何一个置换都可以表示成若干个对换的乘积，且表示形式有无穷种，但是不同的形式，其奇偶型始终保持一致。</p>
<p><strong>置换转换成对换的乘积：</strong>如果存在一个置换为(a b c d) 则他可以转换为(a b) (a c) (a d)的形式。所以k阶的循环置换，可以转换为k - 1个对换的乘积(当然只是其中一种形式).</p>
<p><strong>找循环置换阶数的方法：</strong>将置换以有向图的方式保存，然后通过DFS求有向圈的长度即可。</p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 10;
int n;
int cnt, tot, head[MAXN];
bool vis[MAXN];
struct Edge
{
    int v, next;
}edge[MAXN];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs(int u)
{
    tot++;
    vis[u] = true;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(!vis[v]) dfs(v);
    }
}
int main()

{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int u;
            scanf(&quot;%d&quot;, &amp;u);
            addEdge(i, u);
        }
        memset(vis, false, sizeof vis);
        int ret = 0;
        for(int i = 1; i &lt;= n; i++)
            if(!vis[i])
            {
                tot = 0;
                dfs(i);
                ret += (tot - 1);
            }
        if(n % 2)
        {
            if(ret % 2) printf(&quot;Petr\n&quot;);
                else printf(&quot;Um_nik\n&quot;);
        }
        else 
        {
            if(ret % 2) printf(&quot;Um_nik\n&quot;);
            else printf(&quot;Petr\n&quot;);
        }

    }
    return 0;
}</code></pre><h2 id="F-AND-Graph"><a href="#F-AND-Graph" class="headerlink" title="F-AND Graph"></a>F-AND Graph</h2><h2 id="G-Prince’s-Problem"><a href="#G-Prince’s-Problem" class="headerlink" title="G- Prince’s Problem"></a>G- Prince’s Problem</h2><h2 id="I-Oppa-Funcan-Style-Remastered"><a href="#I-Oppa-Funcan-Style-Remastered" class="headerlink" title="I - Oppa Funcan Style Remastered"></a><a href="https://vjudge.net/problem/CodeForces-986F" target="_blank" rel="noopener">I - Oppa Funcan Style Remastered</a></h2><p>循环置换的性质:一个k阶的循环置换，执行pk次后都会变成I。（p为任意正整数）</p>
<p>故一个置换可以变成 a1阶 a2阶 … am阶循环置换的乘积，那么使得这个置换回到I最少需要执行LCM(a1, a2 …. am)次。</p>
<p>其次就是同余最短路了</p>
<p>终于赶在睡觉前解决这道题了</p>
<p>cf3200分的题，果然质量比较高</p>
<pre><code>/*
Date              : 2019-11-18    21:37:35
By                : Tpaaaaaa
File_Name         ：IOppaFuncanStyleRemastered2.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;      //图中点的数目
int tot, nump;
typedef pair&lt;ll, int&gt; P;
priority_queue &lt;P, vector &lt;P&gt;, greater &lt;P&gt;&gt; que; // 见注释① 
bool Isprime[50000000], inq[MAXN];
int prime[3002000];
ll d[MAXN];
ll pri[110];
ll n, k;
struct Que
{
    ll n, k;    //每次询问的两个变量
    int i;      //初始位置
    string ans; //答案
}ques[10000 + 5];
bool cmp(Que A, Que B)
{
    return A.k &lt; B.k;
}
bool cmp1(Que A, Que B)
{
    return A.i &lt; B.i;
}
void init(int nn)
{
    memset(Isprime, true, sizeof Isprime);
    tot = 0;
    for(int i = 2; i &lt; nn; i++)
        if(Isprime[i])
        {
            prime[++tot] = i;
            for(int j = 2; j * i &lt; nn; j++) Isprime[j * i] = false;
        }
}
int getFactor(ll k)
{
    int ret = 0;
    for(int i = 1; i &lt;= tot &amp;&amp; prime[i] * prime[i] &lt;= k; i++)
    {
        if(k % prime[i] == 0)
        {
            ret ++;
            pri[ret] = prime[i];
            while(k % prime[i] == 0)
                k /= prime[i];
        }
    }
    if(k &gt; 1)   pri[++ret] = k;
    return ret;
}
ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        ll temp = exgcd(b, a%b, y, x);
        y -= x * (a / b);
        return temp;
    }
}
void Dijkstra(int s)        // 这是链式前向星的写法 
{
    memset(d, INF, sizeof d);
    memset(inq, false ,sizeof inq);
    d[s] = 0;                                         // 将起点的d赋值为0 
    que.push(P(0,s));                                 //first 为值， second为编号
    while( !que.empty())
    {
        P now = que.top();
        que.pop();
        int u = now.second;                             //u记录的是弹出点的编号
        if(inq[u])
            continue;
        inq[u] = true;
               for(int i = 1; i &lt;= nump; i++)
               {
                  int v = (u + pri[i] % pri[1]) % pri[1];
                  if(d[v] &gt; d[u] + pri[i])
                  {
                       d[v] = d[u] + pri[i];
                       que.push(P(d[v], v));
                  }
               }                        
    } 

} 
int main()
{
    int t;
    init(5e7);
    cin &gt;&gt; t;
    for(int i = 1; i &lt;= t; i++)
    {
        scanf(&quot;%lld%lld&quot;, &amp;ques[i].n, &amp;ques[i].k);
        ques[i].i = i;
    }
    sort(ques + 1, ques + 1 + t, cmp);
    bool flag;
    k = -1;
    for(int kase = 1; kase &lt;= t; kase++)
    {   
        flag = false;
        n = ques[kase].n;
        if(k != ques[kase].k)          
        {
            k = ques[kase].k;
            nump = getFactor(k);
            if(nump == 1)
            {
                if(n % pri[1])  flag = false;   //NO
                else flag = true;               //YES
            }
            else if(nump == 2)
            {
                ll x, y;
                exgcd(pri[1], pri[2], x, y);
                ll inva = (x + pri[2]) % pri[2];    //a的逆元
                if(pri[1] * (n % pri[2] * inva % pri[2]) &lt;= n)   flag = true;
                else
                        flag = false;
            }
            else if(nump &gt; 2)
            {
                ll up = pri[1];             //以他为源点，为模数.
                //图中有up个点.
                Dijkstra(0);
                if(d[n % up] &lt;= n)    flag = true;
                else flag = false;
            }
            if(flag) ques[kase].ans = &quot;YES&quot;;
            else ques[kase].ans = &quot;NO&quot;;
        }
        else
        {
            if(nump == 1)
            {
                if(n % pri[1])  flag = false;   //NO
                else flag = true;               //YES
            }
            else if(nump == 2)
            {
                ll x, y;    //pri 是ll
                exgcd(pri[1], pri[2], x, y);
                ll inva = (x + pri[2]) % pri[2];    //a的逆元
                if(pri[1] * (n % pri[2] * inva % pri[2]) &lt;= n)   flag = true;
                else
                        flag = false;
            }
            else if(nump &gt; 2)
            {
                if(d[n % pri[1]] &lt;= n)    flag = true;
                else flag = false;
            }
            if(flag) ques[kase].ans = &quot;YES&quot;;
            else ques[kase].ans = &quot;NO&quot;;
        }
    }
    sort(ques + 1, ques + 1 + t, cmp1);
    for(int i = 1; i &lt;= t; i++)
        cout &lt;&lt; ques[i].ans &lt;&lt; endl;
    return 0;
}</code></pre><p>注意nump == 0的情况.</p>
<h2 id="G-Perfect-Encoding"><a href="#G-Perfect-Encoding" class="headerlink" title="G - Perfect Encoding"></a><a href="https://vjudge.net/problem/CodeForces-986D" target="_blank" rel="noopener">G - Perfect Encoding</a></h2><p>此代码WA 40测试点，不想改了…qaq</p>
<p>FFT来加速大数的乘法，大数压三位.</p>
<pre><code>/*
Date              : 2019-11-20    19:07:10
By                : Tpaaaaaa
File_Name         ：GPerfectEncoding.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e6;
struct BigInt
{
    const static int mod = 1000;    //压三位。
    int a[MAXN];
    int len;
    BigInt()
    {
        memset(a, 0, sizeof a);
        len = 1;
    }
    BigInt operator + (const BigInt &amp;b)const
    {
        BigInt res;
        res.len = max(len, b.len);
        for(int i = 0; i &lt;= res.len; i++)
            res.a[i] = 0;
        for(int i = 0; i &lt; res.len; i++)
        {
            res.a[i] += ((i &lt; len) ? a[i] : 0) + ((i &lt; b.len) ? b.a[i] : 0);
            res.a[i + 1] += res.a[i]/mod;
            res.a[i] %= mod; 
        }
        if(res.a[res.len] &gt; 0)  res.len++;
        return res;
    }
    bool operator &gt;= (const BigInt &amp;b)const
    {
        if(len != b.len)
        {
            return len &gt; b.len;
        }    
        else 
        {
            for(int i = 0; i &lt; len; i++)
                if(a[len - i - 1] != b.a[len - i - 1])  return a[len - i - 1] &gt;= b.a[len - i - 1];
        }
        return true;
    }
    bool operator &gt; (const BigInt &amp;b)const
    {
        if(len != b.len)
        {
            return len &gt; b.len;
        }    
        else 
        {
            for(int i = 0; i &lt; len; i++)
                if(a[len - i - 1] != b.a[len - i - 1])  return a[len - i - 1] &gt; b.a[len - i - 1];
        }
        return false;
    }
};

struct Complex
{
    double x, y;
    Complex(double x_ = 0.0, double y_ = 0.0)
    {
        x = x_;
        y = y_;
    }
    Complex operator - (const Complex &amp;b)const
    {
        return Complex(x - b.x, y - b.y);
    }
    Complex operator + (const Complex &amp;b)const
    {
        return Complex(x + b.x, y + b.y);
    }
    Complex operator * (const Complex &amp;b)const
    {
        return Complex(x * b.x - y * b.y, x * b.y + y * b.x);
    }
};
void change(Complex y[], int len)
{
    int i, j, k;
    for(i = 1, j = len / 2; i &lt; len - 1; i++)
    {
        if(i &lt; j) swap(y[i], y[j]);
        k = len / 2;
        while(j &gt;= k)
        {
            j -= k;
            k /= 2;
        }
        if(j &lt; k) j += k;
    }
}
void fft(Complex y[], int len, int on)
{
    change(y, len);
    for(int h = 2; h &lt;= len; h &lt;&lt;= 1)
    {
        Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h));
        for(int j = 0; j &lt; len; j+= h)
        {
            Complex w(1, 0);
            for(int k = j; k &lt; j + h / 2; k++)
            {
                Complex u = y[k];
                Complex t = w * y[k + h/2];
                y[k] = u + t;
                y[k + h/2] = u - t;
                w = w * wn;
            } 
        }
    }
    if(on == -1)
        for(int i = 0; i &lt; len; i++)
            y[i].x /= len;
}
//FFT大数的乘法.
Complex x1[MAXN], x2[MAXN];
BigInt mul(BigInt &amp;A, BigInt &amp;B)
{
    BigInt ret;
    int len1 = A.len;
    int len2 = B.len;
    int len = 1;
    while(len &lt; len1 * 2 || len &lt; len2 * 2) len &lt;&lt;= 1;
    for(int i = 0; i &lt; len1; i++)
        x1[i] = Complex(A.a[i] ,0);
    for(int i = len1; i &lt; len; i++)
        x1[i] = Complex(0, 0);
    for(int i = 0; i &lt; len2; i++)
        x2[i] = Complex(B.a[i], 0);
    for(int i = len2; i &lt; len; i++)
        x2[i] = Complex(0, 0);
    fft(x1, len, 1);
    fft(x2, len, 1);
    for(int i = 0; i &lt; len; i++)
        x1[i] = x1[i] * x2[i];
    fft(x1, len, -1);
    for(int i = 0; i &lt; len; i++)
        ret.a[i] = (int)(x1[i].x + 0.5);
    for(int i = 0; i &lt; len; i++)
    {
        ret.a[i + 1] += ret.a[i] / 1000;
        ret.a[i] %= 1000;               //压三位
    }
    while(ret.a[len - 1] == 0 &amp;&amp; len &gt; 1)   len--;
    ret.len = len;
    return ret;  
}
BigInt selfmul(BigInt A, int k)
{
    BigInt ret;
    ret.len = A.len;
    for(int i = 0; i &lt; A.len; i++)
        ret.a[i] = k * A.a[i];
    for(int i = 0; i &lt; A.len; i++)
    {
        ret.a[i + 1] += ret.a[i] / 1000;
        ret.a[i] %= 1000;               //压三位
    }
    if(ret.a[ret.len] &gt; 0)  ret.len++;

    return ret;
}
BigInt quickMod(BigInt a,int b)
{
    BigInt ans;
    ans.a[0] = 1;
    ans.len = 1;
    while (b)
    {
        if (b&amp;1)
            ans = mul(ans, a);
        a = mul(a, a);
        b &gt;&gt;= 1;
    }
    return ans;
}
char s[MAXN];
BigInt x;
int main()
{
    while(scanf(&quot;%s&quot;, s) != EOF)
    {
        int len = strlen(s);
        x.len = len / 3 + (len % 3 != 0);   //压三维.
        memset(x.a, 0, sizeof x.a);
        int cnt = 0;
        for(int i = 0; i &lt; len; i += 3)
        {
            if(len - i - 1 &gt;= 0)    x.a[cnt] += (s[len - i - 1] - &apos;0&apos;) * 1;
            if(len - i - 2 &gt;= 0)    x.a[cnt] += (s[len - i - 2] - &apos;0&apos;) * 10;
            if(len - i - 3 &gt;= 0)    x.a[cnt] += (s[len - i - 3] - &apos;0&apos;) * 100;
            cnt++;
        }
        if(x.len == 1 &amp;&amp; x.a[0] &lt;= 5)
        {
            printf(&quot;%d\n&quot;, x.a[0]);
            continue;
        }
        int t = (int)((len - 1) * (log(10) / log(3)));
        BigInt thr;
        thr.a[0] = 3;
        thr.len = 1;
        BigInt temp = quickMod(thr, max(0, t - 1));
        ll ret = max(0,(t-1)) * 3;
        while(x &gt; selfmul(temp, 3) &amp;&amp; x &gt; selfmul(temp, 4) &amp;&amp; x &gt; selfmul(temp, 2))
        {
            ret += 3;
            temp = selfmul(temp, 3);
        }
        if(selfmul(temp, 2) &gt;= x)ret += 2;
        else if(selfmul(temp, 3) &gt;= x) ret += 3;
        else if(selfmul(temp, 4) &gt;= x) ret += 4;
        printf(&quot;%lld\n&quot;, ret);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>记录，也是警醒</title>
    <url>/tpaaaaaa.github.io/2019/11/14/%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%B9%9F%E6%98%AF%E8%AD%A6%E9%86%92/</url>
    <content><![CDATA[<p>11.15 - 12.14</p>
<p>英语任务：每天一套卷子，两天一次听力</p>
<p>ACM: 3 - 5题</p>
<p>课程：学习 概率论，电路，数字逻辑</p>
<p>11.15</p>
<p>完成情况：</p>
<p>11.16</p>
<p>完成情况：</p>
<p>11.17</p>
<p>完成情况：</p>
<p>11.18</p>
<p>完成情况：</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>反思</title>
    <url>/tpaaaaaa.github.io/2019/11/14/%E5%8F%8D%E6%80%9D/</url>
    <content><![CDATA[<p>这一个月状态特别差，大部分时间都在混。明明有大把的时间，只草草的看完了组合数学和图论（只是看完而已，并没有消化，更没有练习，掌握特别差），题目也不想写，完全就是看看网课骗骗自己.</p>
<p>接下来一个月，一定要避免这种漫天听网课的行为，这就是自己的舒适区，在这个舒适区里面呆着，是无法提高的。知识储备已经够了，你要的是大量的训练，而不是舒舒服服的看着视频。</p>
<p>下个月的主要事务：</p>
<p>1，大学英语六级。</p>
<p>2，提高上课中的效率，不要发呆。</p>
<p>3，开始专题刷题，先别刷套题，比赛前刷再刷套题找感觉，平时训练应该是分模块的。总结自己的经验。</p>
<p>4，概率论，电路原理，数字逻辑这些课该找时间跟上来了，不然期末特别累。</p>
<p>5，继续归纳总结自己的模板和思路</p>
<p>6，一定的刷题量：每周20题。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[DP]思路</title>
    <url>/tpaaaaaa.github.io/2019/11/01/%5BDP%5D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>1、数列上的一些问题，可以考虑DP，因为线性数列很容易具有无后效性.</p>
<p>2、棋盘上的DP，一般以点为阶段，如果发现无法完全表示状态，去试着加维度。</p>
<p>2_1 在棋盘上面，所以根据经验应该是从上往下递推的</p>
<p>3、线性序列分组数的DP，可以定义dp[i]表示前i个数的分组数，所以有转移方程</p>
<p>dp[i] = dp[0] + dp[1] + dp[2] + dp[3] …. dp[i - 1]</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[数据结构]思路</title>
    <url>/tpaaaaaa.github.io/2019/11/01/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>1、<strong>树上 X到Y的路径积 :</strong> 可以转化为X到根的路径积乘Y到根的路径积 ， 除以LCA到根的路径积 ， 再除以LCA父节点到根的路径积.</p>
<p>2、<strong>待修莫队算法</strong>: <a href="https://blog.csdn.net/chenxiaoran666/article/details/82220385" target="_blank" rel="noopener">https://blog.csdn.net/chenxiaoran666/article/details/82220385</a></p>
<p>（不带修 O(n*sqrt(m)+mlogm)带修 O(n*logn+n^5/3)</p>
<p>3、<strong>莫队算法：</strong> <a href="https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html</a> ，莫队算法的适用条件：</p>
<pre><code>莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下：

1、只有询问没有修改。

2、允许离线。

3、在已知询问 [l,r] 答案的情况下可以 O(1) 得到 [l,r−1],[l,r+1],[l−1,r],[l+1,r] 的答案。

满足以上三个条件就可以在 O(nm−−√+mlogm) 的时间复杂度下得到每个询问的解。</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[图论]思路</title>
    <url>/tpaaaaaa.github.io/2019/11/01/%5B%E5%9B%BE%E8%AE%BA%5D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>1.要判断 a1x1 + a2x2 + a3x3 + …. + amxm = n 是否有解（a1, a2 …. am与n都给定，也就是问n能否被拆成a1,a2…am的和），可以考虑使用<strong>同余最短路</strong>。设最小的系数为ai将整个整数集分成模ai的剩余类，每个剩余类视为图中的点，x与y有边，当且仅当x+aj与y同余。建边完成后，得到一个图，求出0到各个剩余类的最短路。原方程有解的条件是dis[n % ai] &lt;= n. n由0到n%ai 这条最短路径上面的边组成，将n减去最短路径长度后，整除ai得到的就是ai对应的xi。</p>
<p>2.求连通分量的数目，用DFS。</p>
<p>3、看到有向图的第一思路都是缩点(但是要分析一波证明强联通分量中的个体可以拼凑成整体,一般都是边和点可以经过无数次然后贡献只算一次这种类型)DAG上面DP.</p>
<p>4、求最小割，除了最大流最小割定理之外，还可以求其对偶图的最短路.</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[数学]思路</title>
    <url>/tpaaaaaa.github.io/2019/11/01/%5B%E6%95%B0%E5%AD%A6%5D%E6%80%9D%E8%B7%AF/</url>
    <content><![CDATA[<p>我记得我高中也有几个本子专门记录解题思路的，效果貌似还可以.(数学从70补到130，理综从150到了250)。就用这个方法在ACM上试试.</p>
<p>思路就是题目与方法间的link而已.</p>
<p>1、快速求出n！的素因数的指数，也就是对n！进行素数分解。结合这个，就可以快速求出大组合数的素数分解。</p>
<p>2、F[i]=F[i-2]*2+F[i-1]+i^4 这种递推式可以用矩阵来加速递推.</p>
<p>3、对于a^b (mod m) 这种式子，如果b特别大，huge mod，那么我们可以考虑使用欧拉降幂公式 A^K≡A^(K%ϕ(m)+ϕ(m))( mod m) (K&gt;ϕ(m))</p>
<p>证明 <a href="https://blog.csdn.net/weixin_38686780/article/details/81272848" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38686780/article/details/81272848</a><br>4、枚举一个n的所有因子，可以考虑枚举所有小于sqrt(n)的因子，时间复杂度是o(sqrt(n)).</p>
<p>5、如果题目给的限制条件很多，并且相互都独立，可以考虑用容斥定理<a href="https://vjudge.net/problem/22646/origin" target="_blank" rel="noopener">UVA - 11401 </a></p>
<p>6、两个多项式的GCD，思路和普通的gcd一样，只不过要自己重载一下乘除法.</p>
<p>7、<strong>置换的性质：</strong>任何一个置换都可以表示成若干个对换的乘积，且表示形式有无穷种，但是不同的形式，其奇偶型始终保持一致。</p>
<p>8、<strong>置换转换成对换的乘积</strong>：如果存在一个置换为(a b c d) 则他可以转换为(a b) (a c) (a d)的形式。所以k阶的循环置换，可以转换为k - 1个对换的乘积(当然只是其中一种形式).</p>
<p>9、<strong>找循环置换阶数的方法：</strong>将置换以有向图的方式保存，然后通过DFS求有向圈的长度即可。</p>
<p>10、<strong>求a的逆元（模b），如果a和b是互质的，用扩欧求逆元。</strong>扩欧解的是ax + by = gcd(a,b)= 1这个方程，即ax = 1(mod b) 所以x就是a的逆元(模b)。通常情况下，a和b互质往往是这二者是一个数的素因子.</p>
<p>11、<strong>将询问离线：</strong>如果题目刻意告诉你 t组数据，每组数据都有一个n，但是这t个n中 最多只有x个不同的n，也就是说，测试组合很多，但是有许多相同的n。那么我们可以进行离线操作，将询问保存下来，排个序，将n相同的几组测试数据放在一起测试，省的重新建图之类的。</p>
<p>12、有些特别大的数，并且要对这些特别大的数进行一些繁琐的操作（例如快速幂之类的）显然要你自己写大数，并且在实现<strong>大数的乘法的时候，可以考虑用FFT来优化</strong>。</p>
<p>13、题目要将n进行素因数分解，我们只需要预处理出[2…sqrt(n)]的素数即可.因为如果n的因子包括sqrt(n)和某个大于sqrt(n)的数的话，他们的乘积就已经大于n了.</p>
<p>14、使用高精度时候，可以结合压位操作来优化乘法常数。</p>
<p>15、要计算大数的幂，乘等操作时，可以用FFT将卷积的O(n^2) 优化成O(nlogn).</p>
<p>16、估计超大数的对数，可以从他的十进制长度着手开始估计.例：n的十进制长度为1e6以下，是一个很大的大数了。那么我们怎么预估它的log3呢。</p>
<p>我们可以知道 n &gt;= 10^k (k为某个数)。因此，log3(n) &gt;= k * log3(10);</p>
<p>17、<strong>求n!中含有某个因子个数的方法 ：</strong></p>
<p>N!的质因子x的个数 == [N/x]+[N/x^2]+[N/x^3]+….</p>
<p>17.2、将1….n中的n个数进行质因子分解，那么这n个数分解后的素数p的指数之和，也可以用以上方式求.</p>
<p>18、N!的二进制表示中最低位1的位置 == 求 N!的质因子2的个数</p>
<p>19 、<strong>N!的质因子2的个数的另一个方法</strong>：<br>N!含有质因数2的个数，等于N减去N的二进制表示中1的个数</p>
<p>20、模数为素数时，求逆元的时候尽量使用费马小定理.(方便快捷.)</p>
<p>21、整除2的操作，可以等价为&gt;&gt;，乘2的操作，可以理解为&lt;&lt;</p>
<p>22、<strong>在一个序列中，寻找规定长短的区间，使得其中的某个属性值为k最优</strong>，每个点对于它所在的区间的属性有贡献。那么我们可以用<strong>滑动窗口法遍历一遍序列即可</strong>。</p>
<p>23、<strong>Dilworth定理: 偏序集能划分成的最少的全序集个数等于最大反链的元素个数</strong></p>
<p><strong>Dilworth定理的对偶定理</strong>：对于一个偏序集，其最少反链划分数等于其最长链的长度。</p>
<p>24、<strong>要使得若干个数的乘积为n，且使得这些数的和最小</strong>，那么这些数中3的数目一定越多越好.</p>
<p>25、所有大于3的素数模6或同余1，或同余5。这样就可以在条件苛刻的时候压缩筛素数的时间。</p>
<pre><code>//显然压空间可以用bitset，bitset存1e8的空间只需要12.5M。再利用2,3以外的素数==6x+-1，压缩一下就搞定了。 以下代码筛3e8的素数只需要250ms。
void prime()
{
    add(2); add(3); //单独考虑 
    for(int i = 5, d = 2; i &lt;= N; i += d, d = 6 - d) {
       if(!p[i/3]){
          add(i);
          if(i &gt; N/i) continue;
          for(int j = i * i, v = d; j &lt;= N; j += i*v, v = 6 - v)
            p[j/3] = 1;
       } 
    }
}</code></pre><p>26、 long long 的移位运算不能写成(1&lt;&lt;(h-1))，要写成（1LL&lt;&lt;（h-1））</p>
<p>27、<strong>生成树的数目：</strong> 矩阵树定理用于计算无向图生成树个数，和基尔霍夫矩阵的行列式密切相关。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 6155 - Subsequence Count</title>
    <url>/tpaaaaaa.github.io/2019/10/25/HDU6155-SubsequenceCount/</url>
    <content><![CDATA[<pre><code>题意：一个长度为n的二进制串，q个查询，两种操作:
1 l r 将在区间[l, r]的二进制串取反
2 l r 查询区间[l, r]的不同子序列的个数</code></pre><p>动态规划求01子串的数目，线段树维护矩阵.</p>
<h3 id="动态规划求不同01子串的数目"><a href="#动态规划求不同01子串的数目" class="headerlink" title="动态规划求不同01子串的数目"></a>动态规划求不同01子串的数目</h3><p>dp[i][j]表示用前i个字符组成的以j为结尾的01串个数。</p>
<p>如果第i个字符为0，则dp[i][0] = dp[i-1][1] + dp[i-1][0] + 1，dp[i][1] = dp[i-1][1]</p>
<p>如果第i个字符为1，则dp[i][1] = dp[i-1][1] + dp[i-1][0] + 1，dp[i][0] = dp[i-1][0]</p>
<p>对于序列 1 0 1 0</p>
<p>dp[3][1] 表示用前i个元素组成的以1结尾的01串的个数.</p>
<p>dp[3][0] 表示用前i个元素组成的以0结尾的01串的个数.</p>
<p>显然后者dp[3][0]的数目和用前i - 1个元素组成的以0结尾的01串个数是一样.</p>
<p>然后前者，因为第i个元素是也可用来组成以1结尾的子串的。将所有dp[i-1][0]所记录的子串后面添加一个1，就是新的以1结尾的子串了，因此我们</p>
<p>dp[3][1] = dp[2][0] + dp[2][1] + 1;</p>
<p>1是自己也可以当一个子串.</p>
<p>ε＝ε＝ε＝(#&gt;д&lt;)ﾉ好强呀，不看题解根本写不出呀o(╥﹏╥)o</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[数学]拉姆齐Ramsey定理</title>
    <url>/tpaaaaaa.github.io/2019/10/25/%5B%E6%95%B0%E5%AD%A6%5D%E6%8B%89%E5%A7%86%E9%BD%90Ramsey%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>Ramsey定理内容：在一个 n≥6的完全图Kn内，每边涂上红或蓝色，必然有一个红色的三角形或蓝色的三角形。</p>
<p>经典的友谊定理:在至少6人中，或者有3人，他们互相认识；或者有3人，他们两两互相不认识。  </p>
<p>好的文章<a href="https://blog.csdn.net/Feynman1999/article/details/76725788" target="_blank" rel="noopener">https://blog.csdn.net/Feynman1999/article/details/76725788</a></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]最大子段和</title>
    <url>/tpaaaaaa.github.io/2019/10/25/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/</url>
    <content><![CDATA[<p>*<em>一般问题： *</em><br>给定一整数序列A1， A2，… An （可能有负数），求A1<del>An的一个子序列Ai</del>Aj，使得Ai到Aj的和最大<br>例如：整数序列-2, 11, -4, 13, -5, 2, -5, -3, 12, -9的最大子序列的和为21。</p>
<p><strong>解法：</strong></p>
<ol>
<li>利用前缀和，暴力枚举区间长度和区间端点. 时间复杂度O(N^3)</li>
</ol>
<p>2. 分治</p>
<p>3. 动态规划.</p>
<p><strong>关于动态规划的解法</strong></p>
<p>sum[i] 为前缀和.</p>
<p>dp[i]为从1到i的最大子段和</p>
<p>由定义可知道,当b[i-1]&gt;0时,   b[i]=b[i-1]+a[i],否则b[i]=a[i].</p>
<p>b[j]=max{b[j-1]+a[j],a[j]},</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[数学]裴蜀定理</title>
    <url>/tpaaaaaa.github.io/2019/10/24/%5B%E6%95%B0%E5%AD%A6%5D%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>好的博客<a href="https://blog.csdn.net/lleozhang/article/details/82935400" target="_blank" rel="noopener">https://blog.csdn.net/lleozhang/article/details/82935400</a></p>
<p><img src="https://private.codecogs.com/gif.latex?a*x+b*y%3Dc" alt="a*x+b*y=c"></p>
<p><strong>定理：对于给定的正整数a，b，方程有解的充要条件为c是gcd（a，b）的整数倍</strong></p>
<p><strong>定理的推广：</strong></p>
<p>1.</p>
<p>方程</p>
<p><img src="https://private.codecogs.com/gif.latex?ax+by+cz+...+nm%3Df" alt="ax+by+cz+...+nm=f"></p>
<p>（其中a,b,c…n,f为整数）有解的充要条件是f为gcd（a,b,c,…,n）的整数倍 ，显然如果f是素数的话，gcd(a, b, c, … n) == 1</p>
<p>2.</p>
<p><img src="https://private.codecogs.com/gif.latex?a1*b1+a2*b2+...+an*bn" alt="a1*b1+a2*b2+...+an*bn"></p>
<p>给定一个序列{an}，求一个整数序列{bn}使得值最小（要求最小值为正数），求这个最小值</p>
<p>解：根据裴蜀定理的推广，原式最小值即为gcd(a1,a2…an)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 3260 The Fewest Coins</title>
    <url>/tpaaaaaa.github.io/2019/10/21/POJ3260TheFewestCoins/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 8495</p>
<p><strong>Accepted:</strong> 2688</p>
<p>Description</p>
<p>Farmer John has gone to town to buy some farm supplies. Being a very efficient man, he always pays for his goods in such a way that the smallest number of coins changes hands, i.e., the number of coins he uses to pay plus the number of coins he receives in change is minimized. Help him to determine what this minimum number is.</p>
<p>FJ wants to buy <em>T</em> (1 ≤ <em>T</em> ≤ 10,000) cents of supplies. The currency system has <em>N</em> (1 ≤ <em>N</em> ≤ 100) different coins, with values <em>V</em>1, <em>V</em>2, …, <em>VN</em> (1 ≤ <em>Vi</em> ≤ 120). Farmer John is carrying <em>C</em>1 coins of value <em>V</em>1, <em>C</em>2 coins of value <em>V</em>2, …., and <em>CN</em> coins of value <em>VN</em> (0 ≤ <em>Ci</em> ≤ 10,000). The shopkeeper has an unlimited supply of all the coins, and always makes change in the most efficient manner (although Farmer John must be sure to pay in a way that makes it possible to make the correct change).</p>
<p>InputLine 1: Two space-separated integers: <em>N</em> and <em>T</em>.<br>Line 2: N space-separated integers, respectively <em>V</em>1, <em>V</em>2, …, <em>VN</em> coins (<em>V</em>1, …<em>VN</em>)<br>Line 3: N space-separated integers, respectively <em>C</em>1, <em>C</em>2, …, <em>CN</em></p>
<p>OutputLine 1: A line containing a single integer, the minimum number of coins involved in a payment and change-making. If it is impossible for Farmer John to pay and receive exact change, output -1.</p>
<p>Sample Input</p>
<p>3 70<br>5 25 50<br>5 2 1</p>
<p>Sample Output</p>
<p>3</p>
<p>HintFarmer John pays 75 cents using a 50 cents and a 25 cents coin, and receives a 5 cents coin in change, for a total of 3 coins used in the transaction.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>明天好好分析这题，注意顺序 发现不排序也可以AC……</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    14:15:02
By                : Tpaaaaaa
File_Name         ：POJ3260TheFewestCoins.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
背包问题中，阶段顺序对答案有印象.一般用贪心解决顺序问题.//排序
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXM = 3e4 + 10;
const int EXTRA = 1e4 + 10;
int dp1[MAXM], dp2[MAXM];
int v[MAXN], c[MAXN], used[MAXM];
int n, m, t;
struct Node
{
    int v, c;
    friend bool operator &lt;(Node A, Node B)
    {
        return A.v &gt; B.v;
    }
}node[MAXN];
int main()
{
    //m是背包容量, n是物品种类
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;t) != EOF)
    {
        //v[]是价值，c[]是数目
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;node[i].v);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;node[i].c);
        不排序也AC了233//sort(node + 1, node + 1 + n);
        m = t + EXTRA;  //枚举FJ出 t+1, ... t+EXTRA 元
                        //与之对应的是卖家 找零1....EXTRA元
        //所以我们用完全背包预处理出dp2[1]...dp2[EXTRA]的最少钱数
        //用多重背包处理出dp1[t+1] .. dp[t + EXTRA]
        memset(dp1, INF, sizeof dp1);
        dp1[0] = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            memset(used, 0, sizeof used);
            for(int j = node[i].v; j &lt;= m; j++)
                if(dp1[j] &gt; dp1[j - node[i].v] + 1 &amp;&amp; used[j - node[i].v] &lt; node[i].c)
                {
                    //printf(&quot;j = %d, j - v[i] = %d\n&quot;, j, j - v[i]);
                    dp1[j] = dp1[j - node[i].v] + 1;
                    used[j] = used[j - node[i].v] + 1;
                }
        }
        //预处理出dp2[1] ... dp2[EXTRA]
        memset(dp2, INF, sizeof dp2);
        dp2[0] = 0;
        for(int i = 1; i &lt;= n; i++)
            for(int j = node[i].v; j &lt;= EXTRA; j++)
                dp2[j] = min(dp2[j], dp2[j - node[i].v] + 1);
        int ans = INF;
        for(int i = 0; i &lt;= EXTRA; i++)
            if(dp1[t + i] &lt; INF &amp;&amp; dp2[i] &lt; INF)
                ans = min(ans, dp1[t + i] + dp2[i]);
        printf(&quot;%d\n&quot;, ans == INF? -1:ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2184 Cow Exhibition</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJ2184CowExhibition/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 17501</p>
<p><strong>Accepted:</strong> 7131</p>
<p>Description”Fat and docile, big and dumb, they look so stupid, they aren’t much<br>fun…”<br>- Cows with Guns by Dana Lyons </p>
<p>The cows want to prove to the public that they are both smart and fun. In order to do this, Bessie has organized an exhibition that will be put on by the cows. She has given each of the N (1 &lt;= N &lt;= 100) cows a thorough interview and determined two values for each cow: the smartness Si (-1000 &lt;= Si &lt;= 1000) of the cow and the funness Fi (-1000 &lt;= Fi &lt;= 1000) of the cow. </p>
<p>Bessie must choose which cows she wants to bring to her exhibition. She believes that the total smartness TS of the group is the sum of the Si’s and, likewise, the total funness TF of the group is the sum of the Fi’s. Bessie wants to maximize the sum of TS and TF, but she also wants both of these values to be non-negative (since she must also show that the cows are well-rounded; a negative TS or TF would ruin this). Help Bessie maximize the sum of TS and TF without letting either of these values become negative.   </p>
<p>Input* Line 1: A single integer N, the number of cows </p>
<p>* Lines 2..N+1: Two space-separated integers Si and Fi, respectively the smartness and funness for each cow.   </p>
<p>Output* Line 1: One integer: the optimal sum of TS and TF such that both TS and TF are non-negative. If no subset of the cows has non-negative TS and non- negative TF, print 0. </p>
<p>Sample Input</p>
<p>5<br>-5 7<br>8 -6<br>6 -3<br>2 1<br>-8 -5</p>
<p>Sample Output</p>
<p>8</p>
<p>HintOUTPUT DETAILS: </p>
<p>Bessie chooses cows 1, 3, and 4, giving values of TS = -5+6+2 = 3 and TF<br>= 7-3+1 = 5, so 3+5 = 8. Note that adding cow 2 would improve the value<br>of TS+TF to 10, but the new value of TF would be negative, so it is not<br>allowed. </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>下标有负数，可以通过加一个偏移量，变成正的即可.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-18    22:22:18
By                : Tpaaaaaa
File_Name         ：HDU2184CowExhibition.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

dp[i][j] 表示考虑前i个牛，TS为j的情况下，最高的TF值
妙呀小田
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
const int ZERO = 2e5;
const int MAXM = 4e5 + 100;
int n, s[MAXN], f[MAXN], dp[MAXM];
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;s[i], &amp;f[i]);
        memset(dp, -INF, sizeof dp);
        dp[ZERO] = 0;
        for(int i = 1; i &lt;= n; i++)
            if(s[i] &gt; 0)
                for(int j = MAXM - 1; j &gt;= s[i]; j--)
                    dp[j] = max(dp[j], dp[j - s[i]] + f[i]);
            else
                for(int j = 0; j - s[i] &lt; MAXM;j++)
                    dp[j] = max(dp[j], dp[j - s[i]] + f[i]);
        bool flag = false;
        int ans = 0;
        for(int i = MAXM - 1; i &gt;= ZERO; i--)
            if(dp[i] &gt;= 0)
                ans = max(ans, i + dp[i] - ZERO);

        printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题.</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2639 Bone Collector II</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU2639BoneCollectorII/</url>
    <content><![CDATA[<p>*<em>Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 7174    Accepted Submission(s): 3808<br>*</em></p>
<p>Problem DescriptionThe title of this problem is familiar,isn’t it?yeah,if you had took part in the “Rookie Cup” competition,you must have seem this title.If you haven’t seen it before,it doesn’t matter,I will give you a link:</p>
<p>Here is the link:<a href="http://acm.hdu.edu.cn/showproblem.php?pid=2602" target="_blank" rel="noopener">http://acm.hdu.edu.cn/showproblem.php?pid=2602</a></p>
<p>Today we are not desiring the maximum value of bones,but the K-th maximum value of the bones.NOTICE that,we considerate two ways that get the same value of bones are the same.That means,it will be a strictly decreasing sequence from the 1st maximum , 2nd maximum .. to the K-th maximum.</p>
<p>If the total number of different values is less than K,just ouput 0.<br>InputThe first line contain a integer T , the number of cases.<br>Followed by T cases , each case three lines , the first line contain two integer N , V, K(N &lt;= 100 , V &lt;= 1000 , K &lt;= 30)representing the number of bones and the volume of his bag and the K we need. And the second line contain N integers representing the value of each bone. The third line contain N integers representing the volume of each bone.  </p>
<p>OutputOne integer per line representing the K-th maximum of the total value (this number will be less than 231).  </p>
<p>Sample Input</p>
<p>3<br>5 10 2<br>1 2 3 4 5<br>5 4 3 2 1<br>5 10 12<br>1 2 3 4 5<br>5 4 3 2 1<br>5 10 16<br>1 2 3 4 5<br>5 4 3 2 1</p>
<p>Sample Output</p>
<p>12<br>2<br>0</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>背包问题的第k优解的求法.</p>
<p>多开一维.见代码，可做模板</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-18    22:54:18
By                : Tpaaaaaa
File_Name         ：HDU2639BoneCollectorII.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

dp[i][j][k] 表示考虑前i个变量，使得和为j的第k优解
得到状态转移
dp[i][j] = merge(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
merge归并排序
妙呀,前i个变量的前k优解，就是由转移向他的两个状态的各自的前k优解再比试一下
得到的前k优解

要用到的函数
merge(int *, const int *,const int *, extra);
int l = 1, r = 1;
int s = 1;
while(s &lt;= k)
{
    if([l] &lt; [r])
    {
        nas[s] = [r];
        r++;
    }
    else
    {
        nas[s] = [l];
        l++;
    }
    s++;
}
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
const int MAXM = 1e3 + 10;
const int MAXK = 30 + 10;
int n, v, k;
int w[MAXN], c[MAXN];
int dp[MAXN][MAXM][MAXK];
int A[MAXK], B[MAXK];
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;k);    //第k优解，v是背包容量，n是物件种类
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;w[i]); //物品价值
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]); //物品体积
        memset(dp, 0, sizeof dp);/*
        for(int i = 1; i &lt;= n; i++)
            for(int j = 0; j &lt;= v; j++)
                if(j &gt;= c[i])           //两种转移方法
                {
                    int l = 1, r = 1, s = 1;
                    while(s &lt;= k)
                    {
                        if(dp[i - 1][j - c[i]][r] + w[i] &gt; dp[i - 1][j][l])
                        {
                            dp[i][j][s] = dp[i - 1][j - c[i]][r] + w[i];
                            r++;
                        }
                        else if(dp[i - 1][j - c[i]][r] + w[i] &lt; dp[i - 1][j][l])
                        {
                            dp[i][j][s] = dp[i - 1][j][l];
                            l++;
                        }
                        else
                        {
                            dp[i][j][s] = dp[i - 1][j][l];
                            r++, l++;
                        }
                        s++;
                    }
                }
                else                    //只有一种转移方法
                    memcpy(dp[i][j], dp[i - 1][j], sizeof dp[i - 1][j]); */     
        for(int i = 1; i &lt;= n; i++)
            for(int j = 0; j &lt;= v; j++)
                if(j &gt;= c[i])           //两种转移方法
                {
                    for(int o = 1; o &lt;= k; o++)
                    {
                        A[o] = dp[i - 1][j][o];
                        B[o] = dp[i - 1][j - c[i]][o] + w[i];
                    }
                    int x = 1, y = 1, z = 1;
                    A[k + 1] = B[k + 1] = -1;//??
                    while(z &lt;= k &amp;&amp; (x &lt;= k || y &lt;= k))
                    {
                        if(A[x] &gt; B[y])
                            dp[i][j][z] = A[x++];
                        else
                            dp[i][j][z] = B[y++];
                        if(dp[i][j][z] != dp[i][j][z - 1])
                            z++;
                    }
                }
                else memcpy(dp[i][j], dp[i - 1][j], sizeof dp[i - 1][j]);


        printf(&quot;%d\n&quot;, dp[n][v][k]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>背包问题的第k优解</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3466 Proud Merchants</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU3466ProudMerchants/</url>
    <content><![CDATA[<p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 131072/65536 K (Java/Others)<br>Total Submission(s): 9596    Accepted Submission(s): 4032<br>*</em></p>
<p>Problem DescriptionRecently, iSea went to an ancient country. For such a long time, it was the most wealthy and powerful kingdom in the world. As a result, the people in this country are still very proud even if their nation hasn’t been so wealthy any more.<br>The merchants were the most typical, each of them only sold exactly one item, the price was Pi, but they would refuse to make a trade with you if your money were less than Qi, and iSea evaluated every item a value Vi.<br>If he had M units of money, what’s the maximum value iSea could get?</p>
<p>InputThere are several test cases in the input.</p>
<p>Each test case begin with two integers N, M (1 ≤ N ≤ 500, 1 ≤ M ≤ 5000), indicating the items’ number and the initial money.<br>Then N lines follow, each line contains three numbers Pi, Qi and Vi (1 ≤ Pi ≤ Qi ≤ 100, 1 ≤ Vi ≤ 1000), their meaning is in the description.</p>
<p>The input terminates by end of file marker.</p>
<p>OutputFor each test case, output one integer, indicating maximum value iSea could get.</p>
<p>Sample Input</p>
<p>2 10<br>10 15 10<br>5 10 5<br>3 10<br>5 10 5<br>3 5 6<br>2 7 3</p>
<p>Sample Output</p>
<p>5<br>11</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>枚举阶段的顺序，对dp是有影响的，明天好好研究研究.!!!QAQ</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    08:07:21
By                : Tpaaaaaa
File_Name         ：HDU3466ProudMerchants.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
A  p1, q1;
B  p2, q2;

如果先选A， p1 + q2 &lt; p2 + q1;
所以 p1 - q1 &lt; p2 - q2;
所以按照 p - q 递增排序.

q1 - p1 &gt; q2 - p2;
如果q1 - p1 &gt; q2 - p2

则有q1 + p2 &gt; q2 + p1;
    B        A
也就是选了A就能够选B
所以
                if(j &gt;= node[i].q)                                                  //能够第一个选i
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - node[i].p] + node[i].v); //那么也就是往前转移
                else
                dp[i][j] = dp[i - 1][j];
dp[i][j]指的是考虑前i个物品，有j元能够购买的最大价值
在枚举的时候，枚举i的时候
dp[i][j]是考虑拥有j元，第一次购买买i的情况
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 510;
const int MAXM = 5e3 + 10;
int n, m;
struct Node
{
    int p, q, v;
    friend bool operator &lt; (const Node A, const Node B)
    {
        return (A.q - A.p) &lt; (B.q - B.p);
    }
}node[MAXN];
int dp[MAXN][MAXM];
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF) //n是物件数目，m是背包容量
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d%d&quot;, &amp;node[i].p, &amp;node[i].q, &amp;node[i].v);
        sort(node + 1, node + 1 + n);
        memset(dp, 0, sizeof dp);
        dp[0][0] = 0;
        for(int i = 1; i &lt;= n; i++)
            for(int j = m; j &gt;= 0; j--)
                if(j &gt;= node[i].q)
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - node[i].p] + node[i].v);
                else
                dp[i][j] = dp[i - 1][j];
        printf(&quot;%d\n&quot;, dp[n][m]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>枚举阶段的顺序对DP后效性的影响</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2126 Buy the souvenirs</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU2126Buythesouvenirs/</url>
    <content><![CDATA[<p>*<em>Time Limit: 10000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 3650    Accepted Submission(s): 1412<br>*</em></p>
<p>Problem DescriptionWhen the winter holiday comes, a lot of people will have a trip. Generally, there are a lot of souvenirs to sell, and sometimes the travelers will buy some ones with pleasure. Not only can they give the souvenirs to their friends and families as gifts, but also can the souvenirs leave them good recollections. All in all, the prices of souvenirs are not very dear, and the souvenirs are also very lovable and interesting. But the money the people have is under the control. They can’t buy a lot, but only a few. So after they admire all the souvenirs, they decide to buy some ones, and they have many combinations to select, but there are no two ones with the same kind in any combination. Now there is a blank written by the names and prices of the souvenirs, as a top coder all around the world, you should calculate how many selections you have, and any selection owns the most kinds of different souvenirs. For instance:</p>
<p><img src="http://acm.hdu.edu.cn/data/images/C95-1004-1.jpg" alt=""></p>
<p>And you have only 7 RMB, this time you can select any combination with 3 kinds of souvenirs at most, so the selections of 3 kinds of souvenirs are ABC (6), ABD (7). But if you have 8 RMB, the selections with the most kinds of souvenirs are ABC (6), ABD (7), ACD (8), and if you have 10 RMB, there is only one selection with the most kinds of souvenirs to you: ABCD (10).  </p>
<p>InputFor the first line, there is a T means the number cases, then T cases follow.<br>In each case, in the first line there are two integer n and m, n is the number of the souvenirs and m is the money you have. The second line contains n integers; each integer describes a kind of souvenir.<br>All the numbers and results are in the range of 32-signed integer, and 0&lt;=m&lt;=500, 0&lt;n&lt;=30, t&lt;=500, and the prices are all positive integers. There is a blank line between two cases.<br>OutputIf you can buy some souvenirs, you should print the result with the same formation as “You have S selection(s) to buy with K kind(s) of souvenirs”, where the K means the most kinds of souvenirs you can buy, and S means the numbers of the combinations you can buy with the K kinds of souvenirs combination. But sometimes you can buy nothing, so you must print the result “Sorry, you can’t buy anything.”<br>Sample Input</p>
<p>2<br>4 7<br>1 2 3 4</p>
<p>4 0<br>1 2 3 4</p>
<p>Sample Output</p>
<p>You have 2 selection(s) to buy with 3 kind(s) of souvenirs.<br>Sorry, you can’t buy anything.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>01背包，but DP里面存的是方案数，所以转移方程就是 两个可以转移过来的状态值相加了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    08:50:37
By                : Tpaaaaaa
File_Name         ：HDU2126Buythesouvenirs.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
dp[j][k]考虑前i个物品，有j元钱，买k个种类物品的方案数
初始状态是我任意钱，买0类物品的方案数都是1.
初始化，转移方程.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 35;
const int MAXM = 510;
const int MAXK = 35;
int n, m;
int p[MAXN];
int dp[MAXM][MAXK];
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);  //n是物品数量，m是背包容量
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;p[i]);
        memset(dp, 0, sizeof dp);
        for(int i = 0; i &lt;= m; i++)
            dp[i][0] = 1;
        for(int i = 1; i &lt;= n; i++)
            for(int j = m; j &gt;= p[i]; j--)
                for(int k = 1; k &lt;= i; k++)
                    dp[j][k] = dp[j][k] + dp[j - p[i]][k - 1];
        int ans = 0;
        int i;
        for(i = n; i &gt;= 0; i--)
            if(dp[m][i] != 0)   break;
        if(i == 0)  printf(&quot;Sorry, you can&apos;t buy anything.\n&quot;);
        else   
            printf(&quot;You have %d selection(s) to buy with %d kind(s) of souvenirs.\n&quot;, dp[m][i], i);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>01背包求最值方案数</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3181Dollar Dayz</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJ3181DollarDayz/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 11679</p>
<p><strong>Accepted:</strong> 4296</p>
<p>DescriptionFarmer John goes to Dollar Days at The Cow Store and discovers an unlimited number of tools on sale. During his first visit, the tools are selling variously for $1, $2, and $3. Farmer John has exactly $5 to spend. He can buy 5 tools at $1 each or 1 tool at $3 and an additional 1 tool at $2. Of course, there are other combinations for a total of 5 different ways FJ can spend all his money on tools. Here they are: </p>
<pre><code>1 @ US$3 + 1 @ US$2

1 @ US$3 + 2 @ US$1

1 @ US$2 + 3 @ US$1

2 @ US$2 + 1 @ US$1

5 @ US$1</code></pre><p>Write a program than will compute the number of ways FJ can spend N dollars (1 &lt;= N &lt;= 1000) at The Cow Store for tools on sale with a cost of $1..$K (1 &lt;= K &lt;= 100).</p>
<p>InputA single line with two space-separated integers: N and K.</p>
<p>OutputA single line with a single integer that is the number of unique ways FJ can spend his money.</p>
<p>Sample Input</p>
<p>5 3</p>
<p>Sample Output</p>
<p>5</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>完全背包+简陋的高精度.</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-19    09:14:57
By                : Tpaaaaaa
File_Name         ：POJ3181DollarDayz.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

一种简陋版本的高精度.
完全背包.
dp[i][j]表示的是考虑前i个物品, 花掉j元的方案数.

转移方程
    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - c[i]].
初始化
memset(dp, 0, sizeof dp);
dp[0][0] = 1;
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXK = 110;
int n, k;
ull dp1[MAXN];                          //前面18位
ull dp2[MAXN];                          //后面18位
const ull MOD = 1e18;
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) != EOF) //n是背包容量, k为物品种类.
    {
        memset(dp1, 0, sizeof dp1);
        memset(dp2, 0, sizeof dp2);
        dp2[0] = 1;
        for(int i = 1; i &lt;= k; i++)
            for(int j = i; j &lt;= n; j++)
            {
                dp1[j] += dp1[j - i];
                dp1[j] += (dp2[j] + dp2[j - i]) / MOD;
                dp2[j] = (dp2[j] + dp2[j - i]) % MOD;
            }
        if(dp1[n] == 0)
            printf(&quot;%llu&quot;, dp2[n]);
        else
        printf(&quot;%llu%llu\n&quot;, dp1[n], dp2[n]); 
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>完全背包，高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1787 Charlie Change</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJ1787CharlieChange/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 30000K</p>
<p><strong>Total Submissions:</strong> 5762</p>
<p><strong>Accepted:</strong> 1865</p>
<p>DescriptionCharlie is a driver of Advanced Cargo Movement, Ltd. Charlie drives a lot and so he often buys coffee at coffee vending machines at motorests. Charlie hates change. That is basically the setup of your next task. </p>
<p>Your program will be given numbers and types of coins Charlie has and the coffee price. The coffee vending machines accept coins of values 1, 5, 10, and 25 cents. The program should output which coins Charlie has to use paying the coffee so that he uses as many coins as possible. Because Charlie really does not want any change back he wants to pay the price exactly.   </p>
<p>InputEach line of the input contains five integer numbers separated by a single space describing one situation to solve. The first integer on the line P, 1 &lt;= P &lt;= 10 000, is the coffee price in cents. Next four integers, C1, C2, C3, C4, 0 &lt;= Ci &lt;= 10 000, are the numbers of cents, nickels (5 cents), dimes (10 cents), and quarters (25 cents) in Charlie’s valet. The last line of the input contains five zeros and no output should be generated for it.</p>
<p>OutputFor each situation, your program should output one line containing the string “Throw in T1 cents, T2 nickels, T3 dimes, and T4 quarters.”, where T1, T2, T3, T4 are the numbers of coins of appropriate values Charlie should use to pay the coffee while using as many coins as possible. In the case Charlie does not possess enough change to pay the price of the coffee exactly, your program should output “Charlie cannot buy coffee.”.</p>
<p>Sample Input</p>
<p>12 5 3 1 2<br>16 0 0 0 1<br>0 0 0 0 0</p>
<p>Sample Output</p>
<p>Throw in 2 cents, 2 nickels, 0 dimes, and 0 quarters.<br>Charlie cannot buy coffee.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>多重背包优化为完全背包（用used数组）</p>
<p>背包问题记录路径的方法。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    11:52:38
By                : Tpaaaaaa
File_Name         ：POJ1787CharlieChange.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

将多重背包优化成完全背包
并且记录路径.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 5;
int dp[MAXN], used[MAXN], path[MAXN];
int c[5];
int m[] = {0, 1, 5, 10, 25};
int ans[100];
int main()
{
    int p;
    while(scanf(&quot;%d%d%d%d%d&quot;, &amp;p, &amp;c[1], &amp;c[2], &amp;c[3], &amp;c[4]) != EOF)
    {
        if(c[1] + c[2] + c[3] + c[4] + p == 0)  break;
        memset(dp, -INF, sizeof dp);
        dp[0] = 0;
        path[0] = -1;
        memset(ans, 0, sizeof ans);
        for(int i = 1; i &lt;= 4; i++)
        {
            memset(used, 0, sizeof used);
            for(int j = m[i]; j &lt;= p; j++)
                if(dp[j] &lt; dp[j - m[i]] + 1 &amp;&amp; dp[j - m[i]] &gt;= 0 &amp;&amp; used[j - m[i]] &lt; c[i])
                {
                    dp[j] = dp[j - m[i]] + 1;
                    used[j] = used[j - m[i]] + 1;
                    path[j] = j - m[i];
                }
        }
        if(dp[p] &lt; 0)
            printf(&quot;Charlie cannot buy coffee.\n&quot;);
        else
        {
            int i = p;
            while(path[i] != -1)
            {
                ans[i - path[i]]++;
                i = path[i];
            }
             printf(&quot;Throw in %d cents, %d nickels, %d dimes, and %d quarters.\n&quot;,
                ans[m[1]], ans[m[2]], ans[m[3]], ans[m[4]]);

        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>多重背包优化为完全背包，记录路径</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1114 Piggy-Bank</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU1114Piggy-Bank/</url>
    <content><![CDATA[<p>HDU 1114</p>
<p>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 43169    Accepted Submission(s): 21298  </p>
<p>Problem DescriptionBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. </p>
<p>But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee. Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!   </p>
<p>InputThe input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 &lt;= E &lt;= F &lt;= 10000. On the second line of each test case, there is an integer number N (1 &lt;= N &lt;= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 &lt;= P &lt;= 50000, 1 &lt;= W &lt;=10000). P is the value of the coin in monetary units, W is it’s weight in grams.   </p>
<p>OutputPrint exactly one line of output for each test case. The line must contain the sentence “The minimum amount of money in the piggy-bank is X.” where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line “This is impossible.”.   </p>
<p>Sample Input</p>
<p>3<br>10 110<br>2<br>1 1<br>30 50<br>10 110<br>2<br>1 1<br>50 30<br>1 6<br>2<br>10 3<br>20 4</p>
<p>Sample Output</p>
<p>The minimum amount of money in the piggy-bank is 60.<br>The minimum amount of money in the piggy-bank is 100.<br>This is impossible.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>完全背包.模板</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    13:19:16
By                : Tpaaaaaa
File_Name         ：HDU1114PiggyBank.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 510;
const int MAXM = 1e4 + 10;
int n, m;
int w[MAXN], v[MAXN], dp[MAXM];
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        int e, f;
        scanf(&quot;%d%d&quot;, &amp;e, &amp;f);
        m = f - e;          //背包容量
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;w[i], &amp;v[i]);
        memset(dp, INF, sizeof dp);
        dp[0] = 0;
        for(int i = 1; i &lt;= n; i++)
            for(int j = v[i]; j &lt;= m; j++)
                dp[j] = min(dp[j], dp[j - v[i]] + w[i]);
        if(dp[m] &gt;= INF)
            printf(&quot;This is impossible.\n&quot;);
        else
            printf(&quot;The minimum amount of money in the piggy-bank is %d.\n&quot;, dp[m]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ Cash Machine</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJCashMachine/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 10000K</p>
<p><strong>Total Submissions:</strong> 45534</p>
<p><strong>Accepted:</strong> 16606</p>
<p>DescriptionA Bank plans to install a machine for cash withdrawal. The machine is able to deliver appropriate @ bills for a requested cash amount. The machine uses exactly N distinct bill denominations, say Dk, k=1,N, and for each denomination Dk the machine has a supply of nk bills. For example, </p>
<p>N=3, n1=10, D1=100, n2=4, D2=50, n3=5, D3=10 </p>
<p>means the machine has a supply of 10 bills of @100 each, 4 bills of @50 each, and 5 bills of @10 each. </p>
<p>Call cash the requested amount of cash the machine should deliver and write a program that computes the maximum amount of cash less than or equal to cash that can be effectively delivered according to the available bill supply of the machine. </p>
<p>Notes:<br>@ is the symbol of the currency delivered by the machine. For instance, @ may stand for dollar, euro, pound etc.   </p>
<p>InputThe program input is from standard input. Each data set in the input stands for a particular transaction and has the format: </p>
<p>cash N n1 D1 n2 D2 … nN DN </p>
<p>where 0 &lt;= cash &lt;= 100000 is the amount of cash requested, 0 &lt;=N &lt;= 10 is the number of bill denominations and 0 &lt;= nk &lt;= 1000 is the number of available bills for the Dk denomination, 1 &lt;= Dk &lt;= 1000, k=1,N. White spaces can occur freely between the numbers in the input. The input data are correct.   </p>
<p>OutputFor each set of data the program prints the result to the standard output on a separate line as shown in the examples below.   </p>
<p>Sample Input</p>
<p>735 3  4 125  6 5  3 350<br>633 4  500 30  6 100  1 5  0 1<br>735 0<br>0 3  10 100  10 50  10 10</p>
<p>Sample Output</p>
<p>735<br>630<br>0<br>0</p>
<p>HintThe first data set designates a transaction where the amount of cash requested is @735. The machine contains 3 bill denominations: 4 bills of @125, 6 bills of @5, and 3 bills of @350. The machine can deliver the exact amount of requested cash. </p>
<p>In the second case the bill supply of the machine does not fit the exact amount of cash requested. The maximum cash that can be delivered is @630. Notice that there can be several possibilities to combine the bills in the machine for matching the delivered cash. </p>
<p>In the third case the machine is empty and no cash is delivered. In the fourth case the amount of cash requested is @0 and, therefore, the machine delivers no cash.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>多重背包的一种写法，可做模板</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    13:36:34
By                : Tpaaaaaa
File_Name         ：HDU1276CashMachine.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 15;
int n, m;
int c[MAXN], w[MAXN], dp[100010], used[100010];
int main()
{
    //dp[j] 表示小于等于j的最大的能兑换的call
    while(scanf(&quot;%d&quot;, &amp;m) != EOF)   //m为背包容量
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d%d&quot;, &amp;c[i], &amp;w[i]);
        //c[]物品的数目, w[]为物品的体积. v[] = w[]是物品的价值
        memset(dp, 0, sizeof dp);
        for(int i = 1; i &lt;= n; i++)
        {
            memset(used, 0, sizeof used);
            for(int j = w[i]; j &lt;= m; j++)
            {
                if(dp[j] &lt; dp[j - w[i]] + w[i] &amp;&amp; used[j - w[i]] &lt; c[i])
                {
                    dp[j] = dp[j - w[i]] + w[i];
                    used[j] = used[j - w[i]] + 1;                    
                }

            }
        }
        printf(&quot;%d\n&quot;, dp[m]);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>多重背包的used优化</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2063 Investment</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJ2063Investment/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 30000K</p>
<p><strong>Total Submissions:</strong> 13291</p>
<p><strong>Accepted:</strong> 4567</p>
<p>DescriptionJohn never knew he had a grand-uncle, until he received the notary’s letter. He learned that his late grand-uncle had gathered a lot of money, somewhere in South-America, and that John was the only inheritor.<br>John did not need that much money for the moment. But he realized that it would be a good idea to store this capital in a safe place, and have it grow until he decided to retire. The bank convinced him that a certain kind of bond was interesting for him.<br>This kind of bond has a fixed value, and gives a fixed amount of yearly interest, payed to the owner at the end of each year. The bond has no fixed term. Bonds are available in different sizes. The larger ones usually give a better interest. Soon John realized that the optimal set of bonds to buy was not trivial to figure out. Moreover, after a few years his capital would have grown, and the schedule had to be re-evaluated.<br>Assume the following bonds are available:   </p>
<p>Value</p>
<p>Annual<br>interest</p>
<p>4000<br>3000</p>
<p>400<br>250</p>
<p>With a capital of e10 000 one could buy two bonds of $4 000, giving a yearly interest of $800. Buying two bonds of $3 000, and one of $4 000 is a better idea, as it gives a yearly interest of $900. After two years the capital has grown to $11 800, and it makes sense to sell a $3 000 one and buy a $4 000 one, so the annual interest grows to $1 050. This is where this story grows unlikely: the bank does not charge for buying and selling bonds. Next year the total sum is $12 850, which allows for three times $4 000, giving a yearly interest of $1 200.<br>Here is your problem: given an amount to begin with, a number of years, and a set of bonds with their values and interests, find out how big the amount may grow in the given period, using the best schedule for buying and selling bonds.</p>
<p>InputThe first line contains a single positive integer N which is the number of test cases. The test cases follow.<br>The first line of a test case contains two positive integers: the amount to start with (at most $1 000 000), and the number of years the capital may grow (at most 40).<br>The following line contains a single number: the number d (1 &lt;= d &lt;= 10) of available bonds.<br>The next d lines each contain the description of a bond. The description of a bond consists of two positive integers: the value of the bond, and the yearly interest for that bond. The value of a bond is always a multiple of $1 000. The interest of a bond is never more than 10% of its value.</p>
<p>OutputFor each test case, output – on a separate line – the capital at the end of the period, after an optimal schedule of buying and selling.</p>
<p>Sample Input</p>
<p>1<br>10000 4<br>2<br>4000 400<br>3000 250</p>
<p>Sample Output</p>
<p>14050</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>进行k次完全背包.只不过每一次的背包容量变了而已</p>
<p>而且因为总是1000的整数倍,也就是dp[1001] 与 dp[1099]的利润是一样的,</p>
<p>因此我们取个代表mod1000即可.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    15:19:25
By                : Tpaaaaaa
File_Name         ：InvestmentPOJ2063.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 15;
const int MAXM = 5e4 + 10;
int v[MAXN], w[MAXN];
int dp[MAXM];
int n, m, k;
int main()
{
    int t;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;k);
        //m是背包容量
        //每次都刷新一下m即可,一共搞k次
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;, &amp;v[i], &amp;w[i]);
        for(int z = 1; z &lt;= k; z++)
        {
            memset(dp, 0, sizeof dp);      //这个挺耗时的。 
            for(int i = 1; i &lt;= n; i++)
                for(int j = v[i]/1000; j &lt;= m/1000; j++)    //也就是说模1000相同的数，他的年利益是一样的，所以我们就可以用一个变量表示即可
                    dp[j] = max(dp[j], dp[j - v[i]/1000] + w[i]);
            m = m + dp[m/1000];
        }
        printf(&quot;%d\n&quot;, m);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>完全背包</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1059 Dividing</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU1059Dividing/</url>
    <content><![CDATA[<p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 35676    Accepted Submission(s): 10014<br>*</em></p>
<p>Problem DescriptionMarsha and Bill own a collection of marbles. They want to split the collection among themselves so that both receive an equal share of the marbles. This would be easy if all the marbles had the same value, because then they could just split the collection in half. But unfortunately, some of the marbles are larger, or more beautiful than others. So, Marsha and Bill start by assigning a value, a natural number between one and six, to each marble. Now they want to divide the marbles so that each of them gets the same total value.<br>Unfortunately, they realize that it might be impossible to divide the marbles in this way (even if the total value of all marbles is even). For example, if there are one marble of value 1, one of value 3 and two of value 4, then they cannot be split into sets of equal value. So, they ask you to write a program that checks whether there is a fair partition of the marbles.  </p>
<p>InputEach line in the input describes one collection of marbles to be divided. The lines consist of six non-negative integers n1, n2, …, n6, where ni is the number of marbles of value i. So, the example from above would be described by the input-line ``1 0 1 2 0 0’’. The maximum total number of marbles will be 20000. </p>
<p>The last line of the input file will be ``0 0 0 0 0 0’’; do not process this line.  </p>
<p>OutputFor each colletcion, output ``Collection #k:’’, where k is the number of the test case, and then either ``Can be divided.’’ or ``Can’t be divided.’’. </p>
<p>Output a blank line after each test case.  </p>
<p>Sample Input</p>
<p>1 0 1 2 0 0<br>1 0 0 0 1 1<br>0 0 0 0 0 0</p>
<p>Sample Output</p>
<p>Collection #1:<br>Can’t be divided.</p>
<p>Collection #2:<br>Can be divided.</p>
<p>分析：</p>
<p>还没写完……QAQ挖坑明天补</p>
<p>代码：</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>悼念512汶川大地震遇难同胞——珍惜现在，感恩生活</title>
    <url>/tpaaaaaa.github.io/2019/10/19/%E6%82%BC%E5%BF%B5512%E6%B1%B6%E5%B7%9D%E5%A4%A7%E5%9C%B0%E9%9C%87%E9%81%87%E9%9A%BE%E5%90%8C%E8%83%9E%E2%80%94%E2%80%94%E7%8F%8D%E6%83%9C%E7%8E%B0%E5%9C%A8%EF%BC%8C%E6%84%9F%E6%81%A9%E7%94%9F%E6%B4%BB/</url>
    <content><![CDATA[<p>急！灾区的食物依然短缺！<br>为了挽救灾区同胞的生命，心系灾区同胞的你准备自己采购一些粮食支援灾区，现在假设你一共有资金n元，而市场有m种大米，每种大米都是袋装产品，其价格不等，并且只能整袋购买。<br>请问：你用有限的资金最多能采购多少公斤粮食呢？</p>
<p>后记：<br>人生是一个充满了变数的生命过程，天灾、人祸、病痛是我们生命历程中不可预知的威胁。<br>月有阴晴圆缺，人有旦夕祸福，未来对于我们而言是一个未知数。那么，我们要做的就应该是珍惜现在，感恩生活——<br>感谢父母，他们给予我们生命，抚养我们成人；<br>感谢老师，他们授给我们知识，教我们做人<br>感谢朋友，他们让我们感受到世界的温暖；<br>感谢对手，他们令我们不断进取、努力。<br>同样，我们也要感谢痛苦与艰辛带给我们的财富～</p>
<p><img src="http://acm.hdu.edu.cn/data/images/C132-1006-2.JPG" alt=""></p>
<p>Input输入数据首先包含一个正整数C，表示有C组测试用例，每组测试用例的第一行是两个整数n和m(1&lt;=n&lt;=100, 1&lt;=m&lt;=100),分别表示经费的金额和大米的种类，然后是m行数据，每行包含3个数p，h和c(1&lt;=p&lt;=20,1&lt;=h&lt;=200,1&lt;=c&lt;=20)，分别表示每袋的价格、每袋的重量以及对应种类大米的袋数。<br>Output对于每组测试数据，请输出能够购买大米的最多重量，你可以假设经费买不光所有的大米，并且经费你可以不用完。每个实例的输出占一行。<br>Sample Input</p>
<p>1<br>8 2<br>2 100 4<br>4 100 2</p>
<p>Sample Output</p>
<p>400</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>好长的标题呀.</p>
<p>这是多重背包的二进制优化版本. 可做模板</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    18:20:23
By                : Tpaaaaaa
File_Name         ：HDU2191.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
int v[MAXN * 20], w[MAXN * 20];
int dp[MAXN * 20];
int main()
{
    int t, n, m;
    cin &gt;&gt; t;
    while(t--)
    {
        int cnt = 0;
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            int p, h, c;
            scanf(&quot;%d%d%d&quot;, &amp;p, &amp;h, &amp;c);
            for(int j = 1; j &lt;= c; j++)
            {
                w[++cnt] = j * h;
                v[cnt] = j * p;
                c -= j;
            }
            if(c &gt; 0)
            {
                w[++cnt] = c * h;
                v[cnt] = c * p;
            }
        }
        /*只是在输入输出的时候额外处理一下*/
        memset(dp, 0, sizeof dp);
        for(int i = 1; i &lt;= cnt; i++)
            for(int j = m; j &gt;= v[i]; j--)
                dp[j] = max(dp[j], dp[j - v[i]] + w[i]);
        printf(&quot;%d\n&quot;, dp[m]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>多重背包的二进制优化</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3033 I love sneakers!</title>
    <url>/tpaaaaaa.github.io/2019/10/19/HDU3033Ilovesneakers!/</url>
    <content><![CDATA[<p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 8235    Accepted Submission(s): 3272<br>*</em></p>
<p>Problem DescriptionAfter months of hard working, Iserlohn finally wins awesome amount of scholarship. As a great zealot of sneakers, he decides to spend all his money on them in a sneaker store.  </p>
<p><img src="http://acm.hdu.edu.cn/data/images/exe3033-1.JPG" alt=""></p>
<p>There are several brands of sneakers that Iserlohn wants to collect, such as Air Jordan and Nike Pro. And each brand has released various products. For the reason that Iserlohn is definitely a sneaker-mania, he desires to buy at least one product for each brand.<br>Although the fixed price of each product has been labeled, Iserlohn sets values for each of them based on his own tendency. With handsome but limited money, he wants to maximize the total value of the shoes he is going to buy. Obviously, as a collector, he won’t buy the same product twice.<br>Now, Iserlohn needs you to help him find the best solution of his problem, which means to maximize the total value of the products he can buy.<br>InputInput contains multiple test cases. Each test case begins with three integers 1&lt;=N&lt;=100 representing the total number of products, 1 &lt;= M&lt;= 10000 the money Iserlohn gets, and 1&lt;=K&lt;=10 representing the sneaker brands. The following N lines each represents a product with three positive integers 1&lt;=a&lt;=k, b and c, 0&lt;=b,c&lt;100000, meaning the brand’s number it belongs, the labeled price, and the value of this product. Process to End Of File.<br>OutputFor each test case, print an integer which is the maximum total value of the sneakers that Iserlohn purchases. Print “Impossible” if Iserlohn’s demands can’t be satisfied.<br>Sample Input</p>
<p>5 10000 3<br>1 4 6<br>2 5 7<br>3 4 99<br>1 55 77<br>2 44 66</p>
<p>Sample Output</p>
<p>255</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这是分组背包的一种常见题型。常规的分组背包是每一组最多选一个，而此题是每一组最少选一个。所以转移的时候，即会在本组里面发生转移（选多个），也会在前一组之间发生转移（第一个）。</p>
<p>在本组里面，用01背包.</p>
<pre><code>for(int i = 1; i &lt;= bsum[k]; i++)
    for(int j = m; j &gt;= v[k][i]; j--)
    {        
        if(dp[k][j - v[k][i]] != -1)
                dp[k][j] = max(dp[k][j], dp[k][j - v[k][i]] + w[k][i]);
     .....................</code></pre><p>与前一组里面</p>
<pre><code>  ...................................                  
if(dp[k - 1][j - v[k][i]] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - v[k][i]] + w[k][i]);</code></pre><p>这是常见的代码</p>
<pre><code>memset(dp, -1, sizeof dp);
memset(dp[0], 0, sizeof dp[0]);
//dp[i][j] 表示的是考虑前k组，背包容量为j的最大价值

for(int k = 1; k &lt;= kk; k++)
{
    for(int i = 1; i &lt;= bsum[k]; i++)
        for(int j = m; j &gt;= v[k][i]; j--)
        {        
            if(dp[k][j - v[k][i]] != -1)
                    dp[k][j] = max(dp[k][j], dp[k][j - v[k][i]] + w[k][i]);
            if(dp[k - 1][j - v[k][i]] != -1)
                    dp[k][j] = max(dp[k][j], dp[k - 1][j - v[k][i]] + w[k][i]);
        }
}</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    18:32:21
By                : Tpaaaaaa
File_Name         ：IlovesneakersHDU3033.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXK = 15;
const int MAXM = 1e4 + 10;
int bsum[MAXK];
int dp[MAXK][MAXM], v[MAXK][MAXN], w[MAXK][MAXN];
int main()
{
    int n, m, kk;
    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;kk) != EOF)
    {
        memset(bsum, 0, sizeof bsum);   //bsum[i] 第i个牌子有多少个鞋
        for(int i = 1; i &lt;= n; i++)
        {
            int a, b, c;
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            bsum[a]++;
            int cnt = bsum[a];
            v[a][cnt] = b;              //体积
            w[a][cnt] = c;              //价值
        }
        memset(dp, -1, sizeof dp);
        memset(dp[0], 0, sizeof dp[0]);
        //dp[i][j] 表示的是考虑前k组，背包容量为j的最大价值

        for(int k = 1; k &lt;= kk; k++)
        {
            for(int i = 1; i &lt;= bsum[k]; i++)
                for(int j = m; j &gt;= v[k][i]; j--)
                {        
                    if(dp[k][j - v[k][i]] != -1)
                            dp[k][j] = max(dp[k][j], dp[k][j - v[k][i]] + w[k][i]);
                    if(dp[k - 1][j - v[k][i]] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - v[k][i]] + w[k][i]);
                }
        }
        if(dp[kk][m] == -1)
            printf(&quot;Impossible\n&quot;);
        else
            printf(&quot;%d\n&quot;, dp[kk][m]);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>分组背包，每组最少选一个</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3211 Washing Clothes</title>
    <url>/tpaaaaaa.github.io/2019/10/19/POJ3211WashingClothes/</url>
    <content><![CDATA[<p>Washing Clothes</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 131072K</p>
<p><strong>Total Submissions:</strong> 11056</p>
<p><strong>Accepted:</strong> 3579</p>
<p>Description</p>
<p>Dearboy was so busy recently that now he has piles of clothes to wash. Luckily, he has a beautiful and hard-working girlfriend to help him. The clothes are in varieties of colors but each piece of them can be seen as of only one color. In order to prevent the clothes from getting dyed in mixed colors, Dearboy and his girlfriend have to finish washing all clothes of one color before going on to those of another color.</p>
<p>From experience Dearboy knows how long each piece of clothes takes one person to wash. Each piece will be washed by either Dearboy or his girlfriend but not both of them. The couple can wash two pieces simultaneously. What is the shortest possible time they need to finish the job?</p>
<p>Input</p>
<p>The input contains several test cases. Each test case begins with a line of two positive integers <em>M</em> and <em>N</em> (<em>M</em> &lt; 10, <em>N</em> &lt; 100), which are the numbers of colors and of clothes. The next line contains <em>M</em> strings which are not longer than 10 characters and do not contain spaces, which the names of the colors. Then follow <em>N</em> lines describing the clothes. Each of these lines contains the time to wash some piece of the clothes (less than 1,000) and its color. Two zeroes follow the last test case.</p>
<p>Output</p>
<p>For each test case output on a separate line the time the couple needs for washing.</p>
<p>Sample Input</p>
<p>3 4<br>red blue yellow<br>2 red<br>3 blue<br>4 blue<br>6 red<br>0 0</p>
<p>Sample Output</p>
<p>10</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a><strong>分析：</strong></h2><p>其实这个跟分组背包没什么关系，就是多次的01背包而已.</p>
<p>对于每一类衣服，我们用01背包求出清理完的最少时间，然后将每组的时间累加起来即可.</p>
<p>对每一组用01背包的时候，我们将这一组的总的时间设为T，那么我们求出dp[T/2]，也就是我们一个人在T/2时间下能够洗的最多的时间,所以该组的清理最少时间就是T - dp[T/2].</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-19    20:34:55
By                : Tpaaaaaa
File_Name         ：POJ3211washingclothes.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
先分组，然后在组里面用01背包，求出洗完这一组的最少时间.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
int n, m;
int bsum[15];
int v[15][110], vsum[15], dp[100010];
map &lt;string, int&gt; mp;
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;m, &amp;n) &amp;&amp; n + m)
    {
        int cnt = 0;
        mp.clear();
        for(int i = 1; i &lt;= m; i++)
        {
            string s;
            cin &gt;&gt; s;
            mp[s] = ++cnt;
        }//有m个组
        memset(bsum, 0, sizeof bsum);
        memset(vsum, 0, sizeof vsum);
        for(int i = 1; i &lt;= n; i++)
        {
            int a; string s;
            cin &gt;&gt; a &gt;&gt; s;
            int temp = mp[s];           //string 变成编号
            bsum[temp]++;
            int index = bsum[temp];
            v[temp][index] = a;
            vsum[temp] += a;            //这类的总时间
        }
        //枚举每一组.
        int ans = 0;
        for(int k = 1; k &lt;= m; k++)
        {
            int mm = vsum[k] / 2;
            memset(dp, 0, sizeof dp);
            for(int i = 1; i &lt;= bsum[k]; i++)
                for(int j = mm; j &gt;= v[k][i]; j--)
                    dp[j] = max(dp[j], dp[j - v[k][i]] + v[k][i]);
            ans += (vsum[k] - dp[mm]);
        }
        printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>1229 - Treblecross</title>
    <url>/tpaaaaaa.github.io/2019/10/16/1229-Treblecross/</url>
    <content><![CDATA[<p>Treblecross is a two player game where the goal is to get three <strong>X</strong> in a row on a one-dimensional board. At the start of the game all cells in the board are empty. In each turn a player puts an <strong>X</strong> in an empty cell, and if the move results three <strong>X</strong> next to each other, that player wins.</p>
<p>Given the current state of the game, you are to determine if the current player to move can win the game assuming both players play optimally.</p>
<p>Consider the game where the board size is 5 cells. If the first player puts an <strong>X</strong> at position three (in the middle) so the state becomes <strong>..X..</strong>, he will win the game as no matter where the other player puts his <strong>X</strong>, the first player can get three <strong>X</strong> in a row. If, on the other hand, the first player puts the <strong>X</strong> in any other position, the second player will win the game by putting the <strong>X</strong> in the opposite corner (for instance, after the second players move the state might be <strong>.X..X</strong>). This will force the first player to put an X in a position so the second player wins in the next move.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing a string denoting the current status of the game. The string will only contain the characters <strong>‘.’</strong> and <strong>‘X’</strong>. The length of the string (the size of the board) will be between <strong>3</strong> and <strong>200</strong> characters, inclusive. No state will contain three <strong>X</strong> in a row.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the positions on the board, where the player to move may put an <strong>X</strong> and win the game. The positions should be separated by a single space, and be in increasing order. The leftmost position on the board is <strong>1</strong>. If there is no such position print <strong>0</strong>.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>4…..X…..X..X…….X….X..X.X.X…X………………</p>
<p>Case 1: 3Case 2: 0Case 3: 3Case 4: 5 6 13 14</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>对于组合游戏，其SG值不一定是其唯一判断胜负的依据。或者说我们很难轻易的找到一个完美的SG函数表达式，所以<strong>我们可以将所给组合游戏的常规部分交给SG函数去判断，将复杂/特殊的部分，我们单独特判一下</strong>，没有必要绞尽脑汁打算想一个完美的SG函数。 例如本题。</p>
<p>nim游戏中的石子数目，可以等价为可操作的位置数。</p>
<p>这题要好好分析。</p>
<p>还有一点就是如何在先手必胜的情况下，输出先手该走的位置。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-16    16:19:02
By                : Tpaaaaaa
File_Name         ：1229Treblecross2.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 210;
char str[MAXN];
int sg[MAXN], pos[MAXN], mex[MAXN], n, len;   //sg[x] 表示的是x长度的...的sg值
//预处理出sg[]
int getSG(int x)
{
    memset(mex, 0, sizeof mex);
    //枚举它x种放X的情况
    for(int i = 1; i &lt;= x; i++)
    {
        int t = 0;                  //t为这个后继情况的SG值
        int left = max(0, i - 1 - 2);
        int right = max(0, x - i - 2);
        t = sg[left] ^ sg[right];
        mex[t] = 1;
    }
    for(int i = 0; ; i++)
        if(mex[i] == 0) return sg[x] = i;
}
void init()
{
    sg[0] = 0;
    for(int i = 1; i &lt; MAXN; i++)
        sg[i] = getSG(i);
}
//作用就是判断每次枚举产生的后继状态的SG值
//对于这个状态的SG值，我们只需要把他的可行的位置长度的sg值异或起来即可
//也就是说，如果题目不需要将可行的点都输出出来，只是判断能否先手必胜的话
//直接用check这个函数即可
bool check()
{
    int ret = 0;
    int l = -3;
    for(int i = 0; i &lt; len; i++)
        if(str[i] == &apos;X&apos;)
        {
            //if((i + 1 &lt; len &amp;&amp; str[i + 1] == &apos;X&apos;) || (i + 2 &lt; len &amp;&amp; str[i + 2] == &apos;X&apos;))  return false;
            int d = max(0, i - l - 5);         
            l = i;     
            ret ^= sg[d];
        }
        else if((i + 2 &lt; len &amp;&amp; str[i + 1] == &apos;X&apos; &amp;&amp; str[i + 2] == &apos;X&apos;) || (i + 1 &lt; len &amp;&amp; i - 1 &gt;= 0 &amp;&amp; str[i - 1] == &apos;X&apos; &amp;&amp; str[i + 1] == &apos;X&apos;) || (i - 2 &gt;= 0 &amp;&amp; str[i - 1] == &apos;X&apos; &amp;&amp; str[i - 2] == &apos;X&apos;))
            return false;
    int d = max(len - l - 3, 0);
    ret ^= sg[d];
    return ret == 0;
}
//返回的是可行的位置，为0说明必输
//同样是枚举每一个.，然后将这个点变成X，产生就是一个后继状态
//如果这个后继状态的SG值为0，先手必胜，后手必输
//
int solve()
{
    n = 0;              //可行的位置，为0说明先手必输
    len = strlen(str);
    for(int i = 0; i &lt; len; i++)
        if(str[i] == &apos;.&apos;)
        {
            str[i] = &apos;X&apos;;
            if(check())
                pos[++n] = i + 1;
            else if((i + 2 &lt; len &amp;&amp; str[i + 1] == &apos;X&apos; &amp;&amp; str[i + 2] == &apos;X&apos;) || (i + 1 &lt; len &amp;&amp; i - 1 &gt;= 0 &amp;&amp; str[i - 1] == &apos;X&apos; &amp;&amp; str[i + 1] == &apos;X&apos;) || (i - 2 &gt;= 0 &amp;&amp; str[i - 1] == &apos;X&apos; &amp;&amp; str[i - 2] == &apos;X&apos;))
                    pos[++n] = i + 1;
            str[i] = &apos;.&apos;;
        }
    return n;

}
int main()
{
    int t;
    init();
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%s&quot;, str);
        printf(&quot;Case %d: &quot;, kase);
        int n = solve();
        if(n == 0)
            printf(&quot;0\n&quot;);
        else
        {
            for(int i = 1; i &lt;= n; i++)
                if(i == n)
                    printf(&quot;%d\n&quot;, pos[i]);
                else
                    printf(&quot;%d &quot;, pos[i]);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>博弈</tag>
      </tags>
  </entry>
  <entry>
    <title>1296 - Again Stone Game</title>
    <url>/tpaaaaaa.github.io/2019/10/16/1296-AgainStoneGame/</url>
    <content><![CDATA[<p>Alice and Bob are playing a stone game. Initially there are <strong>n</strong> piles of stones and each pile contains some stone. Alice stars the game and they alternate moves. In each move, a player has to select any pile and should remove at least one and no more than half stones from that pile. So, for example if a pile contains 10 stones, then a player can take at least 1 and at most 5 stones from that pile. If a pile contains 7 stones; at most 3 stones from that pile can be removed.</p>
<p>Both Alice and Bob play perfectly. The player who cannot make a valid move loses. Now you are given the information of the piles and the number of stones in all the piles, you have to find the player who will win if both play optimally.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 1000)</strong>. The next line contains <strong>n</strong> space separated integers ranging in <strong>[1, 109]</strong>. The <strong>ith</strong> integer in this line denotes the number of stones in the <strong>ith</strong> pile.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the name of the player who will win the game.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>511310 11 1251 2 3 4 524 931 3 9</p>
<p>Case 1: BobCase 2: AliceCase 3: AliceCase 4: BobCase 5: Alice</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>如果数据量很大，显然常规方法求SG值易超时。</p>
<p><strong>所以当数据量很大，游戏规则很简单的情况，我们甚至可以直接从SG值入手</strong></p>
<p>例如本题直接观察SG值的分布，发现规律。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-16    13:55:26
By                : Tpaaaaaa
File_Name         ：LightOJ1296AgainStoneGame.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

显然
sg[0] = 0;
sg[1] = 0;
然后预处理即可 
emmm 1e9貌似预处理会炸
所以要打表看sg表的规律233
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
int n;
 //然后观察出规律...
 //偶数的sg值   是其两倍
 //奇数的sg值    sg[x] = sg[x/2];
 //
ll getSG(ll a)
{
    if(a % 2 == 0)  return 2 * a;
    else    return getSG(a / 2);
}
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        ll ans = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            ll temp;
            scanf(&quot;%lld&quot;, &amp;temp);
            ans ^= getSG(temp);
        }
        printf(&quot;Case %d: &quot;, kase);
        if(ans) printf(&quot;Alice\n&quot;);
        else    printf(&quot;Bob\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>SG函数，找规律</tag>
      </tags>
  </entry>
  <entry>
    <title>1199 - Partitioning Game</title>
    <url>/tpaaaaaa.github.io/2019/10/15/1199-PartitioningGame/</url>
    <content><![CDATA[<p>Alice and Bob are playing a strange game. The rules of the game are:</p>
<ol>
<li><p>Initially there are <strong>n</strong> piles.</p>
</li>
<li><p>A pile is formed by some cells.</p>
</li>
<li><p>Alice starts the game and they alternate turns.</p>
</li>
<li><p>In each tern a player can pick any pile and divide it into two unequal piles.</p>
</li>
<li><p>If a player cannot do so, he/she loses the game.</p>
</li>
</ol>
<p>Now you are given the number of cells in each of the piles, you have to find the winner of the game if both of them play optimally.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 1000)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 100)</strong>. The next line contains <strong>n</strong> integers, where the ith integer denotes the number of cells in the ith pile. You can assume that the number of cells in each pile is between <strong>1</strong> and <strong>10000</strong>.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and <strong>‘Alice’ *<em>or *</em>‘Bob’</strong> depending on the winner of the game.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>31431 2 317</p>
<p>Case 1: BobCase 2: AliceCase 3: Bob</p>
<h1 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h1><p>In case 1, Alice has only 1 move, she divides the pile with 4 cells into two unequal piles, where one pile has 1 cell and the other pile has 3 cells. Now it’s Bob’s turn. Bob divides the pile with 3 cells into two piles, where one pile has 1 cell and another pile has 2 cells. So, now there are three piles having cells 1, 1, 2. And Alice loses, since she doesn’t have any moves now.</p>
<p>补充一下：有些博客里面称为组合游戏，有些称为组合博弈。</p>
<p>看了翻译：公平组合博弈（Impartial Combinatori Games）<br>有些憨憨翻译成博弈，有些憨憨翻译成游戏。所以我决定在以后统一叫为LCM，免得老是想不过来，这一篇就懒得改了。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>怎么每次都是Alice和Bob这两个憨批，XX皇家赌场欢迎您二位。</p>
<p>按他意思预处理出所有的sg即可，然后将游戏的和分成多个单一的简单组合游戏，将他们的SG值异或即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    20:29:36
By                : Tpaaaaaa
File_Name         ：1199PartitioningGame.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
有n个pile，每个pile里有石子
两人轮流选，选一个pile然后将它分成不等的两份
如果不能再分了，则失败了。
我们将它视为n个简单组合游戏，
对于某一个简单组合游戏，我们求出其sg值

显然sg(x) = mex{sg(1, x-1), sg(2, x - 2), sg(3, x - 3) ... sg(x/2, x + 1)}
设置递归出口
sg(1) = 0;
sg(2) = 0;
憨批玩意，人家直接预处理所有的sg[]
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 11000;
int sg[MAXN], mex[MAXN];
int n;
void init()
{
    sg[1] = sg[2] = 0;
    for(int i = 3; i &lt; MAXN; i++)
    {
        memset(mex, 0, sizeof mex);
        int up;
        if(i % 2 == 0)
            up = i / 2 - 1;
        else    
            up= i / 2;
        for(int j = 1; j &lt;= up; j++)
        {
            int temp = sg[j] ^ sg[i - j];
            mex[temp] = 1;
        }   
        int j; 
        for(j = 0; j &lt; MAXN; j++)
            if(mex[j] == 0)     break;
        sg[i] = j;
    }
}
int main()
{
    int t;
    init();
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        int ans = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            ans ^= sg[temp];
        }
        printf(&quot;Case %d: &quot;, kase);
        if(ans) printf(&quot;Alice\n&quot;);
        else    printf(&quot;Bob\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>组合游戏SG值</tag>
      </tags>
  </entry>
  <entry>
    <title>1253 - Misere Nim</title>
    <url>/tpaaaaaa.github.io/2019/10/15/1253-MisereNim/</url>
    <content><![CDATA[<p>Alice and Bob are playing game of <strong>Misère Nim</strong>. Misère Nim is a game playing on <strong>k</strong> piles of stones, each pile containing one or more stones. The players alternate turns and in each turn a player can select one of the piles and can remove as many stones from that pile unless the pile is empty. In each turn a player must remove at least one stone from any pile. Alice starts first. The player who removes the last stone <strong>loses</strong> the game.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer** k (1 ≤ k ≤ 100)<strong>. The next line contains **k</strong> space separated integers denoting the number of stones in each pile. The number of stones in a pile lies in the range <strong>[1, 109]</strong>.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and <strong>‘Alice’</strong> if Alice wins otherwise print <strong>‘Bob’</strong>.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>342 3 4 551 1 2 4 1011</p>
<p>Case 1: BobCase 2: AliceCase 3: Bob</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>nim游戏的变形—— anti-nim</p>
<p><strong>获胜的条件变成没有后继。</strong></p>
<p>详情看09年的那篇论文。</p>
<p>给结论：</p>
<p><strong>可得到anti-nim游戏的规律：</strong></p>
<pre><code>先手必胜当且仅当： 
（ 1）所有堆的石子数都为 1 且游戏的 SG 值为 0； 
（ 2）有些堆的石子数大于 1 且游戏的 SG 值不为 0。</code></pre><p>扩展到anti-sg，则有</p>
<p><strong>SJ定理</strong></p>
<pre><code>对于任意一个 Anti-SG 游戏， 如果我们规定当局面中所有的单一游戏的 SG 值为 0 时， 游戏结束，此时决策集合为空的选手获胜，则先手必胜当且仅当： 
（1）游戏的 SG 函数不为 0 且游戏中某个单一游戏的 SG 函数大于 1； 
（2）游戏的 SG 函数为 0 且游戏中没有单一游戏的 SG 函数大于 1。</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    18:45:35
By                : Tpaaaaaa
File_Name         ：1253MisereNim.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
//最后没东西拿的人胜利
是 anti_nim 题型
oh，好cool的名字
这类Anti-SG游戏的一个通用定理——SJ定理：
    对于任意一个Anti-SG游戏，如果我们规定当局面中所有的单一游戏的SG值为0时，游戏结束。

    先手必胜当且仅当：
    （1）游戏的SG函数不为0且游戏中某个单一游戏的SG函数大于1；
    （2）游戏的SG函数为0且游戏中没有单一游戏的SG函数大于1。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;

int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        int k;
        scanf(&quot;%d&quot;, &amp;k);
        ll sg = 0;
        bool flag = false;
        for(int i = 1; i &lt;= k; i++)
        {
            ll temp;
            scanf(&quot;%lld&quot;, &amp;temp);
            sg ^= temp;
            if(temp &gt; 1)
                flag = true;        //存在大于1
        }
        printf(&quot;Case %d: &quot;, kase);
        if((sg == 0 &amp;&amp; flag == false) || (sg &gt; 0 &amp;&amp; flag))
            printf(&quot;Alice\n&quot;);
        else
            printf(&quot;Bob\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>anti-nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>1247 - Matrix Game</title>
    <url>/tpaaaaaa.github.io/2019/10/15/1247-MatrixGame/</url>
    <content><![CDATA[<p>Given an <strong>m x n</strong> matrix, where <strong>m</strong> denotes the number of rows and <strong>n</strong> denotes the number of columns and in each cell a pile of stones is given. For example, let there be a <strong>2 x 3</strong> matrix, and the piles are</p>
<p>2 3 8</p>
<p>5 2 7</p>
<p>That means that in cell(1, 1) there is a pile with 2 stones, in cell(1, 2) there is a pile with 3 stones and so on.</p>
<p>Now Alice and Bob are playing a strange game in this matrix. Alice starts first and they alternate turns. In each turn a player selects a row, and can draw any number of stones from any number of cells in that row. But he/she must draw at least one stone. For example, if Alice chooses the 2nd row in the given matrix, she can pick 2 stones from cell(2, 1), 0 stones from cell (2, 2), 7 stones from cell(2, 3). Or she can pick 5 stones from cell(2, 1), 1 stone from cell(2, 2), 4 stones from cell(2, 3). There are many other ways but she must pick at least one stone from all piles. The player who can’t take any stones loses.</p>
<p>Now if both play optimally who will win?</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing two integers: <strong>m</strong> and <strong>n (1 ≤ m, n ≤ 50)</strong>. Each of the next <strong>m</strong> lines contains <strong>n</strong> space separated integers that form the matrix. All the integers will be between <strong>0</strong> and <strong>109</strong> (inclusive).</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and <strong>‘Alice’</strong> if Alice wins, or <strong>‘Bob’</strong> otherwise.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>22 32 3 85 2 72 31 2 33 2 1</p>
<p>Case 1: AliceCase 2: Bob</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>憨憨の水题。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    18:41:08
By                : Tpaaaaaa
File_Name         ：1247MatrixGame.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;

int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        //n行
        ll temp, c, ans = 0;
        int n, m;
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= n; i++)
        {
            temp = 0;
            for(int j = 1; j &lt;= m; j++)
            {
                scanf(&quot;%lld&quot;, &amp;c);
                temp += c;
            }
            ans ^= temp;
        }
        printf(&quot;Case %d: &quot;, kase);
        if(ans)
            printf(&quot;Alice\n&quot;);
        else    
            printf(&quot;Bob\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>nim</tag>
      </tags>
  </entry>
  <entry>
    <title>1192 - Left Right</title>
    <url>/tpaaaaaa.github.io/2019/10/15/1192-LeftRight/</url>
    <content><![CDATA[<p>Two players, Alice and Bob are playing a strange game in a <strong>1 x n</strong> board. The cells are numbered from <strong>0</strong> to <strong>n-1</strong>, where the left most cell is marked as cell <strong>0</strong>. Each cell can contain at most one piece.</p>
<p><img src="http://lightoj.com/data/problems/desc/1192/a1.png" alt=""></p>
<p>Fig 1: an example</p>
<p>There are two kinds of pieces, gray and white. Alice moves all gray pieces, and bob moves all white ones. The pieces alternate, that is, leftmost piece is gray, next is white, next to that is gray, then it’s white again, and so on. There will always be equal number of black and gray pieces. Alice can only move pieces to the right. Bob can only move pieces to the left.</p>
<p>At each move, a player selects one piece and moves that piece, either to its left (Bob) or to its right (Alice), any number of cells (at least 1) but, it can neither jump over other pieces, nor it can move outside the board. The players alternate their turns.</p>
<p>For example, if Alice decides to move the left most gray piece, these two moves are available to her.</p>
<p><img src="http://lightoj.com/data/problems/desc/1192/a2.png" alt=""></p>
<p>Fig 2: Moving the gray piece one cell to the right</p>
<p><img src="http://lightoj.com/data/problems/desc/1192/a3.png" alt=""></p>
<p>Fig 3: Moving the gray piece two cells to the right</p>
<p>Alice moves first. The game ends, when someone is unable to make any move, and loses the game. You can assume that, both of them play optimally (that is, if it is possible to apply a strategy that will ensure someone’s win, he/she will always use that strategy).</p>
<p>Now you are given a configuration of a board, you have to find the winner.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>k (1 ≤ k ≤ 100)</strong> denoting the number of gray pieces in the board. The next line contains <strong>2k</strong> distinct integers (in ascending order) denoting the position of the pieces. The first integer denotes a gray piece, the second integer denotes a white piece, the next integer denotes a gray piece and so on. All the integers will lie in the range <strong>[0, 109]</strong>. Assume that <strong>n</strong> is sufficiently large to contain all the pieces. And at least one move is remaining.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each case, print the case number and <strong>‘Alice’</strong> or <strong>‘Bob’</strong> depending on the winner of the game.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>220 3 7 921 3 7 9</p>
<p>Case 1: AliceCase 2: Bob</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>跟上一题一样，也就是将原题目拆分成多个单一的简单组合游戏，然后balabala</p>
<p>显然左右两个一灰一白的棋子中间的距离视为nim里面堆的石头数.</p>
<p>灰棋向右移动和白棋向左移动，分别就像甲和乙分别轮流拿石头.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    18:28:32
By                : Tpaaaaaa
File_Name         ：1192LeftRight.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

每一对灰棋与白棋的操作，就像nim博弈一样
因此，可以看成多个nim游戏的组合
各种异或一下就可以了


解题：
一般给的是多组游戏，你要将这个题意抽解为多个单独的组合游戏
这样只需要将多组单个的组合游戏的SG值异或起来即可。

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;

int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        int k;
        ll a, b;
        scanf(&quot;%d&quot;, &amp;k);
        ll ans = 0;
        for(int i = 1; i &lt;= k; i++)
        {
            scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);
            ans ^= (b - a - 1);
        }
        printf(&quot;Case %d: &quot;, kase);
        if(ans)
            printf(&quot;Alice\n&quot;);
        else
            printf(&quot;Bob\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>棋类nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>1186 - Incredible Chess</title>
    <url>/tpaaaaaa.github.io/2019/10/15/1186-IncredibleChess/</url>
    <content><![CDATA[<p>You are given an <strong>n x n</strong> chess board. Only pawn is used in the ‘Incredible Chess’ and they can move forward or backward. In each column there are two pawns, one white and one black. White pawns are placed in the lower part of the board and the black pawns are placed in the upper part of the board.</p>
<p>The game is played by two players. Initially a board configuration is given. One player uses white pieces while the other uses black. In each move, a player can move a pawn of his piece, which can go forward or backward any positive integer steps, but it cannot jump over any piece. White gives the first move.</p>
<p>The game ends when there is no move for a player and he will lose the game. Now you are given the initial configuration of the board. You have to write a program to determine who will be the winner.</p>
<p><img src="http://lightoj.com/data/problems/desc/1186/a.png" alt=""></p>
<p>Example of a Board</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case starts with an integer <strong>n (3 ≤ n ≤ 100)</strong> denoting the dimension of the board. The next line will contain <strong>n</strong> integers, <strong>W0, W1, …, Wn-1</strong> giving the position of the white pieces. The next line will also contain <strong>n</strong> integers, <strong>B0, B1, … Bn-1</strong> giving the position of the black pieces. <strong>Wi</strong> means the row position of the white piece of <strong>ith</strong> column. And <strong>Bi</strong> means the row position of the black piece of <strong>ith</strong> column. You can assume that <strong>(0 ≤ Wi &lt; Bi &lt; n) **for</strong> (0 ≤ i &lt; n)** and at least one move is remaining.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and <strong>‘white wins’</strong> or <strong>‘black wins’</strong> depending on the result.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>261 3 2 2 0 15 5 5 3 1 271 3 2 2 0 4 03 4 4 3 1 5 6</p>
<p>Case 1: black winsCase 2: white wins</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>每对黑棋子和白棋子之间的距离可以视为nim游戏里面的堆。</p>
<p>所以我们将整个题目按照每列分成n个简单组合游戏。那么游戏的和就是一个nim游戏了。</p>
<p>我们单独分析每个列的情况(<strong>每列就是一个单独的简单组合游戏</strong>)：</p>
<p>每列的话，都是白棋先走。</p>
<p>白棋有两个选项，向上走or向下走。</p>
<p>显然白棋不会憨憨的往下走。</p>
<p>所以白棋只会往上走，此时黑棋和白棋的距离就减小了（就相当于nim中的甲拿去堆中的一些石头）</p>
<p>黑棋有两个操作，要么向上，将他们的距离拉开，or向下移动，进一步缩短他们的距离.</p>
<p>如果黑棋向上的话，白棋紧随其后也向上，始终将二者的距离保持在依据SG函数的下一个数（那么黑棋向上的操作实际上就没什么作用，并且黑棋有向上移动的上限，显然它不可能一直向上_逃避_）， 那么此状态没有发生改变，白棋还是他之前的状态。如果黑棋向下的话，就相当于是另一个人在拿石子了，所以事情按nim游戏进行.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    18:20:36
By                : Tpaaaaaa
File_Name         ：1186IncredibleChess.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
int w[MAXN];
int main()
{
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        int ans = 0, temp;
        for(int i = 0; i &lt; n; i++)  scanf(&quot;%d&quot;, &amp;w[i]);
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%d&quot;, &amp;temp);
            ans ^= (temp - w[i] - 1);
        }
        printf(&quot;Case %d:&quot;, kase);
        if(ans)
            printf(&quot; white wins\n&quot;);
        else 
            printf(&quot; black wins\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>棋类nim游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>UVA - 11551 Experienced Endeavour</title>
    <url>/tpaaaaaa.github.io/2019/10/15/UVA-11551ExperiencedEndeavour/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p><a href="https://vjudge.net/problem/UVA-11551" target="_blank" rel="noopener">UVA - 11551 Experienced Endeavour</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>随便推推然后用矩阵解决了。越来越不爱写分析了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-15    10:52:10
By                : Tpaaaaaa
File_Name         ：ExperiencedEndeavourUVA11551.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 60;
ll a[MAXN], ans[MAXN];
int n;
ll r;
int siz;           //矩阵的大小.
const int MOD = 1000;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    int mat[MAXN][MAXN];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,ll num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
int main()
{
    int t;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d%lld&quot;, &amp;n, &amp;r);
        siz = n;
        Mat p;
        memset(p.mat, 0, sizeof p.mat);
        for(int i = 0; i &lt; n; i++)  scanf(&quot;%lld&quot;, &amp;a[i]);
        for(int i = 0; i &lt; n; i++)
        {
            int m;
            scanf(&quot;%d&quot;, &amp;m);
            for(int j = 0; j &lt; m; j++)
            {
                int c;
                scanf(&quot;%d&quot;, &amp;c);
                p.mat[i][c] = 1;
            }
        }
        p = power(p, r);
        for(int i = 0; i &lt; n; i++)
        {
            ans[i] = 0;
            for(int j = 0; j &lt; n; j++)
            {
                ans[i] += p.mat[i][j] * a[j];
                ans[i] %= MOD;
            }
        }
        for(int i = 0; i &lt; n; i++)
          if(i == n - 1)
            printf(&quot;%lld\n&quot;, ans[i]);
         else 
            printf(&quot;%lld &quot;, ans[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>[数学]博弈论进阶</title>
    <url>/tpaaaaaa.github.io/2019/10/15/%5B%E6%95%B0%E5%AD%A6%5D%E5%8D%9A%E5%BC%88%E8%AE%BA%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<p>先放链接在这</p>
<p>阶级博弈：<a href="https://blog.csdn.net/try__jhf/article/details/75011381" target="_blank" rel="noopener">https://blog.csdn.net/try__jhf/article/details/75011381</a></p>
<p>Anti-Nim / Anti-SG 见ipad上下的论文。</p>
<p>green 博弈 见pdf</p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>1142 - Summing up Powers (II)</title>
    <url>/tpaaaaaa.github.io/2019/10/14/1142-SummingupPowers(II)/</url>
    <content><![CDATA[<p>Shanto is learning how to power up numbers and he found an efficient way to find <strong>kth</strong> power of a matrix. He was quite happy with his discovery. Suddenly his sister Natasha came to him and asked him to find the summation of the powers. To be specific his sister gave the following problem.</p>
<p>Let <strong>A</strong> be an <strong>n x n</strong> matrix. We define <strong>Ak = A * A * … * A (k times)</strong>. Here, <strong>*** denotes the usual matrix multiplication. You are to write a program that computes the matrix **A + A2 + A3 + … + Ak</strong>.</p>
<p>Shanto smiled and thought that it would be an easy one. But after a while he found that it’s tough for him. Can you help him?Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20)**, denoting the number of test cases.</p>
<p>Each case starts with two integers <strong>n (1 ≤ n ≤ 30)</strong> and <strong>k (1 ≤ k ≤ 109)</strong>. Each of the next <strong>n</strong> lines will contain <strong>n</strong> non-negative integers (not greater than <strong>10</strong>).Output</p>
<p>For each case, print the case number and the result matrix. For each cell, just print the last digit. See the samples for more details.Sample Input</p>
<p>2</p>
<p>3 2</p>
<p>1 4 6</p>
<p>6 5 2</p>
<p>1 2 3</p>
<p>3 10</p>
<p>1 4 6</p>
<p>6 5 2</p>
<p>1 2 3Sample Output</p>
<p>Case 1:</p>
<p>208</p>
<p>484</p>
<p>722</p>
<p>Case 2:</p>
<p>868</p>
<p>620</p>
<p>546</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们设 <strong>F(k) =</strong> <strong>A + A2 + A3 + … + Ak</strong>. (A 无论是数还是矩阵)</p>
<p>都可以考虑一个巧妙的矩阵来加速运算.</p>
<p>A A</p>
<p>0 E</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    20:54:36
By                : Tpaaaaaa
File_Name         ：LightOJ1142SummingupPowers(2).cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 35;
int n, k;
int siz;           //矩阵的大小.
const int MOD = 10;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    int mat[70][70];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        Mat p;
        memset(p.mat, 0, sizeof p.mat);
        for(int i = 0; i &lt; n; i++)
        {   
            for(int j = 0; j &lt; n; j++)
            {
                scanf(&quot;%d&quot;, &amp;p.mat[i][j]);
                p.mat[i][j + n] = p.mat[i][j];
            }
            p.mat[i + n][i + n] = 1;
        }

        siz = 2 * n;
        p = power(p, k);
        printf(&quot;Case %d:\n&quot;, kase);
        for(int i = 0; i &lt; n; i++)
        {
            for(int j = 0; j &lt; n; j++)
                printf(&quot;%d&quot;, p.mat[i][j + n]);

            printf(&quot;\n&quot;);
        }

    }   
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>F(k) = A + A^2 + A^3 + … + A^k用矩阵加速</tag>
      </tags>
  </entry>
  <entry>
    <title>1132 - Summing up Powers</title>
    <url>/tpaaaaaa.github.io/2019/10/14/1132-SummingupPowers/</url>
    <content><![CDATA[<p>Given <strong>N</strong> and <strong>K</strong>, you have to find</p>
<p><strong>(1K + 2K + 3K + … + NK) % 232</strong>Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case contains two integers <strong>N (1 ≤ N ≤ 1015)</strong> and <strong>K (0 ≤ K ≤ 50)</strong> in a single line.Output</p>
<p>For each case, print the case number and the result.Sample Input</p>
<p>3</p>
<p>3 1</p>
<p>4 2</p>
<p>3 3</p>
<p>Sample Output</p>
<p>Case 1: 6</p>
<p>Case 2: 30</p>
<p>Case 3: 36</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>模<strong>232</strong> 可以用usigned int 实现</p>
<p>组合数可以提前打表</p>
<pre><code>//组合数打表模板,适用于N&lt;=3000
//c[i][j]表示从i个中选j个的选法。
long long C[N][N];

void get_C(int maxn)
{
    C[0][0] = 1;
    for(int i = 1; i &lt;= maxn; i++)
    {
        C[i][0] = 1;
        for(int j = 1; j &lt;= i; j++)
            C[i][j] = C[i-1][j] + C[i-1][j-1];
        //C[i][j] = (C[i-1][j] + C[i-1][j-1]) % MOD;
    }
}</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    13:05:53
By                : Tpaaaaaa
File_Name         ：1132SummingupPowers.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
上一题是将两个递推式合在一起
现在是将k个递推式子和在一起

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned int uint;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
const int MAXK = 70;
uint C[MAXK][MAXK];
ll n;
int k;
// 返回C(a, b);
//a b 都小于50
//这是什么初始化操作...
void init()
{
    C[0][0] = 1;
    for(int i = 1; i &lt; MAXK; i++)
    {
        C[i][0] = 1;
        for(int j = 1; j &lt;= i; j++)
            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
    }
}
int siz;           //矩阵的大小.
struct Mat//定义矩阵  
{  
    uint mat[MAXK][MAXK];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b, int siz)//矩阵乘法   
{  
    Mat ans;  
    ans.init();
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
           // ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a, ll num, int siz)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a, siz);
        num &gt;&gt;= 1;  
        a = mul(a, a, siz);  
    }  
    return ans;  
} 
int main()
{
    fileopen;
    int t;
    init();
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%lld%d&quot;, &amp;n, &amp;k);
        Mat p;
        memset(p.mat, 0, sizeof p.mat);
        siz = k + 2;
        for(int i = 0; i &lt; k + 2; i++)
        {

            if(i == k + 1)
            {
                p.mat[i][0] = 1;
                p.mat[i][i] = 1;
            }
            else
            {
                for(int j = i; j &lt; k + 1; j++)
                    p.mat[i][j] = C[k - i][j - i];
            }
        }
        p = power(p, n, siz);
        uint ans = 0;
        for(int i = 0; i &lt; k + 1; i++)
            ans += p.mat[k + 1][i];
        printf(&quot;Case %d: %u\n&quot;, kase, ans);
    }
    return 0;
    fileclose;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ - 1131 Just Two Functions</title>
    <url>/tpaaaaaa.github.io/2019/10/14/LightOJ-1131JustTwoFunctions/</url>
    <content><![CDATA[<p>Let</p>
<p><strong>fn = a1 * fn-1 + b1 * fn-2 + c1 * gn-3</strong></p>
<p><strong>gn = a2 * gn-1 + b2 * gn-2 + c2 * fn-3</strong></p>
<p>Find <strong>fn % M</strong> and <strong>gn % M</strong>. (<strong>%</strong> stands for the modulo operation.)Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 50)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line. Next line contains three integers <strong>a1 b1 c1 (0 ≤ a1, b1, c1 &lt; 25000)</strong>. Next line contains three integers <strong>a2 b2 c2 (0 ≤ a2, b2, c2 &lt; 25000)</strong>. Next line contains three integers <strong>f0 f1 f2 (0 ≤ f0, f1, f2 &lt; 25000)</strong>. Next line contains three integers <strong>g0 g1 g2 (0 ≤ g0, g1, g2 &lt; 25000)</strong>. The next line contains an integer <strong>M (1 ≤ M &lt; 25000)</strong>.</p>
<p>Next line contains an integer <strong>q (1 ≤ q ≤ 100)</strong> denoting the number of queries. Next line contains <strong>q</strong>space separated integers denoting <strong>n</strong>. Each of these integers is non-negative and less than 231.Output</p>
<p>For each case, print the case number in a line. Then for each query, you have to print one line containing <strong>fn % M</strong> and <strong>gn % M</strong>.Sample Input</p>
<p>2</p>
<p>1 1 0</p>
<p>0 0 0</p>
<p>0 1 1</p>
<p>0 0 0</p>
<p>20000</p>
<p>10</p>
<p>1 2 3 4 5 6 7 8 9 10</p>
<p>1 1 1</p>
<p>1 1 1</p>
<p>2 2 2</p>
<p>2 2 2</p>
<p>20000</p>
<p>5</p>
<p>2 4 6 8 10Sample Output</p>
<p>Case 1:</p>
<p>1 0</p>
<p>1 0</p>
<p>2 0</p>
<p>3 0</p>
<p>5 0</p>
<p>8 0</p>
<p>13 0</p>
<p>21 0</p>
<p>34 0</p>
<p>55 0</p>
<p>Case 2:</p>
<p>2 2</p>
<p>10 10</p>
<p>34 34</p>
<p>114 114</p>
<p>386 386</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>两个递推式放在一个矩阵上面求。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    11:17:47
By                : Tpaaaaaa
File_Name         ：1131JustTwoFunctions.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
int a1, b1, c1, a2, b2, c2, f0, f1, f2, g0, g1, g2, MOD;
const int siz = 6;           //矩阵的大小.
struct Mat//定义矩阵  
{  
    int mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
}p, pp;  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
int main()
{
    int t, q;
    fileopen;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(p.mat, 0, sizeof p.mat);
        scanf(&quot;%d%d%d&quot;, &amp;a1, &amp;b1, &amp;c1);
        scanf(&quot;%d%d%d&quot;, &amp;a2, &amp;b2, &amp;c2);
        scanf(&quot;%d%d%d&quot;, &amp;f0, &amp;f1, &amp;f2);
        scanf(&quot;%d%d%d&quot;, &amp;g0, &amp;g1, &amp;g2);
        p.mat[0][0] = a1; p.mat[0][2] = b1; p.mat[0][5] = c1;
        p.mat[1][1] = a2; p.mat[1][3] = b2; p.mat[1][4] = c2;
        p.mat[2][0] = 1;
        p.mat[3][1] = 1;
        p.mat[4][2] = 1;
        p.mat[5][3] = 1;
        scanf(&quot;%d&quot;, &amp;MOD);
        scanf(&quot;%d&quot;, &amp;q);
        printf(&quot;Case %d:\n&quot;, kase);
        for(int i = 1; i &lt;= q; i++)
        {
            int n;
            scanf(&quot;%d&quot;, &amp;n);
            if(n &lt;= 2)
            {
                int f = -1, g = -1;
                if(n == 0)  f = f0, g = g0;
                else if(n == 1) f = f1, g = g1;
                else if(n == 2) f = f2, g = g2;
                printf(&quot;%d %d\n&quot;, f % MOD, g % MOD);
            }
            else
            {
                pp = power(p, n - 2);
                int f = pp.mat[0][0] * f2 % MOD + pp.mat[0][1] * g2 % MOD + pp.mat[0][2] * f1 % MOD + pp.mat[0][3] * g1 % MOD + pp.mat[0][4] * f0 % MOD + pp.mat[0][5] * g0 % MOD;
                int g = pp.mat[1][0] * f2 % MOD + pp.mat[1][1] * g2 % MOD + pp.mat[1][2] * f1 % MOD + pp.mat[1][3] * g1 % MOD + pp.mat[1][4] * f0 % MOD + pp.mat[1][5] * g0 % MOD;
                printf(&quot;%d %d\n&quot;, f % MOD, g % MOD);
            }
        }
    }
    fileclose;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>1070 - Algebraic Problem</title>
    <url>/tpaaaaaa.github.io/2019/10/14/1070-AlgebraicProblem/</url>
    <content><![CDATA[<p><a href="http://lightoj.com/volume_submit.php?problem=1070" target="_blank" rel="noopener"> </a>  <a href="http://udebug.com/LOJ/1070" target="_blank" rel="noopener"></a></p>
<p><a href="http://lightoj.com/volume_showproblem.php?problem=1070&language=english&type=pdf" target="_blank" rel="noopener">PDF (English)</a></p>
<p><a href="http://lightoj.com/volume_problemstat.php?problem=1070" target="_blank" rel="noopener">Statistics</a></p>
<p><a href="http://lightoj.com/forum_showproblem.php?problem=1070" target="_blank" rel="noopener">Forum</a></p>
<p>Time Limit: 2 second(s)</p>
<p>Memory Limit: 32 MB</p>
<p>Given the value of <strong>a+b</strong> and <strong>ab</strong> you will have to find the value of <strong>an+bn</strong>. <strong>a</strong> and <strong>b</strong> not necessarily have to be real numbers.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each case contains three non-negative integers, <strong>p, q</strong> and <strong>n</strong>. Here <strong>p</strong> denotes the value of <strong>a+b</strong> and <strong>q</strong> denotes the value of <strong>ab</strong>. Each number in the input file fits in a signed 32-bit integer. There will be no such input so that you have to find the value of <strong>00</strong>.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each test case, print the case number and <strong>(an+bn)</strong> modulo <strong>264</strong>.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>210 16 27 12 3</p>
<p>Case 1: 68Case 2: 91</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>模2^64 和 模2^32 可以用usigned long long 和 usigned int 实现。</p>
<p>其次就是关于 <strong>f(n) = (an+bn)</strong> 的递推方程。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    10:55:08
By                : Tpaaaaaa
File_Name         ：1070AlgebraicProblem.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
学到一个新的递推公式
是关于f(n) = x^n + y^n次方的递推公式
//取模2^64，unsigned long long！！
//取模2^64，unsigned long long！！
//取模2^64，unsigned long long！！
注意矩阵快速幂的时候，要注意幂为0等特殊情况要特判一下。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
const int siz = 2;           //矩阵的大小.
//取模2^64，unsigned long long！！
struct Mat//定义矩阵  
{  
    ull mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
int main()
{
    ull p, q, n;
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%llu%llu%llu&quot;, &amp;p, &amp;q, &amp;n);
        if(n == 0)
            printf(&quot;Case %d: 2\n&quot;, kase);
        else if(n == 1)
            printf(&quot;Case %d: %llu\n&quot;, kase, p);
        else
        {
            Mat m;
            m.mat[0][0] = p;
            m.mat[0][1] = -q;
            m.mat[1][0] = 1;
            m.mat[1][1] = 0;
            m = power(m, n - 1);
            ull ans = m.mat[0][0] * p + m.mat[0][1] * 2;
            printf(&quot;Case %d: %llu\n&quot;, kase, ans);
        }

    }

    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>f(n) = (a^n+b^n) 的递推方程</tag>
      </tags>
  </entry>
  <entry>
    <title>1065 - Number Sequence</title>
    <url>/tpaaaaaa.github.io/2019/10/14/1065-NumberSequence/</url>
    <content><![CDATA[<p>Let’s define another number sequence, given by the following function:</p>
<p><strong>f(0) = a</strong></p>
<p><strong>f(1) = b</strong></p>
<p><strong>f(n) = f(n-1) + f(n-2), n &gt; 1</strong></p>
<p>When <strong>a = 0</strong> and <strong>b = 1</strong>, this sequence gives the Fibonacci sequence. Changing the values of <strong>a</strong> and <strong>b</strong>, you can get many different sequences. Given the values of <strong>a, b</strong>, you have to find the last <strong>m</strong>digits of <strong>f(n)</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each test case consists of a single line containing four integers <strong>a b n m</strong>. The values of <strong>a</strong> and <strong>b</strong>range in <strong>[0,100]</strong>, value of <strong>n</strong> ranges in <strong>[0, 109]</strong> and value of <strong>m</strong> ranges in <strong>[1, 4]</strong>.Output</p>
<p>For each case, print the case number and the last <strong>m</strong> digits of <strong>f(n)</strong>. However, do <strong>NOT</strong> print any leading zero.Sample Input</p>
<p>4</p>
<p>0 1 11 3</p>
<p>0 1 42 4</p>
<p>0 1 22 4</p>
<p>0 1 21 4</p>
<p>Sample Output</p>
<p>Case 1: 89</p>
<p>Case 2: 4296</p>
<p>Case 3: 7711</p>
<p>Case 4: 946</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>the last <strong>m</strong> digits of <strong>f(n)</strong> <strong>== mod 10^m</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    10:36:36
By                : Tpaaaaaa
File_Name         ：1065NumberSequence.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
const int siz = 2;           //矩阵的大小.
int MOD;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    int mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
ll a, b, n, m;
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%lld%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;n, &amp;m);
        MOD = pow(10, m);
        Mat p;
        p.mat[0][0] = 1; p.mat[0][1] = 1;
        p.mat[1][0] = 1; p.mat[1][1] = 0;
        p = power(p, n - 1);
        ll ans = ((p.mat[0][0] * b) % MOD + (p.mat[0][1] * a) % MOD) % MOD;
        printf(&quot;Case %d: %lld\n&quot;, kase, ans); 
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>1052 - StringGrowth</title>
    <url>/tpaaaaaa.github.io/2019/10/14/1052-StringGrowth/</url>
    <content><![CDATA[<p>Zibon just started his courses in Computer science. After having some lectures on programming courses he fell in love with strings. He started to play with strings and experiments on them. One day he started a string of arbitrary (of course positive) length consisting of only <strong>{a, b}</strong>. He considered it as 1st string and generated subsequent strings from it by replacing all the <strong>b</strong>‘s with <strong>ab</strong>and all the <strong>a</strong>‘s with <strong>b</strong>. For example, if he <strong>ith</strong> string is <strong>abab</strong>, <strong>(i+1)th</strong> string will be <strong>b(ab)b(ab) = babbab</strong>. He found that the <strong>Nth</strong> string has length <strong>X</strong> and <strong>M</strong>th string has length <strong>Y</strong>. He wondered what will be length of the <strong>Kth</strong> string. Can you help him?Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case begins with five integers <strong>N, X, M, Y, K. (0 &lt; N, M, X, Y, K &lt; 109 and N ≠ M)</strong>.Output</p>
<p>For each case print one line containing the case number and <strong>L</strong> which is the desired length <strong>(mod 1000000007)</strong> or the string <strong>“Impossible”</strong> if it’s not possible.Sample Input</p>
<p>2</p>
<p>3 16 5 42 6</p>
<p>5 1 6 10 9</p>
<p>Sample Output</p>
<p>Case 1: 68</p>
<p>Case 2: Impossible</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>自己手推前几项，观察观察出来系数和裴波那契数有关。</p>
<p>ps：矩阵快速幂本质是为了求递推式，显然<strong>递推式可以满足模运算，所以我们可以直接在矩阵求幂的过程中取模了。</strong></p>
<pre><code>我们先推出前几项的式子，f(i) 表示 i st 的字符串的长度
显然我们有
f(1) = x + y;
f(2) = x + 2y;
f(3) = 2x + 3y;
f(4) = 3x + 5y;
f(5) = 5x + 8y;
发现其系数与裴波那切数有关，设p(1) = 1, p(2) = 1, p(3) = 2, p(4) = 3 ...
则有
f(i) = p(i) * x + p(i + 1) * y;
根据题目，我们得到两个方程
f(N) = p(N) * x + p(N + 1) * y;
f(M) = p(M) * x + p(M + 1) * y;
所以求裴波那切的时候用矩阵加速一下。
就可以解出来x与y
知道了x和y  就可以求出任意的f(k)了
同样也利用矩阵加速裴波那契递推式。</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-14    08:53:30
By                : Tpaaaaaa
File_Name         ：1052-StringGrowth.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

之前的思路憨憨了
我们有两个变量，一个是起始状态下a的数目，我们设为x， 起始状态下b的数目，我们设为y
我们先推出前几项的式子，f(i) 表示 i st 的字符串的长度
显然我们有
f(1) = x + y;
f(2) = x + 2y;
f(3) = 2x + 3y;
f(4) = 3x + 5y;
f(5) = 5x + 8y;
发现其系数与裴波那切数有关，设p(1) = 1, p(2) = 1, p(3) = 2, p(4) = 3 ...
则有
f(i) = p(i) * x + p(i + 1) * y;
根据题目，我们得到两个方程
f(N) = p(N) * x + p(N + 1) * y;
f(M) = p(M) * x + p(M + 1) * y;
所以求裴波那切的时候用矩阵加速一下。

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
const int siz = 2;           //矩阵的大小.
const int MOD = 1000000007;           //矩阵快速幂的模数.
bool flag;
struct Mat//定义矩阵  
{  
    ll mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)
            {
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];
                ans.mat[i][j] %= MOD;  
            }  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,ll num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
}
ll N, X, M, Y, K;
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        flag = false;
        scanf(&quot;%lld%lld%lld%lld%lld&quot;, &amp;N, &amp;X, &amp;M, &amp;Y, &amp;K);
        if(N &lt; M)
        {
            swap(N, M);
            swap(X, Y);
        }
        Mat t1;
        t1.mat[0][0] = 1; t1.mat[0][1] = 1;
        t1.mat[1][0] = 1; t1.mat[1][1] = 0;
        t1 = power(t1, N - 1);
        ll pn1 = t1.mat[1][0] + t1.mat[1][1];
        ll pn2 = t1.mat[0][0] + t1.mat[0][1];
        Mat t2;
        t2.mat[0][0] = 1; t2.mat[0][1] = 1;
        t2.mat[1][0] = 1; t2.mat[1][1] = 0;
        t2 = power(t2, M - 1);
        ll pm1 = t2.mat[1][0] + t2.mat[1][1];
        ll pm2 = t2.mat[0][0] + t2.mat[0][1];
        ll x1 = X * pm2 - Y * pn2;
        ll x2 = pn1 * pm2 - pm1 * pn2;
        ll y1 = Y * x2 - pm1 * x1;
        ll y2 = pm2 * x2;
        //方程没有整数解
        if(x1 % x2 || y1 % y2)
            printf(&quot;Case %d: Impossible\n&quot;, kase);
        else
        {
            Mat t3;
            t3.mat[0][0] = 1; t3.mat[0][1] = 1;
            t3.mat[1][0] = 1; t3.mat[1][1] = 0;
            t3 = power(t3, K - 1);
            ll x = x1 / x2;
            ll y = y1 / y2;
            if(x &lt; 0 || y &lt; 0)
                printf(&quot;Case %d: Impossible\n&quot;, kase);
            else
            {
                x %= MOD;
                y %= MOD;
                ll px = t3.mat[1][0] + t3.mat[1][1];
                ll py = t3.mat[0][0] + t3.mat[0][1];
                ll ans = (px * x) % MOD  + (py * y) % MOD;
                printf(&quot;Case %d: %lld\n&quot;, kase, ans % MOD); 
            }

        }

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵快速幂求递推式</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4990 Reading comprehension</title>
    <url>/tpaaaaaa.github.io/2019/10/13/HDU-4990Readingcomprehension/</url>
    <content><![CDATA[<p>Read the program below carefully then answer the question.<br>#pragma comment(linker, “/STACK:1024000000,1024000000”)<br>#include <cstdio><br>#include<iostream><br>#include <cstring><br>#include <cmath><br>#include <algorithm><br>#include<vector> </p>
<p>const int MAX=100000*2;<br>const int INF=1e9; </p>
<p>int main()<br>{<br>  int n,m,ans,i;<br>  while(scanf(“%d%d”,&amp;n,&amp;m)!=EOF)<br>  {<br>    ans=0;<br>    for(i=1;i&lt;=n;i++)<br>    {<br>      if(i&amp;1)ans=(ans<em>2+1)%m;<br>      else ans=ans</em>2%m;<br>    }<br>    printf(“%d\n”,ans);<br>  }<br>  return 0;<br>}InputMulti test cases，each line will contain two integers n and m. Process to end of file.<br><strong>[Technical Specification]</strong><br>1&lt;=n, m &lt;= 1000000000OutputFor each case，output an integer，represents the output of above program.Sample Input</p>
<p>1 10<br>3 100</p>
<p>Sample Output</p>
<p>1<br>5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>两个解法：</p>
<p>①是直接手推一下求出为奇为偶时候各自的通项公式，就是一个等比数列求和的公式，然后用快速幂即可</p>
<p>②是手推出递推公式，然后用矩阵加速一下即可。</p>
<p>并且解锁一个新（其实早该掌握的）知识：</p>
<p>某种简单的逆元求法</p>
<pre><code>逆元的一种简单但有局限的求法
ans=a/b%m  &lt;==&gt;ans=a%(b*m)/b;

证明如下：

a/b=km+x;
a=kbm+bx;
a%(b*m)=bx;
a%(b*m)/b=x;
a/b%m=x=a%(b*m)/b;
前提是a能整除b,即b|a;</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>矩阵快速幂版本</p>
<pre><code>/*
Date              : 2019-10-13    09:33:07
By                : Tpaaaaaa
File_Name         ：ReadingcomprehensionHDU4990（矩阵快速幂版本）.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
const int siz = 3;           //矩阵的大小.
ll MOD;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    ll mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
} 
int main()
{
    ll n;
    while(scanf(&quot;%lld%lld&quot;, &amp;n, &amp;MOD) != EOF)
    {
        Mat A;
        if(n == 1)  printf(&quot;%lld\n&quot;, 1 % MOD);
        else if(n == 2) printf(&quot;%lld\n&quot;, 2 % MOD);
        else
        {
            memset(A.mat, 0, sizeof A.mat);
            A.mat[0][0] = 1; A.mat[0][1] = 2; A.mat[0][2] = 1;
            A.mat[1][0] = 1; 
            A.mat[2][2] = 1;
            A = power(A, n - 2);
            ll ans = A.mat[0][0] * 2 + A.mat[0][1] * 1 + A.mat[0][2];
            printf(&quot;%lld\n&quot;, ans % MOD);
        }
    }
    return 0;
}</code></pre><p>等比数列求和版本</p>
<pre><code>/*
Date              : 2019-10-13    08:39:03
By                : Tpaaaaaa
File_Name         ：ReadingcomprehensionHDU4990.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

//这题可以直接推出通项公式 + 快速幂 + 逆元. 也可以用矩阵求
//通项公式是： f(x) = (2^(x + 1) - 1) /  3; //x为奇
              f(x) = (2^(x + 1) - 2) /  3;
显然f(x)是整数，也就是等式右边能够整除，能够整除的话求逆元就可以用下面这个方法！

逆元的一种简单但有局限的求法
ans=a/b%m  &lt;==&gt;ans=a%(b*m)/b;

证明如下：

a/b=km+x;
a=kbm+bx;
a%(b*m)=bx;
a%(b*m)/b=x;
a/b%m=x=a%(b*m)/b;
前提是a能整除b,即b|a;
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
ll mod;
ll q_pow(ll a, ll b)
{
    ll ans = 1;
    while(b)
    {
        if(b &amp; 1)   ans = ans * a % mod;
        a = a * a % mod;
        b &gt;&gt;= 1;
    }
    return ans;
}
int main()
{
    ll n, m;
    while(scanf(&quot;%lld %lld&quot;, &amp;n, &amp;m) != EOF)
    { 
        mod = 3 * m; 
        if(n &amp; 1)   //奇数
        {
            ll ans = (q_pow(2, n + 1) - 1) ;
            ans = ans / 3;
            printf(&quot;%lld\n&quot;, ans);
        }
        else
        {
            ll ans = (q_pow(2, n + 1) - 2) ;
            ans = ans / 3;
            printf(&quot;%lld\n&quot;, ans);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>矩阵，数学，逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>1272 - Maximum Subset Sum</title>
    <url>/tpaaaaaa.github.io/2019/10/13/1272-MaximumSubsetSum/</url>
    <content><![CDATA[<p><a href="http://lightoj.com/volume_submit.php?problem=1272" target="_blank" rel="noopener"> </a>  <a href="http://udebug.com/LOJ/1272" target="_blank" rel="noopener"></a></p>
<p><a href="http://lightoj.com/volume_showproblem.php?problem=1272&language=english&type=pdf" target="_blank" rel="noopener">PDF (English)</a></p>
<p><a href="http://lightoj.com/volume_problemstat.php?problem=1272" target="_blank" rel="noopener">Statistics</a></p>
<p><a href="http://lightoj.com/forum_showproblem.php?problem=1272" target="_blank" rel="noopener">Forum</a></p>
<p>Time Limit: 2 second(s)</p>
<p>Memory Limit: 32 MB</p>
<p>Little Jimmy is learning how to add integers. As in decimal the digits are 0 to 9, it makes a bit hard for him to understand the summation of all pair of digits. Since addition of numbers requires the knowledge of adding digits. So, his mother gave him a software that can convert a decimal integer to its binary and a binary to its corresponding decimal. So, Jimmy’s idea is to convert the numbers into binaries, and then he adds them and turns the result back to decimal using the software. It’s easy to add in binary, since you only need to know how to add (0, 0), (0, 1), (1, 0), (1, 1). Jimmy doesn’t have the idea of carry operation, so he thinks that</p>
<p>1 + 1 = 0</p>
<p>1 + 0 = 1</p>
<p>0 + 1 = 1</p>
<p>0 + 0 = 0</p>
<p>Using these operations, he adds the numbers in binary. So, according to his calculations,</p>
<p>3 (011) + 7 (111) = 4 (100)</p>
<p>Now you are given an array of <strong>n</strong> integers, indexed from <strong>0</strong> to <strong>n-1</strong>, you have to find a subset of the integers in the array such that the summation (according to Jimmy) of all integers in the subset is as large as possible. You only have to report the maximum sum.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 100)</strong>. The next line contains <strong>n</strong> space separated non-negative integers, denoting the integers of the given array. Each integer fits into a 64 bit signed integer.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number, the maximum subset sum that can be made using Jimmy’s addition.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>239 11 554 8 8 4 4</p>
<p>Case 1: 14Case 2: 12</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>在一个数的集合里面选择出一个子集，使得这个子集的异或值最大。</strong></p>
<p>解锁了新的姿势——线性基（但是WA了 QAQ智商不够）</p>
<p>然后用高斯消元法解了…代码先挂在这算了（应该是还要向上清0）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>线性基</p>
<pre><code>/*
Date              : 2019-10-13    14:36:19
By                : Tpaaaaaa
File_Name         ：1272MaximumSubsetSum.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
线性基的写法，为什么WA了。QAQ
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 70;
//将val插入到线性基中
ll a[MAXN];
void insert(ll val)
{
    for(int i = 63; i &gt;= 0; i--)
    {
        if(val &amp; (1ll &lt;&lt; i))
        {
            if(a[i] == 0)
            {
                a[i] = val;
                return;
            }
            else 
                val ^= a[i];
        }
    }
}
ll query_max()
{
    ll ret = 0;
    for(int i = 63; i &gt;= 0; i--)
    {
        if(ret ^ a[i] &gt; ret)
            ret ^= a[i];
    }
    return ret;
}
int main()
{
    int t, n;
    fileopen;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(a, 0, sizeof a);
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            ll temp;
            scanf(&quot;%lld&quot;, &amp;temp);
            insert(temp);
        }

        ll ans = query_max();
        printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
    fileclose;
    return 0;
}</code></pre><p>高斯消元法</p>
<pre><code>/*
Date              : 2019-10-13    15:00:56
By                : Tpaaaaaa
File_Name         ：1272MaximumSubsetSum（Guass）.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
利用高斯消元法的思想，其实就是线性基
将每个数字的二进制视为一行方程
这样就得到了一个n * 64的系数矩阵
通过上下方程的取xor，使得这个系数矩阵变成上三角形
然后从上往下遍历n个变化后的数，如果ret 异或上这个数之后变大了，就异或上

这不就是线性基吗！！！！！！WHY MY CODE IS WA?? WHY, SAD;
对高斯消元法的掌握更好了呢@@@嘻嘻
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
ll a[MAXN];
//得到a数的二进制第p位（从右往左从0开始）
int get(ll a, int p)
{
    return 1 &amp; (a &gt;&gt; p);
}
//n * m 
void Gauss(int n, int m)
{
    int max_r;
    int col = 63, row = 0;
    for(; col &gt;= 0 &amp;&amp; row &lt; n; col--, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(get(a[i], col) &gt; get(a[max_r], col))     max_r = i;
        if(max_r != row)
        {
            ll temp = a[row];
            a[row] = a[max_r];
            a[max_r] = temp;
        }
        if(get(a[row], col) == 0)
        {
            row--;
            continue;
        }
        for(int i = row + 1; i &lt; n; i++)
            if(get(a[i], col))
                a[i] ^= a[row]; 
        //把上面的清理
        for(int i = 0; i &lt; row; i++)
            if(get(a[i], col))
                a[i] ^= a[row];            
    }

}
int main()
{
    int t, n;
    fileopen;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%lld&quot;, &amp;a[i]);
        Gauss(n, 63);
        ll ans = 0;
        for(int i = 0; i &lt; n; i++)
            ans ^= a[i];
        printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
    fileclose;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，线性基，异或</tag>
      </tags>
  </entry>
  <entry>
    <title>1279 - Graph Coloring</title>
    <url>/tpaaaaaa.github.io/2019/10/13/1279-GraphColoring/</url>
    <content><![CDATA[<p><a href="http://lightoj.com/volume_submit.php?problem=1279" target="_blank" rel="noopener"> </a>  <a href="http://udebug.com/LOJ/1279" target="_blank" rel="noopener"></a></p>
<p><a href="http://lightoj.com/volume_showproblem.php?problem=1279&language=english&type=pdf" target="_blank" rel="noopener">PDF (English)</a></p>
<p><a href="http://lightoj.com/volume_problemstat.php?problem=1279" target="_blank" rel="noopener">Statistics</a></p>
<p><a href="http://lightoj.com/forum_showproblem.php?problem=1279" target="_blank" rel="noopener">Forum</a></p>
<p>Time Limit: 2 second(s)</p>
<p>Memory Limit: 32 MB</p>
<p>Given an undirected graph <strong>G</strong>, you want to color each vertex of the graph using <strong>K</strong> colors. The colors are numbered from <strong>0</strong> to <strong>K-1</strong>. But there is one restriction. Let <strong>v</strong> be any vertex of the graph and <strong>u1, u2 … um</strong> be the adjacent vertices of <strong>v</strong>, then</p>
<p><strong>color(v) = color(u1) + color(u2) + … + color(um) (modulo K)</strong></p>
<p>Now you have to find the number of ways you can color the graph maintaining this restriction.</p>
<h1 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h1><p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing three integers <strong>N</strong>, <strong>M **and</strong> K (1 ≤ N ≤ 100, 2 ≤ K ≤ 109 and K is a prime) <strong>where **N</strong> denotes the number of vertices and <strong>M</strong> denotes the number of edges of the graph.Each of the next <strong>M</strong> lines contains two integers <strong>u v (1 ≤ u, v ≤ N, u ≠ v)</strong> denoting that there is an edge between vertex <strong>u</strong> and <strong>v</strong>. You can safely assume that there is at most one edge between any two vertices.</p>
<h1 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h1><p>For each case, print the case number and the result modulo <strong>1000000007</strong>.</p>
<p>Sample Input</p>
<p>Output for Sample Input</p>
<p>26 0 55 4 31 21 32 43 5</p>
<p>Case 1: 1Case 2: 3</p>
<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1><p>For the second case, let the colors be red (0), green (1) and blue (2). Then the possible results are:</p>
<p><img src="http://lightoj.com/data/problems/desc/1279/a1.png" alt=""></p>
<p><img src="http://lightoj.com/data/problems/desc/1279/a2.png" alt=""></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>高斯消元法 模线性方程组。一些细节要注意，能做模板。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-13    15:50:11
By                : Tpaaaaaa
File_Name         ：1279 Graph Coloring.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
高斯消元法解模线性方程组。模板题
用链式前向星保存图
对于每个点他的连接的边，我们可以得到一个方程
他自己的系数为1，其他与他相连的系数为-1，其余为0.
得到n个方程，之后求解.

注意考虑系数是负数！！
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MOD  = 1000000007;
ll a[MAXN][MAXN];
int n, m;
ll k;
ll gcd(ll a, ll b)
{
    if(b == 0)  return a;
    return gcd(b, a%b);
}
ll lcm(ll a, ll b)
{
    return a/gcd(a, b) * b;
}
int Gauss(int equ, int var)
{
    int col = 1, row = 1, max_r;
    for(; col &lt;= var &amp;&amp; row &lt;= equ; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt;= equ; i++)
            if(abs(a[max_r][col]) &lt; abs(a[i][col]))   max_r = i;
        if(max_r != row)
            for(int i = row; i &lt;= var + 1; i++)
                swap(a[max_r][i], a[row][i]);
        if(a[row][col] == 0)
        {
            row--;
            continue;
        }
        for(int i = row + 1; i &lt;= equ; i++)
        {
            if(a[i][col] != 0)
            {
                ll LCM = lcm(abs(a[row][col]), abs(a[i][col]));
                ll ta = LCM / a[i][col];
                ll tb = LCM / a[row][col];
                for(int j = col; j &lt;= var + 1; j++)
                    a[i][j] = ((a[i][j] * ta - a[row][j] * tb) % k + k) % k; 
            }
        }
    }
    return equ - row + 1;
}
ll qpow(ll a, int b)
{
    ll ret = 1;
    while(b)
    {
        if(b &amp; 1)
            ret = (ret * a) % MOD;
        a = (a * a) % MOD; 
        b &gt;&gt;= 1;
    }
    return ret;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(a, 0, sizeof a);
        //n点，m边，模k，点的编号从1开始
        scanf(&quot;%d%d%lld&quot;, &amp;n, &amp;m, &amp;k);
        for(int i = 1; i &lt;= n; i++)
            a[i][i] = 1;
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            a[u][v] = -1;
            a[v][u] = -1;
        }
        //增广矩阵建立完了。
        int free_num = Gauss(n, n);
        ll ans = qpow(k, free_num);
        //传出来的是自由变量的数目
        if(free_num == 0)
            printf(&quot;Case %d: 1\n&quot;, kase);
        else
            printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法解模线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1027 A Dangerous Maze</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1027ADangerousMaze/</url>
    <content><![CDATA[<p>You are in a maze; seeing <strong>n</strong> doors in front of you in beginning. You can choose any door you like. The probability for choosing a door is equal for all doors.</p>
<p>If you choose the <strong>ith</strong> door, it can either take you back to the same position where you begun in <strong>xi</strong>minutes, or can take you out of the maze after <strong>xi</strong> minutes. If you come back to the same position, you can’t remember anything. So, every time you come to the beginning position, you have no past experience.</p>
<p>Now you want to find the expected time to get out of the maze.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case contains a blank line and an integer <strong>n (1 ≤ n ≤ 100)</strong> denoting the number of doors. The next line contains <strong>n</strong> space separated integers. If the <strong>ith</strong> integer <strong>(xi)</strong> is positive, you can assume that the <strong>ith</strong> door will take you out of maze after <strong>xi</strong> minutes. If it’s negative, then the <strong>ith</strong> door will take you back to the beginning position after <strong>abs(xi)</strong> minutes. You can safely assume that <strong>1 ≤ abs(xi) ≤ 10000</strong>.Output</p>
<p>For each case, print the case number and the expected time to get out of the maze. If it’s impossible to get out of the maze, print <strong>‘inf’</strong>. Print the result in <strong>p/q</strong> format. Where <strong>p</strong> is the numerator of the result and <strong>q</strong> is the denominator of the result and they are relatively prime. See the samples for details.Sample Input</p>
<p>3</p>
<p>1</p>
<p>1</p>
<p>2</p>
<p>-10 -3</p>
<p>3</p>
<p>3 -6 -9Sample Output</p>
<p>Case 1: 1/1</p>
<p>Case 2: inf</p>
<p>Case 3: 18/1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    08:25:38
By                : Tpaaaaaa
File_Name         ：A DangerousMazeLightOJ1027.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
//
设dp[0]为在起点处走出迷宫的期望时间
dp[i] 为在第i个门上走出迷宫的期望时间

if(x[i] &gt; 0)    dp[i] = x[i];
else            dp[i] = -x[i] + dp[0];

得到递推公式
dp[0] = 1/n(dp[1] + dp[2] .... dp[n]);
得到
n*dp[0] = dp[1] + dp[2] ... + dp[n]

化简得到
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
int x;
int gcd(int a, int b)
{
    if(b == 0)  return a;
    else        return gcd(b, a % b);

}
int main()
{
    int t, n;
    int left, right;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        left = n;
        right = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;x);
            if(x &lt; 0)
            {
                right -= x;
                left--;
            }
            else
                right += x;
        }
        printf(&quot;Case %d: &quot;, kase);
        if(left == 0)
            printf(&quot;inf\n&quot;);
        else
        {
            int d = gcd(left, right);
            left /= d;
            right /= d;
            printf(&quot;%d/%d\n&quot;, right, left);
        }

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP， 求期望</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1030 Discovering Gold</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1030DiscoveringGold/</url>
    <content><![CDATA[<p>You are in a cave, a long cave! The cave can be represented by a <strong>1 x N</strong> grid. Each cell of the cave can contain any amount of gold.</p>
<p>Initially you are in position <strong>1</strong>. Now each turn you throw a perfect <strong>6</strong> sided dice. If you get <strong>X</strong> in the dice after throwing, you add <strong>X</strong> to your position and collect all the gold from the new position. If your new position is outside the cave, then you keep throwing again until you get a suitable result. When you reach the <strong>Nth</strong> position you stop your journey. Now you are given the information about the cave, you have to find out the <strong>expected</strong> number of gold you can collect using the given procedure.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case contains a blank line and an integer <strong>N (1 ≤ N ≤ 100)</strong> denoting the dimension of the cave. The next line contains <strong>N</strong> space separated integers. The <strong>ith</strong> integer of this line denotes the amount of gold you will get if you come to the <strong>ith</strong> cell. You may safely assume that all the given integers will be non-negative and no integer will be greater than <strong>1000</strong>.Output</p>
<p>For each case, print the case number and the expected number of gold you will collect. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>3</p>
<p>1</p>
<p>101</p>
<p>2</p>
<p>10 3</p>
<p>3</p>
<p>3 6 9Sample Output</p>
<p>Case 1: 101.0000000000</p>
<p>Case 2: 13.000</p>
<p>Case 3: 15</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    08:53:03
By                : Tpaaaaaa
File_Name         ：DiscoveringGoldLightOJ1030.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
int x[MAXN];
double dp[MAXN];
int main()
{
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;x[i]);
        for(int i = n; i &gt;= 1; i--)
        {
            dp[i] = x[i];
            int up = min(i + 6, n);
            for(int j = i + 1; j &lt;= up; j++)
                dp[i] += (1.0/(up - i)) * dp[j];
        }
        printf(&quot;Case %d: %.7f\n&quot;, kase, dp[1]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP求期望</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1038 Race to 1 Again</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1038Raceto1Again/</url>
    <content><![CDATA[<p>Rimi learned a new thing about integers, which is - any positive integer greater than <strong>1</strong> can be divided by its divisors. So, he is now playing with this property. He selects a number <strong>N</strong>. And he calls this <strong>D</strong>.</p>
<p>In each turn he randomly chooses a divisor of <strong>D</strong> <strong>(1 to D)</strong>. Then he divides <strong>D</strong> by the number to obtain new <strong>D</strong>. He repeats this procedure until <strong>D</strong> becomes <strong>1</strong>. What is the expected number of moves required for <strong>N</strong> to become <strong>1</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each case begins with an integer <strong>N (1 ≤ N ≤ 105)</strong>.Output</p>
<p>For each case of input you have to print the case number and the expected value. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>3</p>
<p>1</p>
<p>2</p>
<p>50</p>
<p>Sample Output</p>
<p>Case 1: 0</p>
<p>Case 2: 2.00</p>
<p>Case 3: 3.0333333333</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>也是水题，</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    09:19:13
By                : Tpaaaaaa
File_Name         ：Raceto1AgainLightOJ1038.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int divor[MAXN];
double dp[MAXN];
//返回x的因子数目
//6的正约数有 1, 2, 3, 6 四个
//所以返回4，将正约数保存在divor[1..4]中
int getd(int x)
{
    int sum = 0;
    //也可以枚举素数，求他相除只有
    for(int i = 2; i &lt;= (int)sqrt(x); i++)
        if(x % i == 0)
        {
            sum++;
            divor[sum] = i;
            if(x / i != i)
            {
                sum++;
                divor[sum] = x / i;
            }
        }
    sum++;
    divor[sum] = 1;
    sum++;
    divor[sum] = x;
    return sum;
}
void init()
{
    dp[1] = 0;
    for(int i = 2; i &lt; MAXN; i++)
    {
        int sum = getd(i);
        double right = sum;
        double left = sum - 1;
        for(int i = 1; i &lt;= sum; i++)
            right += dp[divor[i]];
        dp[i] = right / left;
    }
}
int main()
{
    init();
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        printf(&quot;Case %d: %lf\n&quot;, kase, dp[n]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ - 1079 Just another Robbery</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1079JustanotherRobbery/</url>
    <content><![CDATA[<p>As Harry Potter series is over, Harry has no job. Since he wants to make quick money, (he wants everything quick!) so he decided to rob banks. He wants to make a calculated risk, and grab as much money as possible. But his friends - Hermione and Ron have decided upon a tolerable probability <strong>P</strong> of getting caught. They feel that he is safe enough if the banks he robs together give a probability less than <strong>P</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case contains a real number <strong>P</strong>, the probability Harry needs to be below, and an integer <strong>N (0 &lt; N ≤ 100)</strong>, the number of banks he has plans for. Then follow <strong>N</strong> lines, where line <strong>j</strong> gives an integer <strong>Mj (0 &lt; Mj ≤ 100)</strong> and a real number <strong>Pj</strong> . Bank <strong>j</strong> contains <strong>Mj</strong> millions, and the probability of getting caught from robbing it is <strong>Pj</strong>. A bank goes bankrupt if it is robbed, and you may assume that all probabilities are independent as the police have very low funds.Output</p>
<p>For each case, print the case number and the maximum number of millions he can expect to get while the probability of getting caught is less than <strong>P</strong>.Sample Input</p>
<p>3</p>
<p>0.04 3</p>
<p>1 0.02</p>
<p>2 0.03</p>
<p>3 0.05</p>
<p>0.06 3</p>
<p>2 0.03</p>
<p>2 0.03</p>
<p>3 0.05</p>
<p>0.10 3</p>
<p>1 0.03</p>
<p>2 0.02</p>
<p>3 0.05Sample Output</p>
<p>Case 1: 2</p>
<p>Case 2: 4</p>
<p>Case 3: 6Note</p>
<p>For the first case, if he wants to rob bank 1 and 2, then the probability of getting caught is <strong>0.02 + (1 - 0.02) * .03 = 0.0494</strong> which is greater than the given probability <strong>(0.04)</strong>. That’s why he has only option, just to rob rank 2.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>本质是01背包。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    10:00:11
By                : Tpaaaaaa
File_Name         ：JustanotherRobberyLightOJ1079.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

01背包
dp[i][j] 表示考虑前i个银行，抢j元没被抓的概率

dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - m[i]]*(1 - p[i]));

答案为dp[i][M...1]中M最大的，且dp[i][]大于1-P的

初始状态dp[0][?] = 1;
dp[1][]
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXM = 1010;
double dp[MAXN][MAXM], p[MAXN];
int m[MAXN]; ;
int main()
{
    int t, n;
    double P;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        int sum = 0;
        scanf(&quot;%lf%d&quot;, &amp;P, &amp;n);
        P = 1 - P;
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d %lf&quot;, &amp;m[i], &amp;p[i]);
            sum += m[i];
        }
        memset(dp, 0, sizeof dp);
        dp[0][0] = 1;
        for(int i = 1; i &lt;= n; i++)
        {
            for(int j = sum; j &gt;= 0; j--)
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - m[i]] * (1 - p[i]));
        }
        int i;
        for(i = sum; i &gt;= 0; i--)
            if(dp[n][i] &gt;= P)
                break;
        printf(&quot;Case %d: %d\n&quot;, kase, i);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>01背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1104 Birthday Paradox</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1104BirthdayParadox/</url>
    <content><![CDATA[<p>Sometimes some mathematical results are hard to believe. One of the common problems is the birthday paradox. Suppose you are in a party where there are <strong>23</strong> people including you. What is the probability that at least two people in the party have same birthday? Surprisingly the result is more than <strong>0.5</strong>. Now here you have to do the opposite. You have given the number of days in a year. Remember that you can be in a different planet, for example, in Mars, a year is <strong>669</strong> days long. You have to find the minimum number of people you have to invite in a party such that the probability of at least two people in the party have same birthday is at least <strong>0.5</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20000)**, denoting the number of test cases.</p>
<p>Each case contains an integer <strong>n (1 ≤ n ≤ 105)</strong> in a single line, denoting the number of days in a year in the planet.Output</p>
<p>For each case, print the case number and the desired result.Sample Input</p>
<p>2</p>
<p>365</p>
<p>669</p>
<p>Sample Output</p>
<p>Case 1: 22</p>
<p>Case 2: 30</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    10:25:59
By                : Tpaaaaaa
File_Name         ：BirthdayParadoxLightOJ1104.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;

int main()
{
    int t, n;
    double p;   //p为不在同一天生日的概率， 当1 - p 大于 1/2时.
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        p = 1;
        int i;
        for(i = 2; ; i++)
        {
            p = p * ((n - i + 1)*1.0 / n);
            if(1 - p &gt;= 0.5)
                break;
        }
        printf(&quot;Case %d: %d\n&quot;, kase, i - 1);
    }
    return 0;
}</code></pre><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题。</p>
]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ - 1248 Dice (III)</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1248Dice(III)/</url>
    <content><![CDATA[<p>Given a dice with <strong>n</strong> sides, you have to find the expected number of times you have to throw that dice to see all its faces at least once. Assume that the dice is fair, that means when you throw the dice, the probability of occurring any face is equal.</p>
<p>For example, for a fair two sided coin, the result is 3. Because when you first throw the coin, you will definitely see a new face. If you throw the coin again, the chance of getting the opposite side is 0.5, and the chance of getting the same side is 0.5. So, the result is</p>
<p>1 + (1 + 0.5 * (1 + 0.5 * …))</p>
<p>= 2 + 0.5 + 0.52 + 0.53 + …</p>
<p>= 2 + 1 = 3Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing an integer <strong>n (1 ≤ n ≤ 105)</strong>.Output</p>
<p>For each case, print the case number and the expected number of times you have to throw the dice to see all its faces at least once. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>5</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>6</p>
<p>100</p>
<p>Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 3</p>
<p>Case 3: 5.5</p>
<p>Case 4: 14.7</p>
<p>Case 5: 518.7377517640</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    12:51:32
By                : Tpaaaaaa
File_Name         ：Dice(III)LightOJ-1248.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
double dp;
int main()
{
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        dp = 0;
        for(int i = n - 1; i &gt;= 0; i--)
            dp = dp + n * 1.0 / (n - i);
        printf(&quot;Case %d: %.7f\n&quot;, kase, dp);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1151 Snakes and Ladders</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1151SnakesandLadders/</url>
    <content><![CDATA[<p><strong>‘Snakes and Ladders’</strong> or <strong>‘Shap-Ludu’</strong> is a game commonly played in Bangladesh. The game is so common that it would be tough to find a person who hasn’t played it. But those who haven’t played it (unlucky of course!) the rules are as follows.</p>
<p><img src="https://vj.z180.cn/dd2c24784595e0af1970b1361ea5ce20?v=1570737468" alt=""></p>
<ol>
<li><p>There is a <strong>10 x 10</strong> board containing some cells numbered from <strong>1</strong> to <strong>100</strong>.</p>
</li>
<li><p>You start at position 1.</p>
</li>
<li><p>Each time you throw a perfect dice containing numbers <strong>1</strong> to <strong>6</strong>.</p>
</li>
<li><p>There are some snakes and some ladders in the board. Ladders will take you up from one cell to another. Snakes will take you down.</p>
</li>
<li><p>If you reach a cell that contains the bottom part of a ladder, you will immediately move to the cell which contains the upper side of that ladder. Similarly if you reach a cell that has a snake-head you immediately go down to the cell where the tail of that snake ends.</p>
</li>
<li><p>The board is designed so that from any cell you can jump at most once. (For example there is a snake from 62 to 19, assume that another is from 19 to 2. So, if you reach 62, you will first jump to 19, you will jump to 2. These kinds of cases will not be given)</p>
</li>
<li><p>There is no snake head in the 100-th cell and no ladder (bottom part) in the first cell.</p>
</li>
<li><p>If you reach cell 100, the game ends. But if you have to go outside the board in any time your move will be lost. That means you will not take that move and you have to throw the dice again.</p>
</li>
</ol>
<p>Now given a board, you have to find the expected number of times you need to throw the dice to win the game. The cases will be given such that a result will be found.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 105)**, denoting the number of test cases.</p>
<p>The first line of a case is a blank line. The next line gives you an integer <strong>n</strong> denoting the number of snakes and ladders. Each of the next <strong>n</strong> lines contain two integers <strong>a</strong> and <strong>b (1 ≤ a, b ≤ 100, a ≠ b)</strong>. If <strong>a &lt; b</strong>, it means that there is a ladder which takes you from <strong>a</strong> to <strong>b</strong>. If <strong>a &gt; b</strong>, it means that there is a snake which takes you from <strong>a</strong> to <strong>b</strong>. Assume that the given board follows the above restrictions.Output</p>
<p>For each case of input, print the case number and the expected number of times you need to throw the dice. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>2</p>
<p>14</p>
<p>4 42</p>
<p>9 30</p>
<p>16 8</p>
<p>14 77</p>
<p>32 12</p>
<p>37 58</p>
<p>47 26</p>
<p>48 73</p>
<p>62 19</p>
<p>70 89</p>
<p>71 67</p>
<p>80 98</p>
<p>87 24</p>
<p>96 76</p>
<p>0Sample Output</p>
<p>Case 1: 31.54880806</p>
<p>Case 2: 33.0476190476</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们一般逆推是不会出现环的…但这题目出现了，就解锁了新知识——用高斯消元法解。</p>
<p>自己好好构造好增广矩阵，然后再在模板里面改改就行。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    10:53:41
By                : Tpaaaaaa
File_Name         ：SnakesandLaddersLightOJ1151.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
概率dp + 高斯消元法
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
int tp[MAXN];
double x[MAXN];
double a[MAXN][MAXN];          //增广矩阵
inline int gcd(int a,int b)
{
    int t;
    while(b!=0)
    {
        t=b;
        b=a%b;
        a=t;
    }
    return a;
}
inline int lcm(int a,int b)
{
    return a/gcd(a,b)*b;//先除后乘防溢出
}

int Gauss(int equ,int var)
{
    int i,j,k;
    int max_r;// 当前这列绝对值最大的行.
    int col;//当前处理的列
    int ta,tb;
    int LCM;
    double temp;
    int free_x_num;
    int free_index;

    for(int i=0;i&lt;=var;i++)
    {
        x[i]=0;
    }

    //转换为阶梯阵.
    col=0; // 当前处理的列
    for(k = 0;k &lt; equ &amp;&amp; col &lt; var;k++,col++)
    {// 枚举当前处理的行.
// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(abs(a[i][col])&gt;abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k)
        {// 与第k行交换.
            for(j=k;j&lt;var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(fabs(a[k][col]) &lt; eps)
        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--;
            continue;
        }
        for(i=k+1;i&lt;equ;i++)
        {// 枚举要删去的行.
            if(fabs(a[i][col]) &gt; eps)
            {
                double temp = a[i][col] / a[k][col];
                for(int j = col; j &lt;= var; j++)
                    a[i][j] -= a[k][j] * temp;
            }
        }
    }
    for (i = var - 1; i &gt;= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j &lt; var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        x[i] = temp / a[i][i];
    }
    return 0;
}
int main()
{
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(tp, 0, sizeof tp);
        memset(a, 0, sizeof a);
        scanf(&quot;%d&quot; ,&amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            tp[a] = b;
        }
        //100个方程
        for(int i = 0; i &lt; 99; i++)
        {
            if(tp[i + 1]) // 有tp
            {
                a[i][i] = 1;
                a[i][tp[i + 1] - 1] = -1;
                a[i][100] = 0;
            }   
            else        //没有tp
            {
                int k = 100 - i - 1;
                //说明2
                if(k &gt; 6)
                {
                    a[i][i] = 6;
                    a[i][100] = 6;
                    for(int j = 1; j &lt;= 6; j++)
                        a[i][i + j] = -1;
                }
                else//说明3，只能扔1,2,...,k, 余下的6 - k 为dp[i]
                {
                    a[i][i] = k;
                    a[i][100] = 6;
                    for(int j = 1; j &lt;= k; j++)
                        a[i][i + j] = -1;
                }
            }
        }
        a[99][100] = 0;
        a[99][99] = 1;
        int free_num = Gauss(100, 100);
        printf(&quot;Case %d: %.7f\n&quot;,kase, x[0]);
    }   
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>出现环的概率DP，高斯消元法</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1317 Throwing Balls into the Baskets</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1317ThrowingBallsintotheBaskets/</url>
    <content><![CDATA[<p>You probably have played the game “<strong>Throwing Balls into the Basket</strong>“. It is a simple game. You have to throw a ball into a basket from a certain distance. One day we (the AIUB ACMMER) were playing the game. But it was slightly different from the main game. In our game we were <strong>N</strong> people trying to throw balls into <strong>M *<em>identical Baskets. At each turn we all were selecting a basket and trying to throw a ball into it. After the game we saw exactly *</em>S</strong> balls were successful. Now you will be given the value of <strong>N *<em>and *</em>M</strong>. For each player probability of throwing a ball into any basket successfully is <strong>P</strong>. Assume that there are infinitely many balls and the probability of choosing a basket by any player is *<em>1/M. *</em>If multiple people choose a common basket and throw their ball, you can assume that their balls will not conflict, and the probability remains same for getting inside a basket. You have to find the expected number of balls entered into the baskets after *<em>K *</em>turns.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing three integers <strong>N (1 ≤ N ≤ 16), M (1 ≤ M ≤ 100) **and</strong> K (0 ≤ K ≤ 100)** and a real number <strong>P (0 **</strong>≤<strong>** P **</strong>≤ 1<strong>**)</strong>. <strong>P</strong> contains at most three places after the decimal point.Output</p>
<p>For each case, print the case number and the expected number of balls. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>2</p>
<p>1 1 1 0.5</p>
<p>1 1 2 0.5</p>
<p>Sample Output</p>
<p>Case 1: 0.5</p>
<p>Case 2: 1.000000</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>憨憨题目。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    17:54:19
By                : Tpaaaaaa
File_Name         ：ThrowingBallsintotheBasketsLightOJ1317.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
憨批水题.
但是帮你理清了一下期望和概率的关系
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;

int main()
{
    int t, n, m, k;
    double p;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d%d%d%lf&quot;, &amp;n, &amp;m, &amp;k, &amp;p);
        printf(&quot;Case %d: %.7f\n&quot;, kase, n * p * k);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1364 Expected Cards</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1364ExpectedCards/</url>
    <content><![CDATA[<p>Taha has got a standard deck of cards with him. In addition to the 52 regular ones, there are 2 joker cards. Every regular card has a rank and a suit. The ranks in ascending order are: <strong>A, 2, 3, 4, 5, 6, 7, 8, 9, T, J, Q</strong> and <strong>K</strong>. The suit of a card can be <strong>clubs, diamonds, hearts</strong> or <strong>spades</strong>. That means there are 13 <strong>clubs</strong>, 13 <strong>diamonds</strong>, 13 <strong>hearts</strong> and 13 <strong>spades</strong> - which adds up to 52. The joker cards have no ranks or suits.</p>
<p>One day, Sara gave Taha a challenge. First she randomly shuffles the 54 cards and starts placing one card after another, face-up, on a table. What is the expected number of cards Sara has to place so that there are at least <strong>C</strong> <strong>clubs</strong>, <strong>D</strong> <strong>diamonds,</strong> <strong>H</strong> <strong>hearts</strong> and <strong>S</strong> <strong>spades</strong> on the table? Whenever a joker card is encountered, Taha has to assign it to some suit so that the expected number of cards to reach the goal is minimized. The decision of assigning the joker card to some suit has to be made instantly (i.e. before Sara puts the next card on the table). Note that the assignments of the two joker cards don’t necessarily need to be the same.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing four integers in the order <strong>C</strong>, <strong>D</strong>, <strong>H</strong> and <strong>S</strong>. Each of these integers will be in the range <strong>[0, 15]</strong>.Output</p>
<p>For each case, print the case number first. Then output the expected number of cards Sara needs to place on the table to achieve the goal. If it’s impossible to reach the goal, irrespective of what assignments Sara opts for, output <strong>‘-1’</strong> (without the quotes) instead. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>4</p>
<p>0 0 0 0</p>
<p>15 13 13 13</p>
<p>1 2 3 4</p>
<p>15 15 15 15</p>
<p>Sample Output</p>
<p>Case 1: 0</p>
<p>Case 2: 54</p>
<p>Case 3: 16.3928186102</p>
<p>Case 4: -1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>求期望一般逆推。所以可以结合记忆化搜索，将逆推的已知项变成搜索的递归终点即可.</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    19:09:18
By                : Tpaaaaaa
File_Name         ：ExpectedCardsLightOJ-1364.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
好恶心呀
配合记忆化搜索.
搜索的边界dp[C][D][H][S][0][0] = 0;
dp[C - 1][D][H][S][1][0] = 0.....等等情况
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
double dp[20][20][20][20][5][5];
bool vis[20][20][20][20][5][5];
int exs[5];
int C, D, H, S;
bool Noway()
{
    int num = 0;            //记录需要的joker的数目，如果超过2两个，-1
    if(C &gt; 13)  num += C - 13;
    if(D &gt; 13)  num += D - 13;
    if(H &gt; 13)  num += H - 13;
    if(S &gt; 13)  num += S - 13;
    if(num &gt; 2) return true;
    return false;
}
double dfs(int a, int b, int c, int d, int i, int j)
{
    if(vis[a][b][c][d][i][j])   return dp[a][b][c][d][i][j];
    vis[a][b][c][d][i][j] = true;
    int ret = 52 - a - b - c - d;   //ret表示剩余的牌的数目
    if(!i)  ret++; if(!j) ret++;    //joker还留着的情况
    exs[1] = a; exs[2] = b; exs[3] = c; exs[4] = d; //四个花色的已经存在的数目
    exs[i]++; exs[j]++;
    if(exs[1] &gt;= C &amp;&amp; exs[2] &gt;= D &amp;&amp; exs[3] &gt;= H &amp;&amp; exs[4] &gt;= S)
        return dp[a][b][c][d][i][j] = 0;
    //递归出口设置完了
    double p[5];    //选中四个花色的概率
    double ans = 1;
    p[1] = (13 - a) * 1.0 / ret; p[2] = (13 - b) * 1.0 / ret;
    p[3] = (13 - c) * 1.0 / ret; p[4] = (13 - d) * 1.0 / ret;
    if(13 - a &gt; 0)
    ans += p[1] * dfs(a + 1, b, c, d, i, j);
    if(13 - b &gt; 0)
    ans += p[2] * dfs(a, b + 1, c, d, i, j);
    if(13 - c &gt; 0)
    ans += p[3] * dfs(a, b, c + 1, d, i, j);
    if(13 - d &gt; 0)
    ans += p[4] * dfs(a, b, c, d + 1, i, j);
    //抽中四个花色的期望，接下来是抽中两个joker
    if(i == 0)
    {
        double temp = (double)INF;
        for(int k = 1; k &lt;= 4; k++)
            temp = min(temp, dfs(a, b, c, d, k, j));
        ans += temp * 1.0 / ret;
    }
    if(j == 0)
    {
        double temp = (double)INF;
        for(int k = 1; k &lt;= 4; k++)
            temp = min(temp, dfs(a, b, c, d, i, k));
        ans += temp * 1.0 / ret;
    }
    return dp[a][b][c][d][i][j] = ans;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(vis, false, sizeof vis);
        scanf(&quot;%d%d%d%d&quot;, &amp;C, &amp;D, &amp;H, &amp;S);
        if(Noway())                         //根据初始条件判断有没有解
            printf(&quot;Case %d: -1\n&quot;, kase);
        else
        {
            double ans = dfs(0, 0, 0, 0, 0, 0);
            printf(&quot;Case %d: %.7f\n&quot;, kase, ans);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP求期望</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1284 Lights inside 3D Grid</title>
    <url>/tpaaaaaa.github.io/2019/10/12/LightOJ-1284Lightsinside3DGrid/</url>
    <content><![CDATA[<p>You are given a 3D grid, which has dimensions <strong>X</strong>, <strong>Y</strong> and <strong>Z</strong>. Each of the <strong>X x Y x Z</strong> cells contains a light. Initially all lights are off. You will have <strong>K</strong> turns. In each of the <strong>K</strong> turns,</p>
<ol>
<li><p>You select a cell <strong>A</strong> randomly from the grid,</p>
</li>
<li><p>You select a cell <strong>B</strong> randomly from the grid and</p>
</li>
<li><p>Toggle the states of all the bulbs bounded by cell <strong>A</strong> and cell <strong>B</strong>, i.e. make all the ON lights OFF and make all the OFF lights ON which are bounded by <strong>A</strong> and <strong>B</strong>. To be clear, consider cell <strong>A</strong> is <strong>(x1, y1, z1)</strong> and cell <strong>B</strong> is <strong>(x2, y2, z2)</strong>. Then you have to toggle all the bulbs in grid cell<strong>(x, y, z)</strong> where <strong>min(x1, x2) ≤ x ≤ max(x1, x2)</strong>, <strong>min(y1, y2) ≤ y ≤ max(y1, y2)</strong> and <strong>min(z1, z2) ≤ z ≤ max(z1, z2)</strong>.</p>
</li>
</ol>
<p>Your task is to find the expected number of lights to be ON after <strong>K</strong> turns.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 50)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing four integers <strong>X, Y, Z (1 ≤ X, Y, Z ≤ 100)</strong> and <strong>K (0 ≤ K ≤ 10000)</strong>.Output</p>
<p>For each case, print the case number and the expected number of lights that are ON after <strong>K</strong> turns. Errors less than <strong>10-6</strong> will be ignored.Sample Input</p>
<p>5</p>
<p>1 2 3 5</p>
<p>1 1 1 1</p>
<p>1 2 3 0</p>
<p>2 3 4 1</p>
<p>2 3 4 2Sample Output</p>
<p>Case 1: 2.9998713992</p>
<p>Case 2: 1</p>
<p>Case 3: 0</p>
<p>Case 4: 6.375</p>
<p>Case 5: 9.09765625</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>其实概率DP，DP才是主要的，概率只是个类型罢了。所以我们要用常规的DP思路的思考题目。</p>
<p><strong>还有就是</strong></p>
<p><strong>如果每个点只有两个状态（0 或 1， 选中 或 不选中， 开 或 关），那么这个点给全局的期望贡献等于他是1的概率。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-12    16:59:25
By                : Tpaaaaaa
File_Name         ：Lightsinside3DGridLightOJ1284.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

这题目实际上是两个概率
第一个概率问的是，每个点被选中的概率
这个容易计算, 我们将每个的坐标分为三部分来考虑
如果x坐标满足的概率为Px，y坐标满足选中的概率是Py，z坐标满足选中的概率是Pz
所以整个点被选中的概率是Px*Py*Pz;
那么对于某个一维坐标，他被选中的概率是
1 - 他没被选中的概率
他没被选中的情况就是A，B两点的坐标在他的同一侧，同左侧or同右侧
假如一维坐标有X个点，目前的位置为第i个点
那么它左边有i - 1个点，他右边有X - i个点
所以不被选中的概率是((i - 1)*(i - 1) + (X - i)*(X - i))/X*X 
1 减去他就得到选中的概率
Px*Py*Pz就是空间里面某个点被选中的概率

对于每个点，在k次翻转的操作下，从 OFF 变成 ON 需要被选中奇数次
这就是一个概率DP了
dp[x][y][z][i] 表示翻转了i次下，(x, y, z)被选中为奇数次的概率
则得到递推式
dp[x][y][z][i] = P[x][y][z]*(1 - dp[x][y][z][i - 1]) + (1 - p[x][y][z])*(dp[x][y][z][i - 1]);
他这选中奇数次的概率乘上状态1就是期望了
那么整个的期望就是所有的点的期望之和

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 233;
int X, Y, Z, K;
//(i - 1)*(i - 1) + (X - i)*(X - i))/X*X 
//返回的是被选中的概率
double getP(int x, int y, int z)
{
    double px = 1 - ((x - 1) * (x - 1) + (X - x) * (X - x)) * 1.0/(X * X);
    double py = 1 - ((y - 1) * (y - 1) + (Y - y) * (Y - y)) * 1.0/(Y * Y);
    double pz = 1 - ((z - 1) * (z - 1) + (Z - z) * (Z - z)) * 1.0/(Z * Z);
    return px * py * pz;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        double ans = 0;
        double dp;
        scanf(&quot;%d%d%d%d&quot;, &amp;X, &amp;Y, &amp;Z, &amp;K);
        for(int x = 1; x &lt;= X; x++)
            for(int y = 1; y &lt;= Y; y++)
                for(int z = 1; z &lt;= Z; z++)
                {
                    dp = 0;
                    double p = getP(x, y, z);
                    dp = (1 - pow(1 - 2 * p, K)) * 1.0 / (2 * 1);
                    ans += dp;
                }

        printf(&quot;Case %d: %.7f\n&quot;, kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>SGU 495 Kids and Prizes</title>
    <url>/tpaaaaaa.github.io/2019/10/11/SGU495KidsandPrizes/</url>
    <content><![CDATA[<h4 id="495-Kids-and-Prizes"><a href="#495-Kids-and-Prizes" class="headerlink" title="495. Kids and Prizes"></a>495. Kids and Prizes</h4><p>Time limit per test: 0.5 second(s)<br>Memory limit: 262144 kilobytesinput: standard<br>output: standard</p>
<p>ICPC (International Cardboard Producing Company) is in the business of producing cardboard boxes. Recently the company organized a contest for kids for the best design of a cardboard box and selected <em>M</em> winners. There are <em>N</em>prizes for the winners, each one carefully packed in a cardboard box (made by the ICPC, of course). The awarding process will be as follows:</p>
<ul>
<li>All the boxes with prizes will be stored in a separate room.</li>
<li>The winners will enter the room, one at a time.</li>
<li>Each winner selects one of the boxes.</li>
<li>The selected box is opened by a representative of the organizing committee.</li>
<li>If the box contains a prize, the winner takes it.</li>
<li>If the box is empty (because the same box has already been selected by one or more previous winners), the winner will instead get a certificate printed on a sheet of excellent cardboard (made by ICPC, of course).</li>
<li>Whether there is a prize or not, the box is re-sealed and returned to the room.</li>
</ul>
<p>The management of the company would like to know how many prizes will be given by the above process. It is assumed that each winner picks a box at random and that all boxes are equally likely to be picked. Compute the mathematical expectation of the number of prizes given (the certificates are not counted as prizes, of course).  </p>
<p><strong>Input</strong></p>
<p><img src="http://acm.sgu.ru/temp/cache/e80fa1c6a70d6d03c3786e561ddbbeb6.png" alt=""></p>
<p>The first and only line of the input file contains the values of <em>N</em> and <em>M</em> ().  </p>
<p><strong>Output</strong></p>
<p>The first and only line of the output file should contain a single real number: the expected number of prizes given out. The answer is accepted as correct if either the absolute or the relative error is less than or equal to 10-9.  </p>
<p><strong>Example(s)</strong></p>
<p>sample input</p>
<p>sample output</p>
<p>5 7</p>
<p>3.951424</p>
<p>sample input</p>
<p>sample output</p>
<p>4 3</p>
<p>2.3125</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>概率DP。两种思路</p>
<p><strong>第一种思路</strong>：</p>
<p>我们对礼物进行分析, 每个礼物被选中的概率是1 / n</p>
<p>所以不被选中的概率是 （n - 1) / n</p>
<p>所以m个礼物都没有被选中的概率是 [(n - 1) / n] ^ m;</p>
<p>即没有被选中的礼物的期望数是 n * [ (n - 1)/n] ^ m;</p>
<p>则期望选中的数目就是 n - 上面的式子</p>
<p><strong>第二个思路：</strong></p>
<p>dp[i]为第i个人得到礼物的<strong>概率，也就是得到礼物的期望</strong>嘛，所以m个人得到礼物的期望数就是m个人期望的总和，所以我们首先求出所有的人各自的期望（概率）</p>
<p>得到递推式：</p>
<p>dp[i] = (1 - dp[i - 1])*dp[i - 1] + dp[i - 1] * (dp[i - 1] - 1.0/n);</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ3744 Scout YYF I</title>
    <url>/tpaaaaaa.github.io/2019/10/11/POJ3744ScoutYYFI/</url>
    <content><![CDATA[<p>Scout YYF I</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 11663</p>
<p><strong>Accepted:</strong> 3418</p>
<p>DescriptionYYF is a couragous scout. Now he is on a dangerous mission which is to penetrate into the enemy’s base. After overcoming a series difficulties, YYF is now at the start of enemy’s famous “mine road”. This is a very long road, on which there are numbers of mines. At first, YYF is at step one. For each step after that, YYF will walk one step with a probability of <em>p</em>, or jump two step with a probality of 1-<em>p</em>. Here is the task, given the place of each mine, please calculate the probality that YYF can go through the “mine road” safely.</p>
<p>InputThe input contains many test cases ended with <strong>EOF</strong>.<br>Each test case contains two lines.<br>The First line of each test case is <em>N</em> (1 ≤ <em>N</em> ≤ 10) and <em>p</em> (0.25 ≤ <em>p</em> ≤ 0.75) seperated by a single blank, standing for the number of mines and the probability to walk one step.<br>The Second line of each test case is N integer standing for the place of N mines. Each integer is in the range of [1, 100000000].</p>
<p>OutputFor each test case, output the probabilty in a single line with the precision to 7 digits after the decimal point.</p>
<p>Sample Input</p>
<p>1 0.5<br>2<br>2 0.5<br>2 4</p>
<p>Sample Output</p>
<p>0.5000000<br>0.2500000</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>概率DP入门题，配合矩阵加速。</p>
<p><strong>关于概率DP</strong></p>
<p>一般而言，<strong>求概率是递推，求期望是逆推。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-11    15:23:12
By                : Tpaaaaaa
File_Name         ：ScoutYYFIPOJ3744.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 20;
int a[MAXN];
double p;
int n;
struct Matrix
{
    int r,c;
    double m[2][2];
};
//矩阵乘法 
Matrix multiply(Matrix a,Matrix b)
{
    Matrix res;
    res.r=a.r;
    res.c=b.c;
    for(int i=0;i&lt;res.r;++i){
        for(int j=0;j&lt;res.c;++j){
            res.m[i][j]=0;
            for(int k=0;k&lt;a.c;++k)
                res.m[i][j]+=a.m[i][k]*b.m[k][j];
        }
    }
    return res;
}
//矩阵幂
Matrix myPow(Matrix a,int n)
{
    if(n==0){
        a.m[0][0]=a.m[1][1]=1;
        a.m[0][1]=a.m[1][0]=0;
        return a;
    }else{
        Matrix res=myPow(a,n&gt;&gt;1);
        res=multiply(res,res);
        if(n&amp;1)
            res=multiply(res,a);
        return res;
    }
}

double solve()
{
    Matrix mat;
    mat.r = mat.c = 2;
    mat.m[0][0] = p;
    mat.m[0][1] = 1 - p;
    mat.m[1][0] = 1;
    mat.m[1][1] = 0;
    Matrix temp = myPow(mat, a[1] - 1);     //矩阵快速幂
    double ans = 1 - temp.m[0][0];
    for(int i = 2; i &lt;= n; i++)
    {
        if(a[i] == a[i - 1])    continue;   //两颗一起
        temp = myPow(mat, a[i] - a[i - 1] - 1);
        ans *= (1 - temp.m[0][0]);
    }
    return ans;
}
int main()
{
    while(scanf(&quot;%d %lf&quot;, &amp;n, &amp;p) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);     //地雷的下标
        //dp[i] 表示到第i个格子安全的概率（i处无地雷）
        //dp[i] = dp[i - 1] * p + dp[i - 2] * (1 - p);
        //dp[i] == 0 (i处有地雷)
        sort(a + 1, a + 1 + n);
        printf(&quot;%.7lf\n&quot;, solve());
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>概率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[专题]SHU训练一——图论一</title>
    <url>/tpaaaaaa.github.io/2019/10/09/%5B%E4%B8%93%E9%A2%98%5DSHU%E8%AE%AD%E7%BB%83%E4%B8%80%E2%80%94%E2%80%94%E5%9B%BE%E8%AE%BA%E4%B8%80/</url>
    <content><![CDATA[<p>这题集里面多是模板题.有保留价值 <strong>:)</strong></p>
<ol>
<li><a href="https://vjudge.net/problem/LightOJ-1251" target="_blank" rel="noopener"><strong>LightOJ 1251</strong></a> Forming the Council （2-SAT问题）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1026" target="_blank" rel="noopener"><strong>LightOJ 1026</strong></a> Critical Links （求割边问题）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1063" target="_blank" rel="noopener"><strong>LightOJ 1063</strong></a> Ant Hills（求割点问题）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1291" target="_blank" rel="noopener"><strong>LightOJ 1291</strong></a> Real Life Traffic （边双连通）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1308" target="_blank" rel="noopener"><strong>LightOJ 1308</strong></a> Ant Network （点双连通）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1074" target="_blank" rel="noopener"><strong>LightOJ 1074</strong></a> Extended Traffic (SPFA求负环 )</li>
<li><a href="https://vjudge.net/problem/LightOJ-1108" target="_blank" rel="noopener"><strong>LightOJ 1108</strong></a> Instant View of Big Bang (SPFA 求负环)</li>
<li><a href="https://vjudge.net/problem/LightOJ-1221" target="_blank" rel="noopener"><strong>LightOJ 1221</strong></a> Travel Company （比率环，SPFA）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1002" target="_blank" rel="noopener"><strong>LightOJ 1002</strong></a> Country Roads （Dijkstral求最小瓶颈树）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1029" target="_blank" rel="noopener"><strong>LightOJ 1029</strong></a> Civil and Evil Engineer（Kruskal求生成树）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1040" target="_blank" rel="noopener"><strong>LightOJ 1040</strong></a> Donation （最小生成树）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1041" target="_blank" rel="noopener"><strong>LightOJ 1041</strong></a> Road Construction</li>
<li><a href="https://vjudge.net/problem/LightOJ-1059" target="_blank" rel="noopener"><strong>LightOJ 1059</strong></a> Air Ports</li>
<li><a href="https://vjudge.net/problem/LightOJ-1123" target="_blank" rel="noopener"><strong>LightOJ 1123</strong></a> Trail Maintenance</li>
<li><a href="https://vjudge.net/problem/LightOJ-1124" target="_blank" rel="noopener"><strong>LightOJ 1124</strong></a> Cricket Ranking</li>
<li><a href="https://vjudge.net/problem/LightOJ-1380" target="_blank" rel="noopener"><strong>LightOJ 1380</strong></a> Teleport</li>
<li><a href="https://vjudge.net/problem/LightOJ-1384" target="_blank" rel="noopener"><strong>LightOJ 1384</strong></a> Stream My Contest</li>
<li><a href="https://vjudge.net/problem/LightOJ-1348" target="_blank" rel="noopener"><strong>LightOJ 1348</strong></a> Aladdin and the Return Journey</li>
<li><a href="https://vjudge.net/problem/LightOJ-1250" target="_blank" rel="noopener"><strong>LightOJ 1250</strong></a> Village Postman</li>
<li><a href="https://vjudge.net/problem/LightOJ-1256" target="_blank" rel="noopener"><strong>LightOJ 1256</strong></a> Word Puzzle（欧拉回路）</li>
<li><a href="https://vjudge.net/problem/LightOJ-1003" target="_blank" rel="noopener"><strong>LightOJ 1003</strong></a> Drunk (拓扑排序判断环)</li>
</ol>
<p>逐题：</p>
<ol>
<li><a href="https://vjudge.net/problem/LightOJ-1251" target="_blank" rel="noopener"><strong>LightOJ 1251</strong></a> Forming the Council</li>
</ol>
<p>In a city there are <strong>n</strong> voters, and <strong>m</strong> people formed the Govt. council. The council members are numbered from <strong>1</strong> to <strong>m</strong>. Now everyone is complaining that the council is biased. So, they made a plan. The plan is that the voters are given a chance to vote again to form the new council. A vote will be like <strong>±i ±j</strong>.** ‘+’** means the voter wants that member to be in the council, ‘<strong>-</strong>‘ means the voter doesn’t want the member to be in the council. For example, there are 4 voters, they voted like</p>
<p>*<em>+1 -3    *</em>the voter wants member 1 to be kept in the council or member 3 to be thrown out</p>
<p>*<em>+2 +3  *</em>the voter wants member 2 to be kept in the council or member 3 to be kept in the council</p>
<p>*<em>-1 -2     *</em>the voter wants member 1 to be thrown out or member 2 to be thrown out</p>
<p>*<em>-4 +1    *</em>the voter wants member 4 to be thrown out or member 1 to be kept in the council</p>
<p>A voter will be satisfied if at least one of his wishes becomes true. Now your task is to form the council such that all the voters are happy.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing two integers <strong>n (1 ≤ n ≤ 20000)</strong> and <strong>m (1 ≤ m ≤ 8000)</strong>. Each of the next <strong>n</strong> lines contains a vote in the form <strong>±i ±j (1 ≤ i, j ≤ m)</strong>.Output</p>
<p>For each case, print the case number and <strong>‘Yes’</strong> if a solution exists, or <strong>‘No’</strong> if there is no solution. Then if the result is yes, print another line containing the number of members in the council followed by the members in ascending order. And print a single space between two numbers. There can be many solutions. Any valid one will do.Sample Input</p>
<p>3</p>
<p>4 3</p>
<p>+1 +3</p>
<p>+2 -1</p>
<p>+2 -3</p>
<p>-1 -2</p>
<p>4 2</p>
<p>+1 -2</p>
<p>+1 +2</p>
<p>-1 -2</p>
<p>-1 +2</p>
<p>1 3</p>
<p>+1 -3Sample Output</p>
<p>Case 1: Yes</p>
<p>2 2 3</p>
<p>Case 2: No</p>
<p>Case 3: Yes</p>
<p>0</p>
<p>Note</p>
<p>This is a special judge problem. Wrong output format may cause wrong answer</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>将一个点分成两个状态.变成2-SAT问题</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e4 + 10;
const int MAXM = 8e3 + 10;
int cnt, head[2 * MAXM], dfsSum, ans[2 * MAXM];
bool mark[MAXM * 2];
struct Edge
{
    int v, next;
}edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int oth(int a)
{
    if(a % 2)   return a + 1;
    else        return a - 1;
}
void init()
{
    memset(head, -1, sizeof head);
    cnt = 0;
}
bool dfs(int u)
{
    if(mark[oth(u)]) return false;
    if(mark[u])     return true;
    mark[u] = true;
    ans[++dfsSum] = u;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false) return false;
    }
    return true;
}
bool solve(int m)
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2 * m; i += 2)
        if(mark[i] == false &amp;&amp; mark[i + 1] == false)
        {
            dfsSum = 0;
            if(dfs(i) == false)
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;
                if(dfs(oth(i)) == false)
                    return false;
            }
        }
    return true;
}

int main()
{
    int t, n, m, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= n; i++)
        {
            int a, b;
            scanf(&quot;%d %d&quot;, &amp;a, &amp;b);
            if(a &gt; 0)   a = 2 * a;
            if(b &gt; 0)   b = 2 * b;
            if(a &lt; 0)   a = - 1 - 2 * a;
            if(b &lt; 0)   b = - 1 - 2 * b;
            addEdge(oth(a), b);
            addEdge(oth(b), a);
        }
        printf(&quot;Case %d: &quot;, ++kase);
        if(solve(m))
        {
            printf(&quot;Yes\n&quot;);
            int sum = 0;
            for(int i = 1; i &lt;= 2 * m; i += 2)
                if(mark[i + 1]) sum+
            printf(&quot;%d&quot;, sum);
            for(int i = 1; i &lt;= 2 * m; i += 2)
                if(mark[i + 1])
                    printf(&quot; %d&quot;, (i + 1) / 2);
            printf(&quot;\n&quot;);
        }
        else
            printf(&quot;No\n&quot;);
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1026" target="_blank" rel="noopener"><strong>LightOJ 1026</strong></a> Critical Links</p>
<p>In a computer network a link <strong>L</strong>, which interconnects two servers, is considered critical if there are at least two servers <strong>A</strong> and <strong>B</strong> such that all network interconnection paths between <strong>A</strong> and <strong>B</strong> pass through <strong>L</strong>. Removing a critical link generates two disjoint sub-networks such that any two servers of a sub-network are interconnected. For example, the network shown in figure <strong>1</strong> has three critical links that are marked red: <strong>0 - 1</strong>, <strong>3 - 4</strong> and <strong>6 - 7</strong> in figure <strong>2</strong>.</p>
<p>Figure 1: Original Graph</p>
<p>Figure 2: The Critical Links</p>
<p>It is known that:</p>
<ol>
<li><p>The connection links are bi-directional.</p>
</li>
<li><p>A server is not directly connected to itself.</p>
</li>
<li><p>Two servers are interconnected if they are directly connected or if they are interconnected with the same server.</p>
</li>
<li><p>The network can have stand-alone sub-networks.</p>
</li>
</ol>
<p>Write a program that finds all critical links of a given computer network.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 15)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line. The next line will contain <strong>n (0 ≤ n ≤ 10000)</strong> denoting the number of nodes. Each of the next n lines will contain some integers in the following format:</p>
<p><strong>u (k) v1 v2 … vk</strong></p>
<p>Where <strong>u</strong> is the node identifier, <strong>k</strong> is the number of adjacent nodes; <strong>v1, v2 … vk</strong> are the adjacent nodes of <strong>u</strong>. You can assume that there are at most <strong>100000</strong> edges in total in a case. Dataset is huge, so use faster i/o methods.Output</p>
<p>For each case, print the case number first. Then you should print the number of critical links and the critical links, one link per line, starting from the beginning of the line, as shown in the sample output below. The links are listed in ascending order according to their first element and then second element. Since the graph is bidirectional, print a link <strong>u v</strong> if <strong>u &lt; v</strong>.Sample Input</p>
<p>3</p>
<p>8</p>
<p>0 (1) 1</p>
<p>1 (3) 2 0 3</p>
<p>2 (2) 1 3</p>
<p>3 (3) 1 2 4</p>
<p>4 (1) 3</p>
<p>7 (1) 6</p>
<p>6 (1) 7</p>
<p>5 (0)</p>
<p>0</p>
<p>2</p>
<p>0 (1) 1</p>
<p>1 (1) 0Sample Output</p>
<p>Case 1:</p>
<p>3 critical links</p>
<p>0 - 1</p>
<p>3 - 4</p>
<p>6 - 7</p>
<p>Case 2:</p>
<p>0 critical links</p>
<p>Case 3:</p>
<p>1 critical links</p>
<p>0 - 1</p>
<p>Note</p>
<p>Dataset is huge, use faster I/O methods.</p>
<h3 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h3><p>求割边的模板.</p>
<h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
const int MAXM = 1e5 + 10;
int cnt, tot, head[MAXN], fron[MAXN], dfn[MAXN], low[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2], cut[MAXM * 2];
void addEdge(Edge *edge, int u, int v, int *head)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    tot = cnt = 0;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(fron, -1, sizeof fron);
}
void Tarjan(int u, int root)
{
    ++tot;
    dfn[u] = low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == root)   continue;   //双向边
        if(dfn[v] == 0)
        {
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] &gt; dfn[u])                 //AC
                if(u &lt; v)
                    addEdge(cut, u, v, fron);
                else addEdge(cut, v, u, fron);
        }
        else low[u] = min(low[u], dfn[v]);
    }
}
int solve(int n)
{
    for(int i = 0; i &lt; n; i++)
        if(dfn[i] == 0) Tarjan(i, i);
    int ans = 0;
    for(int u = 0; u &lt; n; u++)
        for(int i = fron[u]; i != -1; i = cut[i].next)
            ans ++;
    return ans;
}
int main()
{
    int t, n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        //点的数目
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            int u, k, v;
            scanf(&quot;%d (%d)&quot;, &amp;u, &amp;k);
            while(k--)
            {
                scanf(&quot;%d&quot;, &amp;v);
                addEdge(edge, u, v, head);
            }
        }
        cnt = 0;
        int ans = solve(n);
        printf(&quot;Case %d:\n&quot;, kase);
        printf(&quot;%d critical links\n&quot;, ans);
        for(int u = 0; u &lt; n; u++)          //点的编号从0开始
        {
            vector &lt; int &gt; vec;
            vec.clear();
            for(int i = fron[u]; i != -1; i = cut[i].next)
                vec.push_back(cut[i].v);
            sort(vec.begin(), vec.end());
            for(int i = 0; i &lt; vec.size(); i++)
                printf(&quot;%d - %d\n&quot;, u, vec[i]);
        }
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1063" target="_blank" rel="noopener"><strong>LightOJ 1063</strong></a> Ant Hills</p>
<p>After many years of peace, an ant-war has broken out.</p>
<p>In the days leading up to the outbreak of war, the ant government devoted a great deal of resources toward gathering intelligence on ant hills. It discovered the following:</p>
<ol>
<li><p>The ant empire has a large network of ant-hills connected by bidirectional tracks.</p>
</li>
<li><p>It is possible to send a message from any ant hill to any other ant hill.</p>
</li>
</ol>
<p>Now you want to stop the war. Since they sometimes attack your house and disturb you quite a lot. So, you have made a plan. You have a gun which can destroy exactly one ant-hill. So, you want to hit an ant hill if it can stop at least two other ant hills passing messages between them. Now you want the total number of ant hills you may choose to fire.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20)**, denoting the number of test cases.</p>
<p>Each test case contains a blank line and two integers <strong>n (1 ≤ n ≤ 10000), m (1 ≤ m ≤ 20000)</strong>. <strong>n</strong>denotes the number of ant hills and <strong>m</strong> denotes the number of bi-directional tracks. Each of the next <strong>m</strong> lines will contain two different integers <strong>a b (1 ≤ a, b ≤ n)</strong> denoting that there is a track between <strong>a</strong> and <strong>b</strong>.Output</p>
<p>For each case, print the case number and the total number of ant hills you may choose to fire.Sample Input</p>
<p>2</p>
<p>5 4</p>
<p>2 1</p>
<p>1 3</p>
<p>5 4</p>
<p>4 1</p>
<p>3 3</p>
<p>1 2</p>
<p>2 3</p>
<p>1 3</p>
<p>Sample Output</p>
<p>Case 1: 2</p>
<p>Case 2: 0</p>
<h3 id="分析：-2"><a href="#分析：-2" class="headerlink" title="分析："></a>分析：</h3><p>求割点模板</p>
<h3 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-08    20:43:05
By                : Tpaaaaaa
File_Name         ：Ant hills LightOJ - 1063 .cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

求割点，模板题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2e4 + 10;
int cnt, head[MAXN], dfn[MAXN], root, low[MAXN], tot;
bool cut[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u, int root)
{
    int child = 0;
    tot++;
    dfn[u] = tot;
    low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v, root);
            low[u] = min(low[u], low[v]);
            if(u != root &amp;&amp; low[v] &gt;= dfn[u])   cut[u] = true;
            if(u == root)   child++;
        }
        else    low[u] = min(low[u], dfn[v]);
    }
    if(u == root &amp;&amp; child &gt;= 2) cut[root] = true;
}
int solve(int n, int m)
{
    for(int i = 1; i &lt;= n; i++)
        if(dfn[i] == 0)
            Tarjan(i, i);
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  ans++;
    return ans;
    /*
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  printf(&quot;%d&quot;, i);    //输出割点编号
    */
}
void init()
{
    cnt = tot = 0;
    memset(head, -1, sizeof head);
    memset(cut, false, sizeof cut);
    memset(dfn, 0, sizeof dfn);

}
int main()
{
    int t, kase = 0, n, m;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addEdge(a, b);
            addEdge(b, a);
        }
        int ans = solve(n, m);
        printf(&quot;Case %d: %d\n&quot;, ++kase, ans);            //割点的数目
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1291" target="_blank" rel="noopener"><strong>LightOJ 1291</strong></a> Real Life Traffic</p>
<p>Dhaka city is full of traffic jam and when it rains, some of the roads become unusable. So, you are asked to redesign the traffic system of the city such that if exactly one of the roads becomes unusable, it’s still possible to move from any place to another using other roads.</p>
<p>You can assume that Dhaka is a city containing some places and bi directional roads connecting the places and it’s possible to go from any place to another using the roads. There can be at most one road between two places. And of course there is no road that connects a place to itself. To be more specific there are <strong>n</strong> places in Dhaka city and for simplicity, assume that they are numbered from <strong>0</strong> to <strong>n-1</strong> and there are <strong>m</strong> roads connecting the places.</p>
<p>Your plan is to build some new roads, but you don’t want to build a road between two places where a road already exists. You want to build the roads such that if any road becomes unusable, there should be an alternate way to go from any place to another using other roads except that damaged road. As you are a programmer, you want to find the minimum number of roads that you have to build to make the traffic system as stated above.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 30)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line. The next line contains two integers: <strong>n (3 ≤ n ≤ 10000)</strong> and <strong>m (≤ 20000)</strong>. Each of the next <strong>m</strong> lines contains two integers <strong>u v (0 ≤ u, v &lt; n, u ≠ v)</strong> meaning that there is a bidirectional road between place <strong>u</strong> and <strong>v</strong>. The input follows the above constraints.Output</p>
<p>For each case, print the case number and the minimum number of roads you have to build such that if one road goes down, it’s still possible to go from any place to another.Sample Input</p>
<p>2</p>
<p>4 3</p>
<p>1 2</p>
<p>2 3</p>
<p>2 0</p>
<p>3 3</p>
<p>1 2</p>
<p>2 0</p>
<p>0 1Sample Output</p>
<p>Case 1: 2</p>
<p>Case 2: 0</p>
<p>Note</p>
<ol>
<li><p>Dataset is huge, use faster I/O methods.</p>
</li>
<li><p>For case 1, one of the solutions is to construct two roads in (0, 1) and (1, 3).</p>
</li>
</ol>
<h3 id="分析：-3"><a href="#分析：-3" class="headerlink" title="分析："></a>分析：</h3><p>边双连通；由树构成连通图。</p>
<h3 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-09    10:22:12
By                : Tpaaaaaa
File_Name         ：RealLifeTrafficLightOJ1291.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

边双连通
构造边双连通图
Tarjan可以求双连通分量
如何用Tarjan求双连通分量，并将其缩点呢
首先用Tarjan求出割边，然后将割边去掉（标记一下）
然后再对整个图进行一遍DFS，染色一下
同色的就代表是一个边双连通分量中的点了

然后压缩为一个点


求出来然后将其缩点
缩点后就成了一颗树
统计树中度为1的节点的数目
也就是叶子节点的数目leaf
则再添加(leaf + 1) / 2个边即可;

*/

#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2e4 + 10;
int cnt, tot, dfn[MAXN], low[MAXN], head[MAXN], belong[MAXN], degree[MAXN];
bool vis[MAXN];
struct Edge
{
    int v, next, avai;
}edge[MAXM * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].avai = 1;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    cnt = tot = 0;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(degree, 0, sizeof degree);
    memset(vis, false, sizeof vis);
}
void Tarjan(int u, int root)
{
    ++tot;
    dfn[u] = low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == root)   continue;
        if(!dfn[v])
        {
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] &gt; dfn[u])
            {
                edge[i].avai = 0;           //标记为割边，即去掉他
                //双向边
                for(int j = head[v]; j != -1; j = edge[j].next)
                    if(u == edge[j].v)
                    {
                        edge[j].avai = 0;
                        break;
                    }
            }
        }
        else low[u] = min(low[u], dfn[v]); 
    }
}
void DFS(int u, int root)
{
    vis[u] = true;
    belong[u] = root;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        if(edge[i].avai == 0)   continue;
        int v = edge[i].v;
        if(!vis[v])
            DFS(v, root);
    }
}
//求构造边双连通图
int solve(int n)
{
    for(int i = 0; i &lt; n; i++)
        if(!dfn[i]) Tarjan(i, i);
    //然后进行一下DFS，缩一下点，染一下色.
    for(int i = 0; i &lt; n; i++)
        if(!vis[i])
            DFS(i, i);
    //求一下度
    for(int u = 0; u &lt; n; u++)
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].v;
            if(belong[v] != belong[u])
                degree[belong[v]]++;
        }
    int sum = 0;            //记录度为1的点的数目，即为叶子节点的数目
    for(int i = 0; i &lt; n; i++)
        if(degree[i] == 1)  sum++;
    return (sum + 1) / 2; 
}
int main()
{
    int t, n, m;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        //n个点，m个边
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            addEdge(v, u);  //无向图
        }
        //求一下割边
        int ans = solve(n);
        printf(&quot;Case %d: %d\n&quot;,kase, ans);
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1308" target="_blank" rel="noopener"><strong>LightOJ 1308</strong></a> Ant Network</p>
<p>Ants made a large underground network for their communication, consisting of <strong>n</strong> junctions, and junctions are connected by <strong>m</strong> underground tunnels. As there are animals/insects that can attack them outside the ground, they made the full network under the ground such that it becomes a safe hideout for them.</p>
<p>The junctions and tunnels are strong but if there is any kind of natural disasters like earthquakes or tornadoes, there is a chance that a junction may collapse. That’s why they want to built some escape shafts in junctions (at most one shaft in one junction) that lead them to the surface. Now they want to build minimum number of shafts such that if any of the junctions (only one) collapses, ants that survive the collapse, still have a path to the surface. Now your task is to find the minimum number of shafts, and the number of ways the minimum shafts can be built.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 30)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line. The next line contains two integers: <strong>n (2 ≤ n ≤ 10000)</strong> and <strong>m (0 ≤ m ≤ 20000)</strong>. Each of the next <strong>m</strong> lines contains two integers <strong>u v (0 ≤ u, v &lt; n, u ≠ v)</strong> meaning that there is a bidirectional tunnel between junction <strong>u</strong> and <strong>v</strong>. The input follows the above constraints. And no tunnel is reported more than once. All junctions are connected.Output</p>
<p>For each case, print the case number, the minimum number of escape shafts and the number of ways they can build the minimum shafts modulo <strong>264</strong>.Sample Input</p>
<p>2</p>
<p>6 6</p>
<p>0 3</p>
<p>0 1</p>
<p>1 4</p>
<p>4 2</p>
<p>2 5</p>
<p>5 0</p>
<p>5 4</p>
<p>2 1</p>
<p>1 3</p>
<p>0 4</p>
<p>4 1Sample Output</p>
<p>Case 1: 2 4</p>
<p>Case 2: 3 1Note</p>
<p>Dataset is huge, use faster I/O methods.</p>
<h3 id="分析：-4"><a href="#分析：-4" class="headerlink" title="分析："></a>分析：</h3><p>割点的问题</p>
<h3 id="代码：-4"><a href="#代码：-4" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-09    11:33:42
By                : Tpaaaaaa
File_Name         ：AntNetworkLightOJ1308.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

mdzz
首先求出割点
然后对每个连通块进行分析（无向图叫连通块）
如果一个连通块里面割点的数目大于1的话，我们就不需要放了
割点为0，我们要放一个lift
割点为1，我们也要放一个lift
组合数都是这个连通块里面的非割点数目.

然后记得特判一下全图是一个连通块的时候
要放2个list

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2e4 + 10;
ull temp;
int cutSum;
int tot, cnt, head[MAXN], dfn[MAXN], low[MAXN];
bool cut[MAXN], vis[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    tot = cnt = 0;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(cut, false, sizeof cut);
    memset(vis, false, sizeof vis);
}
//Tarjan求割点模板
void Tarjan(int u, int root)
{
    int child = 0;
    ++tot;
    dfn[u] = low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;   
        if(!dfn[v])
        {
            Tarjan(v, root);
            low[u] = min(low[u], low[v]);
            if(u != root &amp;&amp; low[v] &gt;= dfn[u])   cut[u] = true;
            if(u == root)   child++;
        }
        else    low[u] = min(low[u], dfn[v]);
    }
    if(u == root &amp;&amp; child &gt;= 2) cut[root] = true;
}
set &lt;int&gt; st;
void DFS(int u)
{
    temp++;
    vis[u] = true;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(cut[v])  
            st.insert(v);
        if(vis[v] == false &amp;&amp; cut[v] == false)
            DFS(v);
    }
}
void solve(int kase, int n)
{
    for(int i = 0; i &lt; n; i++)
        if(!dfn[i]) Tarjan(i, i);
    int sum = 0;
    for(int i = 0; i &lt; n; i++)
        if(cut[i])  sum++;
    ull ans = 1;
    int s = 0;
    if(sum == 0)
    {
        s = 2;
        ans = n * (n - 1) / 2;
    }
    else
    {
        for(int i = 0; i &lt; n; i++)
            if(!cut[i] &amp;&amp; !vis[i])   //遍历去掉割点得到的双连通分量
            {
                st.clear();
                temp = 0;       //非割点的数目
                DFS(i);
                if(st.size() &lt;= 1)
                {
                    s++;
                    ans = ans * temp;
                }
            }
    }
    printf(&quot;Case %d: %d %llu\n&quot;,kase, s, ans);

}
int main()
{
    int t, n, m;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            addEdge(v, u);
        }
        solve(kase, n);
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1108" target="_blank" rel="noopener"><strong>LightOJ 1108</strong></a> Instant View of Big Bang</p>
<p>Have you forgotten about wormholes? Oh my god! Ok, let me explain again.</p>
<p>A wormhole is a subspace tunnel through space and time connecting two star systems. Wormholes have a few peculiar properties:</p>
<ol>
<li><p>Wormholes are one-way only.</p>
</li>
<li><p>The time it takes to travel through a wormhole is negligible.</p>
</li>
<li><p>A wormhole has two end points, each situated in a star system.</p>
</li>
<li><p>A star system may have more than one wormhole end point within its boundaries.</p>
</li>
<li><p>Between any pair of star systems, there is at most one wormhole in each direction.</p>
</li>
<li><p>There are no wormholes with both end points in the same star system.</p>
</li>
</ol>
<p>All wormholes have a constant time difference between their end points. For example, a specific wormhole may cause the person traveling through it to end up 15 years in the future. Another wormhole may cause the person to end up 42 years in the past.</p>
<p>A brilliant physicist wants to use wormholes to study the Big Bang. Since warp drive has not been invented yet, it is not possible for her to travel from one star system to another one directly. Thiscan be done using wormholes, of course.</p>
<p>The scientist can start her journey from any star system. Then she wants to reach a cycle of wormholes somewhere in the universe that causes her to end up in the past. By traveling along this cycle a lot of times, the scientist is able to go back as far in time as necessary to reach the beginning of the universe and see the Big Bang with her own eyes. Write a program to help her to find such star systems where she can start her journey.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 125)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line. The next line contains two numbers <strong>n</strong> and <strong>m</strong> . These indicate the number of star systems <strong>(1 ≤ n ≤ 1000)</strong> and the number of wormholes <strong>(0 ≤ m ≤ 2000)</strong>. The star systems are numbered from <strong>0</strong> to <strong>n-1</strong>. For each wormhole a line containing three integer numbers <strong>x</strong>, <strong>y</strong> and <strong>t</strong> is given. These numbers indicate that this wormhole allows someone to travel from the star system numbered <strong>x</strong> to the star system numbered <strong>y</strong>, thereby ending up <strong>t (-1000 ≤ t ≤ 1000)</strong>years in the future or past, a negative integer denotes past, positive integer denotes future.Output</p>
<p>For each case, print the case number first. Then print the star systems (in ascending order) where she can start her journey. If no such star system is found, print <strong>‘impossible’</strong>.Sample Input</p>
<p>2</p>
<p>3 3</p>
<p>0 1 1000</p>
<p>1 2 15</p>
<p>2 1 -42</p>
<p>4 4</p>
<p>0 1 10</p>
<p>1 2 20</p>
<p>2 3 30</p>
<p>3 0 -60</p>
<p>Sample Output</p>
<p>Case 1: 0 1 2</p>
<p>Case 2: impossible</p>
<h3 id="分析：-5"><a href="#分析：-5" class="headerlink" title="分析："></a>分析：</h3><p>找负环，输出负环上的点，以及能够到达负环的点.</p>
<p>找到负环上的点，可以用反向建图。</p>
<h3 id="代码：-5"><a href="#代码：-5" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-09    13:37:48
By                : Tpaaaaaa
File_Name         ：InstantViewofBigBangLightOJ1108.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
判断负环.bellman_ford spfa
然后输出负环里面所有的点即可.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXM = 2e3 + 10;
int cnt, dis[MAXN], head[MAXN], in[MAXN]; 
bool vis[MAXN], ans[MAXN];
struct Edge
{
    int v, w, next;
}edge[MAXM];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    cnt = 0;
    memset(head, -1, sizeof head);
    memset(ans, false, sizeof ans);
}
set &lt;int&gt; st;
void bellman_ford(int n)
{
    bool flag;
    for(int i = 0; i &lt; n; i++)  
        dis[i] = INF;
    for(int i = 1; i &lt; n; i++)
    {
        flag = true;
        for(int u = 0; u &lt; n; u++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                if(dis[v] &gt; dis[u] + edge[i].w)
                {
                    dis[v] = dis[u] + edge[i].w;
                    flag = false;
                }
            }
        if(flag)    break;
    }
    //好吧原来可以反向建图
}
void dfs(int u)
{
    ans[u] = true;          //u能到达环
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(ans[v] == false)
            dfs(v);
    }
}
void spfa(int s, int n)
{
    for(int i = 0; i &lt; n; i++)
        dis[i] = INF;
    dis[s] = 0;
    queue &lt;int&gt; Q;
    Q.push(s);
    vis[s] = true;
    while(!Q.empty())
    {
        int u = Q.front();
        vis[u] = false;
        Q.pop();
        if(ans[u])  continue;           //已经访问过了
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].v;
            if(dis[v] &gt; dis[u] + edge[i].w)
            {
                dis[v] = dis[u] + edge[i].w;
                if(vis[v] == false)
                {
                    Q.push(v);
                    vis[v] = true;
                    ++in[v];        //入队次数大于等于元素数,说明该点是负环上面的点
                    if(in[v] &gt;= n)
                        dfs(v);     //从v开始bfs标记一下.
                }
            }
        }
    }
}
void solve(int n)
{
    for(int i = 0; i &lt; n; i++)
    {
        memset(in, 0, sizeof in);           //入队的次数
        memset(vis, false, sizeof vis);     //spfa的入队标记
        if(ans[i] == false)
            spfa(i, n);
    }
}
int main()
{
    int t, n, m;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int x, y, w;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
            addEdge(y, x, w);               //反向建图
        }
        solve(n);
        int sum = 0;
        printf(&quot;Case %d:&quot;, kase);
        for(int i = 0; i &lt; n; i++)
            if(ans[i])
            {
                sum++;
                printf(&quot; %d&quot;, i);
            }
         if(sum == 0)
            printf(&quot; impossible&quot;);
        printf(&quot;\n&quot;); 
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1221" target="_blank" rel="noopener"><strong>LightOJ 1221</strong></a> Travel Company</p>
<p>A travel company is planning to launch their bus service in a new route. So they conducted a survey and made a list of all possible roads connecting different cities. Each of the roads has a certain amount of income based on current fare. But at the same time, each road has some expenses too (this includes fuel and maintenance cost, staff payments, taxes and tribute to labor union which is recently approved by the Government). The travel company is looking for a cyclic route. That is, the bus will start from any city, then visit one or more cities each exactly once and return to the starting city. The company is also concerned with the profit on the route. In fact the directors of the company have a strict requirement of a profit ratio strictly greater than <strong>P</strong>. Otherwise they will not launch the service. A profit ratio for a route is the ratio between the total incomes to the total expenses for that route.</p>
<p>One of your friends works in that company and he asks for a little help from you. All you have to do is to determine if there exists such route, so that the company has a profit ratio of <strong>P</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line and three integers <strong>N, R, P (2 ≤ N ≤ 100, 0 ≤ R ≤ 9900, 1 ≤ P ≤ 100)</strong>. <strong>N</strong>, <strong>R</strong> and <strong>P</strong> represents number of cities, number of road links and the expected profit ratio respectively. Then <strong>R</strong> lines follow. Each line contains four integers <strong>Ai, Bi, Ii, Ei (0 ≤ Ai, Bi &lt; N, 0 ≤ Ii≤ 5000, 1 ≤ Ei ≤ 5000)</strong>. <strong>(Ai, Bi)</strong> represents directed road link from city <strong>Ai</strong> to <strong>Bi</strong>. <strong>Ii</strong> and <strong>Ei</strong> are the incomes and expenses of the road link respectively. You may assume that <strong>(Ai, Bi) ≠ (Aj, Bj)</strong>, if <strong>i ≠ j</strong>and <strong>Ai ≠ Bi</strong> for any <strong>i</strong>.Output</p>
<p>For each case, print the case number and <strong>“YES”</strong> if there is a cyclic route for which the profit ratio is greater than <strong>P</strong> or <strong>“NO”</strong>, if there is no such route.Sample Input</p>
<p>3</p>
<p>5 8 3</p>
<p>0 1 17 8</p>
<p>1 0 10 5</p>
<p>1 2 11 5</p>
<p>1 4 5 3</p>
<p>2 3 13 7</p>
<p>3 1 9 4</p>
<p>4 3 11 1</p>
<p>3 0 11 6</p>
<p>5 8 3</p>
<p>0 1 17 8</p>
<p>1 0 10 5</p>
<p>1 2 11 5</p>
<p>1 4 5 3</p>
<p>2 3 13 7</p>
<p>3 1 9 4</p>
<p>4 3 11 2</p>
<p>3 0 11 6</p>
<p>5 8 2</p>
<p>0 1 17 8</p>
<p>1 0 10 5</p>
<p>1 2 11 5</p>
<p>1 4 5 3</p>
<p>2 3 13 7</p>
<p>3 1 9 4</p>
<p>4 3 11 5</p>
<p>3 0 11 6Sample Output</p>
<p>Case 1: YES</p>
<p>Case 2: NO</p>
<p>Case 3: YES</p>
<p>Note</p>
<p>Dataset is huge. Use faster I/O methods.</p>
<h3 id="分析：-6"><a href="#分析：-6" class="headerlink" title="分析："></a>分析：</h3><p>首先利用<strong>分数规划</strong>，得出将每条边的权值设为 income - p * cost</p>
<p>然后问题转化为求解 图中存不存在正环. 用SPFA</p>
<h3 id="代码：-6"><a href="#代码：-6" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-09    20:34:54
By                : Tpaaaaaa
File_Name         ：LightOJ1221TravelCompany.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
题意：
每个边的权值为 income - p * cost

问是否存在正

oh, beautifulllllllll.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
const int MAXM = 1e5;
int cnt, head[MAXN], dis[MAXN], vis[MAXN], in[MAXN];
struct Edge
{
    int v, w, next;
}edge[MAXM];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
bool spfa(int s, int n)
{
    for(int i = 0; i &lt; n; i++)
        dis[i] = 0;
    dis[s] = 0;
    queue &lt;int&gt; Q;
    Q.push(s);
    vis[s] = true;
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].v;
            if(dis[v] &lt; dis[u] + edge[i].w) 
            {
                dis[v] = dis[u] + edge[i].w;
                if(vis[v] == false)
                {
                    vis[v] = true;
                    Q.push(v);
                    in[v]++;
                    if(in[v] &gt;= n)
                        return true;
                }
            }
        }
    }
    return false;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(vis, false, sizeof vis);
    memset(in, 0, sizeof in);
    cnt = 0;
}
int main()
{
    int n, r, p;
    int t;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        init();
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;r, &amp;p);
        for(int i = 1; i &lt;= r; i++)
        {
            int a, b, m, e;
            scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;m, &amp;e);
            addEdge(a, b, m - p * e);
        }
        printf(&quot;Case %d: &quot;, kase);
        bool flag = false;
        //这里怎么优化？？
        //好像都是酱紫耶
        for(int i = 0; i &lt; n; i++)
            if(spfa(i, n))
            {
                flag = true;
                break;
            }
        if(flag)    printf(&quot;YES\n&quot;);
        else        printf(&quot;NO\n&quot;);    
    }
    return 0;
}</code></pre><p><a href="https://vjudge.net/problem/LightOJ-1003" target="_blank" rel="noopener"><strong>LightOJ 1003</strong></a> Drunk</p>
<p>One of my friends is always drunk. So, sometimes I get a bit confused whether he is drunk or not. So, one day I was talking to him, about his drinks! He began to describe his way of drinking. So, let me share his ideas a bit. I am expressing in my words.</p>
<p>There are many kinds of drinks, which he used to take. But there are some rules; there are some drinks that have some pre requisites. Suppose if you want to take wine, you should have taken soda, water before it. That’s why to get real drunk is not that easy.</p>
<p>Now given the name of some drinks! And the prerequisites of the drinks, you have to say that whether it’s possible to get drunk or not. To get drunk, a person should take all the drinks.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 50)**, denoting the number of test cases.</p>
<p>Each case starts with an integer <strong>m (1 ≤ m ≤ 10000)</strong>. Each of the next <strong>m</strong> lines will contain two names each in the format <strong>a b</strong>, denoting that you must have <strong>a</strong> before having <strong>b</strong>. The names will contain at most <strong>10</strong> characters with no blanks.Output</p>
<p>For each case, print the case number and <strong>‘Yes’</strong> or <strong>‘No’</strong>, depending on whether it’s possible to get drunk or not.Sample Input</p>
<p>2</p>
<p>2</p>
<p>soda wine</p>
<p>water wine</p>
<p>3</p>
<p>soda wine</p>
<p>water wine</p>
<p>wine waterSample Output</p>
<p>Case 1: Yes</p>
<p>Case 2: No</p>
<h3 id="分析：-7"><a href="#分析：-7" class="headerlink" title="分析："></a>分析：</h3><p>将不同的酒抽象为不同的点，先后喝的关系抽象为边</p>
<p>问的是这个图中存不存在环.判断图中存不存在环，可以用拓扑排序进行判环</p>
<h3 id="代码：-7"><a href="#代码：-7" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
Date              : 2019-10-10    18:43:01
By                : Tpaaaaaa
File_Name         ：DrunkLightOJ-1003.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

//判断有没有环
拓扑排序判断有没有环
我们先建边, 然后开始拓扑
将入度为0的点分离出来，然后将这个点有边存在的其他点的入度减1
一直做该操作
如果之后不存在入度为0的点，说明有环
即已经拓扑排序的点的数目要小于总的数目
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e4 + 10;
const int MAXM = 1e4 + 10;
int cnt, tot, head[MAXN], n, m, in[MAXN];
map &lt;string, int&gt; mp;
struct Edge
{
    int v, next;
}edge[MAXM];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int getId(string s)
{
    if(mp[s])   return mp[s];
    else        return mp[s] = ++n;
}
void init()
{
    mp.clear();
    memset(head, -1, sizeof head);
    memset(in, 0, sizeof in);
    cnt = n = 0;
}
//无环返回true
bool solve()
{
    int sum = 0;
    queue &lt;int&gt; q;
    for(int i = 1; i &lt;= n; i++)
        if(in[i] == 0) 
            q.push(i);
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        sum++;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].v;
            in[v]--;
            if(in[v] == 0)
                q.push(v);
        }
    }
    if(sum &lt; n) return false;
    else        return true;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    for(int kase = 1; kase&lt;= t; kase++)
    {   //m为边数，n为点数
        scanf(&quot;%d&quot;, &amp;m);
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;   
            string a, b;
            cin &gt;&gt; a &gt;&gt; b;
            u = getId(a);
            v = getId(b);
            in[v]++;
            addEdge(u, v);
        }
        printf(&quot;Case %d: &quot;, kase);
        if(solve()) printf(&quot;Yes\n&quot;);
        else        printf(&quot;No\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[图论]Bron–Kerbosch算法</title>
    <url>/tpaaaaaa.github.io/2019/10/09/%5B%E5%9B%BE%E8%AE%BA%5DBron%E2%80%93Kerbosch%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><em><strong>Bron</strong></em><strong>-</strong><em><strong>Kerbosch</strong></em>** 算法** 计算图的最大全连通分量(团clique) </p>
<h2 id="几个概念："><a href="#几个概念：" class="headerlink" title="几个概念："></a>几个概念：</h2><p><strong>团</strong></p>
<pre><code>对于给定图G=(V,E)。其中，V={1,…,n}是图G的顶点集，E是图G的边集。图G的团就是一个两两之间有边的顶点集合。简单地说，团是G的一个完全子图。如果一个团不被其他任一团所包含，即它不是其他任一团的真子集，则称该团为图G的极大团（maximal clique）。顶点最多的极大团，称之为图G的最大团（maximum clique）。最大团问题的目标就是要找到给定图的最大团。</code></pre><p><em>简单的的说</em></p>
<p><strong>最大团：　顶点集V中取 K个顶点，其两两间有边连接。</strong></p>
<p><strong>最大独立集： 顶点集V中取 K个顶点，其两两间无连接。</strong></p>
<p>有 <strong>最大团中顶点数量 = 补图的最大独立集中顶点数量</strong></p>
<p><strong>补图：</strong> 一个图有着跟G相同的点，而且这些点之间有边相连当且仅当在G里面他们没有边相连。</p>
<p>可以通过求其补图中最大团中顶点数量,就可得出<strong>原图中最大独立集</strong>中顶点数量了</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[图论]最小点基和最小权点基</title>
    <url>/tpaaaaaa.github.io/2019/10/09/%5B%E5%9B%BE%E8%AE%BA%5D%E6%9C%80%E5%B0%8F%E7%82%B9%E5%9F%BA%E5%92%8C%E6%9C%80%E5%B0%8F%E6%9D%83%E7%82%B9%E5%9F%BA/</url>
    <content><![CDATA[<p>博文地址：<a href="https://blog.csdn.net/qq_30796379/article/details/80160624" target="_blank" rel="noopener">https://blog.csdn.net/qq_30796379/article/details/80160624</a></p>
<h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p><strong>点基：</strong>在有向图G=（G,V）中，B是顶点集和V的子集。如果对于任意的y属于V,不属于B，都存在一个x属于B，使得x是y的前代（有一条边从x到y，一般间接相连也算）,则称B是一个点基。</p>
<p>通俗点就是点基里面的点，能够到达点基外所有的点。（像一个基地）</p>
<p><strong>最小点基：</strong>顶点最少的点基。</p>
<p><strong>最小权点基：</strong>顶点对应的权值之和最小的点基。（顶点权值非负）</p>
<p><strong>最高强连通分量:</strong></p>
<p>如果一个强连通分量内部的弧都是向外的，即对于任意一点u不属于该强连通分量，不存在点v，v属于该强连通分量,使得v是u的后代(即u-&gt;v的边)。换句话说，最高强连通分量没有外部的点指向这个强连通分量，如果把最高强连通分量缩成一个点，那么是没有其他点指向这个点的。</p>
<p>缩点后就像一棵树的根。（当然一个图中可能不止一个，也可能没有）</p>
<h2 id="求最小点基的步骤"><a href="#求最小点基的步骤" class="headerlink" title="求最小点基的步骤"></a>求最小点基的步骤</h2><p>①找出图G的所有强连通分量。</p>
<p>②从强连通分量中找出所有的最高强连通分量。也就是缩点后入度为0的点。</p>
<p>③从每个最高强连通分量中<strong>任取一点</strong>，组成点集B就是一个最小点基。</p>
<h2 id="求最小权点基的步骤"><a href="#求最小权点基的步骤" class="headerlink" title="求最小权点基的步骤"></a>求最小权点基的步骤</h2><p>①找出图G的所有强连通分量。</p>
<p>②从强连通分量中找出所有的最高强连通分量。也就是缩点后入度为0的点。</p>
<p>③从每个最高强连通分量中取<strong>权值最小</strong>的点，组成点集B就是一个最小点权基。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]Burnside引理和Polya定理</title>
    <url>/tpaaaaaa.github.io/2019/10/07/%5B%E7%AE%97%E6%B3%95%5DBurnside%E5%BC%95%E7%90%86%E5%92%8CPolya%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>好的文章：<a href="https://blog.csdn.net/WhereIsHeroFrom/article/details/79631703" target="_blank" rel="noopener">https://blog.csdn.net/WhereIsHeroFrom/article/details/79631703</a></p>
<p>手环的旋转问题，有固定公式。 如果量太大，可以结合数论知识来简化运算。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]随机化算法</title>
    <url>/tpaaaaaa.github.io/2019/10/07/%5B%E7%AE%97%E6%B3%95%5D%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>RP题</p>
<p>(poj3318,poj2454)  写完来补</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[模板]三分法求单峰(单谷)函数极值</title>
    <url>/tpaaaaaa.github.io/2019/10/07/%5B%E6%A8%A1%E6%9D%BF%5D%E4%B8%89%E5%88%86%E6%B3%95%E6%B1%82%E5%8D%95%E5%B3%B0(%E5%8D%95%E8%B0%B7)%E5%87%BD%E6%95%B0%E6%9E%81%E5%80%BC/</url>
    <content><![CDATA[<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
double a,b,c;
inline double f(double x) {
    return a*x*x+b*x+c;
}
int main(void)
{
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    //形如y=ax^2+by+c的二次函数
    double l=-1e9,r=1e9;
    while (l+1e-9&lt;r)
    {
        double lmid=l+(r-l)/3.0;
        //图像上位于1/3部分的靠左的mid值 
        double rmid=l+(r-l)/3.0*2.0;
        //图像上位于2/3部分的靠右的mid值
        if (f(lmid)&lt;f(rmid)) l=lmid;
        else r=rmid;
        //求单峰极值 
    } 
    cout&lt;&lt;&quot;X=&quot;&lt;&lt;l&lt;&lt;&apos;\n&apos;;
    cout&lt;&lt;&quot;Y=&quot;&lt;&lt;f(l); 
}

#include&lt;bits/stdc++.h&gt;
using namespace std;
double a,b,c;
inline double f(double x) {
    return a*x*x+b*x+c;
}
int main(void)
{
    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    //形如y=ax^2+by+c的二次函数
    double l=-1e9,r=1e9;
    while (l+1e-9&lt;r)
    {
        double lmid=l+(r-l)/3.0;
        //图像上位于1/3部分的靠左的mid值 
        double rmid=l+(r-l)/3.0*2.0;
        //图像上位于2/3部分的靠右的mid值
        if (f(lmid)&gt;f(rmid)) l=lmid;
        else r=rmid;
        //求单峰极值 
    } 
    cout&lt;&lt;&quot;X=&quot;&lt;&lt;l&lt;&lt;&apos;\n&apos;;
    cout&lt;&lt;&quot;Y=&quot;&lt;&lt;f(l); 
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2976 Dropping tests</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ2976Droppingtests/</url>
    <content><![CDATA[<p>Dropping tests</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 25093</p>
<p><strong>Accepted:</strong> 8283</p>
<p>Description</p>
<p>In a certain course, you take <em>n</em> tests. If you get <em>ai</em> out of <em>bi</em> questions correct on test <em>i</em>, your cumulative average is defined to be</p>
<p><img src="http://poj.org/images/2976_1.gif" alt=""></p>
<p>.</p>
<p>Given your test scores and a positive integer <em>k</em>, determine how high you can make your cumulative average if you are allowed to drop any <em>k</em> of your test scores.</p>
<p><img src="http://poj.org/images/2976_3.gif" alt=""></p>
<p><img src="http://poj.org/images/2976_2.gif" alt=""></p>
<p>Suppose you take 3 tests with scores of 5/5, 0/1, and 2/6. Without dropping any tests, your cumulative average is . However, if you drop the third test, your cumulative average becomes .</p>
<p>Input</p>
<p>The input test file will contain multiple test cases, each containing exactly three lines. The first line contains two integers, 1 ≤ <em>n</em> ≤ 1000 and 0 ≤ <em>k</em> &lt; <em>n</em>. The second line contains <em>n</em> integers indicating <em>ai</em> for all <em>i</em>. The third line contains <em>n</em> positive integers indicating <em>bi</em> for all <em>i</em>. It is guaranteed that 0 ≤ <em>ai</em> ≤ <em>bi</em> ≤ 1, 000, 000, 000. The end-of-file is marked by a test case with <em>n</em> = <em>k</em> = 0 and should not be processed.</p>
<p>Output</p>
<p>For each test case, write a single line with the highest cumulative average possible after dropping <em>k</em> of the given test scores. The average should be rounded to the nearest integer.</p>
<p>Sample Input</p>
<p>3 1<br>5 0 2<br>5 1 6<br>4 2<br>1 2 7 9<br>5 6 7 9<br>0 0</p>
<p>Sample Output</p>
<p>83<br>100</p>
<p>Hint</p>
<p>To avoid ambiguities due to rounding errors, the judge tests have been constructed so that all answers are at least 0.001 away from a decision boundary (i.e., you can assume that the average is never 83.4997).</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>01分数规划…实际上就是一个二分.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    20:43:11
By                : Tpaaaaaa
File_Name         ：Dropping tests poj2976.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
int a[MAXN], b[MAXN];
double arr[MAXN];
int n, k;
double getarr(double mid)
{
    for(int i = 1; i &lt;= n; i++)
    {
        arr[i] = a[i] - mid * b[i];
    }
    sort(arr + 1, arr + 1 + n);
    double all = 0;
    for(int i = 1; i &lt;= k; i++)
        all += arr[n - i + 1];
    return all;
}
int main()
{
    //n对，抛弃k对
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;k) &amp;&amp; n + k)
    {
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;b[i]);
     //k则是需要的数目，也就是前k个
        k = n - k;
        double ans;
        double l = 0, r = 1;
        while(r - l &gt; 1e-4)
        {
            double mid = (l + r) / 2;
            //printf(&quot;mid = %.5f\n&quot;, mid);
            double temp = getarr(mid);
            if(temp &gt;= 0)   l = mid;
            else            r = mid;
        }
        ans = l * 100;
        printf(&quot;%.0f\n&quot;, ans);
    }
   return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>01分数规划，二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1830 开关问题</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ1830%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>开关问题</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 30000K</p>
<p><strong>Total Submissions:</strong> 12262</p>
<p><strong>Accepted:</strong> 4939</p>
<p>Description有N个相同的开关，每个开关都与某些开关有着联系，每当你打开或者关闭某个开关的时候，其他的与此开关相关联的开关也会相应地发生变化，即这些相联系的开关的状态如果原来为开就变为关，如果为关就变为开。你的目标是经过若干次开关操作后使得最后N个开关达到一个特定的状态。对于任意一个开关，最多只能进行一次开关操作。你的任务是，计算有多少种可以达到指定状态的方法。（不计开关操作的顺序）</p>
<p>Input输入第一行有一个数K，表示以下有K组测试数据。<br>每组测试数据的格式如下：<br>第一行 一个数N（0 &lt; N &lt; 29）<br>第二行 N个0或者1的数，表示开始时N个开关状态。<br>第三行 N个0或者1的数，表示操作结束后N个开关的状态。<br>接下来 每行两个数I J，表示如果操作第 I 个开关，第J个开关的状态也会变化。每组数据以 0 0 结束。   </p>
<p>Output如果有可行方法，输出总数，否则输出“Oh,it’s impossible~!!” 不包括引号</p>
<p>Sample Input</p>
<p>2<br>3<br>0 0 0<br>1 1 1<br>1 2<br>1 3<br>2 1<br>2 3<br>3 1<br>3 2<br>0 0<br>3<br>0 0 0<br>1 0 1<br>1 2<br>2 1<br>0 0</p>
<p>Sample Output</p>
<p>4<br>Oh,it’s impossible~!!</p>
<p>Hint第一组数据的说明：<br>一共以下四种方法：<br>操作开关1<br>操作开关2<br>操作开关3<br>操作开关1、2、3 （不记顺序） </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样也是开关问题。注意自己按了之后，自己的状态也会变哟 QAQ！！！</p>
<p>还有就是，有k个自由变量，每个自由变量可以取的值为0,1，则一共有1 &lt;&lt; k 种解组合</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    19:19:58
By                : Tpaaaaaa
File_Name         ：开关问题 poj1830.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 50;
int a[MAXN][MAXN], free_x[MAXN], x[MAXN];
//n * n的矩阵
int Gauss(int n)
{
    memset(x, 0, sizeof x);
    memset(free_x, 0, sizeof free_x);
    int max_r, col = 0, row = 0, num = 0;
    for(; col &lt; n &amp;&amp; row &lt; n; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(a[max_r][col] &lt; a[i][col])   max_r = i;
        if(max_r != row)
            for(int i = col; i &lt;= n; i++)
                swap(a[row][i], a[max_r][i]);
        if(a[row][col] == 0)
        {
            row--;
            free_x[++num] = col;
            continue;
        }
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col])
                for(int j = col; j &lt;= n; j++)
                    a[i][j] ^= a[row][j];
    }
    for(int i = row; i &lt; n; i++)
        if(a[i][col])   return 0;

    return 1 &lt;&lt; (n - row);
}
int main()
{
    int t, n;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        memset(a, 0, sizeof a);
        for(int i = 0; i &lt; n; i++)
            scanf(&quot;%d&quot;, &amp;a[i][n]);
        for(int i = 0; i &lt; n; i++)
        {
            a[i][i] = 1;
            int temp;
            scanf(&quot;%d&quot;, &amp;temp);
            a[i][n] ^= temp;
        }

        int i, j;
        //每个节点翻自己，自己肯定也会变呀 ，傻子
        while(scanf(&quot;%d%d&quot;, &amp;i, &amp;j) &amp;&amp; i + j)
            a[j - 1][i - 1] = 1; 
        int ans = Gauss(n);
        //n * n的矩阵
        if(ans == 0)
            printf(&quot;Oh,it&apos;s impossible~!!\n&quot;);
        else
            printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，开关问题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ1222  EXTENDED LIGHTS OUT</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ1222EXTENDEDLIGHTSOUT/</url>
    <content><![CDATA[<p>EXTENDED LIGHTS OUT</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 10000K</p>
<p><strong>Total Submissions:</strong> 15282</p>
<p><strong>Accepted:</strong> 9315</p>
<p>DescriptionIn an extended version of the game Lights Out, is a puzzle with 5 rows of 6 buttons each (the actual puzzle has 5 rows of 5 buttons each). Each button has a light. When a button is pressed, that button and each of its (up to four) neighbors above, below, right and left, has the state of its light reversed. (If on, the light is turned off; if off, the light is turned on.) Buttons in the corners change the state of 3 buttons; buttons on an edge change the state of 4 buttons and other buttons change the state of 5. For example, if the buttons marked X on the left below were to be pressed,the display would change to the image on the right.   </p>
<p><img src="http://poj.org/images/1222_1.jpg" alt=""></p>
<p>The aim of the game is, starting from any initial set of lights on in the display, to press buttons to get the display to a state where all lights are off. When adjacent buttons are pressed, the action of one button can undo the effect of another. For instance, in the display below, pressing buttons marked X in the left display results in the right display.Note that the buttons in row 2 column 3 and row 2 column 5 both change the state of the button in row 2 column 4,so that, in the end, its state is unchanged.   </p>
<p><img src="http://poj.org/images/1222_2.jpg" alt=""></p>
<p>Note:<br>1. It does not matter what order the buttons are pressed.<br>2. If a button is pressed a second time, it exactly cancels the effect of the first press, so no button ever need be pressed more than once.<br>3. As illustrated in the second diagram, all the lights in the first row may be turned off, by pressing the corresponding buttons in the second row. By repeating this process in each row, all the lights in the first<br>four rows may be turned out. Similarly, by pressing buttons in columns 2, 3 ?, all lights in the first 5 columns may be turned off.<br>Write a program to solve the puzzle.</p>
<p>InputThe first line of the input is a positive integer n which is the number of puzzles that follow. Each puzzle will be five lines, each of which has six 0 or 1 separated by one or more spaces. A 0 indicates that the light is off, while a 1 indicates that the light is on initially.</p>
<p>OutputFor each puzzle, the output consists of a line with the string: “PUZZLE #m”, where m is the index of the puzzle in the input file. Following that line, is a puzzle-like display (in the same format as the input) . In this case, 1’s indicate buttons that must be pressed to solve the puzzle, while 0 indicate buttons, which are not pressed. There should be exactly one space between each 0 or 1 in the output puzzle-like display.</p>
<p>Sample Input</p>
<p>2<br>0 1 1 0 1 0<br>1 0 0 1 1 1<br>0 0 1 0 0 1<br>1 0 0 1 0 1<br>0 1 1 1 0 0<br>0 0 1 0 1 0<br>1 0 1 0 1 1<br>0 0 1 0 1 1<br>1 0 1 1 0 0<br>0 1 0 1 0 0</p>
<p>Sample Output</p>
<p>PUZZLE #1<br>1 0 1 0 0 1<br>1 1 0 1 0 1<br>0 0 1 0 1 1<br>1 0 0 1 0 0<br>0 1 0 0 0 0<br>PUZZLE #2<br>1 0 0 1 1 1<br>1 1 0 0 0 0<br>0 0 0 1 0 0<br>1 1 0 1 0 1<br>1 0 1 1 0 1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>高斯消元法解开关问题。可做模板。解题的时候建议自己画一个矩阵</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    15:33:26
By                : Tpaaaaaa
File_Name         ：POJ1222EXTENDED LIGHTS OUT.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
这种开关问题
    可以暴力枚举第一行的开关情况，然后下面一行为了保证第一行全灭，其操作也就固定了
            一直到最后一行，然后判断最后一行是否全灭了。

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 35;
int a[MAXN][MAXN], x[MAXN];
void getA()
{
    //5行，6列
    for(int i = 0; i &lt; 5; i++)
        for(int j = 0; j &lt; 6; j++)
        {
            int t = i * 6 + j;          //x的下标
            a[t][t] = 1;                
            int up = (i - 1) * 6 + j;
            int down = (i + 1) * 6 + j;
            int left = i * 6 + j - 1;
            int right = i * 6 + j + 1;
            if(i &gt; 0)   a[up][t] = 1;
            if(i &lt; 4)   a[down][t] = 1;
            if(j &gt; 0)   a[left][t] = 1;
            if(j &lt; 5)   a[right][t] = 1;
        }
}
int Gauss(int equ, int var)
{
    for(int i = 0; i &lt;= var; i++)    x[i] = 0;
    int col = 0, row = 0;
    int max_r;
    for(; col &lt; var &amp;&amp; row &lt; equ; col ++, row ++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; equ; i++)
            if(a[i][col] &gt; a[max_r][col])   max_r = i;
        if(max_r != row)
            for(int j = row; j &lt;= var; j++)
                swap(a[row][j], a[max_r][j]);
        if(a[row][col] == 0)
        {
            row --;
            continue;
        }
        for(int i = row + 1; i &lt; equ; i++)
            if(a[i][col] != 0)
            {
                for(int j = col; j &lt;= var; j++)
                    a[i][j] ^= a[row][j];
            }
    }
    for(int i = var - 1; i &gt;= 0; i--)
    {
        x[i] = a[i][var];
        for(int j = i + 1; j &lt; var; j++)
            x[i] ^= (a[i][j] &amp;&amp; x[j]);
    }

}
int main()
{
    int t;
    cin &gt;&gt; t;
    //5 * 6的矩形,意思是有30个方程
    //有30个变量.
    //提前预处理知道每个方程的系数.
    for(int kase = 1; kase &lt;= t; kase++)
    {
        memset(a, 0, sizeof a);
        getA();                     //A的初始化
        //录入30个方程的右边
        //a[x][y] 表示第x个方程，第y个变量
        for(int i = 0; i &lt; 30; i++)
            scanf(&quot;%d&quot;, &amp;a[i][30]);
        Gauss(30, 30);
        printf(&quot;PUZZLE #%d\n&quot;, kase);
        for(int i = 0; i &lt; 30; i++)
        {
            printf(&quot;%d&quot;, x[i]);
            if((i + 1) % 6 == 0)    printf(&quot;\n&quot;);
            else                    printf(&quot; &quot;);

        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，开关问题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2947 Widget Factory</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ2947WidgetFactory/</url>
    <content><![CDATA[<p>Widget Factory</p>
<p><strong>Time Limit:</strong> 7000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 7516</p>
<p><strong>Accepted:</strong> 2632</p>
<p>DescriptionThe widget factory produces several different kinds of widgets. Each widget is carefully built by a skilled widgeteer. The time required to build a widget depends on its type: the simple widgets need only 3 days, but the most complex ones may need as many as 9 days. </p>
<p>The factory is currently in a state of complete chaos: recently, the factory has been bought by a new owner, and the new director has fired almost everyone. The new staff know almost nothing about building widgets, and it seems that no one remembers how many days are required to build each diofferent type of widget. This is very embarrassing when a client orders widgets and the factory cannot tell the client how many days are needed to produce the required goods. Fortunately, there are records that say for each widgeteer the date when he started working at the factory, the date when he was fired and what types of widgets he built. The problem is that the record does not say the exact date of starting and leaving the job, only the day of the week. Nevertheless, even this information might be helpful in certain cases: for example, if a widgeteer started working on a Tuesday, built a Type 41 widget, and was fired on a Friday,then we know that it takes 4 days to build a Type 41 widget. Your task is to figure out from these records (if possible) the number of days that are required to build the different types of widgets.   </p>
<p>InputThe input contains several blocks of test cases. Each case begins with a line containing two integers: the number 1 ≤ n ≤ 300 of the different types, and the number 1 ≤ m ≤ 300 of the records. This line is followed by a description of the m records. Each record is described by two lines. The first line contains the total number 1 ≤ k ≤ 10000 of widgets built by this widgeteer, followed by the day of week when he/she started working and the day of the week he/she was fired. The days of the week are given bythe strings `MON’, `TUE’, `WED’, `THU’, `FRI’, `SAT’ and `SUN’. The second line contains k integers separated by spaces. These numbers are between 1 and n , and they describe the diofferent types of widgets that the widgeteer built. For example, the following two lines mean that the widgeteer started working on a Wednesday, built a Type 13 widget, a Type 18 widget, a Type 1 widget, again a Type 13 widget,and was fired on a Sunday. </p>
<p>4 WED SUN<br>13 18 1 13 </p>
<p>Note that the widgeteers work 7 days a week, and they were working on every day between their first and last day at the factory (if you like weekends and holidays, then do not become a widgeteer!). </p>
<p>The input is terminated by a test case with n = m = 0 .</p>
<p>OutputFor each test case, you have to output a single line containing n integers separated by spaces: the number of days required to build the different types of widgets. There should be no space before the first number or after the last number, and there should be exactly one space between two numbers. If there is more than one possible solution for the problem, then write `Multiple solutions.’ (without the quotes). If you are sure that there is no solution consistent with the input, then write `Inconsistent data.’(without the quotes).</p>
<p>Sample Input</p>
<p>2 3<br>2 MON THU<br>1 2<br>3 MON FRI<br>1 1 2<br>3 MON SUN<br>1 2 2<br>10 2<br>1 MON TUE<br>3<br>1 MON WED<br>3<br>0 0</p>
<p>Sample Output</p>
<p>8 3<br>Inconsistent data.</p>
<p>HintHuge input file, ‘scanf’ recommended to avoid TLE. </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>高斯消元法解模线性方程组。可做模板。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    13:47:45
By                : Tpaaaaaa
File_Name         ：POJ 2947 Widget Factory.cpp（重新写一个）.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 310;
const int MOD = 7;
int x[MAXN];
int a[MAXN][MAXN];
int n, m;               //m是方程数，n是变量数
int gcd(int a, int b)
{
    if(b == 0)  return a;
    return gcd(b, a%b);
}
int lcm(int a, int b)
{
    return a/gcd(a, b) * b;
}
int exGcd(int a, int b, int &amp;x, int &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        int d = exGcd(b, a % b, y, x);
        y -= x*a/b;             //????喵喵喵？？？？？
        return d;
    }
}
int getNum(char temp[])
{
    char cmp[7][10] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;};
    for(int i = 0; i &lt; 7; i++)
        if(strcmp(temp, cmp[i]) == 0)
            return i + 1;
    return -1;
}
//equ个方程，val个变量
//
int Gauss(int equ, int var)
{
    memset(x, 0, sizeof x);
    int col, row;
    for(row = 0, col = 0; row &lt; equ &amp;&amp; col &lt; var; col ++, row ++)
    {
        int max_r;
        for(max_r = row; max_r &lt; equ; max_r++)
            if(a[max_r][col])
                break;

        if(max_r == equ)
        {
            row --;
            continue;
        }
        if(max_r != row)
            for(int j = 0; j &lt;= var; j++)
                swap(a[max_r][j], a[row][j]);

        for(int i = row + 1; i &lt; equ; i++)
        {
            if(a[i][col] == 0)  continue;
            int LCM = lcm(a[row][col], a[i][col]);
            int ta = LCM / a[i][col];
            int tb = LCM / a[row][col];
            for(int j = col; j &lt;= var; j++)
                a[i][j] = ((a[i][j] * ta - a[row][j] * tb) % MOD + MOD) % MOD;
        }
    }
    //无解
    //
    for(int i = row; i &lt; equ; i++)
        if(a[i][col])   return -1;
    if(row &lt; var)         return 0;
    for(int i = equ - 1; i &gt;= 0; i--)
    {
        int temp = a[i][var];
        for(int j = i + 1; j &lt; var; j++)
            temp = ((temp - a[i][j] * x[j])%MOD + MOD) % MOD;
        int b = temp;
        int X, Y;
        int d = exGcd(a[i][i], MOD, X, Y);
        X = X * (b / d) % MOD;
        X =(X % (MOD / d) + (MOD / d)) % (MOD / d);
        if(X &lt; 3)   X += 7;
        x[i] = X; 

    }
    return 1;
}
int main()
{   
    int start, fire, k;
    char A[10], B[10];
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n + m )
    {
        memset(a, 0, sizeof a);
        for(int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d %s %s&quot;, &amp;k, A, B);
            start = getNum(A);
            fire  = getNum(B);
            int day = fire - start + 1;
            a[i][n] = (day % MOD + MOD) % MOD;
            for(int j = 0; j &lt; k; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                a[i][temp - 1] = (a[i][temp - 1] + 1) % MOD;
            }
        }
        int ans = Gauss(m, n);              //从第一行开始.
        if(ans == 0)
            printf(&quot;Multiple solutions.\n&quot;);
        else if(ans == -1)
            printf(&quot;Inconsistent data.\n&quot;);
        else
        {
            printf(&quot;%d&quot;, x[0]);
            for(int i = 1; i &lt; n; i++)
                printf(&quot; %d&quot;, x[i]);
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，解模线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1681 Painter&#39;s Problem</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ-1681Painter&#39;sProblem/</url>
    <content><![CDATA[<p>There is a square wall which is made of n*n small square bricks. Some bricks are white while some bricks are yellow. Bob is a painter and he wants to paint all the bricks yellow. But there is something wrong with Bob’s brush. Once he uses this brush to paint brick (i, j), the bricks at (i, j), (i-1, j), (i+1, j), (i, j-1) and (i, j+1) all change their color. Your task is to find the minimum number of bricks Bob should paint in order to make all the bricks yellow.   </p>
<p><img src="https://vj.z180.cn/7d20b479261eb8fa1c1f3f948676182f?v=1570353995" alt=""></p>
<p>InputThe first line contains a single integer t (1 &lt;= t &lt;= 20) that indicates the number of test cases. Then follow the t cases. Each test case begins with a line contains an integer n (1 &lt;= n &lt;= 15), representing the size of wall. The next n lines represent the original wall. Each line contains n characters. The j-th character of the i-th line figures out the color of brick at position (i, j). We use a ‘w’ to express a white brick while a ‘y’ to express a yellow brick.OutputFor each case, output a line contains the minimum number of bricks Bob should paint. If Bob can’t paint all the bricks yellow, print ‘inf’.Sample Input</p>
<p>2<br>3<br>yyy<br>yyy<br>yyy<br>5<br>wwwww<br>wwwww<br>wwwww<br>wwwww<br>wwwww</p>
<p>Sample Output</p>
<p>0<br>15</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>对于无解的情况，返回INF，有多个解的时候，要返回最小的。可以作为模板哦</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    16:27:37
By                : Tpaaaaaa
File_Name         ：Painter&apos;s Problem POJ1681.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题


眼睛越来越瞎了   QAQ
然而这个写法并不严谨。我们要枚举自由变量的取值，然后再去求出每个情况的sum值，取最小
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 300;
int a[MAXN][MAXN], x[MAXN];
int free_x[MAXN];
int Gauss(int n)
{
    int num = 0;
    memset(free_x, 0, sizeof free_x);
    memset(x, 0, sizeof x); 
    int col = 0, row = 0;
    int max_r;
    for(; col &lt; n &amp;&amp; row &lt; n; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col] &gt; a[max_r][col])   max_r = i;

        if(max_r != row)
            for(int i = col; i &lt;= n; i++)
                swap(a[max_r][i], a[row][i]);
        if(a[row][col] == 0)
        {
            row --;
            free_x[num++] = col;
            continue;
        }
        //开始消了
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col])
                for(int j = col; j &lt;= n; j++)
                    a[i][j] ^= a[row][j];
    }
    //无解的情况就是
    for(int i = row; i &lt; n; i++)
        if(a[i][col])   return -1;
    //多个解的情况，返回的是最小的解
    int res = INF;
    int up = 1 &lt;&lt; (n - row);            
    for(int i = 0; i &lt; up; i++)
    {
        int cnt = 0;
        int index = i;
        for(int j = 0; j &lt; n - row; j++)
        {
            x[free_x[j]] = index &amp; 1;
            if(x[free_x[j]])    cnt++;
            index &gt;&gt;= 1;
        }
        for(int j = row - 1; j &gt;= 0; j--)
        {
            int temp = a[j][n];
            for(int l = j + 1; l &lt; n; l++)
                if(a[j][l]) temp ^= x[l];
            x[j] = temp;
            if(x[j]) cnt++;
        }
        if(cnt &lt; res)  res = cnt;
    }
    return res;
}
void getA(int n)
{
    memset(a, 0, sizeof a);
    for(int i = 0; i &lt; n; i ++)
        for(int j = 0; j &lt; n;j ++)
        {
            int t = i * n + j;
            a[t][t] = 1;
            int up = (i - 1) * n + j;
            int down = (i + 1) * n + j;
            int left = i * n + j - 1;
            int right = i * n + j + 1;
            if(i &gt; 0)   a[up][t] = 1;
            if(j &gt; 0)   a[left][t] = 1;
            if(i &lt; n - 1)   a[down][t] = 1;
            if(j &lt; n - 1)   a[right][t] = 1;
        }
}
int main()
{
    int t, n;
    char ch;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        getA(n);
        for(int i = 0; i &lt; n; i++)
            for(int j = 0; j &lt; n; j++)
            {
                int t = i * n + j;
                cin &gt;&gt; ch;
                //直接想象那个矩阵
                if(ch == &apos;y&apos;) a[t][n * n] = 0;
                else if(ch == &apos;w&apos;) a[t][n * n] = 1;
            }
        //我好傻
        int ans = Gauss(n * n);
        if(ans == -1)
            printf(&quot;inf\n&quot;);
        else    printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，开关问题</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1753 Flip Game</title>
    <url>/tpaaaaaa.github.io/2019/10/06/POJ-1753FlipGame/</url>
    <content><![CDATA[<p>Flip game is played on a rectangular 4x4 field with two-sided pieces placed on each of its 16 squares. One side of each piece is white and the other one is black and each piece is lying either it’s black or white side up. Each round you flip 3 to 5 pieces, thus changing the color of their upper side from black to white and vice versa. The pieces to be flipped are chosen every round according to the following rules:   </p>
<ol>
<li><p>Choose any one of the 16 pieces.   </p>
</li>
<li><p>Flip the chosen piece and also all adjacent pieces to the left, to the right, to the top, and to the bottom of the chosen piece (if there are any).</p>
</li>
</ol>
<p><img src="https://vj.z180.cn/14b4b3ec0b5261bea3a5ad9f1313252c?v=1570137601" alt=""></p>
<p>Consider the following position as an example: </p>
<p>bwbw<br>wwww<br>bbwb<br>bwwb<br>Here “b” denotes pieces lying their black side up and “w” denotes pieces lying their white side up. If we choose to flip the 1st piece from the 3rd row (this choice is shown at the picture), then the field will become: </p>
<p>bwbw<br>bwww<br>wwwb<br>wwwb<br>The goal of the game is to flip either all pieces white side up or all pieces black side up. You are to write a program that will search for the minimum number of rounds needed to achieve this goal.<br>InputThe input consists of 4 lines with 4 characters “w” or “b” each that denote game field position.OutputWrite to the output file a single integer number - the minimum number of rounds needed to achieve the goal of the game from the given position. If the goal is initially achieved, then write 0. If it’s impossible to achieve the goal, then write the word “Impossible” (without quotes).Sample Input</p>
<p>bwwb<br>bbwb<br>bwwb<br>bwww</p>
<p>Sample Output</p>
<p>4</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>开关问题。一般有两种方式，一种是暴力搜索，一种是高斯消元法。</p>
<p>可以作为解开关问题的模板。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-06    18:16:43
By                : Tpaaaaaa
File_Name         ：Flip Game POJ - 1753 .cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 20;
int a[MAXN][MAXN], b[MAXN][MAXN];
int x[MAXN], free_x[MAXN];
//想象一下是16*16的矩阵哦
//注意是翻成相同面
void getA()
{
    for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++)
        {
            int t = i * 4 + j;
            a[t][t] = 1;
            int up = (i - 1) * 4 + j;
            int down = (i + 1) * 4 + j;
            int left = i * 4 + j - 1;
            int right = i * 4 + j + 1;
            if(i &gt; 0)   a[up][t] = 1;
            if(i &lt; 3)   a[down][t] = 1;
            if(j &gt; 0)   a[left][t] = 1;
            if(j &lt; 3)   a[right][t] = 1; 
        }
}
//n * n的矩阵
//为0，为1都算一遍
//就是将原来的翻转一次即可.
int Gauss(int n)
{
    memset(x, 0, sizeof x);
    memset(free_x, 0, sizeof free_x);
    int col = 0, row = 0;
    int max_r, num = 0;
    for(;col &lt; n &amp;&amp; row &lt; n; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col] &gt; a[max_r][col])   max_r = i;
        if(max_r != row)
            for(int i = col; i &lt;= n; i++)
                swap(a[row][i], a[max_r][i]);
        if(a[row][col] == 0)
        {
            row --;
            free_x[num++] = col;
            continue;
        }
        //开始消
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col])
                for(int j = col; j &lt;= n; j++)
                  a[i][j] ^= a[row][j];
    }
    for(int i = row; i &lt; n; i++)
        if(a[i][col]) return INF;
    int up = 1 &lt;&lt; (n - row);
    int ans = INF;
    for(int i = 0; i &lt; up; i++)
    {
        int cnt = 0;
        int index = i;
        for(int j = 0; j &lt; (n - row); j++)
        {
            x[free_x[j]] = index &amp; 1;
            if(x[free_x[j]]) cnt++;
            index &gt;&gt;= 1;
        }
        //处理完了
        for(int j = row - 1; j &gt;= 0; j--)
        {
            //x[j] = a[j][n];
            int temp = a[j][n];
            for(int l = j + 1; l &lt; n; l++)
                if(a[j][l]) temp ^= x[l];

            x[j] = temp;
            if(x[j])
                cnt++;
        }
        if(cnt &lt; ans)
            ans = cnt;
    }
    return ans;             //我特么是个憨憨
}
int main()
{
    char ch;
    memset(a, 0, sizeof a);
    memset(b, 0, sizeof b);
    getA();
    for(int i = 0; i &lt; 16; i++)
    {
        cin &gt;&gt; ch;
        if(ch == &apos;b&apos;) 
                a[i][16] = 1;    
        else    a[i][16] = 0;
        b[i][16] = a[i][16] ^ 1;
    }
    int ans = Gauss(16);
    memcpy(a, b, sizeof b);
    getA();
    int temp = Gauss(16);
    if(temp &lt; ans)
        ans = temp;

    if(ans &gt;= INF)
        printf(&quot;Impossible\n&quot;);
    else
        printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>高斯消元法，开关问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]高斯消元法</title>
    <url>/tpaaaaaa.github.io/2019/10/06/%5B%E6%A8%A1%E6%9D%BF%5D%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%E6%B3%95/</url>
    <content><![CDATA[<p>神奇。</p>
<p>模板</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
using namespace std;

const int MAXN=50;



int a[MAXN][MAXN];//增广矩阵
int x[MAXN];//解集
bool free_x[MAXN];//标记是否是不确定的变元



/*
void Debug(void)
{
    int i, j;
    for (i = 0; i &lt; equ; i++)
    {
        for (j = 0; j &lt; var + 1; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}
*/


inline int gcd(int a,int b)
{
    int t;
    while(b!=0)
    {
        t=b;
        b=a%b;
        a=t;
    }
    return a;
}
inline int lcm(int a,int b)
{
    return a/gcd(a,b)*b;//先除后乘防溢出
}

// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，
//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.
int Gauss(int equ,int var)
{
    int i,j,k;
    int max_r;// 当前这列绝对值最大的行.
    int col;//当前处理的列
    int ta,tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;

    for(int i=0;i&lt;=var;i++)
    {
        x[i]=0;
        free_x[i]=true;
    }

    //转换为阶梯阵.
    col=0; // 当前处理的列
    for(k = 0;k &lt; equ &amp;&amp; col &lt; var;k++,col++)
    {// 枚举当前处理的行.
// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(abs(a[i][col])&gt;abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k)
        {// 与第k行交换.
            for(j=k;j&lt;var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0)
        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--;
            continue;
        }
        for(i=k+1;i&lt;equ;i++)
        {// 枚举要删去的行.
            if(a[i][col]!=0)
            {
                LCM = lcm(abs(a[i][col]),abs(a[k][col]));
                ta = LCM/abs(a[i][col]);
                tb = LCM/abs(a[k][col]);
                if(a[i][col]*a[k][col]&lt;0)tb=-tb;//异号的情况是相加
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j] = a[i][j]*ta-a[k][j]*tb;
                }
            }
        }
    }

  //  Debug();

    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i &lt; equ; i++)
    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if (k &lt; var)
    {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i &gt;= 0; i--)
        {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num &gt; 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = var - 1; i &gt;= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j &lt; var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}
int main(void)
{
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    int i, j;
    int equ,var;
    while (scanf(&quot;%d %d&quot;, &amp;equ, &amp;var) != EOF)
    {
        memset(a, 0, sizeof(a));
        for (i = 0; i &lt; equ; i++)
        {
            for (j = 0; j &lt; var + 1; j++)
            {
                scanf(&quot;%d&quot;, &amp;a[i][j]);
            }
        }
//        Debug();
        int free_num = Gauss(equ,var);
        if (free_num == -1) printf(&quot;无解!\n&quot;);
   else if (free_num == -2) printf(&quot;有浮点数解，无整数解!\n&quot;);
        else if (free_num &gt; 0)
        {
            printf(&quot;无穷多解! 自由变元个数为%d\n&quot;, free_num);
            for (i = 0; i &lt; var; i++)
            {
                if (free_x[i]) printf(&quot;x%d 是不确定的\n&quot;, i + 1);
                else printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        else
        {
            for (i = 0; i &lt; var; i++)
            {
                printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><p>可以解决的问题：</p>
<p>1.直接找出关系，列方程组求解</p>
<p>2. 开关问题</p>
<p>3. 解模线性方程组</p>
<p>浮点型</p>
<pre><code>const int maxn=1002;
const double eps=1e-12;
double a[maxn][maxn];
int equ,var;//equ个方程,var个变量
double x[maxn];//解集
bool free_x[maxn];
int n;

int sgn(double x)
{
    return (x&gt;eps)-(x&lt;-eps);
}
// 高斯消元法解方程组(Gauss-Jordan elimination).(0表示无解，1表示唯一解，大于1表示无穷解，并返回自由变元的个数)
int gauss()
{
    equ=n,var=n;//多少个方程，多少个变量
    int i,j,k;
    int max_r; // 当前这列绝对值最大的行.
    int col; // 当前处理的列.
    double temp;
    int free_x_num;
    int free_index;
    // 转换为阶梯阵.
    col=0; // 当前处理的列.
    memset(free_x,true,sizeof(free_x));
    for(k=0;k&lt;equ&amp;&amp;col&lt;var;k++,col++)
    {
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(sgn(fabs(a[i][col])-fabs(a[max_r][col]))&gt;0)
                max_r=i;
        }
        if(max_r!=k)
        { // 与第k行交换.
            for(j=k;j&lt;var+1;j++)
                swap(a[k][j],a[max_r][j]);
        }
        if(sgn(a[k][col])==0)
        { // 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--; continue;
        }
        for(i=k+1;i&lt;equ;i++)
        { // 枚举要删去的行.
            if (sgn(a[i][col])!=0)
            {
                temp=a[i][col]/a[k][col];
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j]=a[i][j]-a[k][j]*temp;
                }
            }
        }
    }

    for(i=k;i&lt;equ;i++)
    {
        if (sgn(a[i][col])!=0)
            return 0;
    }
    if(k&lt;var)
    {
        for(i=k-1;i&gt;=0;i--)
        {
            free_x_num=0;
            for(j=0;j&lt;var;j++)
            {
                if (sgn(a[i][j])!=0&amp;&amp;free_x[j])
                    free_x_num++,free_index=j;
            }
            if(free_x_num&gt;1) continue;
            temp=a[i][var];
            for(j=0;j&lt;var;j++)
            {
                if(sgn(a[i][j])!=0&amp;&amp;j!=free_index)
                    temp-=a[i][j]*x[j];
            }
            x[free_index]=temp/a[i][free_index];
            free_x[free_index]=0;
        }
        return var-k;
    }

    for (i=var-1;i&gt;=0;i--)
    {
        temp=a[i][var];
        for(j=i+1;j&lt;var;j++)
        {
            if(sgn(a[i][j])!=0)
                temp-=a[i][j]*x[j];
        }
        x[i]=temp/a[i][i];
    }
    return 1;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>LightOJ - 1170 Counting Perfect BST</title>
    <url>/tpaaaaaa.github.io/2019/10/04/LightOJ-1170CountingPerfectBST/</url>
    <content><![CDATA[<p>BST is the acronym for Binary Search Tree. A BST is a tree data structure with the following properties.</p>
<p>i)        Each BST contains a root node and the root may have zero, one or two children. Each of the children themselves forms the root of another BST. The two children are classically referred to as left child and right child.</p>
<p>ii)      The left subtree, whose root is the left children of a root, contains all elements with key values less than or equal to that of the root.</p>
<p>iii)    The right subtree, whose root is the right children of a root, contains all elements with key values greater than that of the root.</p>
<p>An integer m is said to be a perfect power if there exists integer <strong>x &gt; 1</strong> and <strong>y &gt; 1</strong> such that <strong>m = xy</strong>. First few perfect powers are {4, 8, 9, 16, 25, 27, 32, 36, 49, 64, 81, 100, 121, 125, 128, 144, …}. Now given two integer <strong>a</strong> and <strong>b</strong> we want to construct BST using all perfect powers between <strong>a</strong> and <strong>b</strong>, where each perfect power will form the key value of a node.</p>
<p>Now, we can construct several BSTs out of the perfect powers. For example, given <strong>a = 1</strong> and <strong>b = 10</strong>, perfect powers between <strong>a</strong> and <strong>b</strong> are 4, 8, 9. Using these we can form the following five BSTs.</p>
<p><strong>4           4         8          9         9</strong></p>
<p>**  \          \      / \      /         /**</p>
<p>**    8          9   4     9   4         8**</p>
<p>**      \      /                 \      /**</p>
<pre><code>**9   8                     8   4**</code></pre><p>In this problem, given <strong>a</strong> and <strong>b</strong>, you will have to determine the total number of BSTs that can be formed using perfect powers between <strong>a</strong> and <strong>b</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20000)**, denoting the number of test cases.</p>
<p>Each case of input contains two integers: <strong>a</strong> and <strong>b (1 ≤ a ≤ b ≤ 1010, b - a ≤ 106)</strong> as defined in the problem statement.Output</p>
<p>For each case, print the case number and the total number of distinct BSTs that can be formed by the perfect powers between <strong>a</strong> and <strong>b</strong>. Output the result modulo <strong>100000007</strong>.Sample Input</p>
<p>4</p>
<p>1 4</p>
<p>5 10</p>
<p>1 10</p>
<p>1 3Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 2</p>
<p>Case 3: 5</p>
<p>Case 4: 0</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>卡特兰数。</p>
<pre><code>问你n个不同的数，能够构成多少种不同的BST，这是一个卡特兰数。
设dp[n]为n个........
则dp[n] = dp[0]dp[n-1] + dp[1]dp[n-2] ... dp[n-1]dp[0]
满足这样的递推公式的数，就是卡特兰数
他有一个通项公式是
dp[n] = C(2n, n) - C(2n, n - 1)
化简一下就是 dp[n] = C(2n, n) / (n+1);</code></pre><p><strong>卡特兰数常见的应用：</strong></p>
<p>博客地址：<a href="https://blog.csdn.net/wookaikaiko/article/details/81105031" target="_blank" rel="noopener">https://blog.csdn.net/wookaikaiko/article/details/81105031</a></p>
<p> ** 1、进出栈问题**</p>
<p> <strong>2、二叉树构成问题</strong></p>
<p><strong>3、凸多边形的三角形划分</strong></p>
<p><strong>4、有n+1个叶子的满二叉树的个数？</strong></p>
<p><strong>5、在n*n的格子中，只在下三角行走，每次横或竖走一格，有多少中走法？</strong></p>
<p>** 6、将一个凸n+2边形区域分成三角形区域的方法数？**</p>
<p><strong>自己想出递归公式dp[n] = dp[0]dp[n-1] + dp[1]dp[n-2] … dp[n-1]dp[0]</strong></p>
<p><strong>然后辨析出他是卡特兰数，就可以用前人归纳的组合数来简化运算。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;set&gt;
using namespace std;
const int MAXN = 1e6 + 10;
const int MOD  = 100000007;
typedef long long ll;
ll pPow[MAXN], pn, dp[MAXN];
/*
    用筛选法，求出perfect power？？
    问你n个不同的数，能够构成多少种不同的BST，这是一个卡特兰数。
    设dp[n]为n个........
    则dp[n] = dp[0]dp[n-1] + dp[1]dp[n-2] ... dp[n-1]dp[0]
    满足这样的递推公式的数，就是卡特兰数
    他有一个通项公式是
    dp[n] = C(2n, n) - C(2n, n - 1)
    化简一下就是 dp[n] = C(2n, n) / (n+1);

    所以我们接下来的任务就是求出[a, b]之中的perfect powers的数目n了
    因为不超过1e10,所以开方后不超过1e5
    所以我们只需要枚举1e5的数，然后将这些数产生的perfect powers 存入即可
    然后再去重和排序
    lower_bound( begin,end,num) 大于或等于num的数字
    upper_bound                 大于
    对于任意(a,b)中的perfect power数，我们采用自带的二分
    pos1 = upper_bound(a);
    pos2 = upper_bound(b);
    n = pos2 - pos1;
    输出dp[n]即可
*/
//打表卡特兰数.
void init()
{
    ll temp;
    pn = 0;
    for(ll i = 2; i &lt;= 100000; i++)
    {
        ll temp = i * i;
        while(temp &lt;= 1e10)
        {
            pPow[++pn] = temp;
            temp *= i;
        }
    }
    sort(pPow, pPow + pn);
    pn = unique(pPow, pPow + pn) - pPow;
    //pn就是1e10中的perfect pow数的数目
    dp[0]  = 1;
    dp[1] = 1;
    for(int i = 2; i &lt; 1111; i++)
    {
        for(int j = 1; j &lt;= i; j++)
        {
            dp[i] += dp[j - 1] * dp[i - j];
            dp[i] %= MOD;
        }
    }
    dp[0] = 0; 
}
int getN(ll a, ll b)
{
    int pos1 = lower_bound(pPow, pPow + pn, a) - pPow;
    int pos2 = upper_bound(pPow, pPow + pn, b) - pPow;
    return pos2 - pos1;
}
int main()
{
    init();
    int t;
    cin &gt;&gt; t;
    ll a, b;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%lld%lld&quot;, &amp;a, &amp;b);
        int n = getN(a, b);
        printf(&quot;Case %d: %lld\n&quot;, kase, dp[n]);
    }
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>卡特兰数，二叉树构成数</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1117 Helping Cicada</title>
    <url>/tpaaaaaa.github.io/2019/10/04/LightOJ-1117HelpingCicada/</url>
    <content><![CDATA[<p>Cicada is an insect with large transparent eyes and well-veined wings similar to the “jar flies”. The insects are thought to have evolved 1.8 million years ago during the Pleistocene epoch. There are about 2,500 species of cicada around the world which live in temperate tropical climates.</p>
<p>These are all sucking insects, which pierce plants with their pointy mouthparts and suck out the juices. But there are some predators (like birds, the Cicada Killer Wasp) that attack cicadas. Each of the predators has a periodic cycle of attacking Cicadas. For example, birds attack them every three years; wasps attack them every 2 years. So, if Cicadas come in the 12th year, then birds or wasps can attack them. If they come out in the 7th year then no one will attack them.</p>
<p>So, at first they will choose a number <strong>N</strong> which represents possible life-time. Then there will be an integer <strong>M</strong> indicating the total number of predators. The next <strong>M</strong> integers represent the life-cycle of each predator. The numbers in the range from <strong>1</strong> to <strong>N</strong> which are not divisible by any of those <strong>M</strong>life-cycles numbers will be considered for cicada’s safe-emerge year. And you want to help them.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 125)**, denoting the number of test cases.</p>
<p>Each case contains two integers <strong>N (1 ≤ N &lt; 231)</strong> and <strong>M (1 ≤ M ≤ 15)</strong>. The next line contains <strong>M</strong>positive integers (fits into <strong>32</strong> bit signed integer) denoting the life cycles of the predators.Output</p>
<p>For each test case, print the case number and the number of safe-emerge days for cicada.Sample Input</p>
<p>2</p>
<p>15 3</p>
<p>2 3 5</p>
<p>10 4</p>
<p>2 4 5 7Sample Output</p>
<p>Case 1: 4</p>
<p>Case 2: 3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们知道[1..N] 中能够被k整除的数的数目为 N/k 向下取整 因此可以利用容斥定理</p>
<p>容斥定理部分：</p>
<pre><code>for(int i = 1; i &lt; (1 &lt;&lt; m); i++)
{
    ll LCM = 1;
    int cnt = 0;            //记录是多少个数的LCM，如果是奇数则减，偶数则加
    for(int j = 0; j &lt; m; j++)
    {
        if(i &amp; (1 &lt;&lt; j))
        {
            cnt ++;
            LCM = lcm(LCM, a[j + 1]);
        }
    }
    if(cnt &amp; 1)
        ans += n / LCM;
    else
        ans -= n / LCM;
}</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-04    13:22:05
By                : Tpaaaaaa
File_Name         ：LightOJ1117HelpingCicada.cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

我们知道[1..N] 中能够被k整除的数的数目为 N/k 向下取整  因此可以利用容斥定理

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 20;
ll a[MAXN];
ll gcd(ll a, ll b)
{
    if(b == 0)  return a;
    return      gcd(b, a%b);
}
ll lcm(ll a, ll b)
{
    return a / gcd(a, b) * b;
}
int main()
{
   int t, m;
   ll n;
   cin &gt;&gt;t;
   for(int kase = 1; kase &lt;= t; kase ++)
   {
        scanf(&quot;%lld%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
            scanf(&quot;%lld&quot;, &amp;a[i]);
        ll ans = 0;
        //状态压缩
        //ans记录的是被吃的日子
        //n - ans 就是答案了
        for(int i = 1; i &lt; (1 &lt;&lt; m); i++)
        {
            ll LCM = 1;
            int cnt = 0;            //记录是多少个数的LCM，如果是奇数则减，偶数则加
            for(int j = 0; j &lt; m; j++)
            {
                if(i &amp; (1 &lt;&lt; j))
                {
                    cnt ++;
                    LCM = lcm(LCM, a[j + 1]);
                }
            }
            if(cnt &amp; 1)
                ans += n / LCM;
            else
                ans -= n / LCM;
        }
        printf(&quot;Case %d: %lld\n&quot;, kase, n - ans);
   }
   return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>容斥定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1124 Cricket Ranking</title>
    <url>/tpaaaaaa.github.io/2019/10/04/LightOJ-1124CricketRanking/</url>
    <content><![CDATA[<p>World Cup Cricket 2011 is coming. Many of you may not be interested in cricket, but it’s really a passion in our subcontinent. Ranking of cricketers is a common phenomenon there. Cricketers are ranked by their performance in both form of cricket (Test and One-day). People really enjoy this ranking. They like to see their favorite players as top ranked. Currently many such rankings are available. And as you have guessed, each ranking makes a different player as top ranked.</p>
<p>World Cup committee has decided that they will make a new ranking on the performance of players in the world cup. They want the ranking to be acceptable to the public. The rules are:</p>
<p>1)  There are <strong>K</strong> different departments. Cricketers will be given points in each department depending on their performance.</p>
<p>2)  The maximum points for each department are not equal. Such as Sakib Al Hasan can get maximum 25 points in batting but Mushfiqur Rahim can get maximum 10 points for his spectacular wicket keeping.</p>
<p>3)  The sum of maximum points of all departments will be exactly <strong>N</strong> points. And the final ranking will depend on the total earned points out of <strong>N</strong> points.</p>
<p>The ranking committee wants popular cricketers to get top ranked. To do so, they even allow maximum points for fielding more than that of batting. But that can bring lots of criticism. So they decide to fix a range of points for each department. Such as maximum points for batting will be at least 10 and at most 15 or for fielding, it will be at least 8 and at most 12. But the total points will be 20. Then 3 ranking systems are possible, such as: (10, 10), (11, 9) and (12, 8) for batting and fielding respectively. In this problem, you have to find the number of ranking systems possible for given number of departments, range of points for each department and total points.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with a blank line and two integers <strong>K (1 ≤ K ≤ 10)</strong> and <strong>N (1 ≤ N ≤ 106)</strong>. Each of the next <strong>K</strong> lines denotes the lower and upper limit of allowable maximum points for each department. These integers will be in the range <strong>[0, 106]</strong>. And the lower limit of each department will always be less than or equal to the upper limit of that department.Output</p>
<p>For each case, print the case number and the number of rankings possible modulo <strong>100000007</strong>.Sample Input</p>
<p>4</p>
<p>4 10</p>
<p>1 1</p>
<p>2 2</p>
<p>3 3</p>
<p>4 4</p>
<p>4 10</p>
<p>1 1</p>
<p>2 2</p>
<p>3 3</p>
<p>3 3</p>
<p>2 10</p>
<p>1 10</p>
<p>1 10</p>
<p>2 20</p>
<p>10 15</p>
<p>8 12</p>
<p>Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 0</p>
<p>Case 3: 9</p>
<p>Case 4: 3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目大意：给你n个区间，在每个区间里面取一个值，使得这n个值的和为s</p>
<p><strong>隔板法的应用（变量取值有下限）</strong></p>
<p><strong>一般问题1</strong></p>
<p>x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为1</p>
<p>这就可以用隔板法, s 个 元素，就有 s - 1 个空隙，我们要将s个元素分成n部分，每部分最少为1，则需要往其中插入n - 1 个 隔板，所以组合数为C(s - 1, n - 1);</p>
<p><strong>一般问题2</strong></p>
<p>x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为0</p>
<p>这就可以用隔板法, 我们要将s个元素分成n部分，每部分最少为0，则需要往其中再添加n个元素，所以我们的任务是将s + n个元素分成 n 部分，每部分最少为1，所以组合数为C(s + n - 1, n - 1);</p>
<p><strong>一般问题3</strong></p>
<p>x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中 x[i] 至少为 v[i].</p>
<p>我们可以设法将这类问题转化为我们已知组合数的一般问题2和一般问题1.</p>
<p>我们设新的x[i]</p>
<p>得到方程</p>
<p>(x[1] + v[1]) + (x[2] + v[2]) + …. + (x[n] + v[n]) = s;</p>
<p>然后再将v[i] 全部移到左边，得到新的 s = s - v[1] - v[2] … - v[n]</p>
<p>所以得到新的式子</p>
<p>x[1] + x[2] + .. + x[n] = s 其中x[i] 至少为0. 变化为一般问题2了.</p>
<p>对于本题，<strong>变量的取值是额外有上限的</strong>。 正难则反，我们则考虑超过上限的组合数，然后用总的组合数减去它即可 <strong>记得要搭配上容斥定理哟</strong>， 就转化为一般问题3了。</p>
<p><strong>卢卡斯定理（组合数取模）：</strong></p>
<pre><code>//返回a^b次模MOD
ll qpow(ll a, ll b)
{
    ll ans = 1;
    while(b)
    {
        if(b &amp; 1)   
            ans = (ans * a) % MOD;
        a = (a * a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}
// 返回x模MOD的逆元
ll inv(ll x)
{
    return qpow(x, MOD - 2);
}
// 返回组合数C(a, b)
ll C(ll a, ll b)
{
    if(a &lt; b) return 0;
    ll up = 1, down = 1;    //分子分母
    for(int i = a - b + 1; i &lt;= a; i++)
        up = up * i % MOD;
    for(int i = 1; i &lt;= b; i++)
        down = down * i % MOD;
    return up * inv(down) % MOD;
}
ll lucas(ll a, ll b)
{
    if(b == 0)  return 1;
    return C(a % MOD, b % MOD) * lucas(a / MOD, b / MOD) % MOD;
}</code></pre><p><strong>容斥定理部分</strong></p>
<pre><code>for(int i = 1; i &lt; (1 &lt;&lt; n); i++)
{
    int cnt = 0;
    ll temp = s;
    for(int j = 0; j &lt; n; j++)
    {
        if(i &amp; (1 &lt;&lt; j))
        {
            cnt ++;             //记录超过界限的数目
            temp -= v[j] + 1;   //减去他。
        }
    }
    if(temp &lt; 0) continue;      //非法
    ans += f[cnt &amp; 1] * lucas(temp + n - 1, n - 1);
    ans = (ans % MOD + MOD) % MOD; 
}</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-04    13:48:37
By                : Tpaaaaaa
File_Name         ：Cricket Ranking LightOJ - 1124 .cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题
给你n个区间，在每个区间里面取一个值，使得这n个值的和为s
x1 + x2 + x3 + ... + xn = s;
x1 属于[l1, r1], x2 属于[l2, r2] .....
我们左右减去l1 + l2 ... + ln
得到新的式子
x1 + x2 + x3 + ... + xn = s;
其中x1 属于[0, r1 - l1] .....
如果x是非负整数的话，排列数就是C(s + n - 1, n - 1);
但是要减去超过每个变量上限的数目。
这就要用到容斥定理了
减去超过一个过界的数目，加上两个过界的数目....
用状态压缩的方法来枚举。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 100;
const int MOD = 100000007; 
ll v[MAXN]; 
ll n, s;
//返回a^b次模MOD
ll qpow(ll a, ll b)
{
    ll ans = 1;
    while(b)
    {
        if(b &amp; 1)   
            ans = (ans * a) % MOD;
        a = (a * a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}
// 返回x模MOD的逆元
ll inv(ll x)
{
    return qpow(x, MOD - 2);
}
// 返回组合数C(a, b)
ll C(ll a, ll b)
{
    if(a &lt; b) return 0;
    ll up = 1, down = 1;    //分子分母
    for(int i = a - b + 1; i &lt;= a; i++)
        up = up * i % MOD;
    for(int i = 1; i &lt;= b; i++)
        down = down * i % MOD;
    return up * inv(down) % MOD;
}
ll lucas(ll a, ll b)
{
    if(b == 0)  return 1;
    return C(a % MOD, b % MOD) * lucas(a / MOD, b / MOD) % MOD;
}
ll solve()
{
    ll ans = lucas(s + n - 1, n - 1);
    int f[2] = {1, -1};
    for(int i = 1; i &lt; (1 &lt;&lt; n); i++)
    {
        int cnt = 0;
        ll temp = s;
        for(int j = 0; j &lt; n; j++)
        {
            if(i &amp; (1 &lt;&lt; j))
            {
                cnt ++;             //记录超过界限的数目
                temp -= v[j] + 1;   //减去他。
            }

        }
        if(temp &lt; 0) continue;      //非法
        ans += f[cnt &amp; 1] * lucas(temp + n - 1, n - 1);
        ans = (ans % MOD + MOD) % MOD; 
    }
    return ans;
}
int main()
{
   int t;
   cin &gt;&gt;t;
   for(int kase = 1; kase &lt;= t; kase ++)
   {
       //n个区间，和为s
       scanf(&quot;%lld%lld&quot;, &amp;n, &amp;s);
       for(int i = 0; i &lt; n; i++)
       {
           ll l, r;
           scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r);
           r -= l;
           s -= l;
           v[i] = r;                //v[i]就是该变量的上界
       }
       printf(&quot;Case %d: %lld\n&quot;, kase, solve());
   }
   return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>隔板法，卢卡斯定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1028 Trailing Zeroes (I)</title>
    <url>/tpaaaaaa.github.io/2019/10/04/LightOJ-1028TrailingZeroes(I)/</url>
    <content><![CDATA[<p>We know what a base of a number is and what the properties are. For example, we use decimal number system, where the base is <strong>10</strong> and we use the symbols - <strong>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}</strong>. But in different bases we use different symbols. For example in binary number system we use only <strong>0</strong> and <strong>1</strong>. Now in this problem, you are given an integer. You can convert it to any base you want to. But the condition is that if you convert it to any base then the number in that base should have at least one trailing zero that means a zero at the end.</p>
<p>For example, in decimal number system <strong>2</strong> doesn’t have any trailing zero. But if we convert it to binary then <strong>2</strong> becomes <strong>(10)2</strong> and it contains a trailing zero. Now you are given this task. You have to find the number of bases where the given number contains at least one trailing zero. You can use any base from two to infinite.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each case contains an integer <strong>N (1 ≤ N ≤ 1012)</strong>.Output</p>
<p>For each case, print the case number and the number of possible bases where <strong>N</strong> contains at least one trailing zero.Sample Input</p>
<p>3</p>
<p>9</p>
<p>5</p>
<p>2Sample Output</p>
<p>Case 1: 2</p>
<p>Case 2: 1</p>
<p>Case 3: 1</p>
<p>Note</p>
<p>For <strong>9</strong>, the possible bases are: <strong>3</strong> and <strong>9</strong>. Since in base <strong>3</strong>; <strong>9</strong> is represented as <strong>100</strong>, and in base <strong>9</strong>; <strong>9</strong> is represented as <strong>10</strong>. In both bases, <strong>9</strong> contains a trailing zero.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>经过分析可知，实际上求的是n的除去1的因子数。所以可以用唯一分解定理求解因子数，减1就是答案了。</p>
<p>辨析两个概念</p>
<p>因子和因数很相似，但有区别。<br>因子不包括数本身<br>因数包括<br><strong>如10的因子是1，2，5</strong><br><strong>因数是1，2，5，10</strong></p>
<p>唯一分解定理求的是因数的数目.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
Date              : 2019-10-04    20:11:04
By                : Tpaaaaaa
File_Name         ：Trailing Zeroes (I) LightOJ - 1028 .cpp
Description       : 
目前正在专项刷题，为了保证效果。
必须做到：
   1，先想出完整思路，并分析复杂度。
   2. 按照自己的思路过一遍样例，自己编几个复杂的样例
   3. 编写代码的时候，规范风格（例如变量名）
   4. 模块化答题

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
ll prime[MAXN];
int top;
void init()
{
    memset(Isprime, true, sizeof Isprime);
    Isprime[1] = false;
    top = 0;
    for(ll i = 2; i &lt; MAXN; i++)
    {
        if(Isprime[i])
        {
            prime[++top] = i;
            for(ll j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
    }
}
//唯一分解定理可以求因子数和因子和
ll solve(ll n)
{
    ll sum = 1;
    for(int i = 1; i &lt;= top &amp;&amp; prime[i] * prime[i] &lt;= n; i++)
    {
        if(n % prime[i] == 0)
        {
            int temp = 0;           //指数
            while(n % prime[i] == 0)
            {
                temp ++;
                n = n / prime[i];
            }
            sum *= 1 + temp;
        }

    }
    if(n &gt; 1)
        sum *= 2;
    return sum;
}
int main()
{
   int t;
   init();
   ll n;
   cin &gt;&gt; t;
   for(int kase = 1; kase &lt;= t; kase++)
   {
       scanf(&quot;%lld&quot;, &amp;n);
       printf(&quot;Case %d: %lld\n&quot;, kase, solve(n) - 1);
   }
   return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理求因子数</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1058 Parallelogram Counting</title>
    <url>/tpaaaaaa.github.io/2019/10/03/LightOJ-1058ParallelogramCounting/</url>
    <content><![CDATA[<p>There are <strong>n</strong> distinct points in the plane, given by their integer coordinates. Find the number of parallelograms whose vertices lie on these points. In other words, find the number of 4-element subsets of these points that can be written as <strong>{A, B, C, D}</strong> such that <strong>AB || CD</strong>, and <strong>BC || AD</strong>. No four points are in a straight line.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 15)**, denoting the number of test cases.</p>
<p>The first line of each test case contains an integer <strong>n (1 ≤ n ≤ 1000)</strong>. Each of the next <strong>n</strong> lines, contains <strong>2</strong> space-separated integers <strong>x</strong> and <strong>y</strong> (the coordinates of a point) with magnitude (absolute value) of no more than <strong>1000000000</strong>.Output</p>
<p>For each case, print the case number and the number of parallelograms that can be formed.Sample Input</p>
<p>2</p>
<p>6</p>
<p>0 0</p>
<p>2 0</p>
<p>4 0</p>
<p>1 1</p>
<p>3 1</p>
<p>5 1</p>
<p>7</p>
<p>-2 -1</p>
<p>8 9</p>
<p>5 7</p>
<p>1 1</p>
<p>4 8</p>
<p>2 0</p>
<p>9 8Sample Output</p>
<p>Case 1: 5</p>
<p>Case 2: 6</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>平行四边形存在定理。</p>
<p>两根线段的中点在同一个位置，那么这两个线段就能组成一个平行四边形的一对对角线。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-03-12.58.48
 By                : Tpaaaaaa
 Question_Number   ：Parallelogram Counting LightOJ - 1058
 Question_Name     ：简单数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

求出每个线段的中点，然后按照中点排序
对于有着相同中点的两个线段，可以组成一个平行四边形
因此我们得到每个中点所在的线段数
在这些线段中任意取两个即可
即C(n,2)
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
struct Poi
{
    int x, y;
    friend bool operator &lt; (Poi A, Poi B)
    {
        if(A.x == B.x)  return A.y &lt; B.y;
        else            return A.x &lt; B.x;
    }
};
Poi poi[MAXN];
Poi mid[MAXN*MAXN];
int main()
{
    int t;
    int n;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;, &amp;poi[i].x, &amp;poi[i].y);
        int ind = 0;
        for(int i = 1; i &lt; n; i++)
            for(int j = i + 1; j &lt;= n; j++)
            {
                ind++;
                mid[ind].x = (poi[i].x + poi[j].x) ;        //有点东西哦
                mid[ind].y = (poi[i].y + poi[j].y) ;
            }
        sort(mid + 1, mid + 1 + ind);
        int cnt = 1;
        ll ans = 0;
        for(int i = 1; i &lt; ind; i++)
        {
            if(mid[i].x == mid[i + 1].x &amp;&amp; mid[i].y == mid[i + 1].y)
            {
                cnt ++;                                             //记录的是同一中点的数目
            }
            else
            {
                ans += cnt*(cnt - 1) / 2;
                cnt  = 1;
            }
        }
        printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>平行四边形存在定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1067 Combinations</title>
    <url>/tpaaaaaa.github.io/2019/10/03/LightOJ-1067Combinations/</url>
    <content><![CDATA[<p>Given <strong>n</strong> different objects, you want to take <strong>k</strong> of them. How many ways to can do it?</p>
<p>For example, say there are 4 items; you want to take 2 of them. So, you can do it 6 ways.</p>
<p><strong>Take 1, 2</strong></p>
<p><strong>Take 1, 3</strong></p>
<p><strong>Take 1, 4</strong></p>
<p><strong>Take 2, 3</strong></p>
<p><strong>Take 2, 4</strong></p>
<p><strong>Take 3, 4</strong>Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 2000)**, denoting the number of test cases.</p>
<p>Each test case contains two integers <strong>n (1 ≤ n ≤ 106), k (0 ≤ k ≤ n)</strong>.Output</p>
<p>For each case, output the case number and the desired value. Since the result can be very large, you have to print the result modulo <strong>1000003</strong>.Sample Input</p>
<p>3</p>
<p>4 2</p>
<p>5 0</p>
<p>6 4Sample Output</p>
<p>Case 1: 6</p>
<p>Case 2: 1</p>
<p>Case 3: 15</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>组合数取模的模板题。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><pre><code>/*
 Date              : 2019-10-03-13.16.39
 By                : Tpaaaaaa
 Question_Number   ：Combinations LightOJ - 1067
 Question_Name     ：排列组合
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

般对于大组合数取模，a,b不大于10^5的话，
用逆元的方法，可以解决。
对于a,b大于10^5的话，要求p&lt;10^5，
这样就是Lucas定理了，将a,b转化到10^5以内解。
而这题a,b,p虽然都大于10^5，但也没有大太多，
依然可以用Lucas定理来解决，以下就是AC代码。

解这种组合数取模的题目
有两种解法，一种是用数论的逆
另一种是卢卡斯定理

打表的方法：阶乘表，逆元表
费马小定理
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 100;
ll fac[MAXN];                                               //改了这里
ll ni[MAXN], ans;
#define mod 1000003
//求的是x的k次方
ll qpow(ll x,int k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans*x)%mod;
        x = (x*x)%mod;
        k &gt;&gt;= 1;
    }
    return ans;
}
//打表的方法，阶乘表，逆元表哦
void init()
{
    fac[0] = 1; //存的是阶乘模mod
    ni[0] = 1;  //在存的是这个阶乘的值对模的逆元表
    for(int i = 1; i &lt; MAXN; i++)   //????????EXM？？？？？？？？？改了这里
    {
        //显然mod 与 pri互质
        //因为mod是素数，显然互素。
        fac[i] = fac[i-1] * i % mod;
        //printf(&quot;fac[i] = %d\n&quot;, fac[i]);
        //qpow是快速幂取模
        ni[i] = qpow(fac[i], mod - 2);
    }
}
int main()
{
    init();
    int t, n, k;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        ans = ((fac[n]*ni[k]%mod)*ni[n-k])%mod;
        printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>用费马小定理求逆元</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1095 Arrange the Numbers</title>
    <url>/tpaaaaaa.github.io/2019/10/03/LightOJ-1095ArrangetheNumbers/</url>
    <content><![CDATA[<p>Consider this sequence <strong>{1, 2, 3 … N}</strong>, as an initial sequence of first <strong>N</strong> natural numbers. You can rearrange this sequence in many ways. There will be a total of <strong>N!</strong> arrangements. You have to calculate the number of arrangement of first <strong>N</strong> natural numbers, where in first <strong>M</strong> positions; exactly <strong>K</strong> numbers are in their initial position.</p>
<p>For Example, <strong>N = 5, M = 3, K = 2</strong></p>
<p>You should count this arrangement <strong>{1, 4, 3, 2, 5}</strong>, here in first 3 positions 1 is in <strong>1st</strong> position and 3 in <strong>3rd</strong> position. So exactly 2 of its first 3 are in there initial position.</p>
<p>But you should not count <strong>{1, 2, 3, 4, 5}</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 1000)**, denoting the number of test cases.</p>
<p>Each case contains three integers <strong>N (1 ≤ N ≤ 1000), M (M ≤ N), K (0 &lt; K ≤ M)</strong>.Output</p>
<p>For each case, print the case number and the total number of possible arrangements modulo <strong>1000000007</strong>.Sample Input</p>
<p>2</p>
<p>5 3 2</p>
<p>10 6 3Sample Output</p>
<p>Case 1: 12</p>
<p>Case 2: 64320</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>黑板上排列组合，你舍得解开吗</p>
<p>两种思路：1、错排公式 2、容斥定理。</p>
<p>利用了组合数取模。利用的是扩展欧几里得求逆元。</p>
<p>1、错排公式</p>
<p>dp[n] 表示的是将n个元素错排的方法数</p>
<p>可知 dp[n] = (n-1)dp[n-2] + (n-1)dp[n-1];</p>
<p>dp[0] = 1; dp[1] = 0; dp[2] = 1; dp[3] = 2;</p>
<p>2、容斥定理（我自己推的，太难写了，略）</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-03-15.54.55
 By                : Tpaaaaaa
 Question_Number   ：Arrange the Numbers LightOJ - 1095
 Question_Name     : 错排公式||容斥定理
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

    可以用错排公式求解，也可以用容斥定理推（自己推出来啦）
    用递推公式求错排数组
    dp[n] 表示的是将n个元素错排的方法数
    可知
    dp[n] = (n-1)dp[n-2] + (n-1)dp[n-1];
    //见收藏的博客
    显然dp[2] = 1;
        dp[3] = 2;
    所以我们枚举后面 n - m个数中需要错排的数目i [0, n - m]
    与前面必须要错排的 m - k个数凑在一起，一共要有 m - k + i 个元素进行错排
    将这些情况累加。最后与C(m,k)相乘即可


    C(N, M) = N!/M!/(N-M)!
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MOD  = 1000000007;
ll dp[MAXN], ni[MAXN], fac[MAXN];
ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        ll temp = exgcd(b, a%b, y, x);
        y -= x * (a / b);
        return temp;
    }
}
void init()//考虑取模
{
    dp[0] = 1;
    dp[1] = 0;              //WA的原因
    dp[2] = 1;
    dp[3] = 2;
    for(int i = 4; i &lt; MAXN; i++)
        dp[i] = ( (i - 1) * ((dp[i - 1] + dp[i - 2]) % MOD)) % MOD;

    //求出fac表和逆表
    fac[0] = 1;
    ni[0] = 1;
    ll x, y;
    for(int i = 1; i &lt; MAXN; i++)
    {
        fac[i] = (fac[i - 1] * i) % MOD;
        exgcd(fac[i], MOD, x, y);
        ni[i] = (x % MOD + MOD) % MOD;
    }
}
ll C(int N, int M)
{
    return ((fac[N] * ni[M]) % MOD * ni[N - M]) % MOD;
}
int main()
{
    int t;
   // freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    //freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);
    init();
    cin &gt;&gt;t;
    int n, m, k;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
        ll ans = 0;
        for(int i = 0; i &lt;= n - m; i++)
            ans = (ans + (C(n - m, i) * dp[m - k + i]) % MOD) % MOD;

        ans = (ans * C(m, k)) % MOD ;
        printf(&quot;Case %d: %lld\n&quot;, kase, ans);
    }
 //   fclose(stdin);
 //   fclose(stdout);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>扩展欧几里得求逆元，错排公式</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1102 Problem Makes Problem</title>
    <url>/tpaaaaaa.github.io/2019/10/03/LightOJ-1102ProblemMakesProblem/</url>
    <content><![CDATA[<p>As I am fond of making easier problems, I discovered a problem. Actually, the problem is ‘how can you make <strong>n</strong> by adding <strong>k</strong> non-negative integers?’ I think a small example will make things clear. Suppose <strong>n=4</strong> and <strong>k=3</strong>. There are <strong>15</strong> solutions. They are</p>
<ol>
<li><p>0 0 4</p>
</li>
<li><p>0 1 3</p>
</li>
<li><p>0 2 2</p>
</li>
<li><p>0 3 1</p>
</li>
<li><p>0 4 0</p>
</li>
<li><p>1 0 3</p>
</li>
<li><p>1 1 2</p>
</li>
<li><p>1 2 1</p>
</li>
<li><p>1 3 0</p>
</li>
<li><p>2 0 2</p>
</li>
<li><p>2 1 1</p>
</li>
<li><p>2 2 0</p>
</li>
<li><p>3 0 1</p>
</li>
<li><p>3 1 0</p>
</li>
<li><p>4 0 0</p>
</li>
</ol>
<p>As I have already told you that I use to make problems easier, so, you don’t have to find the actual result. You should report the result modulo <strong>1000,000,007</strong>.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 25000)**, denoting the number of test cases.</p>
<p>Each case contains two integer <strong>n (0 ≤ n ≤ 106)</strong> and <strong>k (1 ≤ k ≤ 106)</strong>.Output</p>
<p>For each case, print the case number and the result modulo <strong>1000000007</strong>.Sample Input</p>
<p>4</p>
<p>4 3</p>
<p>3 5</p>
<p>1000 3</p>
<p>1000 5Sample Output</p>
<p>Case 1: 15</p>
<p>Case 2: 35</p>
<p>Case 3: 501501</p>
<p>Case 4: 84793457</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>根据隔板法，我们知道答案就是C(n+k-1, k-1)</p>
<p><strong>隔板法</strong>就是在n个元素间的（n-1）个空中插入k个板，可以把n个元素分成k+1组的方法。　　</p>
<p>应用隔板法必须满足3个条件： 　　<br>（1） 这n个元素必须互不相异；<br>（2） 所分成的每一组<strong>至少分得1个元素</strong>；<br>（3） 分成的组别彼此相异。</p>
<p><strong>公式</strong><br>把10个相同的小球放入3个不同的箱子，每个箱子至少一个，问有几种情况？</p>
<p>C（n-1，m-1）=C(9.2)</p>
<p><strong>例2. 求方程 x+y+z=10的非负整数解的个数。</strong></p>
<p>分析：注意到x、y、z可以为零，故例1解法中的限定“每空至多插一块隔板”就不成立了，怎么办呢？只要添加三个球，给x、y、z各添加一个球，这样原问题就转化为求 x+y+z=13的正整数解的个数了，则问题就等价于把13个相同小球放入3个不同箱子，每个箱子至少一个，有几种情况？易得解的个数为C（n+m-1,m-1）=C（12，2）=66（个）。</p>
<p>隔板法博客<a href="https://blog.csdn.net/sdz20172133/article/details/81431066" target="_blank" rel="noopener">https://blog.csdn.net/sdz20172133/article/details/81431066</a></p>
<p><strong>组合数取模问题总结：</strong></p>
<p>1、数据量不大于10e6的情况下，可以考虑使用打表法，打出fac表和逆元表</p>
<p><strong>注意开4e6的数组会爆32mb的内存。</strong></p>
<p>那么打逆元表的方法又有两种，一种是利用扩展欧几里得算法求逆元，一种是用费马小定理+快速幂求逆元。</p>
<p>2、数据量大的情况下，考虑卢卡斯定理。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-03-16.51.19
 By                : Tpaaaaaa
 Question_Number   ：Problem Makes Problem LightOJ - 1102
 Question_Name     ：隔板法，再练练费马小定理解组合数取模
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

根据隔板法，我们知道答案就是C(n+k-1, k-1)
解组合数取模，有三种方法
一种是打出阶乘表，用Exgcd解出逆元表。然后求
一种是打出阶乘表，用费马小定理解出逆元表。然后求
一种是卢卡斯定理。

本题练习费马小定理
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF  = 0x3f3f3f3f;
const int MAXN = 2e6 + 10;
const ll MOD  = 1000000007;
ll fac[MAXN];
//可以不打逆元表，会爆内存。
//所以可以知道,4e6的数组会爆32mb的内存。大概34mb左右
ll qpow(ll x, ll k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans * x) % MOD;
        x = (x * x) % MOD;
        k &gt;&gt;= 1;
    }
    return ans;
}
void init()
{
    //打出fac表和逆元表
    fac[0] = 1;
    for(int i = 1; i &lt; MAXN; i++)
        fac[i] = (i * fac[i - 1]) % MOD;
}
//返回x的阶乘的逆
ll ni(int x)
{
    return qpow(fac[x], MOD - 2);
}
ll C(int N, int M)
{
    return ((fac[N] * ni(M)) % MOD * ni(N - M)) % MOD;
}
int main()
{
    init();
    int t, n, k;
    cin &gt;&gt; t;
    for(int kase = 1; kase &lt;= t; kase++)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        printf(&quot;Case %d: %lld\n&quot;, kase, C(n + k - 1, k - 1));
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>隔板法</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1179 Josephus Problem(约瑟夫环问题)</title>
    <url>/tpaaaaaa.github.io/2019/10/03/LightOJ-1179JosephusProblem(%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98)/</url>
    <content><![CDATA[<p>The historian Flavius Josephus relates how, in the Romano-Jewish conflict of 67 A.D., the Romans took the town of Jotapata which he was commanding. Escaping, Josephus found himself trapped in a cave with 40 companions. The Romans discovered his whereabouts and invited him to surrender, but his companions refused to allow him to do so. He therefore suggested that they kill each other, one by one, the order to be decided by lot. Tradition has it that the means for affecting the lot was to stand in a circle, and, beginning at some point, count round, every third person being killed in turn. The sole survivor of this process was Josephus, who then surrendered to the Romans. Which begs the question: had Josephus previously practiced quietly with 41 stones in a dark corner, or had he calculated mathematically that he should adopt the 31st position in order to survive?</p>
<p>Now you are in a similar situation. There are <strong>n</strong> persons standing in a circle. The persons are numbered from <strong>1</strong> to <strong>n</strong> circularly. For example, <strong>1</strong> and <strong>n</strong> are adjacent and <strong>1</strong> and <strong>2</strong> are also. The count starts from the first person. Each time you count up to <strong>k</strong> and the <strong>kth</strong> person is killed and removed from the circle. Then the count starts from the next person. Finally one person remains. Given <strong>n</strong>and <strong>k</strong> you have to find the position of the last person who remains alive.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 200)**, denoting the number of test cases.</p>
<p>Each case contains two positive integers <strong>n (1 ≤ n ≤ 105)</strong> and <strong>k (1 ≤ k &lt; 231)</strong>.Output</p>
<p>For each case, print the case number and the position of the last remaining person.Sample Input</p>
<p>6</p>
<p>2 1</p>
<p>2 2</p>
<p>3 1</p>
<p>3 2</p>
<p>3 3</p>
<p>4 6Sample Output</p>
<p>Case 1: 2</p>
<p>Case 2: 1</p>
<p>Case 3: 3</p>
<p>Case 4: 3</p>
<p>Case 5: 2</p>
<p>Case 6: 3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>经典的约瑟夫环问题。可以得到一个递推公式。</p>
<p>优秀的博客<a href="https://www.cnblogs.com/jjscm/p/4463555.html" target="_blank" rel="noopener">https://www.cnblogs.com/jjscm/p/4463555.html</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-03-07.33.02
 By                : Tpaaaaaa
 Question_Number   ：Josephus Problem LightOJ - 1179
 Question_Name     ：数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

    经典的约瑟夫环问题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2;
int main()
{
    int t, n, k, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        int p = 0;             //p[1] = 0;
                               //p[i] = (p[i-1] + k) % i;
        for(int i = 2; i &lt;= n; i++)
            p = (p + k)%i;
        printf(&quot;Case %d: %d\n&quot;,++kase,  p + 1);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1356 Prime Independence</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1356PrimeIndependence/</url>
    <content><![CDATA[<p>给出n个数，找出一个最大素数独立子集，如果a=b*一个素数，那么认为a是b的一个素数乘级，如果一个集合不存在一个数是另一个数的素数乘级，那么这就是素数独立子集。Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 20)**, denoting the number of test cases.</p>
<p>Each case starts with an integer <strong>N (1 ≤ N ≤ 40000)</strong> denoting the size of the set. Next line contains <strong>N</strong> integers separated by a single space. Each of these <strong>N</strong> integers are distinct and between <strong>1</strong> and <strong>500000</strong> inclusive.Output</p>
<p>For each case, print the case number and the size of the largest prime independent subset.Sample Input</p>
<p>3</p>
<p>5</p>
<p>2 4 8 16 32</p>
<p>5</p>
<p>2 3 4 6 9</p>
<p>3</p>
<p>1 2 3</p>
<p>Sample Output</p>
<p>Case 1: 3</p>
<p>Case 2: 3</p>
<p>Case 3: 2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我太菜。和二分图匹配结合在一起。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-08.57.48
 By                : Tpaaaaaa
 Question_Number   ：Prime Independence LightOJ - 1356
 Question_Name     ：数论
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 4e4 + 10;
const int MAXM = 5e5 + 10;
int head[MAXN], ext[MAXM];
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
bool isnp[MAXM];
int prime_num[MAXM], prm[MAXM], Mx[MAXN];
int My[MAXN], Nx, Ny;
int dx[MAXN], dy[MAXN], dis;
bool vst[MAXN];
int Ax[MAXN], Ay[MAXN];
int top;
int cnt;
//求出每个数 的分解后的质因子的数目
void cal_prime_number()
{
    int res;
    prime_num[1] = 0;
    for(int i = 2; i &lt; MAXM; i++)
    {
        int t = i;
        res = 0;
        for(int j = 2; j * j &lt;= t; j++)
        {
            while(t % j == 0)
            {
                res ++;
                t /= j;
            }
        }
        if(t != 1) ++ res;
        prime_num[i] = res;
    }
}

bool searchP()
{
    queue&lt;int&gt; Q;
    dis = INF;
    memset(dx, -1, sizeof dx);
    memset(dy, -1, sizeof dy);
    for (int i = 1; i &lt;= Nx; ++i)
    {
        if (Mx[i] == -1)
        {
            Q.push(i);
            dx[i] = 0;
        }
    }
    while (!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        if (dx[u] &gt; dis) break;
        for (int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].v;
            if (dy[v] == -1)
            {
                dy[v] = dx[u] + 1;
                if (My[v] == -1) dis = dy[v];
                else
                {
                    dx[My[v]] = dy[v] + 1;
                    Q.push(My[v]);
                }
            }
        }
    }
    return dis != INF;
}

bool DFS(int u)
{
    for (int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if (!vst[v] &amp;&amp; dy[v] == dx[u] + 1)
        {
            vst[v] = 1;
            if (My[v] != -1 &amp;&amp; dy[v] == dis) continue;
            if (My[v] == -1 || DFS(My[v]))
            {
                My[v] = u;
                Mx[u] = v;
                return true;
            }
        }
    }
    return false;
}

int MaxMatch()
{
    int res = 0;
    memset(Mx, -1, sizeof Mx);
    memset(My, -1, sizeof My);
    while (true)
    {
        memset(vst, 0 , sizeof vst);
        queue&lt;int&gt; Q;
        dis = INF;
        memset(dx, -1, sizeof dx);
        memset(dy, -1, sizeof dy);
        for (int i = 1; i &lt;= Nx; ++i)
        {
            if (Mx[i] == -1)
            {
                Q.push(i);
                dx[i] = 0;
            }
        }
        while (!Q.empty())
        {
            int u = Q.front();
            Q.pop();
            if (dx[u] &gt; dis) break;
            for (int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                if (dy[v] == -1)
                {
                    dy[v] = dx[u] + 1;
                    if (My[v] == -1) dis = dy[v];
                    else
                    {
                        dx[My[v]] = dy[v] + 1;
                        Q.push(My[v]);
                    }
                }
            }
        }
        if (dis == INF) break;
        for (int i = 1; i &lt;= Nx; ++i)
        {
            if (Mx[i] == -1 &amp;&amp; DFS(i))
                ++res;
        }
    }
    return res;
}

//得到u的所有的质因子，放在prm数组中
void get_prime(int u)
{
    top = 0;
    for(int i = 2; i * i &lt;= u; i++)
    {
        if(u % i == 0)
        {
            prm[top++] = i;
            while(u % i == 0)
                u /= i;
        }
    }
    if(u != 1)
        prm[top++] = u;
}
void addEdge(int u, int v)
{
    ++cnt;
    edge[cnt].next = head[u];
    edge[cnt].v = v;
    head[u] = cnt;
}
int main()
{
    cal_prime_number();
    int t, a, n, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        memset(ext, 0, sizeof ext);
        memset(head, -1, sizeof head);
        cnt = 0;
        Nx = Ny = 0;
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a);
            if(prime_num[a] &amp; 1)
            {
                Ax[++Nx] = a;
                ext[a] = Nx;
            }
            else
            {
                Ay[++Ny] = a;
                ext[a] = Ny;
            }
        }
        for(int i = 1; i &lt;= Nx; i++)
        {
            get_prime(Ax[i]);
            for(int j = 0; j &lt; top; j++)
            {
                //goal为与Ax[i] 有关系的数
                int goal = Ax[i] / prm[j];
                int index = ext[goal];
                if(index == 0) continue;//这个数不存在
                addEdge(i, index);  //给第i个点与index点连线(他与自己这边的肯定不会有边，他与对面不一定有边。)
            }

        }
        for(int i = 1; i &lt;= Ny; i++)
        {
            get_prime(Ay[i]);
            for(int j = 0; j &lt; top; j++)
            {
                int goal = Ay[i] / prm[j];
                int index = ext[goal];
                if(index == 0)  continue;
                addEdge(index, i);
            }
        }
        printf(&quot;Case %d: %d\n&quot;,++kase, n - MaxMatch());
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>二分图匹配</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1341 Aladdin and the Flying Carpet</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1341AladdinandtheFlyingCarpet/</url>
    <content><![CDATA[<p>给一对数字 a，b ，a是一个长方形的面积，问有多少种整数的边的组合可以组成面积为a的长方形，要求最短的边不得小于bInput</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 4000)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing two integers: <strong>a</strong> <strong>b</strong> <strong>(1 ≤ b ≤ a ≤ 1012)</strong>where <strong>a</strong> denotes the area of the carpet and <strong>b</strong> denotes the minimum possible side of the carpet.Output</p>
<p>For each case, print the case number and the number of possible carpets.Sample Input</p>
<p>2</p>
<p>10 2</p>
<p>12 2</p>
<p>Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唯一分解定理。得到所有的因子数。</p>
<p>因子数一半就是因子对数。</p>
<p>然后再减去1…b这个区间里面的因子数。</p>
<p>就是答案了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-09.57.38
 By                : Tpaaaaaa
 Question_Number   ：Aladdin and the Flying Carpet LightOJ - 1341
 Question_Name     ：数论
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


    a是面积，问有多少个整数m n
    使得m*n = a
    其中 min(m, n) &gt;= b;

    10 = 2 * 5
    12 = 2 * 2 * 3
    首先用唯一分解定理，将a分解
    然后求出因子数
    因子数除以二，就是相乘为a的对数A
    然后再枚举[1, b]中是a的正因数的数目B
    A - B就是答案...

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
//开方是这里开方， a的十二次开成6次
const int MAXN = 1e6 + 50;
int prime[MAXN], k;
bool Isprime[MAXN];
void Prime()
{
    k = 0;
    memset(Isprime, true, sizeof Isprime);
    Isprime[1] = false;
    //wa的原因
    for(int i = 2; i &lt; MAXN; i++)
        if(Isprime[i])
        {
            prime[++k] = i;
            for(int j = 2 * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
}
//返回n的因子数
ll solve(ll n)
{
    ll ans = 0, sum = 1;
    //re的原因
    for(ll i = 1; i &lt;= k &amp;&amp; prime[i] * prime[i] &lt;= n; i++)
    {
        if(n % prime[i] == 0)
        {
            ans = 0;
            while(n % prime[i] == 0)
            {
                ans ++;
                n /= prime[i];
            }
            sum *= (1 + ans);
        }
    }
    //如果还有余数.
    if(n &gt; 1)
        sum *= 2;
    return sum;
}
int main()
{
    Prime();
    int t, kase = 0;
    ll ab, b;
    cin &gt;&gt; t;
    ll num;
    while(t--)
    {
        //将a分解
        scanf(&quot;%lld%lld&quot;, &amp;ab, &amp;b);
        if(ab &lt; b * b)
        {
            printf(&quot;Case %d: 0\n&quot;, ++kase);
            continue;
        }
        num = solve(ab);
        num /= 2;
        for(ll i = 1; i &lt; b; i++)
            if(ab % i == 0)
                num --;
        printf(&quot;Case %d: %lld\n&quot;, ++kase, num);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1336 Sigma Function</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1336SigmaFunction/</url>
    <content><![CDATA[<p>求和运算是一种有趣的操作，它来源于古希腊字母σ，现在我们来求一个数字的所有因子之和。例如σ(24)=1+2+3+4+6+8+12+24=60.对于小的数字求和是非常的简单，但是对于大数字求和就比较困难了。现在给你一个n，你需要求出有多少个[ 1 , n ]区间内的数字σ是偶数。<br>注：一个数字的σ指这个数的所有因子之和Input输入包含T(T&lt;=100)组数据，每一组只有一个数字n(1&lt;=n&lt;=10^12)Output输出样例号和一个数字，为所求答案。注意！两组输出之前没有空行。Sample Input</p>
<p>4</p>
<p>3</p>
<p>10</p>
<p>100</p>
<p>1000Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 5</p>
<p>Case 3: 83</p>
<p>Case 4: 947</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唯一分解定理。、</p>
<p>我们将n进行分解</p>
<p>再得到 σ (n)的表达式。我们要想使得 σ （n）为偶数的情况显然很多，所以我们可以考虑使得其为奇数的情况，然后再用总数减去奇数的数目就是偶数的数目了。</p>
<p>我们知道 σ （n）是一堆数的乘积。我们知道，要想使得一堆数的乘积为奇数。那么这一堆数中的每一个数都必须是素数。</p>
<p>即(1 + pi + pi^2 + … + pi^ai) 这个数是奇数。</p>
<p>对于加减法，我们知道奇数加奇数是奇数，奇数加偶数是奇数。所以要想使得以上的式子为奇数</p>
<p>则pi + pi ^ 2 + … + pi ^ ai 必须是偶数。</p>
<p>我们也可以知道，素数除了2之外都是奇数，所以我们这里先考虑p为奇数的情况</p>
<p>显然pi, pi ^ 2, pi ^ 3 ….. pi ^ ai 这ai个数都是奇数。我们知道要想使得奇数之和为偶数，就必须有偶数个奇数。 也就是ai是个偶数。 也就是可以提出一个2来，那么可以将他视为一个平方数。</p>
<p>所以[1, n]中的平方数，和2倍平方数的 σ 都是奇数。所以n减去这些数即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-12.38.57
 By                : Tpaaaaaa
 Question_Number   ：Sigma Function LightOJ - 1336
 Question_Name     ：数论，唯一分解定理
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2;
int main()
{
    ll n;
    int t, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%lld&quot;, &amp;n);
        ll ans = n;
        for(ll i = 1; i * i &lt;= n; i ++)
        {
            ans --;
            if(2 * i * i&lt;= n)
                ans --;
        }
        printf(&quot;Case %d: %lld\n&quot;,++kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理，奇偶</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1282 Leading and Trailing（数的前n位数）</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1282LeadingandTrailing%EF%BC%88%E6%95%B0%E7%9A%84%E5%89%8Dn%E4%BD%8D%E6%95%B0%EF%BC%89/</url>
    <content><![CDATA[<p>给定两个数n,k 求n^k的前三位和最后三位Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 1000)**, denoting the number of test cases.</p>
<p>Each case starts with a line containing two integers: <strong>n (2 ≤ n &lt; 231)</strong> and <strong>k (1 ≤ k ≤ 107)</strong>.Output</p>
<p>For each case, print the case number and the three leading digits (most significant) and three trailing digits (least significant). You can assume that the input is given such that <strong>nk</strong> contains at least six digits.Sample Input</p>
<p>5</p>
<p>123456 1</p>
<p>123456 2</p>
<p>2 31</p>
<p>2 32</p>
<p>29 8751919Sample Output</p>
<p>Case 1: 123 456</p>
<p>Case 2: 152 936</p>
<p>Case 3: 214 648</p>
<p>Case 4: 429 296</p>
<p>Case 5: 665 669</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>常见套路。</p>
<p>求大数的后n项 ——直接取模</p>
<p>求大数的前n项：见此题。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-12.53.53
 By                : Tpaaaaaa
 Question_Number   ：Leading and Trailing LightOJ - 1282
 Question_Name     ：数论
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2;
const int MOD = 1000;
// n的k次 模 mod
//求a^b % MOD
int quickMod(int a,int b)
{
    int ans = 1;
    a = a % MOD;
    while (b)
    {
        if (b&amp;1)
            ans = (ans * a) % MOD;
        a = (a*a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}
int main()
{
    int t, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        int n, k;
        scanf(&quot;%d%d&quot;, &amp;n, &amp;k);
        int ans2 = quickMod(n, k);
        double a = k*log10(n);
        a = fmod(a, 1);         //a存的是小数部分了
        int ans1 = (int)pow(10, a+2);
        printf(&quot;Case %d: %d %03d\n&quot;, ++kase, ans1, ans2);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>大数的前n项，后n项</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1220 Mysterious Bacteria</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1220MysteriousBacteria/</url>
    <content><![CDATA[<p>求满足条件的最大的指数p，使得a^p = x（a是整数）Input</p>
<p>输入包含多组样例T（T&lt;=50），每个样例包括一个整数x，x的范围在32位二进制数以内。Output</p>
<p>对于每个样例输出最大的指数p。Sample Input</p>
<p>3</p>
<p>17</p>
<p>1073741824</p>
<p>25Sample Output</p>
<p>Case 1: 1</p>
<p>Case 2: 30</p>
<p>Case 3: 2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唯一分解定理。</p>
<p>我们将x分解。那么所有质数的指数的gcd就是最大的p</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-14.35.30
 By                : Tpaaaaaa
 Question_Number   ：Mysterious Bacteria LightOJ - 1220
 Question_Name     ：321
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


    将x进行素因数分解。
    p就是每个素数的指数的GCD
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int prime[MAXN], top;
bool Isprime[MAXN];
int gcd(int a, int b)
{
    while(b)
    {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
void init()
{
    memset(Isprime, true, sizeof Isprime);
    top = 0;
    Isprime[1] = false;
    for(int i = 2; i &lt; MAXN; i++)
    {
        prime[++top] = i;
        for(int j = 2 * i; j &lt; MAXN; j += i)
            Isprime[j] = false;
    }
}
int main()
{
    int t, kase = 0;
    ll n, m;
    init();
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%lld&quot;, &amp;m);
        if(m &lt; 0) n = -m;
        else      n = m;
        int i = 1;
        int ans = 0;
        while(n &amp;&amp; prime[i] * prime[i] &lt;= n &amp;&amp; i &lt;= top)
        {
            if(n % prime[i] == 0)
            {
                int zs = 0;
                while(n % prime[i] == 0)
                {
                    zs ++;
                    n /= prime[i];
                }
                if(ans == 0) ans = zs;
                else         ans = gcd(ans, zs);
            }
            i++;
        }
        if(n &gt; 1)
            ans = 1;

        if(m &lt; 0)
            while(ans % 2 == 0)
            {
                ans /= 2;
            }
        printf(&quot;Case %d: %d\n&quot;,++kase,  ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1234 Harmonic Number</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1234HarmonicNumber/</url>
    <content><![CDATA[<p>数学中，第n个调和数是前n个自然数的倒数之和:</p>
<p>在这个问题中，给你一个数n，你应该求出 <strong>Hn</strong>.注意：这个OJ数组开太大会报Runtime Error.Input</p>
<p>开始输入一个整数 <strong>T (**</strong>≤ 10000)**, 代表样例个数.</p>
<p>每一个样例输入一行，包含一个整数 <strong>n (1 ≤ n ≤ 108)</strong>.Output</p>
<p>对于每个样例输出一行，代表答案<strong>Hn</strong> 。输出的结果与标准答案的相对误差小于 <strong>10-8</strong> ，格式如下.Sample Input</p>
<p>12</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>90000000</p>
<p>99999999</p>
<p>100000000</p>
<p>Sample Output</p>
<p>Case 1: 1.0000000000</p>
<p>Case 2: 1.5000000000</p>
<p>Case 3: 1.8333333333</p>
<p>Case 4: 2.0833333333</p>
<p>Case 5: 2.2833333333</p>
<p>Case 6: 2.4500000000</p>
<p>Case 7: 2.5928571429</p>
<p>Case 8: 2.7178571429</p>
<p>Case 9: 2.8289682540</p>
<p>Case 10: 18.8925358988</p>
<p>Case 11: 18.9978964039</p>
<p>Case 12: 18.9978964139</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>减少数组空间的方法。 我们首先观察到式子不难，but预处理的时候，如果直接用前缀和，显然1e8的数组会爆。那么我们怎么样才能他降下来呢，如果我们每隔100个去求一下和，这样就只要存1e6的数组了，不会爆了。所以可以用这种方法减少空间复杂度。</p>
<p>总结：如果求前缀和开的数组会爆的话，可以考虑分段求和(每100个求和一次…..)。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-15.17.08
 By                : Tpaaaaaa
 Question_Number   ：Harmonic Number LightOJ - 1234
 Question_Name     ：321
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题

    因为开1e8的数组会爆
    所以我们可以每隔100个存一下，就只要开1e6的数组了
    小机灵鬼
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e8 + 5;
double a[1000005];
void init()
{
    double ans = 0;
    a[0] = 0;
    for(int i = 1; i &lt; MAXN; i++)
    {
        ans += 1.0/i;
        if(i % 100 == 0)
            a[i/100] = ans; //a[1] 存的是前100
    }
}
int main()
{
    int t, n, kase = 0;
    init();
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        int temp = n / 100;
        double ans = a[temp];
        for(int i = temp * 100 + 1; i &lt;= n;i++)
            ans += 1.0 / i;
        printf(&quot;Case %d: %.10f\n&quot;,++kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>减少数组的大小</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1214 Large Division</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1214LargeDivision/</url>
    <content><![CDATA[<p>给定两个整数a和b，你应该检查a是否可以被b整除。我们知道，当且仅当存在整数c使得a = b * c时，整数a才能被整数b整除。Input</p>
<p>开始会输入一个数字 <strong>T (**</strong>≤ 525)**, 代表了样例数.</p>
<p>每个样例会给两个整数<strong>a (-10200 ≤ a ≤ 10200)</strong> and <strong>b (|b| &gt; 0, b fits into a 32 bit signed integer)</strong>. 数字不会包含前导零.Output</p>
<p>For each case, print the case number first. Then print <strong>‘divisible’</strong> if <strong>a</strong> is divisible by <strong>b</strong>. Otherwise print <strong>‘not divisible’</strong>.Sample Input</p>
<p>6</p>
<p>101 101</p>
<p>0 67</p>
<p>-101 101</p>
<p>7678123668327637674887634 101</p>
<p>11010000000000000000 256</p>
<p>-202202202202000202202202 -101Sample Output</p>
<p>Case 1: divisible</p>
<p>Case 2: divisible</p>
<p>Case 3: divisible</p>
<p>Case 4: not divisible</p>
<p>Case 5: divisible</p>
<p>Case 6: divisible</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>大数取模：模运算 + 秦九韶算法的思想。常见的套路</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-15.33.29
 By                : Tpaaaaaa
 Question_Number   ：Large Division LightOJ - 1214
 Question_Name     ：大数取模
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 300;
char s[MAXN];
bool lpow(char s[], ll mod)
{
    ll res = 0;
    for(int i = 0; i &lt; strlen(s); i++)
    {
        if(s[i] == &apos;-&apos;) continue;
        int now = s[i] - &apos;0&apos;;
        res = (res * 10 + now) % mod;
    }
    if(res == 0)
        return false;
    return true;
}
int main()
{
    int t, kase = 0;
    ll b;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%s %lld&quot;, s, &amp;b);
        if(b &lt; 0) b = -b;
        printf(&quot;Case %d: &quot;, ++kase);
        if(lpow(s,b))
            printf(&quot;not divisible\n&quot;);
        else
            printf(&quot;divisible\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>大数取模，秦九韶</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1078 Integer Divisibility</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1078IntegerDivisibility/</url>
    <content><![CDATA[<p>给你一个数n，一个数m，你需要找到一个k，表示k个n组成的数字可以被m整除。  </p>
<p>例如给你1和3，那么111可以被3整除，所以k为3.Input</p>
<p>输入一个T &lt;= 300，代表样例数。<br>每个样例会给你两个数m（需要除的数）和n（代表数字由n组成）。Output</p>
<p>对于每种情况，打印案例编号和此倍数的位数。如果有几种解决方案;输出最小的一个。Sample Input</p>
<p>3</p>
<p>3 1</p>
<p>7 3</p>
<p>9901 1</p>
<p>Sample Output</p>
<p>Case 1: 3</p>
<p>Case 2: 6</p>
<p>Case 3: 12</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>模运算配合秦九韶算法。 这种涉及到大数的….位数上的问题的常见的套路。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-19.38.43
 By                : Tpaaaaaa
 Question_Number   ：LJ1078、
 Question_Name     ：模运算
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2;
int main()
{
    int t, kase = 0;
    cin&gt;&gt;t;
    int n, m;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;m, &amp;n);
        int ret = n % m;
        int ans = 1;
        while(ret)
        {
            ret =(ret*10 + n % m) % m;
            ans ++;
        }
        printf(&quot;Case %d: %d\n&quot;, ++kase, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>模运算，秦九韶</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1116 Ekka Dokka</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1116EkkaDokka/</url>
    <content><![CDATA[<p>Ekka and his friend Dokka decided to buy a cake. They both love cakes and that’s why they want to share the cake after buying it. As the name suggested that Ekka is very fond of odd numbers and Dokka is very fond of even numbers, they want to divide the cake such that Ekka gets a share of <strong>N</strong>square centimeters and Dokka gets a share of <strong>M</strong> square centimeters where <strong>N</strong> is odd and <strong>M</strong> is even. Both <strong>N</strong> and <strong>M</strong> are positive integers.</p>
<p>They want to divide the cake such that <strong>N * M = W</strong>, where <strong>W</strong> is the dashing factor set by them. Now you know their dashing factor, you have to find whether they can buy the desired cake or not.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 10000)**, denoting the number of test cases.</p>
<p>Each case contains an integer <strong>W (2 ≤ W &lt; 263)</strong>. And <strong>W</strong> will not be a power of <strong>2</strong>.Output</p>
<p>For each case, print the case number first. After that print <strong>“Impossible”</strong> if they can’t buy their desired cake. If they can buy such a cake, you have to print <strong>N</strong> and <strong>M</strong>. If there are multiple solutions, then print the result where <strong>M</strong> is as small as possible.Sample Input</p>
<p>3</p>
<p>10</p>
<p>5</p>
<p>12Sample Output</p>
<p>Case 1: 5 2</p>
<p>Case 2: Impossible</p>
<p>Case 3: 3 4</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>唯一分解定理。首先我们知道如果w是奇数，那么是impossible，因为偶数乘以奇数等于偶数。我们利用唯一分解定理，将输入的数字w分解。可以知道w = 奇数<em>奇数</em>奇数…….*偶数。</p>
<p>其中唯一的偶数就是2的k次方。所以我们只需要求出w分解中的2的k次方，就可以确定最小的偶数M，即可解决问题了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-19.48.47
 By                : Tpaaaaaa
 Question_Number   ：Ekka Dokka LightOJ - 1116
 Question_Name     ：数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e6 + 10;
int main()
{
    int t;
    ll w;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%lld&quot;, &amp;w);
        if(w &amp; 1)
            printf(&quot;Case %d: Impossible\n&quot;, kase);
        else
        {
            ll temp = w;
            ll m = 1;
            while(temp % 2 == 0)
            {
                temp &gt;&gt;= 1;
                m &lt;&lt;= 1;
            }
            ll n = w / m;
            printf(&quot;Case %d: %lld %lld\n&quot;, kase, n, m);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
      <tags>
        <tag>唯一分解定理</tag>
      </tags>
  </entry>
  <entry>
    <title>LightOJ - 1148 Mad Counting</title>
    <url>/tpaaaaaa.github.io/2019/10/02/LightOJ-1148MadCounting/</url>
    <content><![CDATA[<p>Mob was hijacked by the mayor of the Town “TruthTown”. Mayor wants Mob to count the total population of the town. Now the naive approach to this problem will be counting people one by one. But as we all know Mob is a bit lazy, so he is finding some other approach so that the time will be minimized. Suddenly he found a poll result of that town where <strong>N</strong> people were asked “How many people in this town other than yourself support the same team as you in the FIFA world CUP 2010?” Now Mob wants to know if he can find the minimum possible population of the town from this statistics. Note that no people were asked the question more than once.Input</p>
<p>Input starts with an integer <strong>T (**</strong>≤ 100)**, denoting the number of test cases.</p>
<p>Each case starts with an integer <strong>N (1 ≤ N ≤ 50)</strong>. The next line will contain <strong>N</strong> integers denoting the replies <strong>(0 to 106)</strong> of the people.Output</p>
<p>For each case, print the case number and the minimum possible population of the town.Sample Input</p>
<p>2</p>
<p>4</p>
<p>1 1 2 2</p>
<p>1</p>
<p>0</p>
<p>Sample Output</p>
<p>Case 1: 5</p>
<p>Case 2: 1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>水题。懒得分析了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-10-02-20.10.50
 By                : Tpaaaaaa
 Question_Number   ：Mad Counting LightOJ - 1148
 Question_Name     ：数学
 Description       :
 目前正在专项刷题，为了保证效果。
必须做到：
    1，先想出完整思路，并分析复杂度。
    2. 按照自己的思路过一遍样例，自己编几个复杂的样例
    3. 编写代码的时候，规范风格（例如变量名）
    4. 模块化答题


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 60;
int a[MAXN];
int main()
{
    int t, n;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        sort(a + 1, a + 1 + n);
        ll sum = 0;
        for(int i = 1; i &lt;= n; )
        {
            int j = 1;
            sum += a[i] + 1;
            while(j &lt;= a[i] &amp;&amp; a[i] == a[i + j])
                j++;
            i = j + i;
        }
        printf(&quot;Case %d: %lld\n&quot;, kase, sum);
    }

    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>[总结]TPA的ACM模板</title>
    <url>/tpaaaaaa.github.io/2019/09/26/%5B%E6%80%BB%E7%BB%93%5DTPA%E7%9A%84ACM%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>以后学到什么新东西就往里面补充吧。</p>
<h2 id="1-字符串处理"><a href="#1-字符串处理" class="headerlink" title="1 字符串处理"></a>1 字符串处理</h2><h3 id="1-1-KMP"><a href="#1-1-KMP" class="headerlink" title="1.1 KMP"></a>1.1 KMP</h3><p>给定模式串b和文本串a，求b在a中的匹配情况。</p>
<pre><code>/*
  得到模式串b的next数组（串b是默认从下标0开始）
  next[i] 表示串中长度为i的前缀的最长公共前后缀的长度

next数组的应用：
利用next数组求最小循环节
串中长度为m的前缀中的最小循环节的长度为 len[m] = m – next[m]
abcab的最小循环节长度为3，即abc
next[m] = 0意味着自己就是一个循环节，即串没有循环部分。
*/
void getNext(char b[], int nxt[])
{
    int m = strlen(b);
    nxt[0] = -1;        //如果串是从下标1开始，改成nxt[1] = 0;
    int i = 0, j = -1;  //                   int i = 1, j = 0;
    while(i &lt; m)        //                   i &lt;= m
        if(j == -1 || a[i] == a[j])      //  j == 0 || 
            nxt[++i] = ++j;
    else
        j = nxt[j];
}

/*
给出文本串a和模式串b
问模式串在文本串中出现多少次,可重叠
例如：（3对输入上面为串b，下面为串a）
输入：
BAPC
BAPC
AZA
AZAZAZA
VERDI
AVERDXIVYERDIAN
输出：
1
3
0
*/
int kmp(char a[], char b[])
{
    getNext(b, nxt);
    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i],b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum++;
            j = nex[j];
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}

/*
给出文本串a和模式串b
问模式串在文本串中出现多少次,不可重叠
例如 aaaaaa  aa  = 3
*/
int kmp(char a[], char b[])
{
    getNext(b, nxt);              //为什么不报错呀？
    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i], b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum ++;
            j = 0;    //模式串首端
            i ++;     //文本串的下一位
            continue;
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}</code></pre><h3 id="1-2-e-KMP"><a href="#1-2-e-KMP" class="headerlink" title="1.2 e-KMP"></a>1.2 e-KMP</h3><p>定义母串S和子串T，S的长度为n，T的长度为m；</p>
<p>求   字符串S的每一个后缀  与 字符串T  的最长公共前缀；</p>
<pre><code>/*
extend[i]表示T与S[i,n-1]的最长公共前缀,也就是要求出所有extend[i](0&lt;=i&lt;n)
*/
void getExtend(char S[], char T[], int nxt[], int extend[])
{
    int a = 0, p = 0;
    getNext(T, nxt);
    int n = strlen(S);
    int m = strlen(T);
    for(int i = 0; i &lt; n; i++)
    {
        if(i &gt;= p || i + nxt[i - a] &gt;= p)
        {
            if(i &gt;= p)
                p = i;
            while(p &lt; n &amp;&amp; p - i &lt; m &amp;&amp; S[p] == T[p - i])
                p++;
            extend[i] = p - i;
            a = i;
        }
        else
            extend[i] = nxt[i - a];
    }
}


/*
next[i]表示T[i,m-1]和T的最长公共前缀长度.
*/
void getNext(char T[], int nxt[])
{
    int m = strlen(T);
    int a = 0, p = 0;
    nxt[0] = m;
    for(int i = 1; i &lt; m; i++)
    {
        if(i &gt;= p || i + nxt[i - a] &gt;= p)
        {
            if(i &gt;= p)
                p = i;
            while(p &lt; m &amp;&amp; T[p] == T[p - i])
                p++;
            nxt[i] = p - i;
            a = i;
        }
        else
            nxt[i] = nxt[i - a];
    }
}</code></pre><h3 id="1-3-Manacher"><a href="#1-3-Manacher" class="headerlink" title="1.3      Manacher"></a>1.3      Manacher</h3><p>可以在时间复杂度为O(n)的情况下求解一个字符串的最长回文子串长度的问题。</p>
<ol>
<li><p>s=”abcd”，最长回文长度为 1；</p>
</li>
<li><p>s=”ababa”，最长回文长度为 5；</p>
</li>
<li><p>s=”abccb”，最长回文长度为 4，即bccb。</p>
<p>/*<br> p[i]数组表示的是<br> 其中p[i]表示以 i 为中心的最长回文的半径</p>
<pre><code>0 1 2 3 4 5 6 7 ....</code></pre><p> s_new=” $ # a # b # b # a # h # o # p # x # p # o # “<br> p[]  =”   1 2 1 2 5 2 1 2 1 2 1 2 1 2 1 4 1 2 1 2 1”<br> p[i] - 1正好是原字符串中最长回文串的长度。<br> p[i]：原数组前i-1个元素的中心的最长回文半径<br>*/<br>void Manacher()<br>{</p>
<pre><code>int len = Init();
//得到一个新的串，s_new
// len为新串的长度
int id, mx = 0;
for(int i = 1; i &lt; len; i++)
{
    if(i &lt; mx)
        p[i] = min(p[2 * id - i], mx - i);
    else
        p[i] = 1;

    while(s_new[i - p[i]] == s_new[i+p[i]])
        p[i]++;
    if(mx &lt; i + p[i])
    {
        id = i;
        mx = i + p[i];
    }
}</code></pre><p>}</p>
</li>
</ol>
<pre><code>//s=&quot;abbahopxpo&quot;  s_new=&quot;$#a#b#b#a#h#o#p#x#p#o#&quot;
int Init()
{
    int len = strlen(s);
    s_new[0] = &apos;$&apos;;
    s_new[1] = &apos;#&apos;;
    int j = 2;
    for(int i = 0; i &lt; len; i++)
    {
        s_new[j++] = s[i];
        s_new[j++] = &apos;#&apos;;
    }
    s_new[j] = &apos;\0&apos;;
    return j;
}</code></pre><h3 id="1-4-Trie树"><a href="#1-4-Trie树" class="headerlink" title="1.4 Trie树"></a>1.4 Trie树</h3><p>解决xor问题</p>
<pre><code>/*
问题：给n个整数A1, A2……An，
 选出两个数进行异或，得到的结果最大是多少？
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5;
int tire[MAXN][2], tot;
void add(int x)
{
    int p = 1;
    //范围2^31,001000110001000 从左边往右边数第一个是第一个加入的
    for(int i = 30; i &gt;= 0; i --)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(!tire[p][now])
            tire[p][now] = ++tot;
        p = tire[p][now];
    }
}
int Search(int x)
{
    int p = 1;
    int ret = 0;
    for(int i = 30; i &gt;= 0; i--)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(tire[p][now ^ 1])
        {
            p = tire[p][now ^ 1];
            ret |= (1 &lt;&lt; i);
        }
        else p = tire[p][now];
    }
    return ret;
}
int main()
{
    int n, x;
    cin &gt;&gt; n;
    tot = 1;        //tot！！！ = 1
    int ans = 0;
    memset(tire, 0, sizeof tire);
    for(int i = 1; i &lt;= n; i++)
    {
        scanf(&quot;%d&quot;, &amp;x);
        add(x);
        ans = max(ans, Search(x));
    }
    printf(&quot;ans = %d\n&quot;, ans);
    return 0;
}</code></pre><h3 id="1-5-AC自动机"><a href="#1-5-AC自动机" class="headerlink" title="1.5 AC自动机"></a>1.5 AC自动机</h3><p>指针版</p>
<pre><code>/*
题意：第一行输入测试数据的组数，然后输入一个整数n，接下来的n行每行输入一个单词，最后输入一个字符串，问在这个字符串中有多少个单词出现过。
*/
const int INF = 0x3f3f3f3f;
const int MAXN = ;
struct Node
{
    int cnt;
    Node *fail;
    Node *nxt[26];
}*que[MAXN];
char s[MAXN];
char keyword[60];
int head, tail;
Node *root;
void Init(Node *root)
{
    root-&gt;cnt  = 0;
    root-&gt;fail = NULL;
    for(int i = 0; i &lt; 26; i++)
        root-&gt;nxt[i] = NULL;
}
void buildTrie(char keyword[])
{
    Node *p, *q;
    int i, now;
    int len = strlen(keyword);
    p = root;
    for(int i = 0; i &lt; len; i++)
    {
        now = keyword[i] - &apos;a&apos;;
        if(p-&gt;nxt[now] == NULL)
        {
            q = (struct Node *)malloc(sizeof Node);
            Init(q);
            p-&gt;nxt[v] = q;
        }
        p = p-&gt;nxt[now];
    }
    p-&gt;cnt ++;
}
//BFS
void buildAcAutomation(Node *root)
{
    int head = 0, tail = 0;
    que[head++] = root;
    while(head != tail)
    {
        Node *p = NULL;
        Node *temp = que[tail++];
        for(int i = 0; i &lt; 26; i++)
        {
            if(temp-&gt;nxt[i] != NULL)
            {
                if(temp == root)
                    temp-&gt;nxt[i]-&gt;fail = root;
                else
                {
                    p=temp-&gt;fail;
                    while(p!=NULL)
                    {
                        if(p-&gt;nxt[i]!=NULL)
                        {
                            temp-&gt;nxt[i]-&gt;fail = p-&gt;nxt[i];
                        }
                        p = p-&gt;fail;
                    }
                    if(p == NULL)
                        temp-&gt;nxt[i]-&gt;fail = root;
                }
                que[head++] = temp-&gt;nxt[i];
            }
        }
    }
}
int query(Node *root)
{
    int now, sum = 0;
    Node *p = root;
    int len = strlen(s);
    for(int i = 0; i &lt; len; i++)
    {
        now = s[i] - &apos;a&apos;;
        while(p-&gt;nxt[now] == NULL &amp;&amp; p != root)
            p = p-&gt;fail;
        p = p-&gt;nxt[now];
        if(p == NULL)
            p = root;
        Node *temp = p;
        while(temp != root)
        {
            if(temp-&gt;cnt &gt;= 0)
            {
                sum += temp-&gt;cnt;
                temp-&gt;cnt = -1;
            }
            else
                break;
            temp = temp -&gt;fail;
        }
    }
    return sum;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        root = (struct Node*)malloc(sizeof Node);
        Init(root);
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, keyword);
            buildTree(keyword);
        }
        buildAcAutomation(root);
        scanf(&quot;%s&quot;, s);
        printf(&quot;%d\n&quot;, query(root));

    }
    return 0;
}</code></pre><p>数组版</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
// Trie树的结构体
struct Trie
{
    int nxt[MAXN][26], fail[MAXN], edn[MAXN];
    int root, tot;
    //将当前节点初始化
    int newNode()
    {
        tot ++;         //用来记录结点编号的
        for(int i = 0; i &lt; 26; i++)
            nxt[tot][i] = -1;
        edn[tot] = 0;
        return tot;     //返回编号
    }
    void init()
    {
        tot = 0;
        root = newNode();//root一般而言是1
    }
    //往trie树中插入buf
    void add(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            if(nxt[p][now] == -1)
                nxt[p][now] = newNode();

            p = nxt[p][now];
        }
        edn[p]++;
    }
    //AC自动机的构建，也就是fail数组的构建
    void build()
    {
        queue &lt; int &gt; Q;
        fail[root] = root;
        //对根的结点单独处理一哈
        for(int i = 0; i &lt; 26; i++)
        {
            if(nxt[root][i] == -1)
                nxt[root][i] = root;
            else
            {
                fail[nxt[root][i]] = root;
                Q.push(nxt[root][i]);
            }
        }
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for(int i = 0; i &lt; 26; i++)
            {
                if(nxt[now][i] == -1)
                    nxt[now][i] = nxt[fail[now]][i];
                else
                {
                    fail[nxt[now][i]] = nxt[fail[now]][i];
                    Q.push(nxt[now][i]);
                }
            }
        }
    }
    int query(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        int res = 0;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            p = nxt[p][now];
            int temp = p;
            while(temp != root)
            {
                res += edn[temp];
                edn[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};
char buf[2*MAXN];
Trie AC;
int main()
{
    int t;
    int n;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        AC.init();
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            AC.add(buf);
        }
        AC.build();
        scanf(&quot;%s&quot;, buf);
        printf(&quot;%d\n&quot;, AC.query(buf));
    }
    return 0;
}</code></pre><h2 id="2-数学"><a href="#2-数学" class="headerlink" title="2 数学"></a>2 数学</h2><h3 id="2-1-素数"><a href="#2-1-素数" class="headerlink" title="2.1 素数"></a><strong>2.1 素数</strong></h3><h4 id="2-1-1素数筛选（判断-lt-MAXN-的数是否素数）"><a href="#2-1-1素数筛选（判断-lt-MAXN-的数是否素数）" class="headerlink" title="2.1.1素数筛选（判断 &lt;MAXN 的数是否素数）"></a>2.1.1素数筛选（判断 &lt;MAXN 的数是否素数）</h4><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
void init()
{
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
            for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
}</code></pre><h4 id="2-1-2-素数筛选（筛选出小于等于-MAXN-的素数）"><a href="#2-1-2-素数筛选（筛选出小于等于-MAXN-的素数）" class="headerlink" title="2.1.2 素数筛选（筛选出小于等于 MAXN 的素数）"></a>2.1.2 素数筛选（筛选出小于等于 MAXN 的素数）</h4><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
int prime[MAXN], top;
void init()
{
    top = 0;                             // 小于等于MAXN的素数的数目
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
        {
             prime[++top] = i;
             for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
}</code></pre><h3 id="2-2-唯一分解定理"><a href="#2-2-唯一分解定理" class="headerlink" title="2.2 唯一分解定理"></a>2.2 唯一分解定理</h3><pre><code>const int MAXN = 1e6 + 10;
bool Isprime[MAXN];
int prime[MAXN], top;
void init()
{
    top = 0;                             // 小于等于MAXN的素数的数目
    memset(Isprime, true, sizeof Isprime);
    Ispriem[1] = false;
    for(int i = 2; i * i&lt; MAXN; i++)
        if(Isprime[i])
        {
             prime[++top] = i;
             for(int j = i * i; j &lt; MAXN; j += i)
                Isprime[j] = false;
        }
}
//将大数x进行分解。返回的是质因子的种类数
// factor[i][0] 存的是第i个质因子的值
// factor[i][1] 存的是第i个质因子的指数
// 下标从1开始。
int getFactors(long long x)
{
   fatCnt = 0;
   long long temp = x;
   for(int i = 1; prime[i] * prime[i] &lt;= temp; i++)
   {
       if(temp % prime[i] == 0)
       {
            factor[++fatCnt][0] = prime[i];
            factor[fatCnt][1]   = 0;
            while(temp % prime[i] == 0)
            {
                 factor[fatCnt][1] ++;
                 temp /= prime[i];
            } 
       }
   }
   if(temp != 1)
   {
        factor[++fatCnt][0] = temp;
        factor[fatCnt][1]   = 1;
   }
    return fatCnt;
}</code></pre><h3 id="2-3-扩展欧几里得算法"><a href="#2-3-扩展欧几里得算法" class="headerlink" title="2.3 扩展欧几里得算法"></a>2.3 扩展欧几里得算法</h3><p>求解 ax = gcd(a, b) (mod b);</p>
<p>求 ax + by = gcd(a, b)的解</p>
<pre><code>long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
     if(a == 0 &amp;&amp; b == 0)     return 1;
     if(b == 0)
     {
          x = 1;
          y = 0;
          return a;
     }
     long long temp = exgcd(b, a % b, y, x);
     y -= x * a / b;
     return temp;
}</code></pre><h3 id="2-4-求逆元"><a href="#2-4-求逆元" class="headerlink" title="2.4 求逆元"></a>2.4 求逆元</h3><h4 id="2-4-1扩展欧几里得求逆元"><a href="#2-4-1扩展欧几里得求逆元" class="headerlink" title="2.4.1扩展欧几里得求逆元"></a>2.4.1扩展欧几里得求逆元</h4><pre><code>long long exgcd(long long a, long long b, long long &amp;x, long long &amp;y)
{
     if(a == 0 &amp;&amp; b == 0)     return 1;
     if(b == 0)
     {
          x = 1;
          y = 0;
          return a;
     }
     long long temp = exgcd(b, a % b, y, x);
     y -= x * a / b;
     return temp;
}
/*求逆元*/
// ax = 1(mod n)
long long modReverse(long long a, long long n)
{
   long long x, y;
   long long d = exgcd(a, n, x, y);
   if(d == 1)                      //只有gcd(a,n) = 1,互素的情况下才有逆元
        return (x % n + n) % n;
   else
        return -1;                 //没有逆元
}</code></pre><h4 id="2-4-2费马小定理求逆元"><a href="#2-4-2费马小定理求逆元" class="headerlink" title="2.4.2费马小定理求逆元"></a>2.4.2费马小定理求逆元</h4><p>要求： p 为素数, 而且 a 和 p 互质</p>
<p>根据费马小定理，若p为素数，且a和p互质的话，有</p>
<p>a^(p - 1) = 1 (mod p)</p>
<p>所以有 a * a^(p - 2) = 1 (mod p)</p>
<p>即a^(p - 2) 就是a模p的逆元，可以配合快速幂取模</p>
<pre><code>ll qpow(ll x,int k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans*x)%mod;
        x = (x*x)%mod;
        k &gt;&gt;= 1;
    }
    return ans;
}
//打表的方法，阶乘表，逆元表哦
void init()
{
    fac[0] = 1;
    ni[0] = 1; 
    for(int i = 1; i &lt; MAXN; i++)
    {
        //显然mod 与 pri互质
        //因为mod是素数，显然互素。
        fac[i] = fac[i-1] * i % mod;
        ni[i] = qpow(fac[i], mod - 2);
    }
}</code></pre><h3 id="2-7-欧拉函数"><a href="#2-7-欧拉函数" class="headerlink" title="2.7 欧拉函数"></a>2.7 欧拉函数</h3><h4 id="2-7-1-分解质因素求欧拉函数"><a href="#2-7-1-分解质因素求欧拉函数" class="headerlink" title="2.7.1 分解质因素求欧拉函数"></a><strong>2.7.1</strong> 分解质因素求欧拉函数</h4><h4 id="2-7-2-筛法欧拉函数"><a href="#2-7-2-筛法欧拉函数" class="headerlink" title="2.7.2 筛法欧拉函数"></a><strong>2.7.2</strong> 筛法欧拉函数</h4><h4 id="2-7-3-求单个数的欧拉函数"><a href="#2-7-3-求单个数的欧拉函数" class="headerlink" title="2.7.3 求单个数的欧拉函数"></a><strong>2.7.3</strong> 求单个数的欧拉函数</h4><pre><code>//利用公式ϕ(n)=n∏(1−1/p) 其中p是能整除n的素数
ll eular(ll n)
{
    ll ans = n;
    for(int i = 2; i * i &lt;= n; i++)
    {
        if(n % i == 0)
               ans -= ans / i;
               while(n % i == 0)
                   n /= i;
    }
    if(n &gt; 1) ans -= ans / n;  
    return ans;
}</code></pre><h4 id="2-7-4-线性筛（同时得到欧拉函数和素数表）"><a href="#2-7-4-线性筛（同时得到欧拉函数和素数表）" class="headerlink" title="2.7.4 线性筛（同时得到欧拉函数和素数表）"></a><strong>2.7.4</strong> 线性筛（同时得到欧拉函数和素数表）</h4><h4 id="2-8-高斯消元"><a href="#2-8-高斯消元" class="headerlink" title="2.8 高斯消元"></a>2.8 高斯消元</h4><p><strong>2.8.0 高斯消元模板.</strong></p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string.h&gt;
#include&lt;math.h&gt;
using namespace std;

const int MAXN=50;



int a[MAXN][MAXN];//增广矩阵
int x[MAXN];//解集
bool free_x[MAXN];//标记是否是不确定的变元



/*
void Debug(void)
{
    int i, j;
    for (i = 0; i &lt; equ; i++)
    {
        for (j = 0; j &lt; var + 1; j++)
        {
            cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}
*/


inline int gcd(int a,int b)
{
    int t;
    while(b!=0)
    {
        t=b;
        b=a%b;
        a=t;
    }
    return a;
}
inline int lcm(int a,int b)
{
    return a/gcd(a,b)*b;//先除后乘防溢出
}

// 高斯消元法解方程组(Gauss-Jordan elimination).(-2表示有浮点数解，但无整数解，
//-1表示无解，0表示唯一解，大于0表示无穷解，并返回自由变元的个数)
//有equ个方程，var个变元。增广矩阵行数为equ,分别为0到equ-1,列数为var+1,分别为0到var.
int Gauss(int equ,int var)
{
    int i,j,k;
    int max_r;// 当前这列绝对值最大的行.
    int col;//当前处理的列
    int ta,tb;
    int LCM;
    int temp;
    int free_x_num;
    int free_index;

    for(int i=0;i&lt;=var;i++)
    {
        x[i]=0;
        free_x[i]=true;
    }

    //转换为阶梯阵.
    col=0; // 当前处理的列
    for(k = 0;k &lt; equ &amp;&amp; col &lt; var;k++,col++)
    {// 枚举当前处理的行.
// 找到该col列元素绝对值最大的那行与第k行交换.(为了在除法时减小误差)
        max_r=k;
        for(i=k+1;i&lt;equ;i++)
        {
            if(abs(a[i][col])&gt;abs(a[max_r][col])) max_r=i;
        }
        if(max_r!=k)
        {// 与第k行交换.
            for(j=k;j&lt;var+1;j++) swap(a[k][j],a[max_r][j]);
        }
        if(a[k][col]==0)
        {// 说明该col列第k行以下全是0了，则处理当前行的下一列.
            k--;
            continue;
        }
        for(i=k+1;i&lt;equ;i++)
        {// 枚举要删去的行.
            if(a[i][col]!=0)
            {
                LCM = lcm(abs(a[i][col]),abs(a[k][col]));
                ta = LCM/abs(a[i][col]);
                tb = LCM/abs(a[k][col]);
                if(a[i][col]*a[k][col]&lt;0)tb=-tb;//异号的情况是相加
                for(j=col;j&lt;var+1;j++)
                {
                    a[i][j] = a[i][j]*ta-a[k][j]*tb;
                }
            }
        }
    }

  //  Debug();

    // 1. 无解的情况: 化简的增广阵中存在(0, 0, ..., a)这样的行(a != 0).
    for (i = k; i &lt; equ; i++)
    { // 对于无穷解来说，如果要判断哪些是自由变元，那么初等行变换中的交换就会影响，则要记录交换.
        if (a[i][col] != 0) return -1;
    }
    // 2. 无穷解的情况: 在var * (var + 1)的增广阵中出现(0, 0, ..., 0)这样的行，即说明没有形成严格的上三角阵.
    // 且出现的行数即为自由变元的个数.
    if (k &lt; var)
    {
        // 首先，自由变元有var - k个，即不确定的变元至少有var - k个.
        for (i = k - 1; i &gt;= 0; i--)
        {
            // 第i行一定不会是(0, 0, ..., 0)的情况，因为这样的行是在第k行到第equ行.
            // 同样，第i行一定不会是(0, 0, ..., a), a != 0的情况，这样的无解的.
            free_x_num = 0; // 用于判断该行中的不确定的变元的个数，如果超过1个，则无法求解，它们仍然为不确定的变元.
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; free_x[j]) free_x_num++, free_index = j;
            }
            if (free_x_num &gt; 1) continue; // 无法求解出确定的变元.
            // 说明就只有一个不确定的变元free_index，那么可以求解出该变元，且该变元是确定的.
            temp = a[i][var];
            for (j = 0; j &lt; var; j++)
            {
                if (a[i][j] != 0 &amp;&amp; j != free_index) temp -= a[i][j] * x[j];
            }
            x[free_index] = temp / a[i][free_index]; // 求出该变元.
            free_x[free_index] = 0; // 该变元是确定的.
        }
        return var - k; // 自由变元有var - k个.
    }
    // 3. 唯一解的情况: 在var * (var + 1)的增广阵中形成严格的上三角阵.
    // 计算出Xn-1, Xn-2 ... X0.
    for (i = var - 1; i &gt;= 0; i--)
    {
        temp = a[i][var];
        for (j = i + 1; j &lt; var; j++)
        {
            if (a[i][j] != 0) temp -= a[i][j] * x[j];
        }
        if (temp % a[i][i] != 0) return -2; // 说明有浮点数解，但无整数解.
        x[i] = temp / a[i][i];
    }
    return 0;
}
int main(void)
{
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);
    int i, j;
    int equ,var;
    while (scanf(&quot;%d %d&quot;, &amp;equ, &amp;var) != EOF)
    {
        memset(a, 0, sizeof(a));
        for (i = 0; i &lt; equ; i++)
        {
            for (j = 0; j &lt; var + 1; j++)
            {
                scanf(&quot;%d&quot;, &amp;a[i][j]);
            }
        }
//        Debug();
        int free_num = Gauss(equ,var);
        if (free_num == -1) printf(&quot;无解!\n&quot;);
   else if (free_num == -2) printf(&quot;有浮点数解，无整数解!\n&quot;);
        else if (free_num &gt; 0)
        {
            printf(&quot;无穷多解! 自由变元个数为%d\n&quot;, free_num);
            for (i = 0; i &lt; var; i++)
            {
                if (free_x[i]) printf(&quot;x%d 是不确定的\n&quot;, i + 1);
                else printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        else
        {
            for (i = 0; i &lt; var; i++)
            {
                printf(&quot;x%d: %d\n&quot;, i + 1, x[i]);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre><p><strong>2.8.1 解一类开关问题，变成对2取模的01方程组.</strong></p>
<pre><code>bwwb
bbwb
bwwb
bwww
翻一个，周围四个都会变，问全变成w的最少步数.

File_Name         ：Flip Game POJ - 1753 .cpp
const int INF = 0x3f3f3f3f;
const int MAXN = 20;
int a[MAXN][MAXN], b[MAXN][MAXN];
int x[MAXN], free_x[MAXN];
//想象一下是16*16的矩阵哦
//注意是翻成相同面
void getA()
{
    for(int i = 0; i &lt; 4; i++)
        for(int j = 0; j &lt; 4; j++)
        {
            int t = i * 4 + j;
            a[t][t] = 1;
            int up = (i - 1) * 4 + j;
            int down = (i + 1) * 4 + j;
            int left = i * 4 + j - 1;
            int right = i * 4 + j + 1;
            if(i &gt; 0)   a[up][t] = 1;
            if(i &lt; 3)   a[down][t] = 1;
            if(j &gt; 0)   a[left][t] = 1;
            if(j &lt; 3)   a[right][t] = 1; 
        }
}
//n * n的矩阵
//为0，为1都算一遍
//就是将原来的翻转一次即可.
int Gauss(int n)
{
    memset(x, 0, sizeof x);
    memset(free_x, 0, sizeof free_x);
    int col = 0, row = 0;
    int max_r, num = 0;
    for(;col &lt; n &amp;&amp; row &lt; n; col++, row++)
    {
        max_r = row;
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col] &gt; a[max_r][col])   max_r = i;
        if(max_r != row)
            for(int i = col; i &lt;= n; i++)
                swap(a[row][i], a[max_r][i]);
        if(a[row][col] == 0)
        {
            row --;
            free_x[num++] = col;
            continue;
        }
        //开始消
        for(int i = row + 1; i &lt; n; i++)
            if(a[i][col])
                for(int j = col; j &lt;= n; j++)
                  a[i][j] ^= a[row][j];
    }
    for(int i = row; i &lt; n; i++)
        if(a[i][col]) return INF;
    int up = 1 &lt;&lt; (n - row);
    int ans = INF;
    for(int i = 0; i &lt; up; i++)
    {
        int cnt = 0;
        int index = i;
        for(int j = 0; j &lt; (n - row); j++)
        {
            x[free_x[j]] = index &amp; 1;
            if(x[free_x[j]]) cnt++;
            index &gt;&gt;= 1;
        }
        //处理完了
        for(int j = row - 1; j &gt;= 0; j--)
        {
            //x[j] = a[j][n];
            int temp = a[j][n];
            for(int l = j + 1; l &lt; n; l++)
                if(a[j][l]) temp ^= x[l];

            x[j] = temp;
            if(x[j])
                cnt++;
        }
        if(cnt &lt; ans)
            ans = cnt;
    }
    return ans;             //我特么是个憨憨
}
int main()
{
    char ch;
    memset(a, 0, sizeof a);
    memset(b, 0, sizeof b);
    getA();
    for(int i = 0; i &lt; 16; i++)
    {
        cin &gt;&gt; ch;
        if(ch == &apos;b&apos;) 
                a[i][16] = 1;    
        else    a[i][16] = 0;
        b[i][16] = a[i][16] ^ 1;
    }
    int ans = Gauss(16);
    memcpy(a, b, sizeof b);
    getA();
    int temp = Gauss(16);
    if(temp &lt; ans)
        ans = temp;

    if(ans &gt;= INF)
        printf(&quot;Impossible\n&quot;);
    else
        printf(&quot;%d\n&quot;, ans);
    return 0;
}</code></pre><p><strong>2.8.2 解同余方程组.</strong></p>
<pre><code>//解一个模7的同余方程组.
File_Name         ：POJ 2947 Widget Factory.cpp（重新写一个）.cpp
const int INF = 0x3f3f3f3f;
const int MAXN = 310;
const int MOD = 7;
int x[MAXN];
int a[MAXN][MAXN];
int n, m;               //m是方程数，n是变量数
int gcd(int a, int b)
{
    if(b == 0)  return a;
    return gcd(b, a%b);
}
int lcm(int a, int b)
{
    return a/gcd(a, b) * b;
}
int exGcd(int a, int b, int &amp;x, int &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        int d = exGcd(b, a % b, y, x);
        y -= x*a/b;             //????喵喵喵？？？？？
        return d;
    }
}
int getNum(char temp[])
{
    char cmp[7][10] = {&quot;MON&quot;, &quot;TUE&quot;, &quot;WED&quot;, &quot;THU&quot;, &quot;FRI&quot;, &quot;SAT&quot;, &quot;SUN&quot;};
    for(int i = 0; i &lt; 7; i++)
        if(strcmp(temp, cmp[i]) == 0)
            return i + 1;
    return -1;
}
//equ个方程，val个变量
//
int Gauss(int equ, int var)
{
    memset(x, 0, sizeof x);
    int col, row;
    for(row = 0, col = 0; row &lt; equ &amp;&amp; col &lt; var; col ++, row ++)
    {
        int max_r;
        for(max_r = row; max_r &lt; equ; max_r++)
            if(a[max_r][col])
                break;

        if(max_r == equ)
        {
            row --;
            continue;
        }
        if(max_r != row)
            for(int j = 0; j &lt;= var; j++)
                swap(a[max_r][j], a[row][j]);

        for(int i = row + 1; i &lt; equ; i++)
        {
            if(a[i][col] == 0)  continue;
            int LCM = lcm(a[row][col], a[i][col]);
            int ta = LCM / a[i][col];
            int tb = LCM / a[row][col];
            for(int j = col; j &lt;= var; j++)
                a[i][j] = ((a[i][j] * ta - a[row][j] * tb) % MOD + MOD) % MOD;
        }
    }
    //无解
    //
    for(int i = row; i &lt; equ; i++)
        if(a[i][col])   return -1;
    if(row &lt; var)         return 0;
    for(int i = equ - 1; i &gt;= 0; i--)
    {
        int temp = a[i][var];
        for(int j = i + 1; j &lt; var; j++)
            temp = ((temp - a[i][j] * x[j])%MOD + MOD) % MOD;
        int b = temp;
        int X, Y;
        int d = exGcd(a[i][i], MOD, X, Y);
        X = X * (b / d) % MOD;
        X =(X % (MOD / d) + (MOD / d)) % (MOD / d);
        if(X &lt; 3)   X += 7;
        x[i] = X; 

    }
    return 1;
}
int main()
{   
    int start, fire, k;
    char A[10], B[10];
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n + m )
    {
        memset(a, 0, sizeof a);
        for(int i = 0; i &lt; m; i++)
        {
            scanf(&quot;%d %s %s&quot;, &amp;k, A, B);
            start = getNum(A);
            fire  = getNum(B);
            int day = fire - start + 1;
            a[i][n] = (day % MOD + MOD) % MOD;
            for(int j = 0; j &lt; k; j++)
            {
                int temp;
                scanf(&quot;%d&quot;, &amp;temp);
                a[i][temp - 1] = (a[i][temp - 1] + 1) % MOD;
            }
        }
        int ans = Gauss(m, n);              //从第一行开始.
        if(ans == 0)
            printf(&quot;Multiple solutions.\n&quot;);
        else if(ans == -1)
            printf(&quot;Inconsistent data.\n&quot;);
        else
        {
            printf(&quot;%d&quot;, x[0]);
            for(int i = 1; i &lt; n; i++)
                printf(&quot; %d&quot;, x[i]);
            printf(&quot;\n&quot;);
        }
    }
    return 0;
}</code></pre><h3 id="2-9求组合数"><a href="#2-9求组合数" class="headerlink" title="2.9求组合数"></a>2.9求组合数</h3><p>2.9.1组合数取模问题</p>
<p>数据量不大于10e6的情况下，可以考虑使用打表法，打出fac表和逆元表</p>
<p><strong>注意开4e6的数组会爆32mb的内存。</strong></p>
<p>那么打逆元表的方法又有两种，一种是利用扩展欧几里得算法求逆元，一种是用费马小定理+快速幂求逆元。</p>
<pre><code>//用的是扩展欧几里得求逆元.
ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y)
{
    if(b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    else
    {
        ll temp = exgcd(b, a%b, y, x);
        y -= x * (a / b);
        return temp;
    }
}
void init()//考虑取模
{
    dp[0] = 1;
    dp[1] = 0;              //WA的原因
    dp[2] = 1;
    dp[3] = 2;
    for(int i = 4; i &lt; MAXN; i++)
        dp[i] = ( (i - 1) * ((dp[i - 1] + dp[i - 2]) % MOD)) % MOD;

    //求出fac表和逆表
    fac[0] = 1;
    ni[0] = 1;
    ll x, y;
    for(int i = 1; i &lt; MAXN; i++)
    {
        fac[i] = (fac[i - 1] * i) % MOD;
        exgcd(fac[i], MOD, x, y);
        ni[i] = (x % MOD + MOD) % MOD;
    }
}
ll C(int N, int M)
{
    return ((fac[N] * ni[M]) % MOD * ni[N - M]) % MOD;
}

//用的是费马小定理.
//求的是x的k次方模mod
ll qpow(ll x,int k)
{
    ll ans = 1;
    while(k)
    {
        if(k&amp;1)
            ans = (ans*x)%mod;
        x = (x*x)%mod;
        k &gt;&gt;= 1;
    }
    return ans;
}
//打表的方法，阶乘表，逆元表哦
void init()
{
    fac[0] = 1; //存的是阶乘模mod
    ni[0] = 1;  //在存的是这个阶乘的值对模的逆元表
    for(int i = 1; i &lt; MAXN; i++)   //????????EXM？？？？？？？？？改了这里
    {
        //显然mod 与 pri互质
        //因为mod是素数，显然互素。
        fac[i] = fac[i-1] * i % mod;
        //printf(&quot;fac[i] = %d\n&quot;, fac[i]);
        //qpow是快速幂取模
        ni[i] = qpow(fac[i], mod - 2);
    }
}</code></pre><p><strong>2、数据量大的情况下，考虑卢卡斯定理。</strong></p>
<pre><code>//返回a^b次模MOD
ll qpow(ll a, ll b)
{
    ll ans = 1;
    while(b)
    {
        if(b &amp; 1)   
            ans = (ans * a) % MOD;
        a = (a * a) % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}
// 返回x模MOD的逆元
ll inv(ll x)
{
    return qpow(x, MOD - 2);
}
// 返回组合数C(a, b)
ll C(ll a, ll b)
{
    if(a &lt; b) return 0;
    ll up = 1, down = 1;    //分子分母
    for(int i = a - b + 1; i &lt;= a; i++)
        up = up * i % MOD;
    for(int i = 1; i &lt;= b; i++)
        down = down * i % MOD;
    return up * inv(down) % MOD;
}
ll lucas(ll a, ll b)
{
    if(b == 0)  return 1;
    return C(a % MOD, b % MOD) * lucas(a / MOD, b / MOD) % MOD;
}</code></pre><h4 id="2-9-2-隔板法"><a href="#2-9-2-隔板法" class="headerlink" title="2.9.2 隔板法"></a><strong>2.9.2 隔板法</strong></h4><p><strong>一般问题1</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为1</p>
<p><strong>一般问题2</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中xi 至少为0</p>
<p><strong>一般问题3</strong> x1 + x2 + x3 + …. + xn = s 的整数解的组合数。其中 x[i] 至少为 v[i].</p>
<h4 id="2-9-3错排公式"><a href="#2-9-3错排公式" class="headerlink" title="2.9.3错排公式"></a>2.9.3错排公式</h4><p>错排公式</p>
<p>dp[n] 表示的是将n个元素错排的方法数</p>
<p>可知 dp[n] = (n-1)dp[n-2] + (n-1)dp[n-1];</p>
<p>dp[0] = 1; dp[1] = 0; dp[2] = 1; dp[3] = 2;</p>
<h3 id="2-10-FFT"><a href="#2-10-FFT" class="headerlink" title="2.10 FFT"></a>2.10 FFT</h3><pre><code>#include &lt;cstdio&gt;
#include &lt;cmath&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;
#include &lt;complex&gt;
#define space putchar(&apos; &apos;)
#define enter putchar(&apos;\n&apos;)
using namespace std;
typedef long long ll;
template &lt;class T&gt;
void read(T &amp;x){
    char c;
    bool op = 0;
    while(c = getchar(), c &lt; &apos;0&apos; || c &gt; &apos;9&apos;)
    if(c == &apos;-&apos;) op = 1;
        x = c - &apos;0&apos;;
    while(c = getchar(), c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)
        x = x * 10 + c - &apos;0&apos;;
    if(op) x = -x;
}
template &lt;class T&gt;
void write(T x){
    if(x &lt; 0) putchar(&apos;-&apos;), x = -x;
    if(x &gt;= 10) write(x / 10);
    putchar(&apos;0&apos; + x % 10);
}
const int N = 1000005;
const double PI = acos(-1);
typedef complex &lt;double&gt; cp;
char sa[N], sb[N];
int n = 1, lena, lenb, res[N];
cp a[N], b[N], omg[N], inv[N];
void init(){
    for(int i = 0; i &lt; n; i++){
        omg[i] = cp(cos(2 * PI * i / n), sin(2 * PI * i / n));
        inv[i] = conj(omg[i]);
    }
}
void fft(cp *a, cp *omg){
    int lim = 0;
    while((1 &lt;&lt; lim) &lt; n) lim++;
    for(int i = 0; i &lt; n; i++){
        int t = 0;
        for(int j = 0; j &lt; lim; j++)
            if((i &gt;&gt; j) &amp; 1) t |= (1 &lt;&lt; (lim - j - 1));
        if(i &lt; t) swap(a[i], a[t]); // i &lt; t 的限制使得每对点只被交换一次（否则交换两次相当于没交换）
    }
    for(int l = 2; l &lt;= n; l *= 2){
        int m = l / 2;
    for(cp *p = a; p != a + n; p += l)
        for(int i = 0; i &lt; m; i++){
            cp t = omg[n / l * i] * p[i + m];
            p[i + m] = p[i] - t;
            p[i] += t;
        }
    }
}
int main(){
    scanf(&quot;%s%s&quot;, sa, sb);
    lena = strlen(sa), lenb = strlen(sb);
    while(n &lt; lena + lenb) n *= 2;
    for(int i = 0; i &lt; lena; i++)
        a[i].real(sa[lena - 1 - i] - &apos;0&apos;);
    for(int i = 0; i &lt; lenb; i++)
        b[i].real(sb[lenb - 1 - i] - &apos;0&apos;);
    init();
    fft(a, omg);
    fft(b, omg);
    for(int i = 0; i &lt; n; i++)
        a[i] *= b[i];
    fft(a, inv);
    for(int i = 0; i &lt; n; i++){
        res[i] += floor(a[i].real() / n + 0.5);
        res[i + 1] += res[i] / 10;
        res[i] %= 10;
    }
    for(int i = res[lena + lenb - 1] ? lena + lenb - 1: lena + lenb - 2; i &gt;= 0; i--)
        putchar(&apos;0&apos; + res[i]);
    enter;
    return 0;
}</code></pre><p>加速多项式乘法，大数乘法</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define FO(x) {freopen(#x&quot;.in&quot;,&quot;r&quot;,stdin);freopen(#x&quot;.out&quot;,&quot;w&quot;,stdout);}
#define pa pair&lt;int,int&gt;
#define mod 1000000007
#define ll long long
#define mk make_pair
#define pb push_back
#define fi first
#define se second
#define cl(x) memset(x,0,sizeof x)
#ifdef Devil_Gary
#define bug(x) cout&lt;&lt;(#x)&lt;&lt;&quot; &quot;&lt;&lt;(x)&lt;&lt;endl
#define debug(...) fprintf(stderr, __VA_ARGS__)
#else
#define bug(x)
#define debug(...)
#endif
const int INF = 0x7fffffff;
const int N=3e6+5;
/*
char *TT,*mo,but[(1&lt;&lt;15)+2];
#define getchar() ((TT==mo&amp;&amp;(mo=(TT=but)+fread(but,1,1&lt;&lt;15,stdin),TT==mo))?-1:*TT++)//*/
inline int read(){
    int x=0,rev=0,ch=getchar();
    while(ch&lt;&apos;0&apos;||ch&gt;&apos;9&apos;){if(ch==&apos;-&apos;)rev=1;ch=getchar();}
    while(ch&gt;=&apos;0&apos;&amp;&amp;ch&lt;=&apos;9&apos;){x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-&apos;0&apos;;ch=getchar();}
    return rev?-x:x;
}
const int Mod=100;
int ans,K,ls;
int M,l,r[N];
char ss[N];

vector&lt;int&gt;s,g,f;
const double pi = acos(-1.0);
struct Cp{
    double x,y;
    Cp (double _x=0, double _y=0) {x=_x,y=_y;}
    Cp operator + (const Cp&amp; rhs) {return Cp(x+rhs.x,y+rhs.y);}
    Cp operator - (const Cp&amp; rhs) {return Cp(x-rhs.x,y-rhs.y);}
    Cp operator * (const Cp&amp; rhs) {return Cp(x*rhs.x-y*rhs.y,x*rhs.y+y*rhs.x);}
}A[N],B[N],x,w,w0;
inline void FFT(Cp *A,int f) {
    int i,j,k;
    for(i=0;i&lt;M;i++) if(i&lt;r[i]) swap(A[i],A[r[i]]);
    for(i=1;i&lt;M;i&lt;&lt;=1) {
        w.x=cos(pi/i),w.y=sin(pi/i)*f;
        for(j=0;j&lt;M;j+=i&lt;&lt;1) {
            w0.x=1,w0.y=0;
            for(k=0;k&lt;i;++k) {
                x=A[j+k];
                A[j+k]=x+(w0*A[i+j+k]);
                A[i+j+k]=x-(w0*A[i+j+k]);
                w0=w0*w;
            }
        }
    }
    if(f==-1) for(i=0;i&lt;M;++i) A[i].x/=M;
}

void stretch(vector&lt;int&gt;&amp;a){
    int p=0,la=a.size();
    for (int i=0;i&lt;la||p;++i) {
        if(i&gt;=la) a.pb(0);
        ll cur=a[i]+p;
        a[i]=cur%Mod;
        p=cur/Mod;
    }
}
bool cmp(vector&lt;int&gt;a){
    int la=a.size(),lb=s.size();
    if(la&lt;lb) return 0;
    if(la&gt;lb) return 1;
    for(int i=la-1;~i;i--) {
        if(a[i]&lt;s[i]) return 0;
        if(a[i]&gt;s[i]) return 1;
    } 
    return 1;
}
bool work(int x){
    vector&lt;int&gt;h;
    for(int i=0;i&lt;g.size();i++) h.pb(g[i]*x);
    stretch(h);
//  for(int i=0;i&lt;h.size();i++) cout&lt;&lt;h[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    return cmp(h);
}
void solve2(){
    for(int i=0;i&lt;g.size();i++) g[i]=g[i]*3;
    stretch(g); 
}
//calc 3^n
vector&lt;int&gt; solve(vector&lt;int&gt;a,vector&lt;int&gt;b){
    int la=a.size(),lb=b.size();
//  for(int i=0;i&lt;a.size();i++) cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
//  for(int i=0;i&lt;b.size();i++) cout&lt;&lt;b[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
//  bug(la),bug(lb);
    for(M=1,l=0;M&lt;=la+lb;M&lt;&lt;=1,l++);
    for(int i=0;i&lt;a.size();i++) A[i].x=a[i],A[i].y=0; 
    for(int i=0;i&lt;b.size();i++) B[i].x=b[i],B[i].y=0; 
    for(int i=1;i&lt;M;i++) r[i]=(r[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;(l-1));
    FFT(A,1),FFT(B,1);
    for(int i=0;i&lt;M;i++) A[i]=A[i]*B[i];
    FFT(A,-1);
    vector&lt;int&gt;z(la+lb-1);
    for(int i=0;i&lt;=la+lb-2;i++) z[i]=(int)(A[i].x+0.5);
    for(int i=0;i&lt;M;i++) A[i].x=B[i].x=A[i].y=B[i].y=0;
//  for(int i=0;i&lt;z.size();i++) cout&lt;&lt;z[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    return z;
}
void calc(){
    f.pb(3),g.pb(1);
    while(K){
        if(K&amp;1) g=solve(g,f),stretch(g);
        K&gt;&gt;=1,f=solve(f,f),stretch(f);
    }
}
int tt[10]={0,1,2,3,4,5,5,6,6,6};
int main(){
#ifdef Devil_Gary
    freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);
#endif
    scanf(&quot;%s&quot;,ss),ls=strlen(ss),reverse(ss,ss+ls);
    if(ls==1){
        int zjq=ss[0]-&apos;0&apos;; return cout&lt;&lt;tt[zjq]&lt;&lt;endl,0;
    }
    for(int i=0;i&lt;ls;i+=2) {
        int x=ss[i]-&apos;0&apos;;
        if(i+1&lt;ls) x+=(ss[i+1]-&apos;0&apos;)*10;
//      if(i+2&lt;ls) x+=(ss[i+2]-&apos;0&apos;)*100;
        s.pb(x);
    }
    K=(ls-1)*(double)(log(10)/log(3)),--K,ans+=K*3,calc();
    int ans2=ans;
//  for(int i=0;i&lt;s.size();i++) cout&lt;&lt;s[i]&lt;&lt;&quot; &quot;;cout&lt;&lt;endl; 
    for(;;ans+=3,solve2()){
//      for(int i=0;i&lt;g.size();i++) cout&lt;&lt;g[i]&lt;&lt;&quot; &quot;;bug(ans),cout&lt;&lt;endl; 
        if(work(2)) {ans+=2;break;}
        else if(work(3)) {ans+=3;break;}
        else if(work(4)) {ans+=4;break;}
    }
    cout&lt;&lt;ans&lt;&lt;endl;
}

int bit_rev(int t,int n){
    int res=0;
    for (int i=0;i&lt;n;i++) res|=(t&gt;&gt;(n-i-1)&amp;1)&lt;&lt;i;
    return res;
}
void fft(cd *a,int n,int rev){
    int len=1&lt;&lt;n;
    static cd y[N*4];
    for (int i=0;i&lt;len;i++) y[i]=a[bit_rev(i,n)];
    for (int d=1;d&lt;len;d&lt;&lt;=1){
        cd wn=exp(cd(0,PI*rev/d));
        for (int k=0;k&lt;len;k+=(d&lt;&lt;1)){
            cd w=cd(1,0);
            for (int i=k;i&lt;k+d;i++,w*=wn){
                cd u=y[i],v=w*y[i+d];
                y[i]=u+v;
                y[i+d]=u-v;
            }
        }
    }
    if (rev==-1)
    for (int i=0;i&lt;len;i++) y[i]/=len;
    for (int i=0;i&lt;len;i++) a[i]=y[i];
}
void mul(int *a,int la,int *b,int lb,int *c,int &amp;lc){
    int len=1,n=0;
    static cd t1[N*4],t2[N*4];
    for (;len&lt;la*2 || len&lt;lb*2;len&lt;&lt;=1,++n);
    for (int i=0;i&lt;len;i++){
        t1[i]=cd(i&lt;la ? a[i] : 0,0);
        t2[i]=cd(i&lt;lb ? b[i] : 0,0);
    }
    fft(t1,n,1);
    fft(t2,n,1);
    for (int i=0;i&lt;len;i++) t1[i]*=t2[i];
    fft(t1,n,-1);
    lc=len-1;
    for (int i=0;i&lt;len;i++) c[i]=(int)(t1[i].real()+0.5);
}</code></pre><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-2-RMQ"><a href="#3-2-RMQ" class="headerlink" title="3.2 RMQ"></a>3.2 RMQ</h3><p>一维</p>
<pre><code>// dp[i][j] 保存的是[i, i + 2^j - 1] 这个区间里面的最小值
void rmq_init()  // 作用是初始化dp数组， 题目给的数组是arr[1] ... arr[N]
{
    for(int i=1;i&lt;=N;i++)
        dp[i][0]=arr[i];//初始化
    for(int j=1;(1&lt;&lt;j)&lt;=N;j++)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]);

}

//rmq(l, r) 的作用是查询区间[l, r]中的最小值
int rmq(int l,int r)
{
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);
}</code></pre><p>二维</p>
<pre><code>//maxv[a][b][c][d] 保存的是（a,b）为左上角，右下角（a + 2^c - 1, b + 2^d - 1）
//这个矩形区域的最大值
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int Log=12;
const int N=610;
const int inf=1e9;
int n,m,Q;
int maxv[Log][Log][N][N];
int pre[N],val[N][N]; 
void init(){
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)maxv[0][0][i][j]=val[i][j];
    pre[2]=pre[3]=1;
    for(int i=4,up=max(n,m);i&lt;=up;i++)pre[i]=pre[i&gt;&gt;1]+1;
    int up1=pre[n]+1,up2=pre[m]+1;
    for(int l1=0;l1&lt;=up1;l1++){
        for(int l2=0;l2&lt;=up2;l2++){
            if(!l1&amp;&amp;!l2) continue;
            for(int i=1;(i+(1&lt;&lt;l1)-1)&lt;=n;i++){
                for(int j=1;(j+(1&lt;&lt;l2)-1)&lt;=m;j++){
                    if(l2)maxv[l1][l2][i][j]=max(maxv[l1][l2-1][i][j],maxv[l1][l2-1][i][j+(1&lt;&lt;(l2-1))]);
                    else maxv[l1][l2][i][j]=max(maxv[l1-1][l2][i][j],maxv[l1-1][l2][i+(1&lt;&lt;(l1-1))][j]);
                }
            }
        }
    }
}
int query(int x1,int y1,int x2,int y2){
    int p=pre[x2-x1+1],q=pre[y2-y1+1];
    int ans=-inf;
    ans=max(maxv[p][q][x1][y1],maxv[p][q][x1][y2-(1&lt;&lt;q)+1]);
    ans=max(ans,max(maxv[p][q][x2-(1&lt;&lt;p)+1][y1],maxv[p][q][x2-(1&lt;&lt;p)+1][y2-(1&lt;&lt;q)+1]));
    return ans;
}
int x1,x2,y1,y2;
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;Q);
    for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;val[i][j]);
    init();
    for(int i=1;i&lt;=Q;i++){
        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);
        printf(&quot;%d\n&quot;,query(x1,y1,x2,y2));
    }
    return 0;
}</code></pre><h3 id="3-3-树链剖分"><a href="#3-3-树链剖分" class="headerlink" title="3.3 树链剖分"></a>3.3 树链剖分</h3><p>3.3.1 基于点权，查询单点值，修改路径的上的点权</p>
<pre><code>f[u]保存结点u的父亲节点
d[u]保存结点u的深度值
size[u]保存以u为根的子树节点个数
son[u]保存重儿子
rk[u]保存当前
dfs标号在树中所对应的节点
top[u]保存当前节点所在链的顶端节点
id[u]保存树中每个节点剖分以后的新编号（DFS的执行顺序）
void dfs1(int u,int fa,int depth)    //当前节点、父节点、层次深度
{
    f[u]=fa;
    d[u]=depth;
    size[u]=1;    //这个点本身size=1，子树的大小要包括自己哦
    for(int i=head[u]; i != -1;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        dfs1(v,u,depth+1);    //层次深度+1
        size[u]+=size[v];    //子节点的size已被处理，用它来更新父节点的size
        if(size[v]&gt;size[son[u]])
            son[u]=v;    //选取size最大的作为重儿子
    }
}
//外部进入
dfs1(root,0,1);
//第二次dfs
void dfs2(int u,int t)    //当前节点、重链顶端
{
    top[u]=t;
    id[u]=++cnt;    //标记dfs序
    rk[cnt]=u;      //序号cnt对应节点u
    if(!son[u])     //没有子节点
        return;
    dfs2(son[u],t);
/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续，
一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[u]&amp;&amp;v!=f[u])
            dfs2(v,v);    //一个点位于轻链底端，那么它的top必然是它本身
    }
}
//sum函数
int sum(int x,int y)
{
    int ans=0,fx=top[x],fy=top[y];
    while(fx!=fy)    //两点不在同一条重链
    {
        if(d[fx]&gt;=d[fy]) //要让父节点深度大的点先跳，这里是x先跳
        {
            ans+=query(id[fx],id[x],rt);    //线段树区间求和，处理这条重链的贡献
            x=f[fx],fx=top[x];    //将x设置成原链头的父亲结点，走轻边，继续循环
        }
        else
        {
            ans+=query(id[fy],id[y],rt);
            y=f[fy],fy=top[y];
        }
    }
    //循环结束，两点位于同一重链上，但两点不一定为同一点，所以我们还要统计这两点之间的贡献
    if(id[x]&lt;=id[y])
        ans+=query(id[x],id[y],rt);
    else
        ans+=query(id[y],id[x],rt);
    return ans;
}</code></pre><p>3.3.2 基于边权，修改单条边权，查询路径边权最大值</p>
<pre><code> //将边权转移到点权上，然后变成了树链剖分的模板题
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int cnt, tot;
int e[MAXN][3], dep[MAXN], head[MAXN], f[MAXN], top[MAXN], dfn[MAXN], siz[MAXN], son[MAXN], rk[MAXN];
struct Node
{
    int l, r;
    ll sum;
}node[MAXN * 4];

struct Edge
{
    int v, next;
} edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}
//线段树的单点修改
//将k位置的值，变成c
inline void pushUp(int rt)
{
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}
//返回的是编号u点到v点的路径权值和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉
    return ret;

}
void init()
{
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;

}
int main()
{
    int n, m, a, b, c;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt; n; i ++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);
        built(1, 1, n);
        //两次dfs后，我们得到了dfs序
        //我们对dfs序建立线段树
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }
        while(m--)
        {
            int op, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
            if(op == 0)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                update(1, dfn[u], b);
            }
            else //查询a到b的费用
            {
                ll ans = sum(a, b);
                //sum返回的是a到b的权值和
                printf(&quot;%lld\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre><h3 id="3-6-主席树"><a href="#3-6-主席树" class="headerlink" title="3.6 主席树"></a>3.6 主席树</h3><p>3.6.1 静态区间第 <strong>k</strong> 大</p>
<pre><code>/*
给定一个长度为n的序列，有m个询问，每次查询区间第K大的元素。
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int n, m, x, y, k, cnt;
int a[MAXN], lisan[MAXN];
int root[MAXN];
struct Node
{
    int L, R;
    //记录的是地址
    //要明白，
    //这个模板是憨憨，误导别人
    int sum;
};
Node node[20 * MAXN];
int binSearch(int x, int n)
{
    int L = 1;
    int R = n;
    while(L &lt;= R)
    {
        int mid = md(L, R);
        if(lisan[mid] == x)
            return mid;
        else if(lisan[mid] &gt; x)
            R = mid - 1;
        else
            L = mid + 1;
    }
}
void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];
    root = cnt;
    node[cnt].sum ++;

    if(L == R)
        return;

    int mid = md(L, R);
    if(pos &lt;= mid)
        update(pos, node[root].L, L, mid);
    else
        update(pos, node[root].R, mid + 1, R);
}
int query(int i, int j, int k, int L, int R)
{
    //
    if(L == R)
        return L;   //要继续深刻理解一下

    int d = node[node[j].L].sum - node[node[i].L].sum;

    int mid = md(L, R);
    if(k &lt;= d)
        return query(node[i].L, node[j].L, k, L, mid);
    else
        return query(node[i].R, node[j].R, k - d, mid + 1, R);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            lisan[i] = a[i];
        }
        sort(lisan + 1, lisan + 1 + n);
        int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
        //1.离散化
        root[0] = 0;
        node[0].L = node[0].R = node[0].sum = 0;
        cnt = 0;
        //2.初始化
        for(int i = 1; i &lt;= n; i++)
        {
            root[i] = root[i - 1];
            int pos = binSearch(a[i], q);
            update(pos, root[i], 1, q);
        }
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
            int pos = query(root[x - 1], root[y], k, 1, q);
            printf(&quot;%d\n&quot;, lisan[pos]);
        }
    }
    return 0;
}</code></pre><h3 id="3-9-替罪羊树"><a href="#3-9-替罪羊树" class="headerlink" title="3.9 替罪羊树"></a>3.9 替罪羊树</h3><pre><code>/*您需要写一种数据结构（可参考题目标题），来维护一些数，其中需要提供以下操作：

1.插入xx数
2.删除xx数(若有多个相同的数，因只删除一个)
3.查询xx数的排名(排名定义为比当前数小的数的个数+1+1。若有多个相同的数，因输出最小的排名)
4.查询排名为xx的数
5.求xx的前驱(前驱定义为小于xx，且最大的数)
6.求xx的后继(后继定义为大于xx，且最小的数)
*/
//AC的板子
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#define md(x, y)  (x + y) / 2
using namespace std;
const int MAXN = 1e5 + 10;
int cnt = 0, root;
vector &lt; int &gt; vec;
const double alpha = 0.75;
struct Node
{
    int l, r, val;
    int siz, fac;
    bool exist;
};
Node tzy[MAXN];
void newnode(int &amp;now, int val)
{
    now = ++cnt;
    tzy[now].l = tzy[now].r = 0;
    tzy[now].val = val;
    tzy[now].siz = tzy[now].fac = 1;
    tzy[now].exist = true;
}
bool imbalance(int now)
{
    if(max(tzy[tzy[now].l].siz, tzy[tzy[now].r].siz ) &gt; tzy[now].siz * alpha
       || tzy[now].siz - tzy[now].fac &gt; tzy[now].siz * 0.3 )
        return true;
        return false;
}
//将now为根的子树重建，首先用中序遍历
void ldr(int now)
{
    if(!now)
        return;
    ldr(tzy[now].l);
    if(tzy[now].exist)
        vec.push_back(now);
    ldr(tzy[now].r);
}
void lift(int l, int r, int &amp;now)
{
    if(l == r)
    {
        now = vec[l];
        tzy[now].l = tzy[now].r = 0;
        tzy[now].siz = tzy[now].fac = 1;
        return;
    }
    int mid = md(l, r);
    while(l &lt; mid &amp;&amp; tzy[vec[mid]].val == tzy[vec[mid - 1]].val)
        mid --;
    now = vec[mid];
    if(l &lt; mid)
        lift(l, mid - 1, tzy[now].l);
    else
        tzy[now].l = 0;
    lift(mid + 1, r, tzy[now].r);
    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;
    tzy[now].fac = tzy[tzy[now].l].fac + tzy[tzy[now].r].fac + 1;

}
int getrank(int val)
{
    int now = root;
    int rankk = 1;
    while(now)
    {
        if(val &lt;= tzy[now].val)
            now = tzy[now].l;
        else
        {
            rankk += tzy[now].exist + tzy[tzy[now].l].fac;
            now = tzy[now].r;
        }
    }
    return rankk;
}
int getnum(int rak)
{
    int now = root;
    while(now)
    {
        if(tzy[now].exist &amp;&amp; tzy[tzy[now].l].fac + tzy[now].exist == rak)
            break;
        else if(tzy[tzy[now].l].fac &gt;= rak)
            now = tzy[now].l;
        else
        {
            rak -= tzy[tzy[now].l].fac + tzy[now].exist;
            now = tzy[now].r;
        }

    }
    return tzy[now].val;
}
void update(int now, int ori)
{
    if(!now)
        return;
    if(tzy[ori].val &lt; tzy[now].val)
        update(tzy[now].l, ori);
    else
        update(tzy[now].r, ori);

    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;

}
void rebuilt(int &amp;now)
{
    vec.clear();
    ldr(now);
    if(vec.empty())
    {
        now = 0;
        return;
    }
    lift(0, vec.size() - 1, now);
}
void check(int &amp;now, int ori)
{
    if(now == ori)
        return;
        //该点不平衡,将其重构，更新
    if(imbalance(now))
    {
        rebuilt(now);
        update(root, now);
        return;
    }
    if(tzy[ori].val &lt; tzy[now].val)
        check(tzy[now].l, ori);
    else
        check(tzy[now].r, ori);
}
//在now这个位置插入val
void del(int now, int val)
{
    if(tzy[now].exist&amp;&amp;tzy[now].val == val)
    {
        tzy[now].exist = false;
        tzy[now].fac --;
        check(root, now);
        return;
    }
    tzy[now].fac --;
    if(val &lt; tzy[now].val)
        del(tzy[now].l, val);
    else
        del(tzy[now].r, val);
}
void add(int &amp;now, int val)
{
    if(now == 0)
    {
        newnode(now, val);//插入完成
        check(root, now); //从根节点开始往下找，看看是不是存在不平衡的点
        return;
    }
    tzy[now].siz++;
    tzy[now].fac++;
    if(val &lt; tzy[now].val)
        add(tzy[now].l, val);
    else
        add(tzy[now].r, val);
}

int main()
{
    cnt = 0;
    root = 0;
    int t, x, opt;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
        switch(opt)
        {
            case 1:
                add(root, x);
                break;
            case 2:
                del(root, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getrank(x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getnum(x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getnum(getrank(x) - 1));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getnum(getrank(x + 1)));
        }
    }
}</code></pre><h2 id="6-动态规划"><a href="#6-动态规划" class="headerlink" title="6.动态规划"></a>6.动态规划</h2><h3 id="6-2-背包问题"><a href="#6-2-背包问题" class="headerlink" title="6.2 背包问题"></a>6.2 背包问题</h3><p><strong>01背包</strong></p>
<pre><code>//volume 为物品体积，weight为物品价值.
void ZeroOnePack(int volume, int weight)
{
    for(int j =  maxV; j&gt;= volume; j--)
        dp[j] = max(dp[j], dp[j - volume] + weight);
}</code></pre><p><strong>完全背包</strong></p>
<pre><code>void CompletePack(int volume, int weight)
{
    for(int j = volume; j &lt;= maxV; j++)
        dp[j] = max(dp[j], dp[j - volume] + weight);
}</code></pre><p><strong>多重背包：二进制优化成01背包.</strong></p>
<pre><code>void MultiplePack(int volume, int weight, int amount)
{
     if(volume * amount &gt;= maxV) CompletePack(volume, weight);
     else 
     {
          int k = 1;
          while(k &lt; amount)
          {
                ZeroOnePack(k * volume, k * weight);
                amount -= k;
                k &lt;&lt;= 1;
          }
          ZeroOnePack(amount * volume, amount * weigth);
     }

}</code></pre><p><strong>分组背包</strong>,每组最多选一个</p>
<pre><code>for(int k = 1; k &lt;= k; k++)
    for(int j = V; j &gt;= 0; j--)
         for( item i in group k)
              dp[j] = max{dp[j], dp[j - ci] + wi};</code></pre><p>HDU3535 Are You Busy</p>
<p>将01背包，每组至少选一个的背包问题，每组最多选一个的背包问题结合在一起。</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXT = 110;
int dp[MAXN][MAXT];
int main()
{
    int n, T, c, g;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;T) != EOF)
    {
        memset(dp, -1, sizeof dp);
        memset(dp[0], 0, sizeof dp[0]);
        for(int k = 1; k &lt;= n; k++)
        {
            int s, m;
            scanf(&quot;%d%d&quot;, &amp;m, &amp;s);
            if(s == 0)                      //至少选一个
            {
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);
                    for(int j = T; j &gt;= c; j--)
                    {
                        if(dp[k][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k][j - c] + g);
                        if(dp[k - 1][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - c] + g);
                    }
                }
            }
            else if(s == 1)             //最多选一个
            {     
                memcpy(dp[k], dp[k - 1], sizeof dp[k - 1]);
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);

                    for(int j = T; j &gt;= c; j--)
                        if(dp[k - 1][j - c] != -1)
                            dp[k][j] = max(dp[k][j], dp[k - 1][j - c] + g);
                }
            }
            else
            {
                memcpy(dp[k], dp[k - 1], sizeof dp[k - 1]);
                for(int i = 1; i &lt;= m; i++)
                {
                    scanf(&quot;%d%d&quot;, &amp;c, &amp;g);
                    for(int j = T; j &gt;= c; j--)
                        if(dp[k - 1][j - c] != -1)                          //这是能够发生转移的前提.
                            dp[k][j] = max(dp[k][j], dp[k][j - c] + g);     //但实际的转移是发生在本组内部.
                }
            }

        }
        printf(&quot;%d\n&quot;, dp[n][T]);
    }
    return 0;
}</code></pre><p><strong>求第k个最优解.</strong> HDU 2639 Bone CollectorII</p>
<pre><code>/*
dp[i][j][k] 表示考虑前i个变量，使得和为j的第k优解
得到状态转移
dp[i][j] = merge(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);
merge归并排序
妙呀,前i个变量的前k优解，就是由转移向他的两个状态的各自的前k优解再比试一下
得到的前k优解
}
*/
const int INF = 0x3f3f3f3f;
const int MAXN = 1e2 + 10;
const int MAXM = 1e3 + 10;
const int MAXK = 30 + 10;
int n, v, k;
int w[MAXN], c[MAXN];
int dp[MAXN][MAXM][MAXK];
int A[MAXK], B[MAXK];
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;k);    //第k优解，v是背包容量，n是物件种类
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;w[i]); //物品价值
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;c[i]); //物品体积
        memset(dp, 0, sizeof dp);   
        for(int i = 1; i &lt;= n; i++)
            for(int j = 0; j &lt;= v; j++)
                if(j &gt;= c[i])           //两种转移方法
                {
                    for(int o = 1; o &lt;= k; o++)
                    {
                        A[o] = dp[i - 1][j][o];
                        B[o] = dp[i - 1][j - c[i]][o] + w[i];
                    }
                    int x = 1, y = 1, z = 1;
                    A[k + 1] = B[k + 1] = -1;//??
                    while(z &lt;= k &amp;&amp; (x &lt;= k || y &lt;= k))
                    {
                        if(A[x] &gt; B[y])
                            dp[i][j][z] = A[x++];
                        else
                            dp[i][j][z] = B[y++];
                        if(dp[i][j][z] != dp[i][j][z - 1])
                            z++;
                    }
                }
                else memcpy(dp[i][j], dp[i - 1][j], sizeof dp[i - 1][j]);


        printf(&quot;%d\n&quot;, dp[n][v][k]);
    }
    return 0;
}</code></pre><h3 id="6-3树形DP"><a href="#6-3树形DP" class="headerlink" title="6.3树形DP"></a>6.3树形DP</h3><p>HDU1520 没有上司的舞会</p>
<pre><code>const int INF = 0x3f3f3f3f;
const int MAXN = 6e3 + 10;
const int MAXM = MAXN;
int happy[MAXN], dp[MAXN][2];
int in[MAXN], ou[MAXN], cnt, head[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs(int rt)
{
    dp[rt][0] = 0;
    dp[rt][1] = happy[rt];
    if(ou[rt] == 0) return;

    for(int i = head[rt]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        dfs(v);
        dp[rt][0] += max(dp[v][1], dp[v][0]);
        dp[rt][1] += dp[v][0];
    }
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        cnt = 0;
        memset(head, -1, sizeof head);
        memset(ou, 0, sizeof ou);
        memset(in, 0, sizeof in);
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;happy[i]);
        //k - &gt; l
        int l, k;
        while(scanf(&quot;%d%d&quot;, &amp;l, &amp;k) &amp;&amp; l + k)
        {
            addEdge(k, l);
            in[l]++;
            ou[k]++;
        }
        int i;
        for(i = 1; i &lt;= n; i++) if(in[i] == 0) break;
        dfs(i);             //i是根
        int ans = max(dp[i][0], dp[i][1]);      //0为不去，1为去
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre><p>HDU2196 Computer</p>
<pre><code>求树上某个点到其他点的最远距离.
二次扫描换根法
第一次由下往上，得到各个小根对于其子树的情况. 由下往上
第二次由上往下，得到以各个小根为主根的情况.   由上往下.
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int n, cnt;
ll f[MAXN][3];
int t[MAXN][2], head[MAXN];
struct Edge
{
    int v, next;
    ll w;
}edge[MAXN * 2];
void addEdge(int u, int v, int w)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dp(int u, int fa)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        ll w = edge[i].w;
        if(v == fa) continue;
        dp(v, u);
        if(f[u][0] &lt; f[v][0] + w)
        {
            t[u][0] = v; 
            f[u][1] = f[u][0];
            f[u][0] = f[v][0] + w;
        }
        else if(f[u][1] &lt; f[v][0] + w)
        {
            f[u][1] = f[v][0] + w;
            t[u][1] = v;
        }
    }
}
void dfs(int u, int fa)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        int w = edge[i].w;
        if(v == fa) continue;
        if(t[u][0] != v)    
            f[v][2] = max(f[u][0], f[u][2]) + w;
        else
            f[v][2] = max(f[u][1], f[u][2]) + w;
        dfs(v, u);     
    }
}
int main()
{

    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        for(int v = 2; v &lt;= n; v++)
        {
            int u; ll w;
            scanf(&quot;%d%lld&quot;, &amp;u, &amp;w);
            addEdge(u, v, w);
            addEdge(v, u, w);
        }
        memset(f, 0, sizeof f);
        memset(t, 0, sizeof t);
        dp(1,0);                //首先从下往上，求出f[i][0]和f[i][1].
        //以第1个电脑为根.
        //设dp[i]表示第i个节点的到数的其他点的最远距离是dp[i]
        //那么设第i个节点的两个子节点为u,v
        f[1][2] = f[1][1];
        dfs(1, 0);              //其次从上往下dfs
        for(int i = 1; i &lt;= n; i++)
            printf(&quot;%lld\n&quot;, max(f[i][0], f[i][2]));
    }
    return 0;
}</code></pre><h2 id="7-博弈"><a href="#7-博弈" class="headerlink" title="7.博弈"></a>7.博弈</h2><p>三大经典博弈：</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>[C++primer]第十六章模板与泛型编程</title>
    <url>/tpaaaaaa.github.io/2019/09/25/%5BC++primer%5D%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><pre><code>template &lt;typename T&gt;
int conmpare(const T &amp;v1, const T &amp;v2)
{
   if(v1 &lt;  v2)  return -1;
   if(v1 == v2)  return  0;
   return 1;
}</code></pre><p><strong>模板参数列表：</strong></p>
<pre><code>&lt;typename T&gt;</code></pre><p><strong>模板参数</strong></p>
<pre><code>T</code></pre><p><strong>模板实参</strong></p>
<p>当我们在调用一个函数模板时候，编译器通常用函数实参来为我们推断模板实参。当我们调用compare的时候，编译器使用实参的类型来确定绑定到模板参数T的类型。例如：</p>
<pre><code>cout &lt;&lt; compare(1, 0) &lt;&lt; endl;</code></pre><p>实参类型为int，编译器为推断出模板实参为int，并将它绑定到T上。</p>
<p><strong>实例化</strong></p>
<p>编译器用推断出的模板参数来为我们实例化一个特定版本的函数。</p>
<p>这些编译器生成的版本通常被称为模板的实例</p>
<p><strong>模板类型参数</strong></p>
<p><strong>类型参数（T）前必须使用关键字class 或者 typename（在模板参数列表中，这两个关键字的含义相同）</strong></p>
<p><strong>非类型模板参数</strong></p>
<p>一个非类型参数表示一个值而非一个类型。</p>
<p>当一个模板被实例化时，非类型模板参数被一个用户提供的或编译器推断的值所代替。这些值必须是常数表达式。</p>
<pre><code>template &lt;unsigned N, unsigned M&gt;
int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])
{
     return strcmp(p1, p2);
}
//调用
compare(&quot;hi&quot;, &quot;world&quot;);</code></pre><p>调用时，编译器会使用字面常数的大小来代替N,M。从而实例化模板。</p>
<p><strong>在模板定义中，模板非类型参数是一个常数值。在需要常数表达式的地方，可以使用非类型参数，例如指定数组大小</strong></p>
<p>另：</p>
<pre><code>int conmpare(const T &amp;v1, const T &amp;v2)</code></pre><p>模板中的函数参数是const的引用，使得我们保证了函数可以用于不能拷贝的类型。</p>
<p><strong>模板编译</strong></p>
<p>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本，编译器才生成代码。</p>
<p>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明，也包括定义。</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><pre><code>template &lt;typename T&gt; class Blob
{
   public:
   private:
}</code></pre><p>显式模板参数</p>
<pre><code>vector &lt; int &gt; vec;</code></pre><p>我们已经多次见到，在使用一个类模板的时候，我们必须提供额外的信息( &lt; int &gt;)。这些额外的信息就是显式模板实参。</p>
<p><strong>一个类模板的每个实例都是一个独立的类。</strong></p>
<p>可能令人迷惑的是，一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型的名字用作其模板参数。相反的，我们通常将模板自己的参数当做被使用模板的实参。</p>
<pre><code>template &lt;typename ElemType&gt; class LinkList
{
    protected:
        Node&lt;ElemType&gt; *head;        //链表的头指针
        int length;                 //链表的长度
    public:
...
}
//在LinkList这个模板类的定义中，使用了Node这个模板类</code></pre><p>类模板的成员函数本身是一个普通函数。但是，类模板的每一个实例都有其自己的版本的成员函数。因此，类模板的成员函数具有和模板相同的模板参数。因而，定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。</p>
<p>与往常一样，当我们在类外定义一个成员时，必须说明成员属于哪一个类。而且，从一个模板生成的类的名字中必须带有包含其模板参数。当我们定义一个成员函数时，模板实参与模板形参相同。</p>
<p>但有一个例外，就是在类模板自己的作用域中，我们可以直接使用模板名而不提供实参。</p>
<pre><code>#pragma once
template&lt;class ElemType&gt;
//在第index位置插入e,成功返回1，失败返回0
int LinkList&lt;ElemType&gt;::InsertElem(int index, const ElemType &amp;e)
{
   .....
}</code></pre><p>如果一个成员函数没有被使用，则他不会被实例化。也就是说即使某些函数不符合要求，如果没有被调用，我们仍然可以用该类型实例化的类。</p>
<p>跳过类模板和友元（P588）</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]快速幂 + 矩阵快速幂</title>
    <url>/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5D%E5%BF%AB%E9%80%9F%E5%B9%82+%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>快速幂模板</p>
<pre><code>//求a^b % MOD
int quickMod(int a,int b)
{
    int ans = 1;
    while (b)
    {
        if (b&amp;1)
            ans = ans * a % MOD;
        a = a*a % MOD;
        b &gt;&gt;= 1;
    }
    return ans;
}</code></pre><p>矩阵快速幂模板</p>
<p>一键三连的操作</p>
<p>1、矩阵定义 2、矩阵乘法 3、矩阵快速幂</p>
<pre><code>#include&lt;stdio.h&gt;  
#include&lt;string.h&gt;  
#include&lt;algorithm&gt;  
using namespace std;  
//*******************************************************//
const int siz = ??;           //矩阵的大小.
const int MOD = ??;           //矩阵快速幂的模数.
struct Mat//定义矩阵  
{  
    int mat[siz][siz];  
    void init()                //初始化为一个单位阵
    {  
        memset(mat, 0, sizeof(mat));  
        for(int i = 0; i &lt; siz; i++)
             mat[i][i] = 1;
     }   
};  
Mat mul(Mat a,Mat b)//矩阵乘法   
{  
    Mat ans;  
    ans.init();  
    for(int i = 0; i &lt; siz; i++)  
    {  
        for(int j = 0; j &lt; siz; j++)  
        {  
            ans.mat[i][j] = 0;  
            for(int k = 0; k &lt; siz; k++)  
                ans.mat[i][j] += a.mat[i][k] * b.mat[k][j];  
            ans.mat[i][j] %= MOD;  
        }  
    }  
    return ans;  
}  
Mat power(Mat a,int num)//矩阵快速幂模板   
{  
    Mat ans;  
    ans.init();  
    while(num)  
    {  
        if(num &amp; 1)  
            ans = mul(ans, a);
        num &gt;&gt;= 1;  
        a = mul(a, a);  
    }  
    return ans;  
}</code></pre>]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]AC自动机</title>
    <url>/tpaaaaaa.github.io/2019/09/23/%5B%E7%AE%97%E6%B3%95%5DAC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<p>模板HDU2222</p>
<p>静态开点800ms+，动态300+</p>
<p>原文链接：<a href="https://www.cnblogs.com/nullzx/p/7499397.html" target="_blank" rel="noopener">https://www.cnblogs.com/nullzx/p/7499397.html</a></p>
<p>Fail指针的意义：</p>
<p><strong>每个结点的fail指针表示：由根结点到该结点所组成的字符序列的所有后缀 和 整个目标字符串集合（也就是整个Trie树）中的所有前缀 两者中最长公共的部分</strong></p>
<h2 id="多模字符串匹配"><a href="#多模字符串匹配" class="headerlink" title="多模字符串匹配"></a>多模字符串匹配</h2><p>我们现在考虑这样一个问题，在一个文本串text中，我们想找出多个目标字符串target1,target2,……出现的次数和位置。例如：求出目标字符串集合{“nihao”,”hao”,”hs”,”hsr”}在给定文本”sdmfhsgnshejfgnihaofhsrnihao”中所有可能出现的位置。解决这个问题，我们一般的办法就是在文本串中对每个目标字符串单独查找，并记录下每次出现的位置。显然这样的方式能够解决问题，但是在文本串较大、目标字符串众多的时候效率比较低。为了提高效率，贝尔实验室于1975年发明著名的多模字符串匹配算法——AC自动机。AC自动机在实现上要依托于Trie树（也称字典树）并借鉴了KMP模式匹配算法的核心思想。实际上你可以把KMP算法看成每个节点都仅有一个孩子节点的AC自动机。</p>
<h2 id="AC自动机"><a href="#AC自动机" class="headerlink" title="AC自动机"></a>AC自动机</h2><p>AC自动机的基础是Trie树。和Trie树不同的是，树中的每个结点除了有指向孩子的指针（或者说引用），还有一个fail指针，它表示输入的字符与当前结点的<strong>所有孩子结点都不匹配时</strong>(注意，不是和该结点本身不匹配)，自动机的状态应转移到的状态（或者说应该转移到的结点）。fail指针的功能可以类比于KMP算法中next数组的功能。</p>
<p>我们现在来看一个用目标字符串集合{abd,abdk, abchijn, chnit, ijabdf, ijaij}构造出来的AC自动机</p>
<p><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213024913-519231123.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213032851-1965928350.png" alt="clip_image002_thumb4"></a></p>
<p>上图是一个构建好的AC自动机，其中根结点不存储任何字符，根结点的fail指针为null。<strong>虚线表示该结点的fail指针的指向</strong>，所有表示字符串的最后一个字符的结点外部都用红圈表示，我们称该结点为这个字符串的终结结点。每个结点实际上都有fail指针，但为了表示方便<strong>，本文约定一个原则，即所有指向根结点的 fail虚线都未画出</strong>。</p>
<p>从上图中的AC自动机，我们可以看出一个重要的性质：<strong>每个结点的fail指针表示由根结点到该结点所组成的字符序列的所有后缀　和　整个目标字符串集合（也就是整个Trie树）中的所有前缀 两者中最长公共的部分</strong>。</p>
<p>比如图中，由根结点到目标字符串“ijabdf”中的 ‘d’组成的字符序列“ijabd”的所有后缀在整个目标字符串集{abd,abdk, abchijn, chnit, ijabdf, ijaij}的所有前缀中最长公共的部分就是abd，而图中d结点（字符串“ijabdf”中的这个d）的fail正是指向了字符序列abd的最后一个字符。</p>
<h2 id="AC自动机的运行过程"><a href="#AC自动机的运行过程" class="headerlink" title="AC自动机的运行过程"></a>AC自动机的运行过程</h2><p>1.表示当前结点的指针指向AC自动机的根结点，即curr = root</p>
<p>2.从文本串中读取（下）一个字符</p>
<p>3.从<strong>当前结点的所有孩子结点</strong>中寻找与该字符匹配的结点，</p>
<p>  若成功：<strong>判断当前结点以及当前结点fail指向的结点</strong>是否表示一个字符串的结束，若是，则将文本串中索引起点记录在对应字符串保存结果集合中（索引起点= 当前索引-字符串长度+1）。curr指向该孩子结点，继续执行第2步</p>
<p>  若失败：执行第4步。</p>
<p><strong>4**</strong>）**若fail == null（说明目标字符串中没有任何字符串是输入字符串的前缀，相当于重启状态机）curr = root, 执行步骤2，</p>
<p>  否则，将当前结点的指针指向fail结点，执行步骤3)</p>
<p>现在，我们来一个具体的例子加深理解，初始时当前结点为root结点，我们现在假设文本串text = “abchnijabdfk”。</p>
<p><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213044226-1925625313.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213054866-1721843829.png" alt="clip_image004_thumb2"></a></p>
<p>图中的实曲线表示了整个搜索过程中的当前结点指针的转移过程，结点旁的文字表示了当前结点下读取的文本串字符。比如初始时，当前指针指向根结点时，输入字符‘a’,则当前指针指向结点a，此时再输入字符‘b’,自动机状态转移到结点b,……，以此类推。图中AC自动机的最后状态只是恰好回到根结点。</p>
<p>需要说明的是，当指针位于结点b（图中曲线经过了两次b,这里指第二次的b，即目标字符串“ijabdf”中的b）,这时读取文本串字符下标为9的字符（即‘d’）时，由于b的所有孩子结点（这里恰好只有一个孩子结点）中存在能够匹配输入字符d的结点,那么当前结点指针就指向了结点d，而此时该结点d的fail指针指向的结点又恰好表示了字符串“abc”的终结结点（用红圈表示），所以我们找到了目标字符串“abc”一次。这个过程我们在图中用虚线表示，但状态没有转移到“abd”中的d结点。</p>
<p>在输入完所有文本串字符后，我们在文本串中找到了目标字符串集合中的abd一次，位于文本串中下标为7的位置；目标字符串ijabdf一次，位于文本串中下标为5的位置。</p>
<h2 id="构造AC自动机的方法与原理"><a href="#构造AC自动机的方法与原理" class="headerlink" title="构造AC自动机的方法与原理"></a>构造AC自动机的方法与原理</h2><h3 id="1-构造的基本方法"><a href="#1-构造的基本方法" class="headerlink" title="1.构造的基本方法"></a>1.构造的基本方法</h3><p><strong>首先我们将所有的目标字符串插入到Trie树中</strong>，<strong>然后通过广度优先遍历为每个结点的所有孩子节点的fail指针找到正确的指向</strong>。</p>
<p>确定fail指针指向的问题和KMP算法中构造next数组的方式如出一辙。具体方法如下</p>
<p>1）将根结点的所有孩子结点的fail指向根结点，然后将根结点的所有孩子结点依次入列。</p>
<p>2）若队列不为空：</p>
<p>  2.1）出列，我们将出列的结点记为curr, failTo表示curr的fail指向的结点，即failTo = curr.fail</p>
<p>  2.2) a.判断curr.child[i] == failTo.child[i]是否成立，</p>
<p>​              成立：curr.child[i].fail = failTo.child[i]，</p>
<p>​              不成立：判断 failTo == null是否成立</p>
<p>​                             成立： curr.child[i].fail == root</p>
<p>​                             不成立：执行failTo = failTo.fail，继续执行2.2）</p>
<p>​            b.curr.child[i]入列，再次执行再次执行步骤2)</p>
<p>  若队列为空:结束</p>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>每个结点fail指向的解决顺序是按照<strong>广度优先遍历</strong>的顺序完成的，或者说<strong>层序遍历</strong>的顺序进行的，也就是说我们是在解决当前结点的孩子结点fail的指向时，当前结点的fail指针一定已指向了正确的位置。</p>
<p><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213102101-1121823381.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213108835-1236999124.png" alt="clip_image006_thumb4"></a></p>
<p>为了说明问题，我们再次强调“<strong>每个结点的fail指针表示：由根结点到该结点所组成的字符序列的所有后缀 和 整个目标字符串集合（也就是整个Trie树）中的所有前缀 两者中最长公共的部分”</strong>。</p>
<p>以上图所示为例，我们要解决结点x1的某个孩子结点y的fail的指向问题。已知x1.fail指向x2，依据x1结点的fail指针的含义，我们可知红色实线椭圆框内的字符序列必然相等，且表示了<strong>最长</strong>公共部分。依据y.fail的含义，如果x2的某个孩子结点和结点y表示的字符相等，那么y.fail就该指向它。</p>
<p>如果x2的孩子结点中不存在结点y表示的字符，这个时候该怎么办？由于x2.fail指向x3，根据x2.fail的含义，我们可知绿色方框内的字符序列必然相等。显然，如果x3的某个孩子结点和结点y表示的字符相等，那么y.fail就该指向它。</p>
<p>如果x3的孩子结点中不存在结点y表示的字符，我们可以依次重复这个步骤，直到xi结点的fail指向null，这时说明我们已经到了最顶层的根结点，这时，我们只需要让ｙ.fail = root即可。</p>
<p><strong>构造的过程的核心本质就是，已知当前结点的最长公共前缀的前提下，去确定孩子结点的最长公共前缀。这完全可以类比于KMP算法的next数组的求解过程。</strong></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>现在我们假设我们要确定图中结点c的孩子结点h的fail指向。图中每个结点都应该有表示fail的虚线，但为了表示方便<strong>，按照本文约定的原则，所有指向根结点的 fail虚线均未画出</strong>。</p>
<p><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213121460-786707408.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213129726-1090255551.png" alt="clip_image008_thumb4"></a><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213136241-866807221.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213143335-623957692.png" alt="clip_image010_thumb3"></a></p>
<p>左图表示h.fail确定之前， 右图表示h.fail确定之后</p>
<p>左图中，蓝色实线框住的结点的fail都已确定。现在我们应该怎样找到h.fail的正确指向？由于且结点c的fail已知（c结点为h结点的父结点），且指向了Trie树中所有前缀与字符序列‘a’‘b’‘c’的所有后缀（“bc”和“c”）的最长公共部分。现在我们要解决的问题是目标字符串集合的所有前缀中与字符序列‘a’‘b’‘c’ ‘h’的所有后缀的最长公共部分。显然c.fail指向的结点的孩子结点中存在结点h，那么h.fail就应该指向c.fail的孩子结点h，所以右图表示了h.fail确定后的情况。</p>
<p><strong>3.2.2</strong> <strong>确定图中i.fail指向的过程</strong></p>
<p><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213149616-440573765.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213158304-1878910878.png" alt="clip_image012_thumb3"></a><a href="http://images2017.cnblogs.com/blog/834468/201709/834468-20170909213205554-1948386548.png" target="_blank" rel="noopener"><img src="https://images2017.cnblogs.com/blog/834468/201709/834468-20170909213212351-181563923.png" alt="clip_image014_thumb4"></a></p>
<p>左图表示i.fail确定之前， 右图表示i.fail确定之后</p>
<p>确定i.fail的指向时，显然h.fail(h指图中i的父结点的那个h)已指向了正确的位置。也就是说我们现在知道了目标字符串集合所有前缀中与字符序列‘a’‘b’‘c’ ‘h’的所有后缀在Trie树中的最长前缀是‘c’‘h’。显然从图中可知h.fail的孩子结点是没有i结点（这里h.fail只有一个孩子结点n）。字符序列‘c’‘h’的所有后缀在Trie树中的最长前缀可由h.fail的fail得到，而h.fail的fail指向root（依据本博客中画图的原则，这条fail虚线并未画出）,root的孩子结点中存在表示字符i的结点,所以结果如右图所示。</p>
<p>在知道i.fail的情况下，大家可以尝试在纸上画出j.fail的指向，以加深AC自动机构造过程的理解。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-23-09.18.58
 By                : Tpaaaaaa
 Question_Number   ：ac
 Question_Name     ：自动机
 Description       :

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
// Trie树的结构体
struct Trie
{
    int nxt[MAXN][26], fail[MAXN], edn[MAXN];
    int root, tot;
    //将当前节点初始化
    int newNode()
    {
        tot ++;         //用来记录结点编号的
        for(int i = 0; i &lt; 26; i++)
            nxt[tot][i] = -1;
        edn[tot] = 0;
        return tot;     //返回编号
    }
    void init()
    {
        tot = 0;
        root = newNode();//root一般而言是1
    }
    //往trie树中插入buf
    void add(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            if(nxt[p][now] == -1)
                nxt[p][now] = newNode();

            p = nxt[p][now];
        }
        edn[p]++;
    }
    //AC自动机的构建，也就是fail数组的构建
    void build()
    {
        queue &lt; int &gt; Q;
        fail[root] = root;
        //对根的结点单独处理一哈
        for(int i = 0; i &lt; 26; i++)
        {
            if(nxt[root][i] == -1)
                nxt[root][i] = root;
            else
            {
                fail[nxt[root][i]] = root;
                Q.push(nxt[root][i]);
            }
        }
        while(!Q.empty())
        {
            int now = Q.front();
            Q.pop();
            for(int i = 0; i &lt; 26; i++)
            {
                if(nxt[now][i] == -1)
                    nxt[now][i] = nxt[fail[now]][i];
                else
                {
                    fail[nxt[now][i]] = nxt[fail[now]][i];
                    Q.push(nxt[now][i]);
                }
            }
        }
    }
    int query(char buf[])
    {
        int len = strlen(buf);
        int p = root;
        int res = 0;
        for(int i = 0; i &lt; len; i++)
        {
            int now = buf[i] - &apos;a&apos;;
            p = nxt[p][now];
            int temp = p;
            while(temp != root)
            {
                res += edn[temp];
                edn[temp] = 0;
                temp = fail[temp];
            }
        }
        return res;
    }
};
char buf[2*MAXN];
Trie AC;
int main()
{
    int t;
    int n;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        AC.init();
        for(int i = 0; i &lt; n; i++)
        {
            scanf(&quot;%s&quot;, buf);
            AC.add(buf);
        }
        AC.build();
        scanf(&quot;%s&quot;, buf);
        printf(&quot;%d\n&quot;, AC.query(buf));
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]扩展KMP</title>
    <url>/tpaaaaaa.github.io/2019/09/22/%5B%E7%AE%97%E6%B3%95%5D%E6%89%A9%E5%B1%95KMP/</url>
    <content><![CDATA[<p>参考博客：<a href="https://segmentfault.com/a/1190000008663857" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008663857**</a>**</p>
<p><strong>给S和T串，问T串在S串中出现的情况（次数，位置等）</strong></p>
<p><strong>字符串匹配问题</strong></p>
<p><strong>S串：被匹配串</strong></p>
<p><strong>T串：匹配串</strong></p>
<h4 id="KMP-与-EXKMP-中特殊数组的含义！！！！！"><a href="#KMP-与-EXKMP-中特殊数组的含义！！！！！" class="headerlink" title="KMP 与 EXKMP 中特殊数组的含义！！！！！"></a><strong>KMP 与 EXKMP 中特殊数组的含义！！！！！</strong></h4><p><strong>KMP: next[i] 表示的是匹配串T中[1, i - 1]子串的最长公共前后缀长度</strong>                        （是关于T串的）</p>
<p><strong>EXKMP：extend[i] 表示的是被匹配串S中[i, n]子串与T的最长公共前缀长度</strong>            （是关于S串的）</p>
<p>​                 <strong>next[i]</strong>： <code>T[i]...T[m]</code>与T的最长相同前缀长度；</p>
<h2 id="EXKMP"><a href="#EXKMP" class="headerlink" title="EXKMP"></a>EXKMP</h2><p><strong>问题定义：</strong>给定两个字符串S和T（长度分别为n和m），下标从0开始，定义<code>extend[i]</code>等于<code>S[i]...S[n-1]</code>与T的最长相同前缀的长度，求出所有的<code>extend[i]</code>。举个例子，看下表：</p>
<table>
<thead>
<tr>
<th align="center">i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
<th align="center">6</th>
<th align="center">7</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">b</td>
<td align="center">b</td>
<td align="center">b</td>
</tr>
<tr>
<td align="center">T</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">c</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">extend[i]</td>
<td align="center">5</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>为什么说这是KMP算法的扩展呢？<strong>显然，如果在S的某个位置i有<code>extend[i]</code>等于m，则可知在S中找到了匹配串T，并且匹配的首位置是i。而且，扩展KMP算法可以找到S中所有T的匹配。</strong>接下来具体介绍下这个算法。</p>
<h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>（1）</p>
<p><img src="https://segmentfault.com/img/remote/1460000016238171?w=760&h=310" alt="img"></p>
<p>如上图，假设当前遍历到S串位置i，即<code>extend[0]...extend[i - 1]</code>这i个位置的值已经计算得到。设置两个变量，a和p。p代表以a为起始位置的字符匹配成功的最右边界，也就是”p = 最后一个匹配成功位置 + 1”。相较于字符串T得出，<strong>S[a…p)等于T[0…p-a)</strong>。</p>
<p>再定义一个辅助数组<code>int next[]</code>，其中<code>next[i]</code>含义为：<code>T[i]...T[m - 1]</code>与T的最长相同前缀长度，m为串T的长度。举个例子：</p>
<table>
<thead>
<tr>
<th align="center">i</th>
<th align="center">0</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">T</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">a</td>
<td align="center">c</td>
</tr>
<tr>
<td align="center">next[i]</td>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<p>（2）</p>
<p><img src="https://segmentfault.com/img/remote/1460000016238172?w=760&h=310" alt="img"></p>
<p><code>S[i]</code>对应<code>T[i - a]</code>，如果<code>i + next[i - a] &lt; p</code>，如上图，三个椭圆长度相同，根据next数组的定义，此时<code>extend[i] = next[i - a]</code>。</p>
<p>（3）</p>
<p><img src="https://segmentfault.com/img/remote/1460000016238173?w=760&h=310" alt="img"></p>
<p>如果<code>i + next[i - a] == p</code>呢？如上图，三个椭圆都是完全相同的，<code>S[p] != T[p - a]</code>且<code>T[p - i] != T[p - a]</code>，但<code>S[p]</code>有可能等于<code>T[p - i]</code>，所以我们可以直接从<code>S[p]</code>与<code>T[p - i]</code>开始往后匹配，加快了速度。</p>
<p>（4）</p>
<p><img src="https://segmentfault.com/img/remote/1460000016238174?w=760&h=310" alt="img"></p>
<p>如果<code>i + next[i - a] &gt; p</code>呢？那说明<code>S[i...p)</code>与<code>T[i-a...p-a)</code>相同，注意到<code>S[p] != T[p - a]</code>且<code>T[p - i] == T[p - a]</code>，也就是说<code>S[p] != T[p - i]</code>，所以就没有继续往下判断的必要了，我们可以直接将<code>extend[i]</code>赋值为<code>p - i</code>。</p>
<p>（5）最后，就是求解next数组。我们再来看下<code>next[i]</code>与<code>extend[i]</code>的定义：</p>
<ul>
<li><strong>next[i]</strong>： <code>T[i]...T[m - 1]</code>与T的<strong>最长相同前缀长度；</strong></li>
<li><strong>extend[i]</strong>： <code>S[i]...S[n - 1]</code>与T的<strong>最长相同前缀长度。</strong></li>
</ul>
<p>恍然大悟，求解<code>next[i]</code>的过程不就是T自己和自己的一个匹配过程嘛，下面直接看代码。</p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>[随笔]今日份莫名高产</title>
    <url>/tpaaaaaa.github.io/2019/09/21/%5B%E9%9A%8F%E7%AC%94%5D%E4%BB%8A%E6%97%A5%E4%BB%BD%E8%8E%AB%E5%90%8D%E9%AB%98%E4%BA%A7/</url>
    <content><![CDATA[<p>可能是晚上睡得太好了。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2752Seek the Name, Seek the Fame</title>
    <url>/tpaaaaaa.github.io/2019/09/21/POJ2752SeektheName,SeektheFame/</url>
    <content><![CDATA[<p>Seek the Name, Seek the Fame</p>
<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 28356</p>
<p><strong>Accepted:</strong> 14718</p>
<p>DescriptionThe little cat is so famous, that many couples tramp over hill and dale to Byteland, and asked the little cat to give names to their newly-born babies. They seek the name, and at the same time seek the fame. In order to escape from such boring job, the innovative little cat works out an easy but fantastic algorithm: </p>
<p>Step1. Connect the father’s name and the mother’s name, to a new string S.<br>Step2. Find a proper prefix-suffix string of S (which is not only the prefix, but also the suffix of S). </p>
<p>Example: Father=’ala’, Mother=’la’, we have S = ‘ala’+’la’ = ‘alala’. Potential prefix-suffix strings of S are {‘a’, ‘ala’, ‘alala’}. Given the string S, could you help the little cat to write a program to calculate the length of possible prefix-suffix strings of S? (He might thank you by giving your baby a name:)   </p>
<p>InputThe input contains a number of test cases. Each test case occupies a single line that contains the string S described above. </p>
<p>Restrictions: Only lowercase letters may appear in the input. 1 &lt;= Length of S &lt;= 400000.   </p>
<p>OutputFor each test case, output a single line with integer numbers in increasing order, denoting the possible length of the new baby’s name.</p>
<p>Sample Input</p>
<p>ababcababababcabab<br>aaaaa</p>
<p>Sample Output</p>
<p>2 4 9 18<br>1 2 3 4 5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>假设串s的长度为n<br>我们可以求出next数组，那么next[n] = len存的就是这个数组的最长公共前后缀的长度<br>那么我们可以得到最长公共前后缀就是s[0] … s[len - 1]<br>我们令这个最长公共前后缀为s2<br>s2的长度为len，那么next[len] = len 存的就是这个串的最长公共前后缀的长度<br>依次递归下去。知道next[len] = 0, 也就是不存在最长公共前后的情况，递归结束</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>void getNext()
{
    int m = strlen(a);
    nxt[0] = -1;
    int i = 0, j = -1;
    while(i &lt; m)
        if(j == -1 || a[i] == a[j])
            nxt[++i] = ++j;
        else
            j = nxt[j];
}
//输出
void dfs(int m)
{
    if(nxt[m] == 0||nxt[m] == -1) return;
    dfs(nxt[m]);
    printf(&quot;%d &quot;, nxt[m]);
}
int main()
{
    while(scanf(&quot;%s&quot;, a) != EOF)
    {
        getNext();
        int m = strlen(a);
        dfs(m);
        printf(&quot;%d\n&quot;, m);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP中的next数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2406 Power String</title>
    <url>/tpaaaaaa.github.io/2019/09/21/POJ2406PowerString/</url>
    <content><![CDATA[<p>Power Strings</p>
<p><strong>Time Limit:</strong> 3000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 67246</p>
<p><strong>Accepted:</strong> 27749</p>
<p>DescriptionGiven two strings a and b we define a*b to be their concatenation. For example, if a = “abc” and b = “def” then a*b = “abcdef”. If we think of concatenation as multiplication, exponentiation by a non-negative integer is defined in the normal way: a^0 = “” (the empty string) and a^(n+1) = a*(a^n).</p>
<p>InputEach test case is a line of input representing s, a string of printable characters. The length of s will be at least 1 and will not exceed 1 million characters. A line containing a period follows the last test case.</p>
<p>OutputFor each s you should print the largest n such that s = a^n for some string a.</p>
<p>Sample Input</p>
<p>abcd<br>aaaa<br>ababab<br>.</p>
<p>Sample Output</p>
<p>1<br>4<br>3</p>
<p>HintThis problem has huge input, use scanf instead of cin to avoid time limit exceed.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>利用KMP算法中的next解循环节问题</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>void getNext()
{
    int m = strlen(a);
    nxt[0] = -1;
    int i = 0, j = - 1;
    while(i &lt; m)
        if(j == -1 || a[i] == a[j])
            nxt[++i] = ++j;
        else
            j = nxt[j];
}
int main()
{
    while(scanf(&quot;%s&quot;, a))
    {
        if(strcmp(a, &quot;.&quot;) == 0)  break;
        getNext();
        int m = strlen(a);
        int len = m - nxt[m];
        if(len == m || m % len)
            printf(&quot;1\n&quot;);
        else
            printf(&quot;%d\n&quot;, m / len);
        //  len是最小循环节。但是可能存在m无法整除len的情况
        //  无法整除就是1
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法中的next解循环节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1358 Period</title>
    <url>/tpaaaaaa.github.io/2019/09/21/HDU1358Period/</url>
    <content><![CDATA[<h1 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h1><p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65536/32768 K (Java/Others)<br>Total Submission(s): 16456    Accepted Submission(s): 7655<br>*</em></p>
<p>Problem DescriptionFor each prefix of a given string S with N characters (each character has an ASCII code between 97 and 126, inclusive), we want to know whether the prefix is a periodic string. That is, for each i (2 &lt;= i &lt;= N) we want to know the largest K &gt; 1 (if there is one) such that the prefix of S with length i can be written as AK , that is A concatenated K times, for some string A. Of course, we also want to know the period K.  </p>
<p>InputThe input file consists of several test cases. Each test case consists of two lines. The first one contains N (2 &lt;= N &lt;= 1 000 000) – the size of the string S. The second line contains the string S. The input file ends with a line, having the number zero on it.  </p>
<p>OutputFor each test case, output “Test case #” and the consecutive test case number on a single line; then, for each prefix with length i that has a period K &gt; 1, output the prefix size i and the period K separated by a single space; the prefix sizes must be in increasing order. Print a blank line after each test case.  </p>
<p>Sample Input</p>
<p>3<br>aaa<br>12<br>aabaabaabaab<br>0</p>
<p>Sample Output</p>
<p>Test case #1<br>2 2<br>3 3</p>
<p>Test case #2<br>2 2<br>6 2<br>9 3<br>12 4</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>利用KMP算法中的next数组解出最小循环节。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>void getNext()
{
    int m = strlen(a);
    nxt[0] = -1;
    int i = 0, j = -1;
    while(i &lt; m)
        if(j == -1 || a[i] == a[j])
            nxt[++i] = ++j;
    else
        j = nxt[j];
}
int main()
{
    int kase = 0, n;
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        scanf(&quot;%s&quot;, a);
        printf(&quot;Test case #%d\n&quot;, ++kase);
        getNext();
        for(int i = 1; i &lt;= n; i++)
        {
            int len = i - nxt[i];
            //len是循环节的长度
            //nxt == 0，意味着自己就是一个循环节
            //我们不考虑这个情况
            if(nxt[i] != 0 &amp;&amp; i % len == 0)
                printf(&quot;%d %d\n&quot;, i, i / len);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法中的next解循环节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3746 Cyclic Nacklace</title>
    <url>/tpaaaaaa.github.io/2019/09/21/HDU3746CyclicNacklace/</url>
    <content><![CDATA[<h1 id="Cyclic-Nacklace"><a href="#Cyclic-Nacklace" class="headerlink" title="Cyclic Nacklace"></a>Cyclic Nacklace</h1><p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 21149    Accepted Submission(s): 8649<br>*</em></p>
<p>Problem DescriptionCC always becomes very depressed at the end of this month, he has checked his credit card yesterday, without any surprise, there are only 99.9 yuan left. he is too distressed and thinking about how to tide over the last days. Being inspired by the entrepreneurial spirit of “HDU CakeMan”, he wants to sell some little things to make money. Of course, this is not an easy task.</p>
<p>As Christmas is around the corner, Boys are busy in choosing christmas presents to send to their girlfriends. It is believed that chain bracelet is a good choice. However, Things are not always so simple, as is known to everyone, girl’s fond of the colorful decoration to make bracelet appears vivid and lively, meanwhile they want to display their mature side as college students. after CC understands the girls demands, he intends to sell the chain bracelet called CharmBracelet. The CharmBracelet is made up with colorful pearls to show girls’ lively, and the most important thing is that it must be connected by a cyclic chain which means the color of pearls are cyclic connected from the left to right. And the cyclic count must be more than one. If you connect the leftmost pearl and the rightmost pearl of such chain, you can make a CharmBracelet. Just like the pictrue below, this CharmBracelet’s cycle is 9 and its cyclic count is 2:  </p>
<p><img src="http://acm.hdu.edu.cn/data/images/C319-1003-1.jpg" alt=""></p>
<p>Now CC has brought in some ordinary bracelet chains, he wants to buy minimum number of pearls to make CharmBracelets so that he can save more money. but when remaking the bracelet, he can only add color pearls to the left end and right end of the chain, that is to say, adding to the middle is forbidden.<br>CC is satisfied with his ideas and ask you for help.<br>InputThe first line of the input is a single integer T ( 0 &lt; T &lt;= 100 ) which means the number of test cases.<br>Each test case contains only one line describe the original ordinary chain to be remade. Each character in the string stands for one pearl and there are 26 kinds of pearls being described by ‘a’ ~’z’ characters. The length of the string Len: ( 3 &lt;= Len &lt;= 100000 ).<br>OutputFor each case, you are required to output the minimum count of pearls added to make a CharmBracelet.<br>Sample Input</p>
<p>3<br>aaa<br>abca<br>abcde</p>
<p>Sample Output</p>
<p>0<br>2<br>5</p>
<p>Authorpossessor WC<br>Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&key=HDU+3rd+%A1%B0Vegetable-Birds+Cup%A1%B1+Programming+Open+Contest&source=1&searchmode=source" target="_blank" rel="noopener">HDU 3rd “Vegetable-Birds Cup” Programming Open Contest</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>利用next数组求最小循环节</strong>（妙哉妙哉）</p>
<p><strong>串中长度为m的前缀中的最小循环节的长度为 len = m - next[m]</strong></p>
<p>推荐博客<a href="https://www.cnblogs.com/bofengyu/p/4939138.html" target="_blank" rel="noopener">https://www.cnblogs.com/bofengyu/p/4939138.html</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>主程序部分</p>
<pre><code>while(T--)
{
    scanf(&quot;%s&quot;, a);
    int m =strlen(a);
    getNext();
    int len = m - nex[m];
    if(nex[m] == 0)   //next[0] 也表示了没有公共前后缀，即最小循环节就是自己
        printf(&quot;%d\n&quot;, m);
    else if(m % len == 0)
        printf(&quot;%d\n&quot;, 0);
    else
        printf(&quot;%d\n&quot;, len - m % len);
}</code></pre><p>getNext函数还是常规的</p>
<pre><code>void getNext()
{
    int m = strlen(a);
    int i = 0, j = -1;
    nex[0] = -1;
    while(i &lt; m)
        if(j == -1 || a[i] == a[j])
            nex[++i] = ++j;
        else
            j = nex[j];

}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法中的next解循环节问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2087 剪画布条</title>
    <url>/tpaaaaaa.github.io/2019/09/21/HDU2087%E5%89%AA%E7%94%BB%E5%B8%83%E6%9D%A1/</url>
    <content><![CDATA[<h1 id="剪花布条"><a href="#剪花布条" class="headerlink" title="剪花布条"></a>剪花布条</h1><p>*<em>Time Limit: 1000/1000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 38077    Accepted Submission(s): 23263<br>*</em></p>
<p>Problem Description一块花布条，里面有些图案，另有一块直接可用的小饰条，里面也有一些图案。对于给定的花布条和小饰条，计算一下能从花布条中尽可能剪出几块小饰条来呢？  </p>
<p>Input输入中含有一些数据，分别是成对出现的花布条和小饰条，其布条都是用可见ASCII字符表示的，可见的ASCII字符有多少个，布条的花纹也有多少种花样。花纹条和小饰条不会超过1000个字符长。如果遇见#字符，则不再进行工作。  </p>
<p>Output输出能从花纹布中剪出的最多小饰条个数，如果一块都没有，那就老老实实输出0，每个结果之间应换行。  </p>
<p>Sample Input</p>
<p>abcde a3<br>aaaaaa  aa<br>#</p>
<p>Sample Output</p>
<p>0<br>3</p>
<p>Authorqianneng<br>Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&key=%B6%AC%C1%B7%C8%FD%BE%C5%D6%AE%B6%FE&source=1&searchmode=source" target="_blank" rel="noopener">冬练三九之二</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>就是改一下KMP里面，模式串匹配上了，将 j 移动到模式串的首端，将 i 移动到文本串的后面一位</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>void getNext()
{
    int m = strlen(b);
    nex[0] = -1;
    int i = 0, j = -1;
    while(i &lt; m)
    {
        if(j == -1 || b[i] == b[j])
            nex[++i] = ++j;
        else
            j = nex[j];
    }
}
int kmp()
{
    getNext();              //为什么不报错呀？

    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i], b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum ++;
            j = 0;    //模式串首端
            i ++;     //文本串的下一位
            continue;
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3461 Oulipo</title>
    <url>/tpaaaaaa.github.io/2019/09/21/POJ3461Oulipo/</url>
    <content><![CDATA[<p>Oulipo</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 57715</p>
<p><strong>Accepted:</strong> 22488</p>
<p>Description</p>
<p>The French author Georges Perec (1936–1982) once wrote a book, La disparition, without the letter ‘e’. He was a member of the Oulipo group. A quote from the book:</p>
<blockquote>
<p>Tout avait Pair normal, mais tout s’affirmait faux. Tout avait Fair normal, d’abord, puis surgissait l’inhumain, l’affolant. Il aurait voulu savoir où s’articulait l’association qui l’unissait au roman : stir son tapis, assaillant à tout instant son imagination, l’intuition d’un tabou, la vision d’un mal obscur, d’un quoi vacant, d’un non-dit : la vision, l’avision d’un oubli commandant tout, où s’abolissait la raison : tout avait l’air normal mais…</p>
</blockquote>
<p>Perec would probably have scored high (or rather, low) in the following contest. People are asked to write a perhaps even meaningful text on some subject with as few occurrences of a given “word” as possible. Our task is to provide the jury with a program that counts these occurrences, in order to obtain a ranking of the competitors. These competitors often write very long texts with nonsense meaning; a sequence of 500,000 consecutive ‘T’s is not unusual. And they never use spaces.</p>
<p>So we want to quickly find out how often a word, i.e., a given string, occurs in a text. More formally: given the alphabet {‘A’, ‘B’, ‘C’, …, ‘Z’} and two finite strings over that alphabet, a word <em>W</em> and a text <em>T</em>, count the number of occurrences of <em>W</em> in <em>T</em>. All the consecutive characters of W must exactly match consecutive characters of <em>T</em>. Occurrences may overlap.</p>
<p>Input</p>
<p>The first line of the input file contains a single number: the number of test cases to follow. Each test case has the following format:</p>
<ul>
<li>One line with the word <em>W</em>, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with 1 ≤ |<em>W</em>| ≤ 10,000 (here |<em>W</em>| denotes the length of the string <em>W</em>).</li>
<li>One line with the text <em>T</em>, a string over {‘A’, ‘B’, ‘C’, …, ‘Z’}, with |<em>W</em>| ≤ |<em>T</em>| ≤ 1,000,000.</li>
</ul>
<p>Output</p>
<p>For every test case in the input file, the output should contain a single number, on a single line: the number of occurrences of the word <em>W</em> in the text <em>T</em>.</p>
<p>Sample Input</p>
<p>3<br>BAPC<br>BAPC<br>AZA<br>AZAZAZA<br>VERDI<br>AVERDXIVYERDIAN</p>
<p>Sample Output</p>
<p>1<br>3<br>0</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>意思：给出文本串和模式串<br>问模式串在文本串中出现多少次<br>把KMP中的找到部分稍稍改动下就ok了。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>KMP和getNext部分（串从0开始）</p>
<pre><code>void getNext()
{
    int m = strlen(b);
    nex[0] = -1;        //要小于他自己的下标
    int i = 0, j = -1;
    while(i &lt; m)
    {
        if(j == -1 || b[i] == b[j])
            nex[++i] = ++j;
        else
            j = nex[j];
    }
}
int kmp()
{
    getNext();
    int sum = 0;
    int n = strlen(a);
    int m = strlen(b);
    //a[i],b[j]
    int i = 0, j = 0;
    while(i &lt; n &amp;&amp; j &lt; m)
    {
        if(j == m - 1 &amp;&amp; a[i] == b[j])
        {
            sum++;
            j = nex[j];
        }
        if(j == -1 || a[i] == b[j])
            i++,j++;
        else
            j = nex[j];
    }
    return sum;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 1711 Number Sequence</title>
    <url>/tpaaaaaa.github.io/2019/09/21/HDU1711NumberSequence/</url>
    <content><![CDATA[<h1 id="Number-Sequence"><a href="#Number-Sequence" class="headerlink" title="Number Sequence"></a>Number Sequence</h1><p>*<em>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 32768/32768 K (Java/Others)<br>Total Submission(s): 53899    Accepted Submission(s): 21619<br>*</em></p>
<p>Problem DescriptionGiven two sequences of numbers : a[1], a[2], …… , a[N], and b[1], b[2], …… , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], …… , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one.  </p>
<p>InputThe first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate a[1], a[2], …… , a[N]. The third line contains M integers which indicate b[1], b[2], …… , b[M]. All integers are in the range of [-1000000, 1000000].  </p>
<p>OutputFor each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead.  </p>
<p>Sample Input</p>
<p>2<br>13 5<br>1 2 1 2 3 1 2 3 1 3 2 1 2<br>1 2 3 1 3<br>13 5<br>1 2 1 2 3 1 2 3 1 3 2 1 2<br>1 2 3 2 1</p>
<p>Sample Output</p>
<p>6<br>-1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>给定两个数字序列 a[] 和 b[]，<br>b[] 有可能整体作为一个连续子序列出现在了 a[] 中，<br>现在请你找出 b[] 在 a[] 中第一次出现的位置</p>
<p>KMP算法的板子题。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>while(T--)
{
    memset(a, 0, sizeof a);
    memset(b, 0, sizeof b);
    memset(nex, 0, sizeof nex);
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    //s1 = a[]是长串，长度为n
    for(int i = 1; i &lt;= m; i++)
        scanf(&quot;%d&quot;, &amp;b[i]);
    //s2 = b[]是短串，长度为m
    printf(&quot;%d\n&quot;, kmp());
}</code></pre><p>KMP算法（数组从1开始）部分：</p>
<pre><code>int kmp()
{
    getNext();
    int i = 1, j = 1;
    //a[i], b[j]
    while(i &lt;= n &amp;&amp; j &lt;= m)
    {
        if(a[i] == b[j] || j == 0)
            i++,j++;
        else
            j = nex[j];
    }
    if(j &gt; m)   return i - m;
    else return -1;
}</code></pre><p>得到next数组</p>
<pre><code>void getNext()
{
    int i = 1, j = 0;
    nex[1] = 0;
    while(i &lt;= m)
    {
        if(j == 0 || b[i] == b[j])
            nex[++i] = ++j;
        else
            j = nex[j];
    }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>KMP算法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3630 Phone List</title>
    <url>/tpaaaaaa.github.io/2019/09/21/POJ3630PhoneList/</url>
    <content><![CDATA[<p>Phone List</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 38326</p>
<p><strong>Accepted:</strong> 10790</p>
<p>Description</p>
<p>Given a list of phone numbers, determine if it is consistent in the sense that no number is the prefix of another. Let’s say the phone catalogue listed these numbers:</p>
<ul>
<li>Emergency 911</li>
<li>Alice 97 625 999</li>
<li>Bob 91 12 54 26</li>
</ul>
<p>In this case, it’s not possible to call Bob, because the central would direct your call to the emergency line as soon as you had dialled the first three digits of Bob’s phone number. So this list would not be consistent.</p>
<p>Input</p>
<p>The first line of input gives a single integer, 1 ≤ <em>t</em> ≤ 40, the number of test cases. Each test case starts with <em>n</em>, the number of phone numbers, on a separate line, 1 ≤ <em>n</em> ≤ 10000. Then follows <em>n</em> lines with one unique phone number on each line. A phone number is a sequence of at most ten digits.</p>
<p>Output</p>
<p>For each test case, output “YES” if the list is consistent, or “NO” otherwise.</p>
<p>Sample Input</p>
<p>2<br>3<br>911<br>97625999<br>91125426<br>5<br>113<br>12340<br>123440<br>12345<br>98346</p>
<p>Sample Output</p>
<p>NO<br>YES</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>将电话号码A依次插入tire树</p>
<p>插入过程会有两种情况是False：</p>
<p>第一种是没有创造新的节点。说明电话号码A是其他号码的前缀。</p>
<p>第二种是在插入过程中，经历过了一点，其被标记为串终点。说明以该点结尾的</p>
<p>串是A串的前缀。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>输入部分</p>
<pre><code>bool flag = true;
scanf(&quot;%d&quot;, &amp;n);
for(int i = 1; i &lt;= n; i++)
{
    char lis[15];
    scanf(&quot;%s&quot;, lis);
    if(!add(lis))
        flag = false;
}</code></pre><p>add部分</p>
<pre><code>bool add(char *str)
{
    int p = 1;
    bool vis = false;                      //true表示他没有前缀
    for(int i = 0; i &lt; strlen(str); i++)
    {
        int now = str[i] - &apos;0&apos;;
        if(edn[p])  return false;           //说明有前缀了
        if(!tire[p][now])
        {
            tire[p][now] = ++tot;
            vis = true;            //如果没有创造新节点，也就是vis为false，那么它就是别人的前缀
        }
        p = tire[p][now];
    }
    edn[p] = true;
    return vis;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3764 The xor-longest Path</title>
    <url>/tpaaaaaa.github.io/2019/09/21/POJ3764Thexor-longestPath/</url>
    <content><![CDATA[<p>The xor-longest Path</p>
<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 13601</p>
<p><strong>Accepted:</strong> 2659</p>
<p>Description</p>
<p>In an edge-weighted tree, the xor-length of a path <em>p</em> is defined as the xor sum of the weights of edges on <em>p</em>:</p>
<p><img src="http://poj.org/formula?tex=_%7Bxor%7Dlength%28p%29%3D%5Coplus_%7Be+%5Cin+p%7Dw%28e%29" alt="_{xor}length(p)=\oplus_{e \in p}w(e)"></p>
<p>⊕ is the xor operator.</p>
<p>We say a path the xor-longest path if it has the largest xor-length. Given an edge-weighted tree with n nodes, can you find the xor-longest path? 　</p>
<p>Input</p>
<p>The input contains several test cases. The first line of each test case contains an integer <em>n</em>(1&lt;=<em>n</em>&lt;=100000), The following <em>n</em>-1 lines each contains three integers <em>u</em>(0 &lt;= <em>u</em> &lt; <em>n</em>),<em>v</em>(0 &lt;= <em>v</em> &lt; <em>n</em>),<em>w</em>(0 &lt;= <em>w</em> &lt; 2^31), which means there is an edge between node <em>u</em> and <em>v</em> of length <em>w</em>.</p>
<p>OutputFor each test case output the xor-length of the xor-longest path.</p>
<p>Sample Input</p>
<p>4<br>0 1 3<br>1 2 4<br>1 3 6</p>
<p>Sample Output</p>
<p>7</p>
<p>Hint</p>
<p>The xor-longest path is 0-&gt;1-&gt;2, which has length 7 (=3 ⊕ 4)</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>异或满足交换律和结合律。<strong>也就是多个数在异或的时候，我们可以先将相同的数提前异或得到0消掉（0与任何数异或之后还是那个数）</strong></p>
<p>假如我们要求A到B路径上的的异或值。</p>
<p>我们首先求出A到根的异或值<br>和B到根的异或值<br>假如A到根的路径上有边D,E,F,G,H;<br>B到根上的路径上有边 J,K,F,G,H;<br>即F,G,H为LCA（A,B）上面公共的部分<br>所以A到根的异或值X为<br>D xor E xor F xor G xor H<br>B到根的异或值Y为<br>J xor K xor F xor G xor H<br>则我们发现X xor Y<br>D xor E xor J xor K xor 0 ..后面的相同一对的异或值为0<br>任何一个数，异或0对他没有影响</p>
<p>所以X xor Y就是X到Y路径<br>那么我们预处理出来每个节点到根的异或值<br>然后就变成了上一个题目了</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>for(int i = 1; i &lt; n; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
    addEdge(u, v, w);
    addEdge(v, u, w);
}
xorr[0] = 0; //根节点到自己的异或值为0
dfs(0, -1); //假设0号为根节点，从他开始求所有点的异或值</code></pre><p>用dfs求各点到达根节点的异或值</p>
<p>无向图dfs的遍历方式</p>
<pre><code>void dfs(int u, int fa)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        int w = edge[i].w;
        if(v != fa)
        {
            xorr[v] = xorr[u]^w;
            dfs(v, u);
        }
    }
}</code></pre><p>然后是求解每个异或值</p>
<pre><code>    int ans = 0;
    for(int i = 0; i &lt; n; i++)
    {
        add(xorr[i]);
        ans = max(ans, Search(xorr[i]));
    }
    printf(&quot;%d\n&quot;, ans);
}</code></pre><p>这一套和之前一样</p>
<pre><code>void add(int x)
{
    int p = 1;
    for(int i = 30; i &gt;= 0; i--)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(!tire[p][now]) tire[p][now] = ++ tot;
        p = tire[p][now];
    }
}
int Search(int x)
{
    int p   = 1;
    int ret = 0;
    for(int i = 30; i &gt;= 0; i--)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(tire[p][now ^ 1])
        {
            p = tire[p][now ^ 1];
            ret |= (1 &lt;&lt; i);
        }
        else
            p = tire[p][now];
    }
    return ret;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>trie树解异或问题</tag>
      </tags>
  </entry>
  <entry>
    <title>The XOR Largest Pair</title>
    <url>/tpaaaaaa.github.io/2019/09/21/TheXORLargestPair/</url>
    <content><![CDATA[<p>问题：给n个整数A1, A2……An，<br>选出两个数进行异或，得到的结果最大是多少？<br>N &lt;= 1e5, 0 &lt;= Ai &lt; 2^31</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>关于xor</strong>：</p>
<p><strong>XOR :相同为0，不相同为1</strong>。</p>
<p><strong>任何数 xor 0 = 还是这个数。</strong></p>
<p><strong>任何数 xor 1 = 每个二进制位都变了。</strong></p>
<p><strong>自己 xor 自己 = 0</strong></p>
<p>将整数变成一串二进制字符串。</p>
<p>然后将这个串放入tire树中。</p>
<p>然后再用这个串在tire树中查找。从最高位开始找，找与之当前位不同的值。</p>
<p><strong>一般这种异或的题，要往tire树上考虑</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>tot = 1;        //tot！！！ = 1
int ans = 0;
memset(tire, 0, sizeof tire);
for(int i = 1; i &lt;= n; i++)
{
    scanf(&quot;%d&quot;, &amp;x);    //录入第i个个数
    add(x);             //并且将这个数存入tire树中
    ans = max(ans, Search(x)); //去tire树中搜索极大xor值
}</code></pre><p>tire树的插入——add函数</p>
<pre><code>void add(int x)
{
    int p = 1;
    for(int i = 30; i &gt;= 0; i --)
    {
        int now = (x &gt;&gt; i) &amp; 1;        //从高位到低位依次插入
        if(!tire[p][now])
            tire[p][now] = ++tot;
        p = tire[p][now];
    }
}</code></pre><p>tire树的xor查找函数——search函数</p>
<pre><code>int Search(int x)
{
    int p = 1;
    int ret = 0;
    for(int i = 30; i &gt;= 0; i--)
    {
        int now = (x &gt;&gt; i) &amp; 1;
        if(tire[p][now ^ 1])
        {
            p = tire[p][now ^ 1];
            ret |= (1 &lt;&lt; i);
        }
        else p = tire[p][now];
    }
    return ret;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>trie树解异或问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]KMP</title>
    <url>/tpaaaaaa.github.io/2019/09/21/%5B%E7%AE%97%E6%B3%95%5DKMP/</url>
    <content><![CDATA[<p>这一周好累。终于有时间学东西了qaq</p>
<p>博文地址：<a href="https://blog.csdn.net/qq_37969433/article/details/82947411" target="_blank" rel="noopener">https://blog.csdn.net/qq_37969433/article/details/82947411</a></p>
<p>KMP求最小循环节<a href="https://www.cnblogs.com/bofengyu/p/4939138.html" target="_blank" rel="noopener">https://www.cnblogs.com/bofengyu/p/4939138.html</a></p>
<p>太妙了。</p>
<p>求next数组的模板</p>
<pre><code>void getNext()
{
    int i = 1, j = 0;
    nex[1] = 0;
    while(i &lt;= m)
    {
        if(j == 0 || b[i] == b[j])
            nex[++i] = ++j;
        else
            j = nex[j];
    }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]尺取法</title>
    <url>/tpaaaaaa.github.io/2019/09/18/%5B%E7%AE%97%E6%B3%95%5D%E5%B0%BA%E5%8F%96%E6%B3%95/</url>
    <content><![CDATA[<p><code>**尺取法：**顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。</code></p>
<p><code>使用尺取法时应清楚以下四点：</code></p>
<p><code>1、  什么情况下能使用尺取法?  2、何时推进区间的端点？ 3、如何推进区间的端点？ 4、何时结束区间的枚举？</code></p>
<p><code>尺取法通常适用于选取区间有一定规律，或者说所选取的区间有一定的变化趋势的情况，通俗地说，**在对所选取区间进行判断之后，我们可以明确如何进一步有方向地推进区间端点以求解满足条件的区间**，如果已经判断了目前所选取的区间，但却无法确定所要求解的区间如何进一步得到根据其端点得到，那么尺取法便是不可行的。首先，明确题目所需要求解的量之后，区间左右端点一般从最整个数组的起点开始，之后判断区间是否符合条件在根据实际情况变化区间的端点求解答案。</code></p>
<p><code>现在我们先举个栗子并分析一下尺取法的过程叭～</code></p>
<p><code>以下是几个经典的使用尺取法的例题，都是从挑战书上引用的。我们来挨个分析一下。（尺取法通常会需要对某些量进行预处理，以便能在使用时快速地判断。）</code></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>POJ 2796 Feel Good</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ2796FeelGood/</url>
    <content><![CDATA[<p>Feel Good</p>
<p><strong>Time Limit:</strong> 3000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 22821</p>
<p><strong>Accepted:</strong> 6259</p>
<p><strong>Case Time Limit:</strong> 1000MS</p>
<p>Special Judge</p>
<p>DescriptionBill is developing a new mathematical theory for human emotions. His recent investigations are dedicated to studying how good or bad days influent people’s memories about some period of life.</p>
<p>A new idea Bill has recently developed assigns a non-negative integer value to each day of human life. </p>
<p>Bill calls this value the emotional value of the day. The greater the emotional value is, the better the daywas. Bill suggests that the value of some period of human life is proportional to the sum of the emotional values of the days in the given period, multiplied by the smallest emotional value of the day in it. This schema reflects that good on average period can be greatly spoiled by one very bad day. </p>
<p>Now Bill is planning to investigate his own life and find the period of his life that had the greatest value. Help him to do so.</p>
<p>InputThe first line of the input contains n - the number of days of Bill’s life he is planning to investigate(1 &lt;= n &lt;= 100 000). The rest of the file contains n integer numbers a1, a2, … an ranging from 0 to 106 - the emotional values of the days. Numbers are separated by spaces and/or line breaks.</p>
<p>OutputPrint the greatest value of some period of Bill’s life in the first line. And on the second line print two numbers l and r such that the period from l-th to r-th day of Bill’s life(inclusive) has the greatest possible value. If there are multiple periods with the greatest possible value,then print any one of them.</p>
<p>Sample Input</p>
<p>6<br>3 1 6 4 5 2</p>
<p>Sample Output</p>
<p>60<br>3 5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>单调栈的应用</p>
<p>1.最基础的应用就是给定一组数，针对每个数，寻找它和它右边第一个比它大的数之间有多少个数。</p>
<p>2.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列的长度最大。</p>
<p>3.给定一序列，寻找某一子序列，使得子序列中的最小值乘以子序列所有元素和最大。</p>
<p>此题为第三种</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
ll a[MAXN], sum[MAXN];
int top;
ll tmp;
int sta, edn;
stack &lt; int &gt; st;
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        sum[0] = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%lld&quot;, &amp;a[i]);
            sum[i] = sum[i - 1] + a[i];
        }
        a[n + 1] = -1;
        ll ans = 0;
        //维护一个单调递增的区间哦
        while(!st.empty()) st.pop();
        for(int i = 1; i &lt;= n + 1; i++)
        {
            if(st.empty() || a[i] &gt;= a[st.top()]) st.push(i);
            else
            {
                while(!st.empty() &amp;&amp; a[i] &lt; a[st.top()])
                {
                    top = st.top();
                    tmp = sum[i - 1] - sum[top - 1];
                    tmp = tmp * a[top];
                    if(tmp &gt;= ans) //???要等于呀
                    {
                        ans = tmp;
                        sta = top;
                        edn = i - 1;
                    }
                    st.pop();
                }
                st.push(top);
                a[top] = a[i];
            }
        }

        printf(&quot;%lld\n&quot;, ans);
        printf(&quot;%d %d\n&quot;, sta, edn);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2559 Largest Rectangle in a Histogram</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ2559LargestRectangleinaHistogram/</url>
    <content><![CDATA[<p>Largest Rectangle in a Histogram</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 33049</p>
<p><strong>Accepted:</strong> 10765</p>
<p>DescriptionA histogram is a polygon composed of a sequence of rectangles aligned at a common base line. The rectangles have equal widths but may have different heights. For example, the figure on the left shows the histogram that consists of rectangles with the heights 2, 1, 4, 5, 1, 3, 3, measured in units where 1 is the width of the rectangles:   </p>
<p><img src="http://poj.org/images/2559_1.jpg" alt=""></p>
<p>Usually, histograms are used to represent discrete distributions, e.g., the frequencies of characters in texts. Note that the order of the rectangles, i.e., their heights, is important. Calculate the area of the largest rectangle in a histogram that is aligned at the common base line, too. The figure on the right shows the largest aligned rectangle for the depicted histogram.</p>
<p>InputThe input contains several test cases. Each test case describes a histogram and starts with an integer <em>n</em>, denoting the number of rectangles it is composed of. You may assume that <em>1&lt;=n&lt;=100000</em>. Then follow <em>n</em> integers <em>h1,…,hn</em>, where <em>0&lt;=hi&lt;=1000000000</em>. These numbers denote the heights of the rectangles of the histogram in left-to-right order. The width of each rectangle is <em>1</em>. A zero follows the input for the last test case.</p>
<p>OutputFor each test case output on a single line the area of the largest rectangle in the specified histogram. Remember that this rectangle must be aligned at the common base line.</p>
<p>Sample Input</p>
<p>7 2 1 4 5 1 3 3<br>4 1000 1000 1000 1000<br>0</p>
<p>Sample Output</p>
<p>8<br>4000</p>
<p>HintHuge input, scanf is recommended.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目类型：用单调栈求 一个子序列，使得子序列中的最小值×子序列的长度最大</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
ll h[MAXN], ans, top, tmp;
stack &lt; int &gt; st;
int main()
{
    int n, m;
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%lld&quot;, &amp;h[i]);
        while(!st.empty()) st.pop();
        h[n+1] = -1;
        ans = 0;
        for(int i = 1; i &lt;= n + 1; i++)
        {
            if(st.empty()||h[i] &gt;= h[st.top()])  st.push(i);
            else
            {
                while(!st.empty() &amp;&amp; h[i] &lt; h[st.top()])
                {
                    top = st.top();
                    tmp = (i - top) * h[top];
                    ans = max(ans, tmp);
                    st.pop();
                }
                st.push(top);
                h[top] = h[i];
            }
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3250 Bad Hair Day</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3250BadHairDay/</url>
    <content><![CDATA[<p>Bad Hair Day</p>
<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 26244</p>
<p><strong>Accepted:</strong> 8984</p>
<p>Description</p>
<p>Some of Farmer John’s <em>N</em> cows (1 ≤ <em>N</em> ≤ 80,000) are having a bad hair day! Since each cow is self-conscious about her messy hairstyle, FJ wants to count the number of other cows that can see the top of other cows’ heads.</p>
<p>Each cow <em>i</em> has a specified height <em>hi</em> (1 ≤ <em>hi _≤ 1,000,000,000) and is standing in a line of cows all facing east (to the right in our diagrams). Therefore, cow _i</em> can see the tops of the heads of cows in front of her (namely cows <em>i</em>+1, <em>i</em>+2, and so on), for as long as these cows are strictly shorter than cow <em>i</em>.</p>
<p>Consider this example:</p>
<pre><code>=  </code></pre><p>=       =<br>=   -   =         Cows facing right –&gt;<br>=   =   =<br>= - = = =<br>= = = = = =<br>1 2 3 4 5 6 </p>
<p>Cow#1 can see the hairstyle of cows #2, 3, 4<br>Cow#2 can see no cow’s hairstyle<br>Cow#3 can see the hairstyle of cow #4<br>Cow#4 can see no cow’s hairstyle<br>Cow#5 can see the hairstyle of cow 6<br>Cow#6 can see no cows at all!  </p>
<p>Let <em>ci</em> denote the number of cows whose hairstyle is visible from cow <em>i</em>; please compute the sum of <em>c</em>1 through <em>cN</em>.For this example, the desired is answer 3 + 0 + 1 + 0 + 1 + 0 = 5.</p>
<p>InputLine 1: The number of cows, <em>N</em>.<br>Lines 2..N+1: Line <em>i</em>+1 contains a single integer that is the height of cow <em>i</em>.</p>
<p>OutputLine 1: A single integer that is the sum of <em>c</em>1 through <em>cN</em>.</p>
<p>Sample Input</p>
<p>6<br>10<br>3<br>7<br>4<br>12<br>2</p>
<p>Sample Output</p>
<p>5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>单调栈。 比较好的博客总结：<a href="https://blog.csdn.net/zuzhiang/article/details/78134247" target="_blank" rel="noopener">https://blog.csdn.net/zuzhiang/article/details/78134247</a></p>
<pre><code>6 5
c[6] = 0;
c[5] = 1;
c[4] = 0;
c[3] = 1;
c[2] = 0;
c[1] = 3;


从右往左入栈
为空的话，当前值为0 ，入栈即可
如果 比栈顶的元素高，那么当前值+1，再加上栈顶元素能够看到的数目
然后栈顶元素出去， 继续比较..低的话，就不加</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 8e4 + 10;
int h[MAXN], a[MAXN];
stack &lt; int &gt; sta;
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;h[i]);

        while(!sta.empty()) sta.pop();
        int ret = 0;
        for(int i = n; i &gt; 0; i--)
        {
            ret = 0;
            while(sta.empty() == false &amp;&amp; h[sta.top()] &lt; h[i] )
            {
                ret ++;
                ret += a[sta.top()];
                sta.pop();
            }
            sta.push(i);
            a[i] = ret;
        }
        ll all = 0;
        for(int i = 1; i &lt;= n; i++)
            all += a[i];
        printf(&quot;%lld\n&quot;, all);          //我真是一个可爱的憨批

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3122 pie</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3122pie/</url>
    <content><![CDATA[<p>Pie</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 28086</p>
<p><strong>Accepted:</strong> 8459</p>
<p>Special Judge</p>
<p>Description</p>
<p><img src="http://poj.org/images/3122_1.jpg" alt=""></p>
<p>My birthday is coming up and traditionally I’m serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though. </p>
<p>My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size. </p>
<p>What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.</p>
<p>InputOne line with a positive integer: the number of test cases. Then for each test case:</p>
<ul>
<li>One line with two integers N and F with 1 ≤ N, F ≤ 10 000: the number of pies and the number of friends.</li>
<li>One line with N integers ri with 1 ≤ ri ≤ 10 000: the radii of the pies.</li>
</ul>
<p>OutputFor each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10−3.</p>
<p>Sample Input</p>
<p>3<br>3 3<br>4 3 3<br>1 24<br>5<br>10 5<br>1 4 2 3 4 5 6 5 4 2</p>
<p>Sample Output</p>
<p>25.1327<br>3.1416<br>50.2655</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目类型：求满足条件的最大值。</p>
<pre><code>n个pie，每个pie有个r，那么我们就可以求出每个pie的面积
 然后二分一个面积mid
 然后记录每个pie整除整个面积mid的数目（也就是这个pie能够切成多少片），然后将这些数目累加起来
 如果累加的数目 &gt;= 我们的人数
    则说明面积还能够更大  l = mid + 1;
 不然的说，说明面积要变小
                          r= mid - 1;</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
#define getS(x)   x*x*1.0*PI

using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int n, m;
double s[MAXN];             //记录每个pie的面积
bool solve(double x)
{
    int ret = 0;
    for(int i = 1; i &lt;= n; i++)
    {
        int temp = (int)(s[i]/x);
        ret += temp;
    }


    if(ret &gt;= m)
        return true;
    else
        return false;
}
int main()
{
    int t, r;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        m++;                    //朋友和自己
        double maxS = 0.0;
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;r);
            s[i] = getS(r);
            maxS = max(maxS, s[i]);
        }
        double l = 0;
        double r = maxS;
        double ans = 0;
        //l &lt; r
        while(fabs(r - l) &gt; eps )
        {


            double mid = md(l, r);
          //  printf(&quot;l = %.2f, r = %.2f, mid = %.2f\n&quot;, l, r, mid);
            if(solve(mid))
            {
                ans = mid;
                l = mid;
            }
            else
            {
                r = mid;
            }
        }
        printf(&quot;%.4f\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3258 River Hopscotch</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3258RiverHopscotch/</url>
    <content><![CDATA[<p>River Hopscotch</p>
<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 24317</p>
<p><strong>Accepted:</strong> 10051</p>
<p>Description</p>
<p>Every year the cows hold an event featuring a peculiar version of hopscotch that involves carefully jumping from rock to rock in a river. The excitement takes place on a long, straight river with a rock at the start and another rock at the end, <em>L</em> units away from the start (1 ≤ <em>L</em> ≤ 1,000,000,000). Along the river between the starting and ending rocks, <em>N</em> (0 ≤ <em>N</em> ≤ 50,000) more rocks appear, each at an integral distance <em>Di</em> from the start (0 &lt; <em>Di</em> &lt; <em>L</em>).</p>
<p>To play the game, each cow in turn starts at the starting rock and tries to reach the finish at the ending rock, jumping only from rock to rock. Of course, less agile cows never make it to the final rock, ending up instead in the river.</p>
<p>Farmer John is proud of his cows and watches this event each year. But as time goes by, he tires of watching the timid cows of the other farmers limp across the short distances between rocks placed too closely together. He plans to remove several rocks in order to increase the shortest distance a cow will have to jump to reach the end. He knows he cannot remove the starting and ending rocks, but he calculates that he has enough resources to remove up to <em>M _rocks (0 ≤ _M</em> ≤ <em>N</em>).</p>
<p>FJ wants to know exactly how much he can increase the shortest distance <em>*before*</em> he starts removing the rocks. Help Farmer John determine the greatest possible shortest distance a cow has to jump after removing the optimal set of <em>M</em> rocks.</p>
<p>InputLine 1: Three space-separated integers: <em>L</em>, <em>N</em>, and <em>M</em><br>Lines 2..<em>N</em>+1: Each line contains a single integer indicating how far some rock is away from the starting rock. No two rocks share the same position.</p>
<p>OutputLine 1: A single integer that is the maximum of the shortest distance a cow has to jump after removing <em>M</em> rocks</p>
<p>Sample Input</p>
<p>25 5 2<br>2<br>14<br>11<br>21<br>17</p>
<p>Sample Output</p>
<p>4</p>
<p>HintBefore removing any rocks, the shortest jump was a jump of 2 from 0 (the start) to 2. After removing the rocks at 2 and 14, the shortest required jump is a jump of 4 (from 17 to 21 or from 21 to 25).  </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目类型：求最大化的最小值。</p>
<pre><code>//我们可以将二分分为 最大化最小值和 最小化最大值 两类
这是NOIP2015 day1 T2的原题呀  啊啊啊啊 当年的回忆呀（水了20分）

二分枚举一个最小距离mid
然后来判断这个距离可不可行。
如果可行，说明这个最小距离还能变大。则l = mid + 1
如果不可行，说明缩小r = mid - 1;

怎样判断某个最短距离可不可行呢
也就是要保证所有的点之间的距离一定要大于or等于二分的最小距离。所以就要移动点，到最后计算移动的点数。如果
点数超过了M个，说明不可行

int before = 0;
for(int i = 1; i &lt;= n + 1; i ++)
    if(dis[i] - before &lt; mid)       //说明当前这个点要被移动走
    {
        ret ++;
    }
    else                            // 说明不用移走，更新before
    {
        before = dis[i];
    }

    // 这只保证了一个方向，然后再从终点走一遍。所以要标记一下被移走的石头</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
bool vis[MAXN];
int dis[MAXN], L, n, m;
bool solve(int X)
{
    int ret = 0;
    int before = 0;
    memset(vis, true, sizeof vis);
    for(int i = 1; i &lt;= n; i++)
    {
        if(dis[i] - before &lt; X)
        {
            vis[i] = false;             //这个被移走了
            ret ++;                     //移走的数目加1
        }
        else
            before = dis[i];
    }
    int last = dis[n + 1];
    for(int i = n; i &gt; 0; i--)
    {
        if(vis[i] == false) continue;   //已经被移走了
        if(last - dis[i] &lt; X)
            ret ++;
        else
            last = dis[i];
    }
    if(ret &gt; m)
        return false;
    return true;
}
int main()
{
    while(scanf(&quot;%d%d%d&quot;, &amp;L, &amp;n, &amp;m) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;dis[i]);
        sort(dis + 1, dis + 1 + n);
        dis[0] = 0;
        dis[n + 1] = L:
        int l = 0;
        int r = L;
        int ans = 0;
        while(l &lt;= r)
        {
            int mid = md(l, r);
            if(solve(mid))
            {
                ans = mid;
                l = mid + 1;
            }
            else
                r = mid - 1;
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3579 Median</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3579Median/</url>
    <content><![CDATA[<p>Median</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 13595</p>
<p><strong>Accepted:</strong> 4686</p>
<p>Description</p>
<p>Given <em>N</em> numbers, <em>X</em>1, <em>X</em>2, … , <em>XN</em>, let us calculate the difference of every pair of numbers: ∣<em>Xi _-</em> Xj_∣ (1 ≤_ i <em>＜</em> j <em>≤</em> N_). We can get <em>C(N,2)</em> differences through this work, and now your task is to find the median of the differences as quickly as you can!</p>
<p>Note in this problem, the median is defined as the <em>(m/2)-th</em>  smallest number if <em>m</em>,the amount of the differences, is even. For example, you have to find the third smallest one in the case of _m _= 6.</p>
<p>Input</p>
<p>The input consists of several test cases.<br>In each test case, <em>N</em> will be given in the first line. Then <em>N</em> numbers are given, representing <em>X</em>1, <em>X</em>2, … , <em>XN</em>, ( _Xi _≤ 1,000,000,000  3 ≤ N ≤ 1,00,000 )</p>
<p>Output</p>
<p>For each test case, output the median in a separate line.</p>
<p>Sample Input</p>
<p>4<br>1 3 2 4<br>3<br>1 10 2</p>
<p>Sample Output</p>
<p>1<br>8</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目类型：求第k大的元素。二分套二分。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int a[MAXN], m, n;
// 用二分快速得到 比mid小的差值的数目
// 显然差值的数目最多有10^10次方，开ll
bool solve(int X)
{
    ll ret = 0;     //记录差值比 X 小的数目
    for(int i = n; i &gt; 1; i--)
    {
        //拿第i个点，和之前1..i-1 的差值作比较
        //显然i和1 ... i-1的差值是递减的。i与1的差值最大， i与i-1的差值最小
        //所以求个mid
        int l = 1;
        int r = i - 1;
        ll ans = 0;
        while(l &lt;= r)
        {
            int mid = md(l, r); //也就是去计算a[i] - a[mid]
            int dif = a[i] - a[mid];
            if(dif &lt; X)
            {
                ans = i - mid;
                r = mid - 1;
            }
            else
                l = mid + 1;
        }
        ret += ans;
    }
    //意味着，比x小的数，多了，说明x开大了，mid 要往下面缩
    if(ret &gt;= m)
        return true;
    //意味着，比x小的数，少了，说明x开小了，mid 要往上面走，但也有可能是正确的
    return false;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;a[i]);
        sort(a + 1, a + 1 + n);
        int l = 0;
        int r = 1e9;
        int ans = 0;
        m = n*(n-1)/2;
        m = (m+1)/2;
        while(l &lt;= r)
        {
            int mid = md(l, r); //mid二分的是差值
            if(solve(mid))
            {
                r = mid - 1;
            }
            else
            {
                ans = mid;
                //所以这个ans放在哪里，要看这个里面包不包含正确情况
                l = mid + 1;
            }

        }

        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>二分套二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3104 Drying</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3104Drying/</url>
    <content><![CDATA[<p>Drying</p>
<p><strong>Time Limit:</strong> 2000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 27122</p>
<p><strong>Accepted:</strong> 6799</p>
<p>Description</p>
<p>It is very hard to wash and especially to dry clothes in winter. But Jane is a very smart girl. She is not afraid of this boring process. Jane has decided to use a radiator to make drying faster. But the radiator is small, so it can hold only one thing at a time.</p>
<p>Jane wants to perform drying in the minimal possible time. She asked you to write a program that will calculate the minimal time for a given set of clothes.</p>
<p>There are <em>n</em> clothes Jane has just washed. Each of them took <em>ai</em> water during washing. Every minute the amount of water contained in each thing decreases by one (of course, only if the thing is not completely dry yet). When amount of water contained becomes zero the cloth becomes dry and is ready to be packed.</p>
<p>Every minute Jane can select one thing to dry on the radiator. The radiator is very hot, so the amount of water in this thing decreases by <em>k</em> this minute (but not less than zero — if the thing contains less than <em>k</em> water, the resulting amount of water will be zero).</p>
<p>The task is to minimize the total time of drying by means of using the radiator effectively. The drying process ends when all the clothes are dry.</p>
<p>Input</p>
<p>The first line contains a single integer <em>n</em> (1 ≤ <em>n</em> ≤ 100 000). The second line contains <em>ai</em> separated by spaces (1 ≤ <em>ai</em> ≤ 109). The third line contains <em>k</em> (1 ≤ <em>k</em> ≤ 109).</p>
<p>Output</p>
<p>Output a single integer — the minimal possible number of minutes required to dry all clothes.</p>
<p>Sample Input</p>
<p><strong>sample input #1</strong><br>3<br>2 3 9<br>5</p>
<p><strong>sample input #2</strong><br>3<br>2 3 6<br>5</p>
<p>Sample Output</p>
<p><strong>sample output #1</strong><br>3</p>
<p><strong>sample output #2</strong><br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目类型： 求一个满足条件的最小值</p>
<p>这种求最值的情况，都要考虑一下二分哦@……@<br>我们二分一下最小时间mid<br>我们知道如果每件衣服的含水量都小于mid，那么mid时间后就会流光，因此那些含水量 &lt;= mid的衣服，可以不用管 对于那些含水量大于mid的，我们要对他使用烘干器，我们设对某个含水量water大于mid的衣服使用t分钟的烘干器，那么它 自己流的水量就是 mid - t。所以得到式子 water - (mid - t) &lt;= k * t 得到 water - mid &lt;= t(k - 1) 也就是 t &gt;= (water - mid)/(k-1)<br>所以t是 (water - mid)/(k-1)的向上取整</p>
<p>即要想使得含水量大于mid的衣服烘干，至少要t时间，所以我们求出所有的含水量大于mid的衣服所需要的最少的t，然后求和<br>如果求的和 &gt; mid,则说明这个mid不行， 往大了的放大，不然说明这个mid太大了，往小了缩小</p>
<p>妙呀妙呀小机灵鬼</p>
<p>got一个二分模板<br>Got一个向上取整的方式</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int a[MAXN], n, k;
bool solve(int mid) //mid为总时间
{
    ll all = 0;    //记录总的t的使用时间
    ll  t = 0;
    for(int i = 1; i &lt;= n; i++)
    {
        if(a[i] &lt;= mid) continue;
        t = (a[i] - mid + k - 2)/ (k - 1);
        //懂了.  got一个新的向上取整的方式
        all += t;
    }
    if(all &gt; mid)
        return false;
    else
        return true;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        //每件衣服的含水量
        scanf(&quot;%d&quot;, &amp;k);
        sort(a + 1, a + 1 + n);
        if(k == 1)
            printf(&quot;%d\n&quot;, a[n]);
        else
        {
            int l = 0;
            int r = 1e9 + 10;
            int ans = 0;
            while(l &lt;= r)
            {
                int mid = md(l, r);
                if(solve(mid))
                {
                    ans = mid;
                    //ooooo我以后就用这种方式算了
                    r = mid - 1;

                }
                else
                    l = mid + 1;
            }
            printf(&quot;%d\n&quot;, ans);
        }

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3685 Matrix</title>
    <url>/tpaaaaaa.github.io/2019/09/18/POJ3685Matrix/</url>
    <content><![CDATA[<p>Matrix</p>
<p><strong>Time Limit:</strong> 6000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 10234</p>
<p><strong>Accepted:</strong> 3190</p>
<p>Description</p>
<p>Given a <em>N</em> × <em>N</em> matrix A, whose element in the <em>i</em>-th row and <em>j</em>-th column <em>Aij</em> is an number that equals <em>i</em>2 + 100000 × <em>i</em> + <em>j</em>2 - 100000 × <em>j</em> + <em>i</em> × <em>j</em>, you are to find the <em>M</em>-th smallest element in the matrix.</p>
<p>Input</p>
<p>The first line of input is the number of test case.<br>For each test case there is only one line contains two integers, <em>N</em>(1 ≤ <em>N</em> ≤ 50,000) and <em>M</em>(1 ≤ <em>M</em> ≤ <em>N</em> × <em>N</em>). There is a blank line before each test case.</p>
<p>Output</p>
<p>For each test case output the answer on a single line.</p>
<p>Sample Input</p>
<p>12</p>
<p>1 1</p>
<p>2 1</p>
<p>2 2</p>
<p>2 3</p>
<p>2 4</p>
<p>3 1</p>
<p>3 2</p>
<p>3 8</p>
<p>3 9</p>
<p>5 1</p>
<p>5 25</p>
<p>5 10</p>
<p>Sample Output</p>
<p>3<br>-99993<br>3<br>12<br>100007<br>-199987<br>-99993<br>100019<br>200013<br>-399969<br>400031<br>-99939</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p><strong>题目类型：找第k小的元素。</strong> 方法：二分套二分</p>
<p>给你矩形，矩形上的每个点值都是确定的<br>你要去找第m小的值<br>二分套二分<br>同行元素递减，同列元素递增</p>
<p>我们第一层二分，枚举的是答案，也就是第m小的数，设我们枚举的是midAns</p>
<p>然后去判断比这个数小的数目，如果比他小的数目 要大于or等于m，说明他会排在m的后面，因此我们要将第一次二分往左边缩小<br>否则的话，如果比他小的数目要小于 m，说明他会排在m的前面，因此我们要将第一层二分往右边扩大</p>
<p>那么怎么快速的得到在这个矩阵里面比midAns小的数的数目呢，这就需要在矩形里面矩形二分了，也就是在二分里面套一个二分</p>
<p>我们分析可以知道，i^2 + 100000 × i + j^2 - 100000 × j + i × j 在这个表达式里面，在同一行or同一列里面都是单调的<br>显然可以对行or对列进行二分，快速得到这一列or一行中小于midAns的数目，然后将每一行or列 的数目累加起来，就是整个<br>矩形小于midAns的数目了<br>我们分析每一列的数目<br>那么对于某一列而言，i2 + 100000 × i + j2 - 100000 × j + i × j 这个表示里面的j就相当于是一个常数<br>我们可以求导得到 2i + 100000 - j 这个显然是大于0的，也就是说，在一列当中，按行数递增，第一行最小，最后一行最大<br>那么我们二分枚举中间行，然后…快速确定小于的数目，然后累加</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
ll n;
//那么我们发现1，n
ll cal(ll i, ll j)
{
    return i*i + 100000 * i + j * j - 100000 * j + i * j;
}
//返回矩阵中比m小的数的数目
ll solve(ll m)
{
    ll ret = 0;
    for(int j = 1; j &lt;= n; j++)     //枚举每一列
    {
        ll l = 1;                   //二分每一行，
        ll r = n;
        ll cnt = n;
        while(l &lt;= r)
        {
            ll mid = md(l, r);
            ll temp = cal(mid, j);
            if(temp &gt;= m)
            {
                r = mid - 1;
                cnt = mid - 1;
            }
            else
            {
                l = mid + 1;
            }
        }
        ret += cnt;
    }
    return ret;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    ll m;
    while(t--)
    {
        scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);
        ll l =  - ( 3 * n * n + 200000 * n );
        ll r =    ( 3 * n * n + 200000 * n );
        ll ans=0;
        while(l &lt;= r)
        {
            ll mid = md(l, r);
            ll sum = solve(mid);        //返回的是比mid小的数目
            if(sum &gt;= m)                 //排名靠后了，说明取大了
            {
                r = mid - 1;
                ans = r;
            }
            else
                l = mid + 1；
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>基本算法</category>
      </categories>
      <tags>
        <tag>二分套二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5052 Yaoge’s maximum profit</title>
    <url>/tpaaaaaa.github.io/2019/09/17/HDU5052Yaoge%E2%80%99smaximumprofit/</url>
    <content><![CDATA[<h1 id="Yaoge’s-maximum-profit"><a href="#Yaoge’s-maximum-profit" class="headerlink" title="Yaoge’s maximum profit"></a>Yaoge’s maximum profit</h1><p>*<em>Time Limit: 10000/5000 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)<br>Total Submission(s): 1637    Accepted Submission(s): 546<br>*</em></p>
<p>Problem DescriptionYaoge likes to eat chicken chops late at night. Yaoge has eaten too many chicken chops, so that Yaoge knows the pattern in the world of chicken chops. There are N cities in the world numbered from 1 to N . There are some roads between some cities, and there is one and only one simple path between each pair of cities, i.e. the cities are connected like a tree. When Yaoge moves along a path, Yaoge can choose one city to buy ONE chicken chop and sell it in a city after the city Yaoge buy it. So Yaoge can get profit if Yaoge sell the chicken chop with higher price. Yaoge is famous in the world. AFTER Yaoge has completed one travel, the price of the chicken chop in each city on that travel path will be increased by V .<br>InputThe first line contains an integer T (0 &lt; T ≤ 10), the number of test cases you need to solve. For each test case, the first line contains an integer N (0 &lt; N ≤ 50000), the number of cities. For each of the next N lines, the i-th line contains an integer Wi(0 &lt; Wi ≤ 10000), the price of the chicken chop in city i. Each of the next N - 1 lines contains two integers X Y (1 ≤ X, Y ≤ N ), describing a road between city X and city Y . The next line contains an integer Q(0 ≤ Q ≤ 50000), the number of queries. Each of the next Q lines contains three integer X Y V(1 ≤ X, Y ≤ N ; 0 &lt; V ≤ 10000), meaning that Yaoge moves along the path from city X to city Y , and the price of the chicken chop in each city on the path will be increased by V AFTER Yaoge has completed this travel.<br>OutputFor each query, output the maximum profit Yaoge can get. If no positive profit can be earned, output 0 instead.<br>Sample Input</p>
<p>1<br>5<br>1<br>2<br>3<br>4<br>5<br>1 2<br>2 3<br>3 4<br>4 5<br>5<br>1 5 1<br>5 1 1<br>1 1 2<br>5 1 1<br>1 2 1</p>
<p>Sample Output</p>
<p>4<br>0<br>0<br>1<br>0</p>
<p>Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2014+ACM%2FICPC+Asia+Regional+Shanghai+Online&source=1&searchmode=source" target="_blank" rel="noopener">2014 ACM/ICPC Asia Regional Shanghai Online</a><br>Recommendhujie</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树链剖分。但是细节好多，我这种弱鸡调了半天，烦 但最后还是AC了，今日份的开心。但感觉自己对树链剖分更加熟练了。</p>
<p>要学会自己出数据，学会Debug。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-17-12.16.14
 By                : Tpaaaaaa
 Question_Number   ：HDU 5052
 Question_Name     ：线段树
 Description       :
 询问树上路径的最大值减去最小值
 不对，是有顺序的。
 所以在合并区间的时候。如果右区间的最小值 与 左区间的最大值的差，要大于左区间的差 和右区间的差，则更新差
 不然的话，就用左区间和右区间里面较大的差作为区间的差，并且更最大值和最小值。
 所以线段树维护的区间信息包括 区间的最小值，区间的最大值，区间的顺序最大差。
 还有就是在跳的时候，好像会不一样吧。
 左边的遍历顺序是从dfn大的往dfn小的走
 因此就是左边的区间取的是最大值，右边的区间取得是最小值。
 因此，我们要保存的差，分为两类，左大右小，一类是左小右大。
 然后更新的时候，差不会边，最值分别加v即可。



 变成了区间查询 和区间修改.
 树链剖分就可以解决了
 编一个数据
 1
 5
 1 2 3 4 5
 1 2
 2 4
 2 5
 1 3
 5
 1 2 1
 1 4 1
 1 5 1
 4 3 1
 5 3 1

  1
 5
 1 2 3 4 5
 1 2
 2 4
 2 5
 1 3
 5
 5 3 1
 3 5 1
 5 4 1
 4 5 1
 2 3 1

 题目数据给的太弱了，要自己造几个！！！ 别过了样例就兴高采烈的提交
 AC了   爽！！！！网络赛的题目，感觉自己的线段树变强了

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int e[MAXN][3], head[MAXN], cnt, tot, val, dep[MAXN], son[MAXN], top[MAXN], rk[MAXN], dfn[MAXN], fa[MAXN];
int flag[MAXN];
int siz[MAXN], a[MAXN];
inline int Read(){
     int x = 0,f = 1;char c = getchar();
     while(c &lt; &apos;0&apos; || c &gt; &apos;9&apos;){if(c == &apos;-&apos;) f = -1;c = getchar();}
     while(c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;){x = x * 10 + c - &apos;0&apos;;c = getchar();}
     return x * f;
  }
struct Edge
{
    int v, next;
} edge[MAXN * 2];
inline void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    //dif[0]是左小右大
    int l, r, dif[2], mx, mn, lazy;
}node[MAXN * 4];
inline void pushUp(int rt)
{
    node[rt].mx = max(node[ls(rt)].mx, node[rs(rt)].mx);
    node[rt].mn = min(node[ls(rt)].mn, node[rs(rt)].mn);

    node[rt].dif[0] = node[rs(rt)].mx - node[ls(rt)].mn;
    node[rt].dif[0] = max(node[rt].dif[0], node[rs(rt)].dif[0]);
    node[rt].dif[0] = max(node[rt].dif[0], node[ls(rt)].dif[0]);
    node[rt].dif[1] = node[ls(rt)].mx - node[rs(rt)].mn;
    node[rt].dif[1] = max(node[rt].dif[1], node[rs(rt)].dif[1]);
    node[rt].dif[1] = max(node[rt].dif[1], node[ls(rt)].dif[1]);
}
inline void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].lazy = 0;
    if(l == r)
    {
        node[rt].mx = node[rt].mn = a[rk[l]];   //存的是dfn序列，所以用rk
        node[rt].dif[0] = node[rt].dif[1] = 0;
        return ;
    }
    int mid = md(l, r);
    built(ls(rt), l, mid);
    built(rs(rt), mid + 1, r);
    pushUp(rt);
}
//将l, r区间里面的值都加v
inline void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[ls(rt)].lazy += node[rt].lazy;
        node[rs(rt)].lazy += node[rt].lazy;
        node[ls(rt)].mn += node[rt].lazy;
        node[rs(rt)].mn += node[rt].lazy;
        node[ls(rt)].mx += node[rt].lazy;
        node[rs(rt)].mx += node[rt].lazy;
        node[rt].lazy = 0;
    }
}
void update(int rt, int l, int r, int v)
{
    if(l &gt; node[rt].r || r &lt; node[rt].l)
        return;
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy += v;
        node[rt].mn += v;
        node[rt].mx += v;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update(ls(rt), l, r, v);
    else if(l &gt; mid)
        update(rs(rt), l, r, v);
    else
    {
        update(ls(rt), l, mid, v);
        update(rs(rt), mid + 1, r, v);
    }
    pushUp(rt);
}
inline void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
inline void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u]) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
int query(int rt, int l, int r, int com, int &amp;tmax, int &amp;tmin)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        tmax = node[rt].mx;
        tmin = node[rt].mn;
        return node[rt].dif[com];
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r, com, tmax, tmin);
    else if(l &gt; mid)
        return query(rs(rt), l, r, com, tmax, tmin);
    else
        {
            int mx1,mx2,mn1,mn2;
            int ans1 = query(ls(rt), l, mid, com, mx1, mn1);
            int ans2 = query(rs(rt), mid + 1, r, com, mx2, mn2);
            tmax = max(mx1, mx2);
            tmin = min(mn1, mn2);
            int ans = max(ans1, ans2);
            if(com == 0)
                ans = max(ans, mx2 - mn1);
            else
                ans = max(ans, mx1 - mn2);
            return ans;
        }
}
int lca(int u, int v)
{
    int ret = 0;
    // 要明白，要么起点往上跳，要么终点往上跳
    // maxv 和minv记录的是  非起点跳的区间的信息
    int tmax = 0, tmin = INF;
    int maxv = 0, minv = INF;
    int maxu = 0, minu = INF;
   while(top[u] != top[v])
    {
        if(dep[top[u]] &gt; dep[top[v]])               //说明这次跳的是起点
        {
             ret = max(ret, query(1, dfn[top[u]], dfn[u], 1, tmax, tmin));
             update(1, dfn[top[u]], dfn[u], val);
             //temp记录的是本次起点跳的区间的最值。
             ret = max(ret, tmax - minu);
             maxu = max(tmax, maxu);
             minu = min(tmin, minu);
             u = fa[top[u]];
        }
        else                                        //跳的是终点
        {
            ret = max(ret, query(1, dfn[top[v]], dfn[v], 0, tmax, tmin));
            update(1, dfn[top[v]], dfn[v], val);
            ret = max(ret, maxv - tmin);
            maxv = max(maxv, tmax);
            minv = min(minv, tmin);
            v = fa[top[v]];
        }
    }
    //目前在同一个链上了，并且u仍然是起点
    if(dep[u] &gt; dep[v])     //说明要跳起点,那么就要和终点跳的区间合并，我操。好难
    {
        ret = max(ret, query(1, dfn[v], dfn[u], 1, tmax, tmin));
        ret = max(ret, tmax - minu);
        minu = min(tmin, minu);

        ret = max(ret, maxv - minu);
        update(1, dfn[v], dfn[u], val);

    }
    else
    {
        ret = max(ret, query(1, dfn[u], dfn[v], 0, tmax, tmin));
        ret = max(ret, maxv - tmin);
        maxv = max(maxv, tmax);
        ret = max(ret, maxv - minu);
        update(1, dfn[u], dfn[v], val);
    }

    return ret;

}
inline void init()
{
    memset(head, -1, sizeof head);
    memset(siz, 0, sizeof siz);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;
}
int main()
{
    int t, n, x, y, q;
    t = Read();
    while(t--)
    {
        n = Read();
        init();
        for(int i = 1; i &lt;= n; i++)
            a[i] = Read();
        for(int i = 1; i &lt; n; i++)
        {
            x = Read(), y = Read();
            addEdge(x,y);
            addEdge(y,x);
        }
        fa[1] = 1;
        dfs1(1);
        dfs2(1,1);
        built(1, 1, n);
        q = Read();
        for(int i = 1; i &lt;= q; i ++)
        {
            x = Read(), y = Read(), val = Read();
            int ans = lca(x, y);
            printf(&quot;%d\n&quot;, ans);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3237 Tree</title>
    <url>/tpaaaaaa.github.io/2019/09/16/POJ3237Tree/</url>
    <content><![CDATA[<p>Tree</p>
<p><strong>Time Limit:</strong> 5000MS</p>
<p><strong>Memory Limit:</strong> 131072K</p>
<p><strong>Total Submissions:</strong> 13998</p>
<p><strong>Accepted:</strong> 3547</p>
<p>Description</p>
<p>You are given a tree with <em>N</em> nodes. The tree’s nodes are numbered 1 through <em>N</em> and its edges are numbered 1 through <em>N</em> − 1. Each edge is associated with a weight. Then you are to execute a series of instructions on the tree. The instructions can be one of the following forms:</p>
<p><code>CHANGE</code> <em>i</em> <em>v</em></p>
<p>Change the weight of the <em>i</em>th edge to <em>v</em></p>
<p><code>NEGATE</code> <em>a</em> <em>b</em></p>
<p>Negate the weight of every edge on the path from <em>a</em> to <em>b</em></p>
<p><code>QUERY</code> <em>a</em> <em>b</em></p>
<p>Find the maximum weight of edges on the path from <em>a</em> to <em>b</em></p>
<p>Input</p>
<p>The input contains multiple test cases. The first line of input contains an integer <em>t</em> (<em>t</em> ≤ 20), the number of test cases. Then follow the test cases.</p>
<p>Each test case is preceded by an empty line. The first nonempty line of its contains <em>N</em> (<em>N</em> ≤ 10,000). The next <em>N</em> − 1 lines each contains three integers <em>a</em>, <em>b</em> and c, describing an edge connecting nodes <em>a</em> and <em>b</em> with weight <em>c</em>. The edges are numbered in the order they appear in the input. Below them are the instructions, each sticking to the specification above. A lines with the word “<code>DONE</code>” ends the test case.</p>
<p>Output</p>
<p>For each “<code>QUERY</code>” instruction, output the result on a separate line.</p>
<p>Sample Input</p>
<p>1</p>
<p>3<br>1 2 1<br>2 3 2<br>QUERY 1 2<br>CHANGE 1 3<br>QUERY 1 2<br>DONE</p>
<p>Sample Output</p>
<p>1<br>3</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样是树链剖分，只不过在线段树上的操作骚了一些而已。</p>
<p>Change 是改变某条边的权值</p>
<p>Query 是查询某条路径上的最大值</p>
<p>Negate 是将某条路径上的权值全部取相反数</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先是常规的树的输入部分</p>
<pre><code>for(int i = 1; i &lt; n; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
    addEdge(a, b);
    addEdge(b, a);
    e[i][0] = a;
    e[i][1] = b;
    e[i][2] = c;
}
fa[1] = 1;
dfs1(1);
dfs2(1, 1);
build(1, 1, n);</code></pre><p>然后是将边权下沉为点权的操作</p>
<pre><code>//接着是将边权下沉为点权
for(int i = 1; i &lt; n; i++)
{
    int u = e[i][0];
    int v = e[i][1];
    int w = e[i][2];
    if(dep[u] &lt; dep[v])
        swap(u, v);
    update1(1, dfn[u], w);
}</code></pre><p>显然，udpate1是线段树的单点更新，因为此题还要用到区间修改，所以取名update1</p>
<p>因为要进行取相反数的操作，所以我们维护的区间信息要包括最大值和最小值（取相反数后，二者会填负号后交换）</p>
<pre><code>void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>然后是处理查询部分</p>
<pre><code>while(cin &gt;&gt; s)
{
    if(s == &quot;DONE&quot;) break;
    scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
    if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
        printf(&quot;%d\n&quot;, lca(a, b));
    else if(s == &quot;NEGATE&quot;)
    {
                          //这里憨憨了，是对dfs序上进行的处理
        Negate(a, b);
    }
    else if(s == &quot;CHANGE&quot;)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        update1(1, dfn[u], b);
    }

}</code></pre><p>lca函数就是树链剖分函数。求的是一条路径上的最大值。</p>
<pre><code>int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}</code></pre><p>query就是常规的线段树查询区间最大值的函数</p>
<pre><code>int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].maxx;
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}</code></pre><p>然后是Negate函数，这也是对路径上的修改，所以也是路径剖分函数（就是这里WA了很久o(╥﹏╥)o）</p>
<pre><code>void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}</code></pre><p>可能稍微麻烦一点的，就是因为是区间修改嘛，所以要用到lazy标记，所以它的区间修改部分就是update2.</p>
<p><strong>这种翻转问题的区间修改，都可以用酱紫的lazy标记哦</strong></p>
<pre><code>    node[rt].lazy = (node[rt].lazy + 1) % 2;

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        node[rt].maxx = - node[rt].maxx;
        node[rt].minn = - node[rt].minn;
        swap(node[rt].maxx, node[rt].minn);
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}</code></pre><p><strong>然后是pushDown函数</strong></p>
<pre><code>void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}</code></pre><p>完整代码：</p>
<pre><code>/*
 Date              : 2019-09-16-16.43.18
 By                : Tpaaaaaa
 Question_Number   ：POJ3237
 Question_Name     ：树链剖分
 Description       :

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int e[MAXN][3], head[MAXN], cnt, tot, dep[MAXN], son[MAXN], top[MAXN], rk[MAXN], dfn[MAXN], fa[MAXN];
int siz[MAXN];
struct Edge
{
    int v, next;
};
Edge edge[MAXN * 2];
struct Node
{
    int l, r, maxx, minn, lazy;    //要维护区间里面的最小值和sum
}node[MAXN * 4 * 2];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(siz, 0, sizeof siz);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;
}
void dfs1(int u)
{
    dep[u] = dep[fa[u]] + 1;
    siz[u] = 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u])
        {
            fa[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }
    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u]) return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != fa[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void build(int rt, int l, int r)
{
    node[rt].l = l; //维护的是dfs序
    node[rt].r = r;
    node[rt].minn = node[rt].maxx = node[rt].lazy = 0;
    int mid = md(l, r);
    if(l == r)
        return;
    build(ls(rt), l, mid);
    build(rs(rt), mid + 1, r);
}
inline void pushUp(int rt)
{
    node[rt].minn = min(node[ls(rt)].minn, node[rs(rt)].minn);
    node[rt].maxx = max(node[ls(rt)].maxx, node[rs(rt)].maxx);
}
void pushDown(int rt)
{
    if(node[rt].lazy != 0)
    {
        node[rt].lazy = 0;
        node[ls(rt)].lazy = (node[ls(rt)].lazy + 1) % 2;
        node[rs(rt)].lazy = (node[rs(rt)].lazy + 1) % 2;

        node[ls(rt)].maxx = - node[ls(rt)].maxx;
        node[ls(rt)].minn = - node[ls(rt)].minn;
        swap(node[ls(rt)].maxx, node[ls(rt)].minn);

        node[rs(rt)].maxx = - node[rs(rt)].maxx;
        node[rs(rt)].minn = - node[rs(rt)].minn;
        swap(node[rs(rt)].maxx, node[rs(rt)].minn);
    }
}

void update1(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].minn = c;
        node[rt].maxx = c;
        return;
    }
    pushDown(rt);
    int m = md(node[rt].l, node[rt].r);
    if(k &lt;= m)
        update1(ls(rt), k, c);
    else
        update1(rs(rt), k, c);
    pushUp(rt);
}

void update2(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = (node[rt].lazy + 1) % 2;
        int temp =  node[rt].maxx;
        node[rt].maxx = - node[rt].minn;
        node[rt].minn = - temp;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update2(ls(rt), l, r);
    else if(l &gt; mid)
        update2(rs(rt), l, r);
    else
    {
        update2(ls(rt), l, mid);
        update2(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}
int query(int rt, int l, int r)
{

    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        return node[rt].maxx;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return max(query(ls(rt), l, mid), query(rs(rt), mid + 1, r));
}
int lca(int u, int v)
{
    int ret = -100000000;    //
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        ret = max(ret, query(1, dfn[top[u]], dfn[u]));
        u = fa[top[u]];
    }
    if(u == v) return ret;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret = max(ret, query(1, dfn[son[u]], dfn[v]));
    return ret;
}
void Negate(int u, int v)
{
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        update2(1, dfn[top[u]], dfn[u]);
        u = fa[top[u]];
    }
    if(u == v) return;
    if(dep[u] &gt; dep[v])
        swap(u, v);
    update2(1, dfn[son[u]], dfn[v]);
}
int main()
{
    int t, a, b, c, n;
    string s;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);
            addEdge(b, a);
            e[i][0] = a;
            e[i][1] = b;
            e[i][2] = c;
        }
        fa[1] = 1;
        dfs1(1);
        dfs2(1, 1);
        build(1, 1, n);
        //接着是将边权下沉为点权
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            update1(1, dfn[u], w);
        }
        while(cin &gt;&gt; s)
        {
            if(s == &quot;DONE&quot;) break;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            if(s == &quot;QUERY&quot;)        //询问的是a到b路径上的max
            {
                int ans = lca(a, b);
                printf(&quot;%d\n&quot;, ans);
            }
            else if(s == &quot;NEGATE&quot;)
            {
            //这里憨憨了
                //if(dep[a] &gt; dep[b])
                    //swap(a, b);
                Negate(a, b);
               // update2(1, dfn[a], dfn[b]); //update2的作用是将[]区间里面的翻转次数加1
            }
            else if(s == &quot;CHANGE&quot;)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                update1(1, dfn[u], b);
            }

        }


    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>FZU 2082 过路费</title>
    <url>/tpaaaaaa.github.io/2019/09/16/FZU2082%E8%BF%87%E8%B7%AF%E8%B4%B9/</url>
    <content><![CDATA[<p>有n座城市，由n-1条路相连通，使得任意两座城市之间可达。每条路有过路费，要交过路费才能通过。每条路的过路费经常会更新，现问你，当前情况下，从城市a到城市b最少要花多少过路费。Input</p>
<p>有多组样例，每组样例第一行输入两个正整数n,m(2 &lt;= n&lt;=50000，1&lt;=m &lt;= 50000),接下来n-1行，每行3个正整数a b c，(1 &lt;= a,b &lt;= n , a != b , 1 &lt;= c &lt;= 1000000000).数据保证给的路使得任意两座城市互相可达。接下来输入m行，表示m个操作，操作有两种：一. 0 a b，表示更新第a条路的过路费为b，1 &lt;= a &lt;= n-1 ； 二. 1 a b ， 表示询问a到b最少要花多少过路费。Output对于每个询问，输出一行，表示最少要花的过路费。</p>
<p>Sample Input</p>
<p>2 3<br>1 2 1<br>1 1 2<br>0 1 2<br>1 2 1</p>
<p>Sample Output</p>
<p>1<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树链剖分的常用处理方式：将边权下沉到深度较深的点上，作为点的权值。</p>
<p>妙哉妙哉，借此来分析一下树链剖分的代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>树信息的录入</p>
<pre><code>        for(int i = 1; i &lt; n; i ++)
        {
//一条无向边 &lt;a,b&gt; 权值为c
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);</code></pre><p>然后就是树链剖分最为关键的两次dfs，第一次dfs，我们获得相关数组信息</p>
<pre><code>//siz[u]存的是以u为根的子树的大小
//dep[u]存的是结点u的深度
//f[u]存的是结点u的父结点
//son[u]存的是u结点的重儿子结点编号

void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}</code></pre><p>第二次dfs，我们将获得dfs序，top[]等信息</p>
<pre><code>//dfn[u] 存的是u结点在dfs序中的编号
//top[u] 存的是u结点所在重链上的头结点
//rk[tot] 保存的是dfs序中tot号结点的编号

void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}</code></pre><p>获得完dfs序后，我们对dfs序建立线段树，那么我们要将边权下沉到深度较深的结点上，作为点的权值</p>
<pre><code>//常规的线段树建树操作
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}

        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }</code></pre><p>update是线段树的单点更新</p>
<pre><code>void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}</code></pre><p>接着是处理询问</p>
<pre><code>while(m--)
{
    int op, a, b;
    scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
    //将第a条路的费用变成b
    if(op == 0)
    {
        int u = e[a][0];
        int v = e[a][1];
        if(dep[u] &lt; dep[v])
            swap(u, v);
        //妙哉
        update(1, dfn[u], b);
    }
    else //查询a到b的费用
    {
        ll ans = sum(a, b);
        //sum返回的是a到b的权值和
        printf(&quot;%lld\n&quot;, ans);
    }
}</code></pre><p>sum函数也是树链剖分里面一个较为重要的部分，实际上就是利用我们之前求出来的top数组，来进行求LCA等操作。将树上两结点的路径，转化为dfs序上一些区间的组合，这样我们对这条路径上的处理，就转化为了对dfs序上一些区间的处理，而对于一个一维数组的区间处理，线段树是很可的。</p>
<pre><code>//返回的是编号u点到v点的路径权值和，就是常规的线段树区间查询函数
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉，这样就没计算头结点的权值了。
    return ret;

}

/*
 Date              : 2019-09-16-08.40.58
 By                : Tpaaaaaa
 Question_Number   ：FZU 2082
 Question_Name     ：树链剖分
 Description       :
 //将边权转移到点权上，然后变成了树链剖分的模板题
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
int cnt, tot;
int e[MAXN][3], dep[MAXN], head[MAXN], f[MAXN], top[MAXN], dfn[MAXN], siz[MAXN], son[MAXN], rk[MAXN];
struct Node
{
    int l, r;
    ll sum;
}node[MAXN * 4];

struct Edge
{
    int v, next;
} edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void dfs1(int u)
{
    siz[u] = 1;
    dep[u] = dep[f[u]] + 1;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u])
        {
            f[v] = u;
            dfs1(v);
            siz[u] += siz[v];
            if(siz[v] &gt; siz[son[u]])
                son[u] = v;
        }

    }
}
void dfs2(int u, int tp)
{
    top[u] = tp;
    dfn[u] = ++ tot;
    rk[tot] = u;
    if(!son[u])
        return;
    dfs2(son[u], tp);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v != f[u] &amp;&amp; v != son[u])
            dfs2(v, v);
    }
}
void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].sum = 0;
    if(l != r)
    {
        int mid = md(l, r);
        built(ls(rt), l, mid);
        built(rs(rt), mid + 1, r);
    }
}
//线段树的单点修改
//将k位置的值，变成c
inline void pushUp(int rt)
{
    node[rt].sum = node[ls(rt)].sum + node[rs(rt)].sum;
}
void update(int rt, int k, int c)
{
    if(node[rt].l == node[rt].r)
    {
        node[rt].sum = c;
        return;
    }
    int mid = md(node[rt].l, node[rt].r);
    if(k &lt;= mid)
        update(ls(rt), k, c);
    else
        update(rs(rt), k, c);
    pushUp(rt);
}
//返回的是编号u点到v点的路径权值和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
  //  pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);

}
ll sum(int u, int v)
{
    ll ret = 0;
    while(top[u] != top[v])
    {
        if(dep[top[u]] &lt; dep[top[v]])
            swap(u, v);
        //要从u这个位置跳到top[u]
        //也就是区间里面 dfn[top[u]] 到 dfn[u]的和
        ret += query(1, dfn[top[u]], dfn[u]);
        u = f[top[u]];
    }
    if(u == v)  return ret; //相遇了
    //在同一个链上，深度大的点，dfn大
    if(dep[u] &gt; dep[v])
        swap(u, v);
    ret += query(1, dfn[son[u]], dfn[v]);
    //son[u] 妙哉妙哉
    return ret;

}
void init()
{
    memset(head, -1, sizeof head);
    memset(dep, 0, sizeof dep);
    memset(son, 0, sizeof son);
    cnt = tot = 0;

}
int main()
{
    int n, m, a, b, c;
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt; n; i ++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            addEdge(a, b);  //没有权值的边
            addEdge(b, a);
            e[i][0] = a;    //用一个二维数组保存边的信息
            e[i][1] = b;
            e[i][2] = c;
        }
        f[1] = 1;
        dfs1(1);    //从一号节点dfs下去
        dfs2(1, 1);
        built(1, 1, n);
        //两次dfs后，我们得到了dfs序
        //我们对dfs序建立线段树
        for(int i = 1; i &lt; n; i++)
        {
            int u = e[i][0];
            int v = e[i][1];
            int w = e[i][2];
            if(dep[u] &lt; dep[v])
                swap(u, v);
            //在dfs序中，将dfn这个位置的点的值变成w
            update(1, dfn[u], w);
        }
        while(m--)
        {
            int op, a, b;
            scanf(&quot;%d%d%d&quot;, &amp;op, &amp;a, &amp;b);
            //将第a条路的费用变成b
            if(op == 0)
            {
                int u = e[a][0];
                int v = e[a][1];
                if(dep[u] &lt; dep[v])
                    swap(u, v);
                //妙哉
                update(1, dfn[u], b);
            }
            else //查询a到b的费用
            {
                ll ans = sum(a, b);
                //sum返回的是a到b的权值和
                printf(&quot;%lld\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]CDQ分治</title>
    <url>/tpaaaaaa.github.io/2019/09/16/%5B%E7%AE%97%E6%B3%95%5DCDQ%E5%88%86%E6%B2%BB/</url>
    <content><![CDATA[<p>博文地址<a href="https://www.cnblogs.com/hzf29721/p/10343179.html" target="_blank" rel="noopener">https://www.cnblogs.com/hzf29721/p/10343179.html</a></p>
<p>CDQ分治，有国家队某巨佬发明（仿佛是插头dp的论文作者？？？），主要用于解决带修改，查询，可排序序列的一系列问题，仅可支持<strong>离线操作</strong><br>CDQ分治的主要步骤有以下几点：<br>1、读入（废话）<br>1、将已经读入好的数据按照某关键字排序<br>2、设当前区间为[l,r][l,r]，递归处理左区间[l,mid][l,mid]和右区间[mid+1,r][mid+1,r]，计算左区间的修改操作对右区间的影响（一般用树状数组等数据结构维护）<br>3、清除数据结构内的修改数据<br>本题又叫三维偏序问题，是CDQ分治的经典题型<br>先按照第一维（即aiai）排序，这样就将问题转化到了二维<br>设当前区间为[l,r][l,r]<br>讲[l,mid][l,mid]和[mid+1,r][mid+1,r]分别按照第二维排序，此时在左区间中的aa均小于有区间中的aa(<strong>保证第一维</strong>)，设左区间已访问到plpl，右区间已访问到prpr(l≤pl≤mid,mid+1≤pr≤r)(l≤pl≤mid,mid+1≤pr≤r)<br>当b[pl]&lt;=b[pr]b[pl]&lt;=b[pr]时(<strong>保证第二维</strong>)，即将plpl点的cc值加入树状数组<br>统计比prpr点的cc值小或等于的点的数量(<strong>保证第三维</strong>)</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[纪念]新博客的100篇文章</title>
    <url>/tpaaaaaa.github.io/2019/09/15/%5B%E7%BA%AA%E5%BF%B5%5D%E6%96%B0%E5%8D%9A%E5%AE%A2%E7%9A%84100%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<p>8月19号开始，到9月15号。将近一个月的时间，感觉自己明显在变强！！！！加油加油！！！十一月的招新赛要加油！！！！！！！！</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 3015 Disharmony Trees</title>
    <url>/tpaaaaaa.github.io/2019/09/15/HDU-3015DisharmonyTrees/</url>
    <content><![CDATA[<p>One day Sophia finds a very big square. There are n trees in the square. They are all so tall. Sophia is very interesting in them.   </p>
<p><img src="https://vj.ti12z.cn/e79e812bfb09daff576ac5ce95a12388?v=1566913617" alt=""></p>
<p>She finds that trees maybe disharmony and the Disharmony Value between two trees is associated with two value called FAR and SHORT. </p>
<p>The FAR is defined as the following:If we rank all these trees according to their X Coordinates in ascending order.The tree with smallest X Coordinate is ranked 1th.The trees with the same X Coordinates are ranked the same. For example,if there are 5 tree with X Coordinates 3,3,1,3,4. Then their ranks may be 2,2,1,2,5. The FAR of two trees with X Coordinate ranks D1 and D2 is defined as F = abs(D1-D2). </p>
<p>The SHORT is defined similar to the FAR. If we rank all these trees according to their heights in ascending order，the tree with shortest height is ranked 1th.The trees with the same heights are ranked the same. For example, if there are 5 tree with heights 4,1,9,7,4. Then their ranks may be 2,1,5,4,2. The SHORT of two trees with height ranks H1 and H2 is defined as S=min(H1,H2). </p>
<p>Two tree’s Disharmony Value is defined as F*S. So from the definition above we can see that, if two trees’s FAR is larger , the Disharmony Value is bigger. And the Disharmony value is also associated with the shorter one of the two trees. </p>
<p>Now give you every tree’s X Coordinate and their height , Please tell Sophia the sum of every two trees’s Disharmony value among all trees.InputThere are several test cases in the input </p>
<p>For each test case, the first line contain one integer N (2 &lt;= N &lt;= 100,000) N represents the number of trees. </p>
<p>Then following N lines, each line contain two integers : X, H (0 &lt; X,H &lt;=1,000,000,000 ), indicating the tree is located in Coordinates X and its height is H.OutputFor each test case output the sum of every two trees’s Disharmony value among all trees. The answer is within signed 64-bit integer.Sample Input</p>
<p>2<br>10 100<br>20 200<br>4<br>10 100<br>50 500<br>20 200<br>20 100</p>
<p>Sample Output</p>
<p>1<br>13</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>与之前的mofest题意差不多，解法差不多。维护两棵树状数组，一棵存的是树的数目，一棵存的是树的坐标和。只不过要离散化而已</p>
<h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><pre><code>/*
 Date              : 2019-09-15-13.10.03
 By                : Tpaaaaaa
 Question_Number   ：poj 3015
 Question_Name     ：树状数组
 Description       :
 每棵树都有两个属性，一个是x，一个是h
 我们首先按照h单调递减排序
 然后按排序后的顺序依次取点

 假如取到第i棵树
 那么之前的i-1棵树的h 都要大于等于第i棵树的h
 那么第i棵树与之前i-1棵数的S=min(h1, h2) = h
 都是h
 设有3棵树在i之前，他们的坐标分为a，b，c
 设a = D(a), b = D(b) ...
 用离散化操作来处理。
 设第i棵树的坐标为x
 i与之前i-1棵树的value和 sum =
 sum = h*abs(a - x) + h*abs(b - x) + h*abs(c - x)
设a,b,c都小于x，也就是在x之前，那么sum
 sum = h*(x - a) + h*(x - b) + h*(x - c)
     = h(3*x - (a + b + c));
也就是说，将之前i-1棵树分成两部分，第一部分为
坐标小于x的，第二部分是坐标大于x的
 大于x部分的
 sum = h*((i - 3)*x - (tot - ()))




*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
ll c1[MAXN], c2[MAXN];
int lisan[2][MAXN];
struct Tree
{
    int x, h;
    friend bool operator &lt; (Tree a, Tree b)
    {
        return a.h &gt; b.h;
    }
};
Tree tree[MAXN];
int binSearch(int k, int n, int i)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int m = md(l, r);
        if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] != k )
            return m;
        else if(lisan[i][m] == k &amp;&amp; lisan[i][m - 1] == k )
            r = m - 1;
        else if(lisan[i][m] &gt; k)
            r = m - 1;
        else
            l = m + 1;
    }
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n, m, cnt;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        cnt = 0;
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;tree[i].x, &amp;tree[i].h);
            lisan[0][++cnt] = tree[i].x;
            lisan[1][cnt] = tree[i].h;
        }
        sort(lisan[0] + 1, lisan[0] + 1 + n);
        sort(lisan[1] + 1, lisan[1] + 1 + n);
        sort(tree + 1, tree + 1 + n);
        ll ans = 0;
        ll tot = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x = binSearch(tree[i].x, n, 0);
            int h = binSearch(tree[i].h, n, 1);
            ll s1 = sum1(x);   //排在x之前的数目
            ll s2 = sum2(x);   //排在x之前的坐标和
            ans += h * (s1 * x - s2);
            ans -= h * ((i - s1 - 1) * x - (tot - s2));
            up1(x, 1);
            up2(x, x);
            tot += x;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1990 MooFest</title>
    <url>/tpaaaaaa.github.io/2019/09/15/POJ1990MooFest/</url>
    <content><![CDATA[<p>Every year, Farmer John’s N (1 &lt;= N &lt;= 20,000) cows attend “MooFest”,a social gathering of cows from around the world. MooFest involves a variety of events including haybale stacking, fence jumping, pin the tail on the farmer, and of course, mooing. When the cows all stand in line for a particular event, they moo so loudly that the roar is practically deafening. After participating in this event year after year, some of the cows have in fact lost a bit of their hearing. </p>
<p>Each cow i has an associated “hearing” threshold v(i) (in the range 1..20,000). If a cow moos to cow i, she must use a volume of at least v(i) times the distance between the two cows in order to be heard by cow i. If two cows i and j wish to converse, they must speak at a volume level equal to the distance between them times max(v(i),v(j)). </p>
<p>Suppose each of the N cows is standing in a straight line (each cow at some unique x coordinate in the range 1..20,000), and every pair of cows is carrying on a conversation using the smallest possible volume. </p>
<p>Compute the sum of all the volumes produced by all N(N-1)/2 pairs of mooing cows.<br>Input* Line 1: A single integer, N </p>
<p>* Lines 2..N+1: Two integers: the volume threshold and x coordinate for a cow. Line 2 represents the first cow; line 3 represents the second cow; and so on. No two cows will stand at the same location.<br>Output* Line 1: A single line with a single integer that is the sum of all the volumes of the conversing cows.<br>Sample Input</p>
<p>4<br>3 1<br>2 5<br>2 6<br>4 3</p>
<p>Sample Output</p>
<p>57</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组的一种考法， 维护两棵树状数组。详细见代码</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>/*
 Date              : 2019-09-15-09.54.27
 By                : Tpaaaaaa
 Question_Number   ：poj1990
 Question_Name     ：树状数组练习题
 Description       :
 N个牛，就有N(N-1)/2 的pair
 我们先将牛按照音量排序
 依次取出牛
 假如考虑牛 i
 之前取出的牛的音量一定小于or等于牛i
 所以我们要计算牛i 和之前出现的牛的cost
 我们将之前出现的牛分为两类
 第一类是坐标小于牛i的
 假设第一类有三头牛，他们的坐标为a,b,c
 则cost1 = v[i](pos[i] - a + pos[i] - b + pos[i] - c)
         = v[i](3 * pos[] - (a + b + c))
 我们将其一般化，设牛i的坐标为x，第一类有num头牛，他们的坐标和为sum
 cost1 = v[i] * (num * x - sum)

 那么第二类里面有总的牛数 - 左边的牛数，他们的坐标和是总的坐标和 减去左边的坐标和
                 numAll - num                          sumAll - sum
 cost2 = v[i] * ( (numAll - num)*x - (sumAll - sum))

 所以我们需要维护两个树状数组，第一棵树状数组维护的是x坐标之前的牛的数目
   这个就是一般的0 1的树状数组
第二棵树状数组维护的是在前i头牛的坐标和
   up!!
   G++为什么会超时
   大量输入的时候，G++很有可能超时
   C++很有可能栈溢出
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define s(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e4 + 10;
ll c1[MAXN];
ll  c2[MAXN];
struct Node
{
    int v, pos;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.v &lt;= b.v;
    }
};
Node node[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void up1(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c1[i] += v;
}
void up2(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c2[i] += v;
}
ll sum1(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c1[i];
    return sum;
}
ll sum2(int x)
{
    ll sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c2[i];
    return sum;
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(c1, 0, sizeof c1);
        memset(c2, 0, sizeof c2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].v ,&amp;node[i].pos);
            node[i].i = i;
        }
        sort(node + 1, node + 1 + n);
        ll ans = 0;
        ll total = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x  = node[i].pos;        //当前牛的坐标
            int vo = node[i].v;          //当前牛的音量
            ll s1 = sum1(x);
            ll s2 = sum2(x);
            //sum1返回的是在x坐标之前的牛的数目
            //sum2返回的是那些牛的坐标和
            ans += vo * (s1 * x - s2);
            ans -= vo * ( (i - s1 - 1) * x - (total - s2));
            total += x;
            up1(x, 1);      
            up2(x, x);
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3321 apple tree</title>
    <url>/tpaaaaaa.github.io/2019/09/15/POJ3321appletree/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There is an apple tree outside of kaka’s house. Every autumn, a lot of apples will grow in the tree. Kaka likes apple very much, so he has been carefully nurturing the big apple tree.</p>
<p>The tree has <em>N</em> forks which are connected by branches. Kaka numbers the forks by 1 to <em>N</em> and the root is always numbered by 1. Apples will grow on the forks and two apple won’t grow on the same fork. kaka wants to know how many apples are there in a sub-tree, for his study of the produce ability of the apple tree.</p>
<p>The trouble is that a new apple may grow on an empty fork some time and kaka may pick an apple from the tree for his dessert. Can you help kaka?</p>
<p><img src="https://vj.ti12z.cn/95a992a75f75b7d92488d79284d3b4ef?v=1568225018" alt=""></p>
<p>Input</p>
<p>The first line contains an integer <em>N</em> (<em>N</em> ≤ 100,000) , which is the number of the forks in the tree.<br>The following <em>N</em> - 1 lines each contain two integers <em>u</em> and <em>v</em>, which means fork <em>u</em> and fork <em>v</em> are connected by a branch.<br>The next line contains an integer <em>M</em> (<em>M</em> ≤ 100,000).<br>The following <em>M</em> lines each contain a message which is either<br>“<strong>C <em>x</em></strong>“ which means the existence of the apple on fork <em>x</em> has been changed. i.e. if there is an apple on the fork, then Kaka pick it; otherwise a new apple has grown on the empty fork.<br>or<br>“<strong>Q <em>x</em></strong>“ which means an inquiry for the number of apples in the sub-tree above the fork <em>x</em>, including the apple (if exists) on the fork x<br>Note the tree is full of apples at the beginningOutputFor every inquiry, output the correspond answer per line.Sample Input</p>
<p>3<br>1 2<br>1 3<br>3<br>Q 1<br>C 2<br>Q 1</p>
<p>Sample Output</p>
<p>3<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组+dfs序。emmm可以里面区间查询来实现单点查询。</p>
<p>G++ 与 C++的区别：<a href="https://blog.csdn.net/lynn_ming/article/details/82014563" target="_blank" rel="noopener">https://blog.csdn.net/lynn_ming/article/details/82014563</a></p>
<p>G++ 容易TLE， C++容易RE</p>
<pre><code>/*
 Date              : 2019-09-15-08.56.16
 Question_Number   ：poj 3321
 Question_Name     ：apple tree
 Description       : 用dfs遍历树，得到dfs序。
                     对于每个节点u, 都有他的子树范围是[begin[u], last[u]]
                     字典序中排在[begin. last]之中的，都是u的子树节点
                     所以我们询问的也是这个区间的数目
                     但是我们更改的是某个节点
                     所以我们先查询这个节点是1or0，然后再去更改是+1 还是-1

                     查询的话， sum(last) - sum(begin - 1) 就可以了
                     //全局变量的锅
 By                : Tpaaaaaa
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int cnt, n, m, c[MAXN], a[MAXN], u, v, x, first[MAXN], last[MAXN], tot, head[MAXN];
char ch;
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int lowbit(int x)
{
    return x&amp;(-x);
}
void dfs(int u, int f)
{
    first[u] = ++ tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == f) continue;
            dfs(v, u);
    }
    last[u] = tot;
}
int down(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
void up(int x, int v)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
        c[i] += v;
}

int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            a[i] = 1;
            up(i, 1);
            head[i] = -1;
        }
        cnt = tot = 0;
        for(int i = 1; i &lt; n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v);
            //addEdge(v, u);
        }
        dfs(1, 1);                  //从第一个root开始
        scanf(&quot;%d&quot;, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            scanf(&quot;%d&quot;, &amp;x);
            if(ch == &apos;Q&apos;)
            {

                int sum = down(last[x]) - down(first[x]) + a[first[x]];
                printf(&quot;%d\n&quot;, sum);
            }
            else
            {
                if(a[first[x]])
                {
                    a[first[x]] = 0;
                    up(first[x], -1);
                }
                else
                {
                    a[first[x]] = 1;
                    up(first[x], 1);
                }
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组，dfs序</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2155 Matrix</title>
    <url>/tpaaaaaa.github.io/2019/09/15/POJ2155Matrix/</url>
    <content><![CDATA[<p>Given an N*N matrix A, whose elements are either 0 or 1. A[i, j] means the number in the i-th row and j-th column. Initially we have A[i, j] = 0 (1 &lt;= i, j &lt;= N). </p>
<p>We can change the matrix in the following way. Given a rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2), we change all the elements in the rectangle by using “not” operation (if it is a ‘0’ then change it into ‘1’ otherwise change it into ‘0’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. </p>
<p>1. C x1 y1 x2 y2 (1 &lt;= x1 &lt;= x2 &lt;= n, 1 &lt;= y1 &lt;= y2 &lt;= n) changes the matrix by using the rectangle whose upper-left corner is (x1, y1) and lower-right corner is (x2, y2).<br>2. Q x y (1 &lt;= x, y &lt;= n) querys A[x, y].<br>InputThe first line of the input is an integer X (X &lt;= 10) representing the number of test cases. The following X blocks each represents a test case. </p>
<p>The first line of each block contains two numbers N and T (2 &lt;= N &lt;= 1000, 1 &lt;= T &lt;= 50000) representing the size of the matrix and the number of the instructions. The following T lines each represents an instruction having the format “Q x y” or “C x1 y1 x2 y2”, which has been described above.<br>OutputFor each querying output one line, which has an integer representing A[x, y]. </p>
<p>There is a blank line between every two continuous test cases.<br>Sample Input</p>
<p>1<br>2 10<br>C 2 1 2 2<br>Q 2 2<br>C 2 1 2 1<br>Q 1 1<br>C 1 1 2 1<br>C 1 2 1 2<br>C 1 1 2 2<br>Q 1 1<br>C 1 1 2 1<br>Q 2 1</p>
<p>Sample Output</p>
<p>1<br>0<br>0<br>1</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要理解清楚，树状数组里面的sum函数和update的函数</p>
<p>update(x，v)函数，实际上是一个由a[x] 往上遍历到各个包含他的c[]中，因为x发生了改变，因此所有包含他的c[]的值相应的也要发生改变，所以可以理解为下级向上级反映情况(#^.^#)</p>
<p>sum(x) 函数，实际上是往下找，找到一些c[]，使得这些c[]包含了a[1],a[2] … a[x] 这x个节点的信息，所以可以理解为上级给下级布置任务(#^.^#)</p>
<p>我们可以直接将update函数叫成up函数，sum函数叫成down函数，方便理解</p>
<p>这题目就颠覆了我们传统观念里面up是更新，down是求和的思想。之前是单点更新和区间查找，此题是区间更新和单点查询</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-15-08.09.49
 Question_Number   ：poj 2155
 Question_Name     ：二维树状数组
 Description       :
 By                : Tpaaaaaa
 //直接记录去反的次数呀！！！！
 mod 2 = 0  说明为0

 树状数组up和down操作
 up(x), up(x, y)操作是 往上找  包含这个点(x) or (x, y)的区间
 是由a数组 找到c数组
 down(x)  or (x,y) 操作是往下走，找被他包含的区间, 也就是[0...x] or[0..x][0..y]
 是由c数组，找到a数组
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rsx)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1000 + 10;
int c[MAXN][MAXN], n;
int lowbit(int x)
{
    return x&amp;(-x);
}
void down(int x,int y)
{

    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            c[i][j]++;
}
int up(int x, int y)
{
    int sum = 0;
    for(int i = x; i &lt;= n; i += lowbit(i))
        for(int j = y; j &lt;= n; j += lowbit(j))
           sum += c[i][j];
    return sum;
}
int main()
{
    int t, x1, x2, y1, y2, m;
    char ch;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; ch;
            if(ch == &apos;C&apos;)
            {
                scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                down(x2, y2);   //是指将[x2, y1]整个范围内的点发生反转一次
                down(x1-1, y2);
                down(x2,y1-1);
                down(x1-1, y1-1);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;x1, &amp;y1);
                int times = up(x1, y1);
                printf(&quot;%d\n&quot;, times&amp;1);
            }
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2852 KiKi&#39;s K-Number</title>
    <url>/tpaaaaaa.github.io/2019/09/15/HDU-2852KiKi&#39;sK-Number/</url>
    <content><![CDATA[<p>For the k-th number, we all should be very familiar with it. Of course,to kiki it is also simple. Now Kiki meets a very similar problem, kiki wants to design a container, the container is to support the three operations. </p>
<p>Push: Push a given element e to container </p>
<p>Pop: Pop element of a given e from container </p>
<p>Query: Given two elements a and k, query the kth larger number which greater than a in container; </p>
<p>Although Kiki is very intelligent, she can not think of how to do it, can you help her to solve this problem?<br>InputInput some groups of test data ,each test data the first number is an integer m (1 &lt;= m &lt;100000), means that the number of operation to do. The next m lines, each line will be an integer p at the beginning, p which has three values:<br>If p is 0, then there will be an integer e (0 &lt;e &lt;100000), means press element e into Container. </p>
<p>If p is 1, then there will be an integer e (0 &lt;e &lt;100000), indicated that delete the element e from the container   </p>
<p>If p is 2, then there will be two integers a and k (0 &lt;a &lt;100000, 0 &lt;k &lt;10000),means the inquiries, the element is greater than a, and the k-th larger number.<br>OutputFor each deletion, if you want to delete the element which does not exist, the output “No Elment!”. For each query, output the suitable answers in line .if the number does not exist, the output “Not Find!”.Sample Input</p>
<p>5<br>0 5<br>1 2<br>0 6<br>2 3 2<br>2 8 1<br>7<br>0 2<br>0 2<br>0 4<br>2 1 1<br>2 1 2<br>2 1 3<br>2 1 4</p>
<p>Sample Output</p>
<p>No Elment!<br>6<br>Not Find!<br>2<br>2<br>4<br>Not Find!</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>树状数组，配合二分，可以寻找第k个位置，或者求某个位置的值</p>
<pre><code>/*
 Date              : 2019-09-15-14.50.27
 By                : Tpaaaaaa
 Question_Number   ：poj2852
 Question_Name     ：树状数组
 Description       :

 sum(x) 返回的是小于等于x的数的数目
 那么对于op = 0
 up(x, 1)
 op = 1
 up(x, -1);（如果sum(x) - sum(x - 1) == 0, 则说明不存在，那么printf）
 op = 2

 小于等于a的数目为sum = sum(a)
 所以我们找的是排名sum + k的数
 int l = 1;
 int r = MAXN
 int m = md(l, r)
 if(sum(m) == sum + k || sum(m) &gt; sum + k &amp;&amp; sum(m - 1) &lt; sum + k)  //注意这里的条件
    while(123123)

    {flag}
 ..
 用二分即可？？
 这个x数存不存在
 sum(x) - sum(x - 1) 是否为0即可知道
 注意：
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)     x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int c[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c[i] += v;
}
int sum(int x)
{
    int s = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        s += c[i];
    return s;
}
int binSearch(int k)
{
    int l = 1;
    int r = MAXN - 10;
    while(l &lt;= r)
    {
        int m = md(l, r);
        int s = sum(m);
        int s2 = sum(m - 1);
        if(s == k || (s2 &lt; k &amp;&amp; s &gt; k) )
        {
            while(sum(m - 1) == k)
                m --;
            return m;
        }
        else if(s &gt; k)
            r = m - 1;
        else
            l = m + 1;
    }
    return -1;
}
int main()
{
    int n, op, x, k;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;op);
            if(op == 0)
            {
                scanf(&quot;%d&quot;, &amp;x);
                update(x, 1);
            }
            else if(op == 1)
            {
                scanf(&quot;%d&quot;, &amp;x);
                if(0 == sum(x) - sum(x - 1))
                    printf(&quot;No Elment!\n&quot;);
                else
                    update(x, -1);
            }
            else
            {
                scanf(&quot;%d%d&quot;, &amp;x, &amp;k);
                int rak = k + sum(x);
                int ans = binSearch(rak);
                if(ans == -1)
                    printf(&quot;Not Find!\n&quot;);
                else
                    printf(&quot;%d\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>Ordering the Soldiers SPOJ - ORDERS</title>
    <url>/tpaaaaaa.github.io/2019/09/15/OrderingtheSoldiersSPOJ-ORDERS/</url>
    <content><![CDATA[<p>As you are probably well aware, in Byteland it is always the military officer’s main worry to order his soldiers on parade correctly. In Bitland ordering soldiers is not really such a problem. If a platoon consists of n men, all of them have different rank (from 1 - lowest to n - highest) and on parade they should be lined up from left to right in increasing order of rank.</p>
<p>Sounds simple, doesn’t it? Well, Msgt Johnny thought the same, until one day he was faced with a new command. He soon discovered that his elite commandos preferred to do the fighting, and leave the thinking to their superiors. So, when at the first rollcall the soldiers lined up in fairly random order it was not because of their lack of discipline, but simply because they couldn’t work out how to form a line in correct order of ranks. Msgt Johnny was not at all amused, particularly as he soon found that none of the soldiers even remembered his own rank. Over the years of service every soldier had only learned which of the other soldiers were his superiors. But Msgt Johnny was not a man to give up easily when faced with a true military challenge. After a moment’s thought a solution of brilliant simplicity struck him and he issued the following order: “men, starting from the left, one by one, do: (step forward; go left until there is no superior to the left of you; get back in line).”. This did indeed get the men sorted in a few minutes. The problem was solved… for the time being.</p>
<p>The next day, the soldiers came in exactly the same order as the day before, and had to be rearranged using the same method. History repeated. After some weeks, Msgt Johnny managed to force each of his soldiers to remember how many men he passed when going left, and thus make the sorting process even faster.</p>
<p>If you know how many positions each man has to walk to the left, can you try to find out what order of ranks the soldiers initially line up in?</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains an integer t&lt;=50, the number of test cases. It is followed by t test cases, each consisting of 2 lines. The first line contains a single integer n (1&lt;=n&lt;=200000). The second line contains n space separated integers wi, denoting how far the i-th soldier in line must walk to the left when applying Msgt Johnny’s algorithm.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each test case, output a single line consisting of n space separated integers - the ranks of the soldiers, given from left to right in their initial arrangement.</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input:</strong><br>2<br>3<br>0 1 0<br>5<br>0 1 2 0 1</p>
<p><strong>Output:</strong><br>2 1 3<br>3 2 1 5 4</p>
<p><strong>Warning: large Input/Output data, be careful with certain languages</strong></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>分析一下发现，其实可以看成一个插队问题，因为最后一个人总能排到他想去的位置，就像最后一个插队的人，总不会被插队一样。</p>
<p>5</p>
<p>0 1 2 0 1</p>
<p>转化为插队问题 数字代表的是想插的位置</p>
<p>1 1 1 4 4</p>
<p>我们从后往前，就像解决插队问题一样。用树状数组解决即可</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-15-14.09.35
 By                : Tpaaaaaa
 Question_Number   ：ordering the soldiers
 Question_Name     ：树状数组，插队问题
 Description       :
 插队问题，从后往前插
 最后一个人插队的位置是固定的
 5
 0 1 2 0 1
 转化为插队问题
 数字代表的是想插的位置
 1  1  1  4  4
 用线段树解决
 那么树状数组怎么解呢？
 配合二分试试
 l = 1, r = 5
 md = (l, r);
 if(sum(md) == i)
    return md;
update(md, 0);
 else
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
int c[MAXN], a[MAXN], pos[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        c[i] += v;
}
//找到空余为x的位置
int down(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
int binSearch(int x, int n)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int m = md(l, r);
        int sum = down(m);
        //m这个位置之前剩余的位置数，等于要插入的序号
        if(sum == x )
        {
            while(down(m - 1) == x)
                m = m - 1;
            return m;
        }

        else if(sum &gt; x)
            r = m - 1;
        else
            l = m + 1;
    }
}
int main()
{
    int t, n, d;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;d);
            a[i] = i - d;
            update(i, 1);
            //a[i]记录的是要插的位置
        }
        for(int i =  n; i &gt; 0; i--)
        {
            pos[i] = binSearch(a[i], n);
            update(pos[i], -1);
            //1表示空余，0表示被占了
        }
        for(int i = 1; i &lt;= n; i++)
         i == 1 ? printf(&quot;%d&quot;,pos[i]) : printf(&quot; %d&quot;, pos[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组解插队问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]树链剖分</title>
    <url>/tpaaaaaa.github.io/2019/09/15/%5B%E7%AE%97%E6%B3%95%5D%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p>视频链接<a href="https://www.bilibili.com/video/av62060264" target="_blank" rel="noopener">https://www.bilibili.com/video/av62060264</a></p>
<p>博文地址<a href="https://www.cnblogs.com/ivanovcraft/p/9019090.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivanovcraft/p/9019090.html</a></p>
<p>变量含义</p>
<ul>
<li>f[u]保存结点u的父亲节点</li>
<li>d[u]保存结点u的深度值</li>
<li>size[u]保存以u为根的子树节点个数</li>
<li>son[u]保存重儿子</li>
<li>rk[u]保存当前</li>
<li>dfs标号在树中所对应的节点</li>
<li>top[u]保存当前节点所在链的顶端节点</li>
<li>id[u]保存树中每个节点剖分以后的新编号（DFS的执行顺序）  </li>
</ul>
<p>第一次DFS，求出每个节点的父节点，深度，重儿子，子树大小等数据</p>
<pre><code>void dfs1(int u,int fa,int depth)    //当前节点、父节点、层次深度
{
    f[u]=fa;
    d[u]=depth;
    size[u]=1;    //这个点本身size=1，子树的大小要包括自己哦
    for(int i=head[u]; i != -1;i=e[i].next)
    {
        int v=e[i].to;
        if(v==fa)
            continue;
        dfs1(v,u,depth+1);    //层次深度+1
        size[u]+=size[v];    //子节点的size已被处理，用它来更新父节点的size
        if(size[v]&gt;size[son[u]])
            son[u]=v;    //选取size最大的作为重儿子
    }
}
//外部进入
dfs1(root,0,1);</code></pre><p>第二遍dfs，然后连接重链，同时标记每一个节点的dfs序，并且为了用数据结构来维护重链，我们在dfs时保证一条重链上各个节点dfs序连续（即处理出数组top,id,rk）</p>
<pre><code>void dfs2(int u,int t)    //当前节点、重链顶端
{
    top[u]=t;
    id[u]=++cnt;    //标记dfs序
    rk[cnt]=u;      //序号cnt对应节点u
    if(!son[u])     //没有子节点
        return;
    dfs2(son[u],t);
/*我们选择优先进入重儿子来保证一条重链上各个节点dfs序连续，
一个点和它的重儿子处于同一条重链，所以重儿子所在重链的顶端还是t*/
    for(int i=head[u];i;i=e[i].next)
    {
        int v=e[i].to;
        if(v!=son[u]&amp;&amp;v!=f[u])
            dfs2(v,v);    //一个点位于轻链底端，那么它的top必然是它本身
    }
}</code></pre><p>两遍dfs就是树链剖分的主要处理，通过dfs我们已经保证<strong>一条重链上各个节点dfs序连续</strong>，那么可以想到，我们可以通过数据结构（以线段树为例）来维护一条重链的信息<br>回顾上文的那个题目，修改和查询操作原理是类似的，以查询操作为例，其实就是个LCA，不过这里使用了top来进行加速，因为top可以直接跳转到该重链的起始结点，轻链没有起始结点之说，他们的top就是自己。<strong>需要注意的是，每次循环只能跳一次，并且让结点深的那个来跳到top的位置，避免两个一起跳从而插肩而过。</strong></p>
<pre><code>int sum(int x,int y)
{
    int ans=0,fx=top[x],fy=top[y];
    while(fx!=fy)    //两点不在同一条重链
    {
        if(d[fx]&gt;=d[fy]) //要让父节点深度大的点先跳，这里是x先跳
        {
            ans+=query(id[fx],id[x],rt);    //线段树区间求和，处理这条重链的贡献
            x=f[fx],fx=top[x];    //将x设置成原链头的父亲结点，走轻边，继续循环
        }
        else
        {
            ans+=query(id[fy],id[y],rt);
            y=f[fy],fy=top[y];
        }
    }
    //循环结束，两点位于同一重链上，但两点不一定为同一点，所以我们还要统计这两点之间的贡献
    if(id[x]&lt;=id[y])
        ans+=query(id[x],id[y],rt);
    else
        ans+=query(id[y],id[x],rt);
    return ans;
}</code></pre><p>妙哉妙哉</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]前缀和 差分 快速幂</title>
    <url>/tpaaaaaa.github.io/2019/09/15/%5B%E7%AE%97%E6%B3%95%5D%E5%89%8D%E7%BC%80%E5%92%8C%E5%B7%AE%E5%88%86%E5%BF%AB%E9%80%9F%E5%B9%82/</url>
    <content><![CDATA[<p>视频链接<a href="https://www.bilibili.com/video/av63194309" target="_blank" rel="noopener">https://www.bilibili.com/video/av63194309</a></p>
<h2 id="前缀和："><a href="#前缀和：" class="headerlink" title="前缀和："></a>前缀和：</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>这个优化主要是用来在O（1）时间内求出一个序列a中,a[i]+a[i+1]+……+a[j]的和。</p>
<p>具体原理十分简单：用sum[i]表示（a[1]+a[2]+……+a[i])，其中sum[0]=0，则（a[i]+a[i+1]+……+a[j]）即等于sum[j]-sum[i-1]。</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><h3 id="二维前缀和-1"><a href="#二维前缀和-1" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>同理，有一维就有二维。对于一个矩阵a，我们也能在O（1）时间内求出子矩阵[x1<del>x2][y1</del>y2]的和。</p>
<p>设sum[i][j]为子矩阵[1<del>i][1</del>j]的和。则由容斥原理得：</p>
<p>sum[0][j]=sum[i][0]=0</p>
<p>a[x1<del>x2][y1</del>y2]=sum[x2][y2]-sum[x1-1][y2]-sum[x2][y1-1]+sum[x1-1][y1-1]</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><p>博文链接<a href="https://blog.csdn.net/weixin_38686780/article/details/88827686" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38686780/article/details/88827686</a></p>
<p>众所周知，<strong>前缀和的差</strong> 是原序列，<strong>差分的和</strong> 是原序列</p>
<p>差分操作有助于把原序列上的“区间操作”转化为差分序列上的“单点操作”，在树上有着独特的应用。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[数据结构]替罪羊树</title>
    <url>/tpaaaaaa.github.io/2019/09/14/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91/</url>
    <content><![CDATA[<p>替罪羊树是一棵不需要旋转操作的AVL树，因此比较简单，适合入门学习。</p>
<p>视频：<a href="https://www.bilibili.com/video/av58948184/?spm_id_from=333.788.videocard.0" target="_blank" rel="noopener">https://www.bilibili.com/video/av58948184/?spm_id_from=333.788.videocard.0</a></p>
<p>模板题：<a href="https://www.luogu.org/problem/P3369" target="_blank" rel="noopener">https://www.luogu.org/problem/P3369</a></p>
<p>树的节点 Node</p>
<pre><code>struct Node
{
    int l, r, val;
// l,r为子节点的下标，val为该节点的权值
    int siz, fac;
// siz为该子树的大小，fac为该子树在删除操作之后的大小
    bool exist;
// 该点是否存在
};</code></pre><p>新节点的构建</p>
<pre><code>//用val构建一个新的节点，now为他的地址
void newnode(int &amp;now, int val)
{
    now = ++cnt;
    tzy[now].val = val;
    tzy[now].siz = tzy[now].fac = 1;
    tzy[now].exist = true;
}</code></pre><p>添加节点的操作——add</p>
<pre><code>//在树中插入一个val的值
void add(int &amp;now, int val)
{
    if(now == 0)
    {
        newnode(now, val);//插入完成
        check(root, now); //从根节点开始往下找，看看是不是存在不平衡的点
        return;
    }
    tzy[now].siz++;
    tzy[now].fac++;

    if(val &lt; tzy[now].val)
        add(tzy[now].l, val);
    else
        add(tzy[now].r, val);
}</code></pre><p>删除操作 —— del</p>
<pre><code>//在树中删除权值为val的点,惰性删除
void del(int now, int val)
{

    if(tzy[now].exist &amp;&amp; tzy[now].val == val)
    {
        tzy[now].exist = false;
        tzy[now].fac --;
        check(root, now);
        return;
    }
    tzy[now].fac --;
    if(val &lt; tzy[now].val)
        del(tzy[now].l, val);
    else
        del(tzy[now].r, val);
}</code></pre><p>检查树是否需要重构——check</p>
<pre><code>void check(int &amp;now, int ori)
{
    if(now == ori)
        return;
        //该点不平衡,将其重构，更新
    if(imbalance(now))
    {
        rebuilt(now);
        update(root, now);
        return;
    }
    if(tzy[ori].val &lt; tzy[now].val)
        check(tzy[now].l, ori);
    else
        check(tzy[now].r, ori);
}</code></pre><p>判断某个点是否不平衡——imbalance</p>
<pre><code>bool imbalance(int now)
{
    if(max(tzy[tzy[now].l].siz, tzy[tzy[now].r].siz ) &gt; tzy[now].siz * alpha
       || tzy[now].siz - tzy[now].fac &gt; tzy[now].siz * 0.3 )
        return true;
    return false;
}</code></pre><p>重构函数——rebuilt</p>
<pre><code>void rebuilt(int &amp;now)
{
    vec.clear();
    ldr(now);
    if(vec.empty())
    {
        now = 0;
        return;
    }
    lift(0, vec.size() - 1, now);
}</code></pre><p>其中的中序遍历</p>
<pre><code>void ldr(int now)
{
    if(!now) return;
    ldr(tzy[now].l);
    if(tzy[now].exist)
        vec.push_back(now);
    ldr(tzy[now].r);
}</code></pre><p>以及lift函数</p>
<pre><code>void lift(int l, int r, int &amp;now)
{
    if(l == r)
    {
        now = vec[l];
        tzy[now].l = tzy[now].r = 0;
        tzy[now].siz = tzy[now].fac = 1;
        return;
    }
    int mid = md(l, r);
    while(l &lt; mid &amp;&amp; tzy[vec[mid]].val == tzy[vec[mid - 1]].val)
        mid --;
    now = vec[mid];
    if(l &lt; mid)
        lift(l, mid - 1, tzy[now].l);
    else
        tzy[now].l = 0;

    lift(mid + 1, r, tzy[now].r);
    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;
    tzy[now].fac = tzy[tzy[now].l].fac + tzy[tzy[now].r].fac + 1;

}</code></pre><p>祖父节点的siz更新</p>
<pre><code>void update(int now, int ori)
{
    if(!now)
        return;
    if(tzy[ori].val &lt; tzy[now].val)
        update(tzy[now].l, ori);
    else
        update(tzy[now].r, ori);

    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;

}</code></pre><p>查询值的排名——getrank</p>
<pre><code>int getrank(int val)
{
    int now = root;
    int rankk = 1;
    while(now)
    {
        if(val &lt;= tzy[now].val)
            now = tzy[now].l;
        else
        {
            rankk += tzy[now].exist + tzy[tzy[now].l].fac;
            now = tzy[now].r;
        }
    }
    return rankk;
}</code></pre><p>某个排名的值查询——getnum</p>
<pre><code>int getnum(int rak)
{
    int now = root;
    while(now)
    {
        if(tzy[tzy[now].l].fac + tzy[now].exist == rak)
            break;
        else if(tzy[tzy[now].l].fac &gt;= rak)
            now = tzy[now].l;
        else
        {
            rak -= tzy[tzy[now].l].fac + tzy[now].exist;
            now = tzy[now].r;
        }
    }
    return tzy[now].val;
}</code></pre><p>获得某个数的前驱和后继</p>
<pre><code>前驱：getnum(getrank(x) - 1)
后继：getnum(getrank(x + 1))</code></pre><p>完整的板子：</p>
<pre><code>//AC的板子
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;
#define md(x, y)  (x + y) / 2
using namespace std;
const int MAXN = 1e5 + 10;
int cnt = 0, root;
vector &lt; int &gt; vec;
const double alpha = 0.75;
struct Node
{
    int l, r, val;
    int siz, fac;
    bool exist;
};
Node tzy[MAXN];
void newnode(int &amp;now, int val)
{
    now = ++cnt;
    tzy[now].l = tzy[now].r = 0;
    tzy[now].val = val;
    tzy[now].siz = tzy[now].fac = 1;
    tzy[now].exist = true;
}
bool imbalance(int now)
{
    if(max(tzy[tzy[now].l].siz, tzy[tzy[now].r].siz ) &gt; tzy[now].siz * alpha
       || tzy[now].siz - tzy[now].fac &gt; tzy[now].siz * 0.3 )
        return true;
        return false;
}
//将now为根的子树重建，首先用中序遍历
void ldr(int now)
{
    if(!now)
        return;
    ldr(tzy[now].l);
    if(tzy[now].exist)
        vec.push_back(now);
    ldr(tzy[now].r);
}
void lift(int l, int r, int &amp;now)
{
    if(l == r)
    {
        now = vec[l];
        tzy[now].l = tzy[now].r = 0;
        tzy[now].siz = tzy[now].fac = 1;
        return;
    }
    int mid = md(l, r);
    while(l &lt; mid &amp;&amp; tzy[vec[mid]].val == tzy[vec[mid - 1]].val)
        mid --;
    now = vec[mid];
    if(l &lt; mid)
        lift(l, mid - 1, tzy[now].l);
    else
        tzy[now].l = 0;
    lift(mid + 1, r, tzy[now].r);
    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;
    tzy[now].fac = tzy[tzy[now].l].fac + tzy[tzy[now].r].fac + 1;

}
int getrank(int val)
{
    int now = root;
    int rankk = 1;
    while(now)
    {
        if(val &lt;= tzy[now].val)
            now = tzy[now].l;
        else
        {
            rankk += tzy[now].exist + tzy[tzy[now].l].fac;
            now = tzy[now].r;
        }
    }
    return rankk;
}
int getnum(int rak)
{
    int now = root;
    while(now)
    {
        //??
        if(tzy[now].exist &amp;&amp; tzy[tzy[now].l].fac + tzy[now].exist == rak)
            break;
        else if(tzy[tzy[now].l].fac &gt;= rak)
            now = tzy[now].l;
        else
        {
            rak -= tzy[tzy[now].l].fac + tzy[now].exist;
            now = tzy[now].r;
        }

    }
    return tzy[now].val;
}
void update(int now, int ori)
{
    if(!now)
        return;
    if(tzy[ori].val &lt; tzy[now].val)
        update(tzy[now].l, ori);
    else
        update(tzy[now].r, ori);

    tzy[now].siz = tzy[tzy[now].l].siz + tzy[tzy[now].r].siz + 1;

}
void rebuilt(int &amp;now)
{
    vec.clear();
    ldr(now);
    if(vec.empty())
    {
        now = 0;
        return;
    }
    lift(0, vec.size() - 1, now);
}
void check(int &amp;now, int ori)
{
    if(now == ori)
        return;
        //该点不平衡,将其重构，更新
    if(imbalance(now))
    {
        rebuilt(now);
        update(root, now);
        return;
    }
    if(tzy[ori].val &lt; tzy[now].val)
        check(tzy[now].l, ori);
    else
        check(tzy[now].r, ori);
}
//在now这个位置插入val
void del(int now, int val)
{
    if(tzy[now].exist&amp;&amp;tzy[now].val == val)
    {
        tzy[now].exist = false;
        tzy[now].fac --;
        check(root, now);
        return;
    }
    tzy[now].fac --;
    if(val &lt; tzy[now].val)
        del(tzy[now].l, val);
    else
        del(tzy[now].r, val);
}
void add(int &amp;now, int val)
{
    if(now == 0)
    {
        newnode(now, val);//插入完成
        check(root, now); //从根节点开始往下找，看看是不是存在不平衡的点
        return;
    }
    tzy[now].siz++;
    tzy[now].fac++;
    if(val &lt; tzy[now].val)
        add(tzy[now].l, val);
    else
        add(tzy[now].r, val);
}

int main()
{
    cnt = 0;
    root = 0;
    int t, x, opt;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;opt, &amp;x);
        switch(opt)
        {
            case 1:
                add(root, x);
                break;
            case 2:
                del(root, x);
                break;
            case 3:
                printf(&quot;%d\n&quot;, getrank(x));
                break;
            case 4:
                printf(&quot;%d\n&quot;, getnum(x));
                break;
            case 5:
                printf(&quot;%d\n&quot;, getnum(getrank(x) - 1));
                break;
            case 6:
                printf(&quot;%d\n&quot;, getnum(getrank(x + 1)));
        }
    }
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[随笔]中秋不宜敲代码</title>
    <url>/tpaaaaaa.github.io/2019/09/14/%5B%E9%9A%8F%E7%AC%94%5D%E4%B8%AD%E7%A7%8B%E4%B8%8D%E5%AE%9C%E6%95%B2%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>敲了半小时代码，200+行，然后编译器卡了没保存，哭哭哭。心态炸</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>[操作]DFS序</title>
    <url>/tpaaaaaa.github.io/2019/09/14/%5B%E6%93%8D%E4%BD%9C%5DDFS%E5%BA%8F/</url>
    <content><![CDATA[<p>树通常有多种类型，但其终归是非线性结构，操作起来有时总是那么费时。</p>
<p>我们知道，树是一种非线性的数据结构，它的一些数据调用肯定是没有线性结构来得方便的。所以这个时候，dfs站了出来。基于dfs函数，我们可以在遍历的同时记录下每个节点进出栈的时间序列。就假设有这样一颗树： </p>
<p><img src="https://img-blog.csdn.net/20171103154348840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzk2NzA0MzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>dfs序就是： </p>
<p><img src="https://img-blog.csdn.net/20171103154427093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzk2NzA0MzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>我们发现，一个点的进出栈的时间点之间的时间段就是它的子树在栈中的所有时间。也就是说，子树的dfs序肯定大于根节点的进栈时间小于根节点的出栈时间，这就成了一个区间问题。所以我们就把一个树上的问题“拍”到了一个线性的数据结构上面。区间问题就是贼好做的了，有各种强大的数据结构可以用来维护区间，例如线段树。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 1394 Minimum Inversion Number</title>
    <url>/tpaaaaaa.github.io/2019/09/13/HDU1394MinimumInversionNumber/</url>
    <content><![CDATA[<p>The inversion number of a given number sequence a1, a2, …, an is the number of pairs (ai, aj) that satisfy i &lt; j and ai &gt; aj. </p>
<p>For a given sequence of numbers a1, a2, …, an, if we move the first m &gt;= 0 numbers to the end of the seqence, we will obtain another sequence. There are totally n such sequences as the following: </p>
<p>a1, a2, …, an-1, an (where m = 0 - the initial seqence)<br>a2, a3, …, an, a1 (where m = 1)<br>a3, a4, …, an, a1, a2 (where m = 2)<br>…<br>an, a1, a2, …, an-1 (where m = n-1) </p>
<p>You are asked to write a program to find the minimum inversion number out of the above sequences.<br>InputThe input consists of a number of test cases. Each case consists of two lines: the first line contains a positive integer n (n &lt;= 5000); the next line contains a permutation of the n integers from 0 to n-1.<br>OutputFor each case, output the minimum inversion number on a single line.<br>Sample Input</p>
<p>10<br>1 3 6 9 0 8 5 7 4 2</p>
<p>Sample Output</p>
<p>16</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要清楚整个数列的逆序数代表的含义，每个数的逆序数的含义。</p>
<p>复习一下用树状数组解普通逆序数问题</p>
<p>普通求逆序数的思路，将数列排序离散化，然后按原数列顺序从后往前依次将数放入（以离散化后的下标），然后用线段树维护离散化后的数， 可用树状数组解。</p>
<p>然后对逆序数这个这个数的性质进行思考<br>第一个数的逆序数，就是在他之后的，比他小的数<br>把第一个数移到最后去，则他的逆序数变成了0.<br>那些比他大的数，他们的逆序数都加1</p>
<p>那些比他小的数，逆序数没有发什么变化。</p>
<p>而第一个数的逆序数，就是比他小的数的数目<br>也就是统计一下，比第一个数大的数有哪些<br>那么这一次移动，总的逆序数的变化<br>sum = sum - (第一个数的逆序数) + 数列中比第一个数大的数的数目</p>
<p>= sum - (数列中比第一个数小的数的数目) + (数列中比第一个数大的数的数目)<br>用树状数组解出总的逆序数，和每个点的逆序数。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y) (x + y) / 2
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e3 + 10;
int inverNum[MAXN];
int q;
int c[MAXN], a[MAXN], lisan[MAXN];
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int v)
{
    for(int i = x; i &lt;= q; i += lowbit(i))
        c[i] += v;
}
int sum(int x)
{
    int ans = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        ans += c[i];
    return ans;
}
int binSearch(int x, int n)
{
    int l = 1;
    int r = n;
    while(l &lt;= r)
    {
        int mid = md(l, r);
        if(lisan[mid] == x)
            return mid;
        else if(lisan[mid] &gt; x)
            r = mid - 1;
        else
            l = mid + 1;
    }
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            lisan[i] = a[i];
        }
        sort(lisan + 1, lisan + 1 + n);
        q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
        memset(c, 0, sizeof c);
        int ans = 0;
        for(int i = n; i &gt; 0; i--)
        {
            int pos = binSearch(a[i], q);
            update(pos, 1);
            inverNum[i] = sum(pos - 1);
            ans += inverNum[i];
        }
        //第一次移第一个数，第二个以第二个数
        for(int i = 1; i &lt; n; i++)
        {
            inverNum[i] = 0;
            int temp = 0;
            for(int j = 1; j &lt;= n; j++)
                if(i != j &amp;&amp; a[j] &gt; a[i])
                    inverNum[j]++;
            for(int j = 1; j &lt;= n; j++)
                temp += inverNum[j];

            ans = min(ans, temp);
        }
        printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组，逆序对数</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 3974 Assign the task</title>
    <url>/tpaaaaaa.github.io/2019/09/13/HDU3974Assignthetask/</url>
    <content><![CDATA[<p>There is a company that has N employees(numbered from 1 to N),every employee in the company has a immediate boss (except for the leader of whole company).If you are the immediate boss of someone,that person is your subordinate, and all his subordinates are your subordinates as well. If you are nobody’s boss, then you have no subordinates,the employee who has no immediate boss is the leader of whole company.So it means the N employees form a tree. </p>
<p>The company usually assigns some tasks to some employees to finish.When a task is assigned to someone,He/She will assigned it to all his/her subordinates.In other words,the person and all his/her subordinates received a task in the same time. Furthermore,whenever a employee received a task,he/she will stop the current task(if he/she has) and start the new one. </p>
<p>Write a program that will help in figuring out some employee’s current task after the company assign some tasks to some employee.InputThe first line contains a single positive integer T( T &lt;= 10 ), indicates the number of test cases. </p>
<p>For each test case: </p>
<p>The first line contains an integer N (N ≤ 50,000) , which is the number of the employees. </p>
<p>The following N - 1 lines each contain two integers u and v, which means the employee v is the immediate boss of employee u(1&lt;=u,v&lt;=N). </p>
<p>The next line contains an integer M (M ≤ 50,000). </p>
<p>The following M lines each contain a message which is either </p>
<p>“C x” which means an inquiry for the current task of employee x </p>
<p>or </p>
<p>“T x y”which means the company assign task y to employee x. </p>
<p>(1&lt;=x&lt;=N,0&lt;=y&lt;=10^9)OutputFor each test case, print the test case number (beginning with 1) in the first line and then for every inquiry, output the correspond answer per line.Sample Input</p>
<p>1<br>5<br>4 3<br>3 2<br>1 3<br>5 2<br>5<br>C 3<br>T 2 1<br> C 3<br>T 3 2<br>C 3</p>
<p>Sample Output</p>
<p>Case #1:<br>-1<br>1<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>妙哉妙哉</p>
<p>首先根据领导关系，构建一棵树，显然这是一棵有根树，我们从根开始dfs，得到一个dfs序，记录每个点first[u] 和last[u]，也就是这个点第一次出现在dfs序中的位置和最后一次出现在dfs序中的位置， 显然dfs序中first[u] 到 last[u]中的节点，间接或者直接由u控制，因此每次对u的任务下达，我们就可以将dfs序中[ first, last]这个区间里面的节点的任务都变成u的任务，所以用线段树来维护区间信息。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>输入部分</p>
<pre><code>scanf(&quot;%d&quot;, &amp;n);
for(int i = 1; i &lt;= n; i++)
{
    in[i] = 0;
    emp[i].clear();
}
for(int i = 1; i &lt;= n - 1; i++)
{
    int x, y;
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    emp[y].push_back(x);   
    in[x] ++;
    //入度为0说明是大boss
}
cnt = 0;
int k = 0;
for(int i = 1; i &lt;= n; i++)
    if(in[i] == 0)
    {
        k = i;
        break;
    }
memset(vis, false, sizeof vis);
dfs(k);//从大boss开始dfs
built(1, 1, cnt); //以dfs序建立一棵树</code></pre><p>树的建立</p>
<pre><code>void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    node[rt].lazy = -1;
    if(l == r)
        return;
    int mid = md(l, r);
    built(ls(rt), l, mid);
    built(rs(rt), mid + 1, r);
}</code></pre><p>接下来的操作</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    cin &gt;&gt; c;
    if(c == &apos;C&apos;)
    {
        int x;
        scanf(&quot;%d&quot;, &amp;x);
        int ans = query(1, first[x]);
        printf(&quot;%d\n&quot;, ans);
    }
    else
    {
        int x, y;
        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
        update(1, first[x], last[x], y);
    }
}</code></pre><p>update函数</p>
<pre><code>void update(int rt, int l, int r, int v)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
    {
        node[rt].lazy = v;
        return;
    }
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        update(ls(rt), l, r, v);
    else if(l &gt; mid)
        update(rs(rt), l, r, v);
    else
    {
        update(ls(rt), l, mid, v);
        update(rs(rt), mid + 1, r, v);
    }
}</code></pre><p>查询部分</p>
<pre><code>// 返回第pos人的lazy值
int query(int rt, int pos)
{
    if(node[rt].l == node[rt].r)
        return node[rt].lazy;
    pushDown(rt);
    int mid = md(node[rt].l, node[rt].r);       //我可以骂人吗
    if(pos &lt;= mid)
        return query(ls(rt), pos);
    else
        return query(rs(rt), pos);
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>dfs序，线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4027 Can you answer these queries?</title>
    <url>/tpaaaaaa.github.io/2019/09/13/HDU-4027Canyouanswerthesequeries/</url>
    <content><![CDATA[<p>A lot of battleships of evil are arranged in a line before the battle. Our commander decides to use our secret weapon to eliminate the battleships. Each of the battleships can be marked a value of endurance. For every attack of our secret weapon, it could decrease the endurance of a consecutive part of battleships by make their endurance to the square root of it original value of endurance. During the series of attack of our secret weapon, the commander wants to evaluate the effect of the weapon, so he asks you for help.<br>You are asked to answer the queries that the sum of the endurance of a consecutive part of the battleship line. </p>
<p>Notice that the square root operation should be rounded down to integer.InputThe input contains several test cases, terminated by EOF.<br>  For each test case, the first line contains a single integer N, denoting there are N battleships of evil in a line. (1 &lt;= N &lt;= 100000)<br>  The second line contains N integers Ei, indicating the endurance value of each battleship from the beginning of the line to the end. You can assume that the sum of all endurance value is less than 2 63.<br>  The next line contains an integer M, denoting the number of actions and queries. (1 &lt;= M &lt;= 100000)<br>  For the following M lines, each line contains three integers T, X and Y. The T=0 denoting the action of the secret weapon, which will decrease the endurance value of the battleships between the X-th and Y-th battleship, inclusive. The T=1 denoting the query of the commander which ask for the sum of the endurance value of the battleship between X-th and Y-th, inclusive.<br>OutputFor each test case, print the case number at the first line. Then print one line for each query. And remember follow a blank line after each test case.Sample Input</p>
<p>10<br>1 2 3 4 5 6 7 8 9 10<br>5<br>0 1 10<br>1 1 10<br>1 1 5<br>0 5 8<br>1 4 8</p>
<p>Sample Output</p>
<p>Case #1:<br>19<br>7<br>6</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>0操作是将[x, y]区间里面的数都开方，1操作是求[x, y]区间和。由题知道，给定树列上的数，最多为2^64，也就是说开一次就是2^32，再开一次就是2^16 , 2^8. 2^4 . 2^2 2 1 ,也就是说，每个数最多开7次，所以可以用这个来剪枝。如果某个区间和 == 区间长度，说明区间里面的数都是1，就剪枝不需要操作，不然的话就单个单个开方。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>线段树的构建</p>
<pre><code>void built(int rt, int l, int r)
{
    node[rt].l = l;
    node[rt].r = r;
    if(l == r)
    {
        node[rt].sum = a[l];
        return;
    }

    int mid = md(l, r);
    built(ls(rt), l, mid);
    built(rs(rt), mid + 1, r);
    pushUp(rt);
}</code></pre><p>输入部分</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    int t, x, y;
    scanf(&quot;%d%d%d&quot;, &amp;t, &amp;x, &amp;y);
    if(y &lt; x)
        swap(x, y); //这是个什么傻逼坑点？？？
    if(t == 0)
    {
        update(1, x, y);
    }
    else
    {
        ll ans = query(1, x, y);
        printf(&quot;%lld\n&quot;, ans);
    }
}</code></pre><p>update部分</p>
<pre><code>//将[l, r]这个区间里面的值全部开根号
void update(int rt, int l, int r)
{
    if(node[rt].sum == (node[rt].r - node[rt].l +1))
        return;     //说明没有操作的必要了
    if(node[rt].l == node[rt].r) //单点更新到底了
    {
        if(node[rt].sum != 1)
            node[rt].sum = (int)sqrt(double(node[rt].sum));
        return;
    }
    int mid = md(node[rt].l, node[rt].r);

    if(r &lt;= mid)
        update(ls(rt), l, r);
    else if (l &gt; mid)
        update(rs(rt), l, r);
    else
    {
        update(ls(rt), l, mid);
        update(rs(rt), mid + 1, r);
    }
    pushUp(rt);
}</code></pre><p>查询部分</p>
<pre><code>//返回[l, r]区间和
ll query(int rt, int l, int r)
{
    if(node[rt].l == l &amp;&amp; node[rt].r == r)
        return node[rt].sum;
    int mid = md(node[rt].l, node[rt].r);
    if(r &lt;= mid)
        return query(ls(rt), l, r);
    else if(l &gt; mid)
        return query(rs(rt), l, r);
    else
        return query(ls(rt), l, mid) + query(rs(rt), mid + 1, r);
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 4417 Super Mario</title>
    <url>/tpaaaaaa.github.io/2019/09/13/HDU4417SuperMario/</url>
    <content><![CDATA[<p>Mario is world-famous plumber. His “burly” figure and amazing jumping ability reminded in our memory. Now the poor princess is in trouble again and Mario needs to save his lover. We regard the road to the boss’s castle as a line (the length is n), on every integer point i there is a brick on height hi. Now the question is how many bricks in [L, R] Mario can hit if the maximal height he can jump is H.InputThe first line follows an integer T, the number of test data.<br>For each test data:<br>The first line contains two integers n, m (1 &lt;= n &lt;=10^5, 1 &lt;= m &lt;= 10^5), n is the length of the road, m is the number of queries.<br>Next line contains n integers, the height of each brick, the range is [0, 1000000000].<br>Next m lines, each line contains three integers L, R,H.( 0 &lt;= L &lt;= R &lt; n 0 &lt;= H &lt;= 1000000000.)OutputFor each case, output “Case X: “ (X is the case number starting from 1) followed by m lines, each line contains an integer. The ith integer is the number of bricks Mario can hit for the ith query.<br>Sample Input</p>
<p>1<br>10 10<br>0 5 2 7 5 4 3 8 7 7<br>2 8 6<br>3 5 0<br>1 3 1<br>1 9 4<br>0 1 0<br>3 5 5<br>5 5 1<br>4 6 3<br>1 5 7<br>5 7 3</p>
<p>Sample Output</p>
<p>Case 1:<br>4<br>0<br>0<br>3<br>1<br>2<br>0<br>1<br>5<br>1</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>给一个数列，问这个数列里面的某个区间[L, R]中 比H小or 等的数目有多少个</p>
<p>主席树。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>输入和离散化以及主席树初始化</p>
<pre><code>scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
for(int i = 1; i &lt;= n; i++)
{
    scanf(&quot;%d&quot;, &amp;a[i]);
    lisan[i] = a[i];
}
sort(lisan + 1, lisan + 1 + n);
int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
cnt = 0;
root[0] = 0;
node[0].lson = node[0].rson = node[0].sum = 0;</code></pre><p>建立第1 … n棵主席树</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    int pos = binSearch(a[i], q);
    root[i] = root[i - 1];
    update(pos, root[i], 1, q);
}</code></pre><p>主席树的构建——update（是不是叫built更合适）</p>
<pre><code>void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];
    root = cnt;
    node[cnt].sum++;
    if(L == R)
        return;     //已经递归到pos位了
    int mid = md(L, R);

    if(pos &lt;= mid)  //pos位要小于mid位，说明左子树要改
        update(pos, node[root].lson, L, mid);
    else
        update(pos, node[root].rson, mid + 1, R);
}</code></pre><p>接下来是查询第[x, y]区间中比h小或等的数目</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
    x++;
    y++; //孤儿题目
    //不是求[x, y]区间中第k大的数，而是比k小于等于的数的数目
    int pos = query(root[x - 1], root[y], k, 1, q);
    printf(&quot;%d\n&quot;, pos);
}</code></pre><p>查询部分</p>
<pre><code>int query(int i, int j, int k, int L, int R)
{
 //o记录的是原数列中[L, R]区间数的总数
    int o = node[j].sum - node[i].sum;      //[L, R]这个区间里面的总次数
    if(L == R)
    {
        if(k &gt;= lisan[L])
            return o;
        else
            return 0;
    }
    int ld = node[node[j].lson].sum - node[node[i].lson].sum; 
//ld记录的是原数列中[L, R]区间中  位于离散化后数组前半部分的数的数目
    int rd = node[node[j].rson].sum - node[node[i].rson].sum;   //[mid + 1, R] 这里面的次数
    int mid = md(L, R);     //返回的是在离散数组中的下标
    if( k &lt;= lisan[mid])   
        return query(node[i].lson, node[j].lson, k, L, mid);
    else
        return query(node[i].rson, node[j].rson, k, mid + 1, R) + ld;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2761 feed the dogs</title>
    <url>/tpaaaaaa.github.io/2019/09/13/POJ2761feedthedogs/</url>
    <content><![CDATA[<p>Feed the dogs</p>
<p><strong>Time Limit:</strong> 6000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 23590</p>
<p><strong>Accepted:</strong> 7497</p>
<p>DescriptionWind loves pretty dogs very much, and she has n pet dogs. So Jiajia has to feed the dogs every day for Wind. Jiajia loves Wind, but not the dogs, so Jiajia use a special way to feed the dogs. At lunchtime, the dogs will stand on one line, numbered from 1 to n, the leftmost one is 1, the second one is 2, and so on. In each feeding, Jiajia choose an inteval[i,j], select the k-th pretty dog to feed. Of course Jiajia has his own way of deciding the pretty value of each dog. It should be noted that Jiajia do not want to feed any position too much, because it may cause some death of dogs. If so, Wind will be angry and the aftereffect will be serious. Hence any feeding inteval will not contain another completely, though the intervals may intersect with each other. </p>
<p>Your task is to help Jiajia calculate which dog ate the food after each feeding.   </p>
<p>InputThe first line contains n and m, indicates the number of dogs and the number of feedings. </p>
<p>The second line contains n integers, describe the pretty value of each dog from left to right. You should notice that the dog with lower pretty value is prettier. </p>
<p>Each of following m lines contain three integer i,j,k, it means that Jiajia feed the k-th pretty dog in this feeding. </p>
<p>You can assume that n&lt;100001 and m&lt;50001.   </p>
<p>OutputOutput file has m lines. The i-th line should contain the pretty value of the dog who got the food in the i-th feeding.</p>
<p>Sample Input</p>
<p>7 2<br>1 5 2 6 3 7 4<br>1 5 3<br>2 7 1</p>
<p>Sample Output</p>
<p>3<br>2</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>给定一个长度为n的序列，有m个询问，每次查询区间第K大的元素。 主席树裸题</p>
<p>依次来分析代码：</p>
<p>主席树的节点</p>
<pre><code>struct Node
{
    int lson, rson;//记录的是子节点的下标
    int sum;       //记录的是这个节点维护的区间中数的数目
};</code></pre><p>输入部分</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    scanf(&quot;%d&quot;, &amp;a[i]);
    lisan[i] = a[i];
}
sort(lisan + 1, lisan + 1 + n);
int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
//1.离散化</code></pre><p>主席树初始化：</p>
<pre><code>root[0] = 0;
node[0].L = node[0].R = node[0].sum = 0;
cnt = 0;</code></pre><p>开始建立第1 .. n 棵主席树</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
{
    root[i] = root[i - 1];       //第i棵主席树，是依照第i-1棵构建的
    int pos = binSearch(a[i], q);
    update(pos, root[i], 1, q);  //与第i-1棵的差别是，第pos位置置1
}</code></pre><p>主席树的构建函数——update</p>
<pre><code>void update(int pos, int &amp;root, int L, int R)
{
    cnt ++;
    node[cnt] = node[root];   //node[cnt]先完全依照node[root]构建
    root = cnt;
    node[cnt].sum ++;         //对sum进行修改

    if(L == R)
        return;

    int mid = md(L, R);
    if(pos &lt;= mid)           //说明左子区间部分与第i-1主席树不同，要改
        update(pos, node[root].L, L, mid);
    else
        update(pos, node[root].R, mid + 1, R);
}</code></pre><p>接下来是查询部分，查询第 i - 1棵和第 j 棵主席树，就可以知道[i, j]这个区间的信息了。</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
    int pos = query(root[x - 1], root[y], k, 1, q);
    printf(&quot;%d\n&quot;, lisan[pos]);
}</code></pre><p>接下来是查询函数query</p>
<pre><code>int query(int i, int j, int k, int L, int R)
{
    if(L == R)
        return L;   //要继续深刻理解一下，因为每一棵主席树，是基于离散化数组的树
                    //返回的也是离散化后的下标

    int d = node[node[j].L].sum - node[node[i].L].sum;

    int mid = md(L, R);
    if(k &lt;= d)
        return query(node[i].L, node[j].L, k, L, mid);
    else
        return query(node[i].R, node[j].R, k - d, mid + 1, R);
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title>SPOJ Matrix Summation</title>
    <url>/tpaaaaaa.github.io/2019/09/11/SPOJMatrixSummation/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-11-12.59.57
 Question_Number   ：MATSUM - Matrix Summation
 Question_Name     ：树状数组
 Description       :
 二维树状数组，与以往不同的是
 直接将某个点的值set为某个值。
 所以要知道这个点之前是什么值，然后再去更改
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
int c[MAXN][MAXN];
int n;
int lowbit(int x)
{
    return x&amp;(-x);
}
void update(int x, int y, int v)
{
    for(int i = x; i &lt;= n; i += lowbit(i))
        for(int j = y; j &lt;= n; j += lowbit(j))
            c[i][j] += v;
}
int query(int x, int y)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            sum += c[i][j];
    return sum;
}
int main()
{
    char s[3];
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while(t--)
    {
        scanf(&quot;%d&quot;, &amp;n);
        memset(c, 0, sizeof c);
        while(1)
        {
            getchar();
            scanf(&quot;%s&quot;, s);
            if(s[0] == &apos;E&apos;)
                break;
            if(s[1] == &apos;E&apos;)
            {
                int x, y, num;
                scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;num);
                x ++;
                y ++;
                int temp = query(x, y) - query(x - 1, y) - query(x, y - 1) + query(x - 1, y - 1);
                int add = num - temp;
                update(x, y, add);
            }
            else if(s[1] == &apos;U&apos;)
            {
                int x1, y1, x2, y2;
                scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);
                x1 ++; y1 ++; x2 ++; y2 ++;
                int  ans = query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
                printf(&quot;%d\n&quot;, ans);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 1195 Mobile phones</title>
    <url>/tpaaaaaa.github.io/2019/09/11/POJ1195Mobilephones/</url>
    <content><![CDATA[<p>Mobile phones</p>
<p><strong>Time Limit:</strong> 5000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 24007</p>
<p><strong>Accepted:</strong> 11040</p>
<p>DescriptionSuppose that the fourth generation mobile phone base stations in the Tampere area operate as follows. The area is divided into squares. The squares form an S * S matrix with the rows and columns numbered from 0 to S-1. Each square contains a base station. The number of active mobile phones inside a square can change because a phone is moved from a square to another or a phone is switched on or off. At times, each base station reports the change in the number of active phones to the main base station along with the row and the column of the matrix. </p>
<p>Write a program, which receives these reports and answers queries about the current total number of active mobile phones in any rectangle-shaped area.   </p>
<p>InputThe input is read from standard input as integers and the answers to the queries are written to standard output as integers. The input is encoded as follows. Each input comes on a separate line, and consists of one instruction integer and a number of parameter integers according to the following table.   </p>
<p><img src="http://poj.org/images/1195_1.jpg" alt=""></p>
<p>The values will always be in range, so there is no need to check them. In particular, if A is negative, it can be assumed that it will not reduce the square value below zero. The indexing starts at 0, e.g. for a table of size 4 * 4, we have 0 &lt;= X &lt;= 3 and 0 &lt;= Y &lt;= 3. </p>
<p>Table size: 1 * 1 &lt;= S * S &lt;= 1024 * 1024<br>Cell value V at any time: 0 &lt;= V &lt;= 32767<br>Update amount: -32768 &lt;= A &lt;= 32767<br>No of instructions in input: 3 &lt;= U &lt;= 60002<br>Maximum number of phones in the whole table: M= 2^30   </p>
<p>OutputYour program should not answer anything to lines with an instruction other than 2. If the instruction is 2, then your program is expected to answer the query by writing the answer as a single line containing a single integer to standard output.</p>
<p>Sample Input</p>
<p>0 4<br>1 1 2 3<br>2 0 0 2 2<br>1 1 1 2<br>1 1 2 -1<br>2 1 1 2 3<br>3</p>
<p>Sample Output</p>
<p>3<br>4</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>二维树状数组。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
const int MAX = 1024 + 10;
int c[MAXN][MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
void update(int x, int y, int v)
{
    for(int i = x; i &lt; MAXN; i += lowbit(i))
        for(int j = y; j &lt; MAXN; j += lowbit(j))
            c[i][j] += v;
}
int query(int x, int y)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            sum += c[i][j];
    return sum;
}

int main()
{
    int com, n;
    scanf(&quot;%d%d&quot;, &amp;com, &amp;n);
    memset(c, 0, sizeof c);
    while(scanf(&quot;%d&quot;, &amp;com) &amp;&amp; com &lt; 3)
    {
        if(com == 1)
        {
            int x, y, a;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;a);
            x ++;
            y ++;
            update(x, y, a);
        }
        else if(com == 2)
        {
            int l, b, r, t;
            scanf(&quot;%d%d%d%d&quot;, &amp;l, &amp;b, &amp;r, &amp;t);
            l++; b++; r++; t++;
            ll ans = query(r, t) - query(l - 1, t) - query(r, b - 1) + query(l - 1, b - 1);
            printf(&quot;%lld\n&quot;, ans);
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2352 Stars</title>
    <url>/tpaaaaaa.github.io/2019/09/11/POJ2352Stars/</url>
    <content><![CDATA[<p>Stars</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 59723</p>
<p><strong>Accepted:</strong> 25480</p>
<p>DescriptionAstronomers often examine star maps where stars are represented by points on a plane and each star has Cartesian coordinates. Let the level of a star be an amount of the stars that are not higher and not to the right of the given star. Astronomers want to know the distribution of the levels of the stars.   </p>
<p><img src="http://poj.org/images/2352_1.jpg" alt=""></p>
<p>For example, look at the map shown on the figure above. Level of the star number 5 is equal to 3 (it’s formed by three stars with a numbers 1, 2 and 4). And the levels of the stars numbered by 2 and 4 are 1. At this map there are only one star of the level 0, two stars of the level 1, one star of the level 2, and one star of the level 3. </p>
<p>You are to write a program that will count the amounts of the stars of each level on a given map.</p>
<p>InputThe first line of the input file contains a number of stars N (1&lt;=N&lt;=15000). The following N lines describe coordinates of stars (two integers X and Y per line separated by a space, 0&lt;=X,Y&lt;=32000). There can be only one star at one point of the plane. Stars are listed in ascending order of Y coordinate. Stars with equal Y coordinates are listed in ascending order of X coordinate.   </p>
<p>OutputThe output should contain N lines, one number per line. The first line contains amount of stars of the level 0, the second does amount of stars of the level 1 and so on, the last line contains amount of stars of the level N-1.</p>
<p>Sample Input</p>
<p>5<br>1 1<br>5 1<br>7 1<br>3 3<br>5 5</p>
<p>Sample Output</p>
<p>1<br>2<br>1<br>1<br>0</p>
<p>HintThis problem has huge input data,use scanf() instead of cin to read data to avoid time limit exceed.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>将所给的[x, y]按照y从小到大，y相同，则x从小到大<br>对于每一个区间[a, b]，排在他前面的点，一定在他下面<br>那么它的level值，就是他的b的sum(b);</p>
<p>ans += sum(b + 1);<br>update(b, 1);</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-11-11.32.59
 Question_Number   ：poj 2352
 Question_Name     ：树状数组
 Description       :
 将所给的[x, y]按照y从小到大，y相同，则x从小到大
 对于每一个区间[a, b]，排在他前面的点，一定在他下面
 那么它的level值，就是他的b的sum(b);

 ans += sum(b + 1);
 update(b, 1);
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 15000 + 10;
const int MAXM = 32000 + 10;
int n;
int ans[MAXN];
int c[MAXM];
int lowbit(int x)
{
    return x&amp;(-x);
}
int query(int x)
{
    int sum = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        sum += c[i];
    return sum;
}
void update(int x, int v)
{
    for(int i = x; i &lt; MAXM; i += lowbit(i))
        c[i] += v;
}
struct Node
{
    int x, y;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.y == b.y)
            return a.x &lt; b.x;
        else
            return a.y &lt; b.y;
    }
};
Node node[MAXN];
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y);
            node[i].x ++;
            node[i].y ++;
            node[i].i = i;
        }
        sort(node + 1, node + 1 + n);
        memset(c, 0, sizeof c);
        memset(ans, 0, sizeof ans);
        for(int i = 1; i &lt;= n; i++)
        {
            ans[query(node[i].x)] ++;
            update(node[i].x, 1);
        }
        for(int i = 0; i &lt; n; i++)
            printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 3067 Japan</title>
    <url>/tpaaaaaa.github.io/2019/09/11/POJ3067Japan/</url>
    <content><![CDATA[<p>Japan</p>
<p><strong>Time Limit:</strong> 1000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 35873</p>
<p><strong>Accepted:</strong> 9601</p>
<p>DescriptionJapan plans to welcome the ACM ICPC World Finals and a lot of roads must be built for the venue. Japan is tall island with N cities on the East coast and M cities on the West coast (M &lt;= 1000, N &lt;= 1000). K superhighways will be build. Cities on each coast are numbered 1, 2, … from North to South. Each superhighway is straight line and connects city on the East coast with city of the West coast. The funding for the construction is guaranteed by ACM. A major portion of the sum is determined by the number of crossings between superhighways. At most two superhighways cross at one location. Write a program that calculates the number of the crossings between superhighways.</p>
<p>InputThe input file starts with T - the number of test cases. Each test case starts with three numbers – N, M, K. Each of the next K lines contains two numbers – the numbers of cities connected by the superhighway. The first one is the number of the city on the East coast and second one is the number of the city of the West coast.</p>
<p>OutputFor each test case write one line on the standard output:<br>Test case (case number): (number of crossings)</p>
<p>Sample Input</p>
<p>1<br>3 4 4<br>1 4<br>2 3<br>3 2<br>3 1</p>
<p>Sample Output</p>
<p>Test case 1: 5</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先将题目的交叉转化为数学意思<br>[A, B], [C, D] 对于这俩个区间，如果存在交叉<br>就意味着(A - C) * (B - D) &lt; 0 那么我们按照所给区间的左端点从小到大排序 如果左端点相同，那么右端点从小到达排序 对于任意个区间[A, B]，排在他前面的区间[C, D] 肯定有A &gt;= C, 对于A &gt; C的情况，我们可以根据<br>D的位置来确定[A, B]和[C, D]是否存在交点。<br>若B &lt; D,则二者存在交点。</p>
<p>所以我们维护一棵树状数组，叶子节点1 … M<br>叶子节点状态 = 0表示这个点还没有出现<br>= 1 表示这个点已经出现了</p>
<p>那么我们按照排序的顺序，依次取出区间[A, B]<br>然后利用树状数组求出sum(m) - sum(B)<br>然而将B这个叶子结点+1.<br>妙哉妙哉</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXM = MAXN * MAXN;
int c[MAXN];
int n, m, k;
struct Node
{
    int L, R;
    int i;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.L == b.L)
            return a.R &lt; b.R;
        else
            return a.L &lt; b.L;
    }
};
Node node[MAXM];
int lowbit(int x)
{
    return x&amp;(-x);
}
int query(int x)
{
    int ans = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        ans += c[i];
    return ans;
}
void update(int x, int v)
{
    for(int i = x; i &lt;= m; i += lowbit(i))
        c[i] += v;
}
int main()
{
    int t, kase = 0;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);
        for(int i = 1; i &lt;= k; i++)
            scanf(&quot;%d%d&quot;, &amp;node[i].L, &amp;node[i].R);
        ll ans = 0;
        sort(node + 1, node + 1 + k);
        memset(c, 0, sizeof c);
        for(int i = 1; i &lt;= k; i++)
        {
            ans += query(m) - query(node[i].R);
            update(node[i].R, 1);
        }
        printf(&quot;Test case %d: %lld\n&quot;, ++kase , ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]主席树</title>
    <url>/tpaaaaaa.github.io/2019/09/11/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
    <content><![CDATA[<p>主席树的视频讲解：</p>
<h2 id="代码分析："><a href="#代码分析：" class="headerlink" title="代码分析："></a>代码分析：</h2><p>主席树的Node节点（注意L，R与平常的线段树中的定义不同哦！！！）：</p>
<pre><code>struct Node
{
    int L, R, sum;
    //这个L和R存的不是区间范围
    //然而左孩子和右孩子的数组下标
    //sum为这个节点所维护区间中的数字数目。
};</code></pre><p>主席树的建立：</p>
<pre><code>        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;a[i]);
            lisan[i] = a[i];
        }
        sort(lisan + 1, lisan + 1 + n);
        int q = unique(lisan + 1, lisan + 1 + n) - (lisan + 1);
//对输入的数组a[]进行离散化操作。
//主席树初始化
        cnt = 0;    
        root[0] = 0;
        node[0].L = node[0].R = node[0].sum = 0;
//开始枚举n个点，依次建立n个树。
        for(int i = 1; i &lt;= n; i++)
        {
            root[i] = root[i - 1];
            int pos = binSearch(a[i], q);
            update(pos, root[i], 1, n);
        }</code></pre><p>各个变量的解释</p>
<pre><code>int a[MAXN], lisan[MAXN], root[MAXN];
//a是输入进来的数组，lisan是离散化后的数组，root[i]存的是第i个带权线段树的树根的下标</code></pre><p>第 i 个带权线段树保存的信息是，a[1] … a[ i ]这 i 个数的带权线段树。</p>
<p>主席树的更新——update函数</p>
<pre><code>//作用是相较于以rt为根的原主席树，添加一个位置为pos的数，产生一个新的主席树
void update(int pos, int &amp;rt, int l, int r)
{
    node[++cnt] = node[rt];
    //完全复制成前一个权值线段树。
    //也就是添加pos这个位置的数之前的状态
    rt = cnt;       //更改成根节点编号
    node[cnt].sum ++;
    //因为相较于前一个权值线段树，我这个
    //里面多了一个a[i]，也就是说数的数目多了1
    if(l == r)
        return;
    int mid = md(l, r);
    //如果pos在左边，那么意味着右边的权值线段树
    //可以不改，只需要改左边的，那么右边则保留原来
    //前一个线段树的编号，而利用递归去更改左边的
    if(pos &lt;= mid)
        update(pos, node[rt].L, l, mid);
    else
        update(pos, node[rt].R, mid + 1, r);
}</code></pre><p>对于每个区间的查询的部分是：</p>
<pre><code>        for(int i = 1; i &lt;= m; i++)
        {
            int x, y, k;
            scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;k);
            int pos = query(root[x - 1], root[y], k, 1, n);
            printf(&quot;%d\n&quot;, lisan[pos]);
        }

//作用是求[i + 1,j]中第k大的数
int query(int i, int j, int k, int l, int r)
{
    int d = node[node[j].L].sum - node[node[i].L].sum;
    //这计算的是在[i,j]这个区间里面
    // 左半部分变化的值。也就是
    if(l == r)
        return l;
    int mid = md(l, r);
    if(k &lt;= d)          //说明左半部分的数目大于k th
        return query(node[i].L, node[j].L, k, l, mid);
    else
        return query(node[i].R, node[j].R, k - d , mid + 1, r);//我这里犯傻了
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]线段树的应用——扫描线法</title>
    <url>/tpaaaaaa.github.io/2019/09/10/%5B%E7%AE%97%E6%B3%95%5D%E7%BA%BF%E6%AE%B5%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E6%89%AB%E6%8F%8F%E7%BA%BF%E6%B3%95/</url>
    <content><![CDATA[<p>博文地址：<a href="https://blog.csdn.net/xianpingping/article/details/83032798" target="_blank" rel="noopener">https://blog.csdn.net/xianpingping/article/details/83032798</a></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意:"></a>题意:</h2><p>二维平面有n个平行于坐标轴的矩形,现在要求出这些矩形的总面积. 重叠部分只能算一次.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h2><p>线段树的典型扫描线用法.</p>
<pre><code>首先假设有下图两个矩阵,我们如果用扫描线的方法如何计算它们的总面积呢?</code></pre><p><img src="https://img-blog.csdn.net/20140330014222578?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>首先我们将矩形的<strong>上下边分为上位边(即y坐标大的那条平行于x轴的边),和下位边(y坐标小的平行于x轴的边).放入结构体数组seg[]中，</strong>然后我们将他们按照y坐标从小到大排序,可以得到4条扫描线:</p>
<p><img src="https://img-blog.csdn.net/20140330014311968?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>又因为上面2个矩形有4个不同的浮点数x坐标,但通常x的取值范围很大，但图中x坐标的数目并没有那么多，所以我们需要把x坐标离散化, 同时这样才能用线段树来维护信息.所以我们这样离散化:</p>
<p><img src="https://img-blog.csdn.net/20140330014323453?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzQ4MDYwMA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>由上图可知,4个不同的x坐标把x轴分成了<strong>3段有效的区间.这里要注意我们线段树中每个叶节点(控制区间[L,L])不是指X[L]坐标,而是指区间[X[L],X[L+1]]. 也就是说，线段树的叶子不是原图中的节点，而是原图中最小的一段区间而已。</strong>线段树中其他节点控制的区间[L,R],也是指的第L个区间到第R个区间。例如[1, 2]在图中表示的区间是[x1, x2]（这是1） + [x2, x3] (这是2) = [x1, x3];</p>
<p><strong>所以[L, R]控制的范围实际上是[Xr, Xl + 1];</strong></p>
<p>然后我们Y坐标从小到大的顺序读入每条扫描线,并维护当前我们所读入的所有扫描线能有效覆盖X轴的最大长度node[1].len .这里特别要注意如果我们读入的扫描线是矩形的下位边,那么我们就使得该范围的标记lazy位+1,如果是上位边,那么该范围的cnt就-1.所以如果cnt=0时,表示该节点控制的范围没有被覆盖,只要cnt!=0 就表示该节点控制的几块区间仍然被覆盖.</p>
<p>tips: 可以将线段树的node节点中增加len2,len3。。。之前的len表示的是被覆盖的长度，那么len2表示的就是被覆盖两次的长度, len3表示覆盖3次….</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>树的节点Node结构体和线段Seg结构体部分</p>
<pre><code>struct Node
{
    int L, R;             //保存的是这个节点维护的区间端点
    int lazy;             //这个区间的lazy标记，lazy == 0表示没有被覆盖
    double len;           //这个区间里面被覆盖的长度
};
Node node[8 * MAXN];
struct Seg
{
    double x1, x2;      //这条线段的左右端点的x坐标
    double y;           //这条线段的高
    int flag;           // = 1 表示这条线段是矩形的下底，= -1表示上底
    friend bool operator &lt; (Seg a, Seg b)
    {
        return a.y &lt; b.y;
    }
};</code></pre><p>线段树的建立——built</p>
<pre><code>void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    node[root].lazy = 0;
    node[root].len = 0;
    if(L != R)             //注意[L, R]表示的不是第L个x坐标到第R个x坐标间的区间
                           //而是第L个区间到第R个区间的和区间
    {
        int mid = (L + R) / 2;
        built(ls(root), L, mid);
        built(rs(root), mid + 1, R);
    }
}</code></pre><p>线段树的区间更新——update函数</p>
<pre><code>void update(int root, int L, int R, int flag)
{
    if(node[root].L == L &amp;&amp; node[root].R == R)
    {
        node[root].lazy += flag;             //目前的区间就是我们要处理的区间
        pushUp(root);
        return;
    }
//没有pushDown
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)
        update(ls(root), L, R, flag);
    else if(L &gt; mid)              
        update(rs(root), L, R, flag);
    else
    {
        update(ls(root), L, mid, flag);
        update(rs(root), mid + 1, R, flag); //我改了这里
    }
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)
{
    if(node[root].lazy &gt; 0)
        node[root].len = recX[node[root].R + 1] - recX[node[root].L];
    else if(node[root].L == node[root].R)
        node[root].len = 0; // lazy == 0并且没有后代了
    else
        node[root].len = node[ls(root)].len + node[rs(root)].len;
}</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;*</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Date              : 2019-09-09-16.47.52</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Question_Number   ：hdu 1255</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Question_Name     ：线段树，扫描线法</span></pre></td></tr><tr><td class="code"><pre><span class="line"> Description       :</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 离散化</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">*&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;functional&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;cstdio&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;cstring&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;algorithm&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;string&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;vector&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;stack&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;bitset&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;cstdlib&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;cmath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;set&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;list&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;deque&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;map&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define ls(x)  x &lt;&lt; 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define rs(x)  x &lt;&lt; 1 | 1</span></pre></td></tr><tr><td class="code"><pre><span class="line">#define md(x, y)  (x + y) &#x2F; 2</span></pre></td></tr><tr><td class="code"><pre><span class="line">using namespace std;</span></pre></td></tr><tr><td class="code"><pre><span class="line">typedef long long ll;</span></pre></td></tr><tr><td class="code"><pre><span class="line">const double PI &#x3D; acos(-1.0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">const double eps &#x3D; 1e-6;</span></pre></td></tr><tr><td class="code"><pre><span class="line">const int INF &#x3D; 0x3f3f3f3f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">const int MAXN &#x3D; 1000 + 10;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">double x[2 * MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct Node</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int L, R;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int lazy;           &#x2F;&#x2F;lazy</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int cover;          &#x2F;&#x2F;覆盖次数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Node node[8 * MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">struct Seg</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double x1, x2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int flag;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    friend bool operator &lt; (Seg a, Seg b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return a.y &lt; b.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Seg seg[2 * MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">void addSeg(double x1, double y1, double x2, double y2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt ++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].x1 &#x3D; x1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].x2 &#x3D; x2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].y &#x3D; y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].flag &#x3D; -1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x[cnt] &#x3D; x1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt ++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].x1 &#x3D; x1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].x2 &#x3D; x2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].y &#x3D; y1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    seg[cnt].flag &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x[cnt] &#x3D; x2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void built(int root, int L, int R)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node[root].L &#x3D; L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node[root].R &#x3D; R;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node[root].lazy &#x3D; 0;   &#x2F;&#x2F;-1表示减掉一次cover，1表示加上一次cover，0表示无操作</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node[root].len &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    node[root].cover &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(L !&#x3D; R)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int mid &#x3D; md(L, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        built(ls(root), L, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        built(rs(root), mid + 1, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void pushUp(int root)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(node[root].cover &gt; 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].len &#x3D; x[node[root].R + 1] - x[node[root].L];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else if(node[root].L &#x3D;&#x3D; node[root].R)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].len &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].len &#x3D; node[ls(root)].len + node[rs(root)].len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void pushDown(int root)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(node[root].lazy !&#x3D; 0)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[ls(root)].lazy +&#x3D; node[root].lazy;         &#x2F;&#x2F;我改了这里</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[rs(root)].lazy +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[ls(root)].cover +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[rs(root)].cover +&#x3D; node[root].lazy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].lazy &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">void update(int root, int L, int R, int flag)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(node[root].L &#x3D;&#x3D; L &amp;&amp; node[root].R &#x3D;&#x3D; R)      &#x2F;&#x2F;目前我们要覆盖的部分就是我们所处的</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].lazy +&#x3D; flag;                    &#x2F;&#x2F;同样的，[L, R]这个区间的覆盖次数+1, 他的子区间[L, mid] [mid +1, R]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        node[root].cover +&#x3D; flag;                    &#x2F;&#x2F;的覆盖次数同样要加1</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pushUp(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pushDown(root);                                  &#x2F;&#x2F;将flag传下去</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int mid &#x3D; md(node[root].L, node[root].R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(R &lt;&#x3D; mid)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        update(ls(root), L, R, flag);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else if(L &gt; mid)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        update(rs(root), L, R, flag);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    else</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        update(ls(root), L, mid, flag);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        update(rs(root), mid + 1, R, flag);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pushUp(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">double query(int root)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(node[root].cover &gt;&#x3D; 2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return node[root].len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if(node[root].L &#x3D;&#x3D; node[root].R)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return 0;               &#x2F;&#x2F;说明到叶子节点了，只有返回0了</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pushDown(root);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double ans1 &#x3D; query(ls(root));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    double ans2 &#x3D; query(rs(root));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return ans1 + ans2;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int binSearch(double k, int n)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int L &#x3D; 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int R &#x3D; n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while(L &lt;&#x3D; R)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int mid &#x3D; md(L, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if(x[mid] &#x3D;&#x3D; k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return mid;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if(x[mid] &gt; k)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            R &#x3D; mid - 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else</span></pre></td></tr><tr><td class="code"><pre><span class="line">            L &#x3D; mid + 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return -1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int main()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int t, n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cin &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while(t--)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt;&#x3D; n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            double x1, x2, y1, y2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            scanf(&quot;%lf%lf%lf%lf&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F;题目描述有误，是左下角和右上角</span></pre></td></tr><tr><td class="code"><pre><span class="line">            addSeg(x1, y1, x2, y2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(x + 1, x + 1 + cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;将x排序，然后去重</span></pre></td></tr><tr><td class="code"><pre><span class="line">        int m &#x3D; unique(x + 1, x + 1 + cnt) - (x + 1);   &#x2F;&#x2F;m为离散化后的x坐标的数目</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F;也就是说，线段树的叶子结点数目为m - 1   因为m个x坐标，将x轴变成了m-1个区间</span></pre></td></tr><tr><td class="code"><pre><span class="line">        built(1, 1, m - 1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(seg + 1, seg + 1 + cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        double ans &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        for(int i &#x3D; 1; i &lt; cnt; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            double h &#x3D; seg[i + 1].y - seg[i].y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int L &#x3D; binSearch(seg[i].x1, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            int R &#x3D; binSearch(seg[i].x2, m) - 1;&#x2F;&#x2F;这个区间[L, R] 实际上就能表示[x1, x2]了</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            update(1, L, R, seg[i].flag);       &#x2F;&#x2F;将[L, R] +flag</span></pre></td></tr><tr><td class="code"><pre><span class="line">            double len &#x3D; query(1);              &#x2F;&#x2F;查询里面cover次数大于2的部分</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F;找到len</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#x2F;&#x2F; len &#x3D; 线段树中被覆盖次数大于1次的部分</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#x2F;&#x2F;  printf(&quot;L &#x3D; %d, R &#x3D; %d, h &#x3D; %.2f, len &#x3D; %.2f \n&quot;, L, R + 1, h, len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans +&#x3D; h * len;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        printf(&quot;%.2f\n&quot;, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 4553 约会安排</title>
    <url>/tpaaaaaa.github.io/2019/09/10/HDU4553%E7%BA%A6%E4%BC%9A%E5%AE%89%E6%8E%92/</url>
    <content><![CDATA[<h1 id="约会安排"><a href="#约会安排" class="headerlink" title="约会安排"></a>约会安排</h1><p>*<em>Time Limit: 2000/1000 MS (Java/Others)    Memory Limit: 65535/32768 K (Java/Others)<br>Total Submission(s): 4544    Accepted Submission(s): 1300<br>*</em></p>
<p>Problem Description　　寒假来了，又到了小明和女神们约会的季节。<br>　　小明虽为屌丝级码农，但非常活跃，女神们常常在小明网上的大段发言后热情回复“呵呵”，所以，小明的最爱就是和女神们约会。与此同时，也有很多基友找他开黑，由于数量实在过于巨大，怎么安排时间便成了小明的一大心事。<br>　　我们已知小明一共有T的空闲时间，期间会有很多女神或者基友来找小明。<br>　　作为一个操作系统曾经怒考71分的大神，小明想到了一个算法，即“首次适应算法”，根据操作系统课本的描述，就是找一段最靠前的符合要求的连续空间分配给每个请求，由此小明做出了一个决定：<br>　　当一个基友来找小明时，小明就根据“首次适应算法”来找一段空闲的时间来和基友约好，如果找到，就说“X,let’s fly”（此处，X为开始时间），否则就说“fly with yourself”；<br>　　当女神来找小明时，先使用一次“首次适应算法”，如果没有找到，小明就冒着木叽叽的风险无视所有屌丝基友的约定，再次使用“无视基友首次适应算法”，两次只要有一次找到，就说“X,don’t put my gezi”（此处，X为开始时间），否则就说“wait for me”<br>　　当然，我们知道小明不是一个节操负无穷的人，如果和女神约会完，还有剩余时间，他还是会和原来约好的基友去dota的。（举个例子：小西（屌丝）和小明约好在1<del>5这个时间单位段内打dota，这时候，女神来和小明预约长度为3的时间段，那么最终就是1</del>3小明去和女神约会，搞定后在4<del>5和小西打dota）<br>　　小明偶尔也会想要学习新知识，此时小明就会把某一个时间区间的所有已经预定的时间全部清空用来学习并且怒吼“I am the hope of chinese chengxuyuan!!”，不过小明一般都是三分钟热度，再有人来预定的话，小明就会按耐不住寂寞把学习新知识的时间分配出去。<br>Input输入第一行为CASE，表示有CASE组测试数据；<br>每组数据以两个整数T，N开始，T代表总共的时间，N表示预约请求的个数；<br>接着的N行，每行表示一个女神或者基友的预约，“NS QT”代表一个女神来找小明约一段长为QT的时间，“DS QT”则代表一个屌丝的长为QT的请求，当然也有可能是小明想学知识了，“STUDY!! L R”代表清空L</del>R区间内的所有请求。</p>
<p>[Technical Specification]<br>1. 1 &lt;= CASE &lt;= 30<br>2. 1 &lt;= T, N &lt;= 100000<br>3. 1 &lt;= QT &lt;= 110000<br>4. 1 &lt;= L &lt;= R &lt;=T<br>Output对于每一个case，第一行先输出“Case C:”代表是第几个case，然后N行，每行对应一个请求的结果(参照描述)。<br>输出样本(可复制此处)：<br>“X,let’s fly”,”fly with yourself”,”X,don’t put my gezi”,”wait for me”,”I am the hope of chinese chengxuyuan!!”  </p>
<p>Sample Input</p>
<p>1<br>5 6<br>DS 3<br>NS 2<br>NS 4<br>STUDY!! 1 5<br>DS 4<br>NS 2</p>
<p>Sample Output</p>
<p>Case 1:<br>1,let’s fly<br>4,don’t put my gezi<br>wait for me<br>I am the hope of chinese chengxuyuan!!<br>1,let’s fly<br>1,don’t put my gezi</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树，不过较普通的线段树而言，这个线段树维护区间里面多了一项就是女神占用的时间信息。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
struct Node
{
    int L, R;
    int Lsum[2], Rsum[2], sum[2];
    int lazy[2];
};
Node node[MAXN * 4];
void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    node[root].Lsum[0] = node[root].Rsum[0] = node[root].sum[0] = R - L + 1;    //总安排
    node[root].Lsum[1] = node[root].Rsum[1] = node[root].sum[1] = R - L + 1;    //给ns的安排
    node[root].lazy[0] = node[root].lazy[1] = -1;                               // -1 表示没有标记
    if(L != R)
    {
        int mid = (node[root].L + node[root].R) / 2;
        built(2 * root, L, mid);
        built(2 * root + 1, mid + 1, R);
    }
}
void pushUp(int root, int com)
{
    node[root].Lsum[com] = node[2 * root].Lsum[com];
    if(node[2 * root].Lsum[com] == node[2 * root].R - node[2 * root].L + 1)
        node[root].Lsum[com] += node[2 * root + 1].Lsum[com];

    node[root].Rsum[com] = node[2 * root + 1].Rsum[com];
    if(node[2 * root + 1].Rsum[com] == node[2 * root + 1].R - node[2 * root + 1].L + 1) //我眼睛瞎了
        node[root].Rsum[com] += node[2 * root].Rsum[com];

    node[root].sum[com] = max(max(node[2 * root].sum[com], node[2 * root + 1].sum[com]), node[2 * root].Rsum[com] + node[2 * root + 1].Lsum[com]);
}
void pushDown(int root, int com)
{
    if(node[root].lazy[com] != -1)
    {
        int v = node[root].lazy[com];
        node[root].lazy[com] = -1;

        node[2 * root].lazy[com] = node[2 * root + 1].lazy[com] = v;
        if(v == 0)
        {
            node[2 * root].Lsum[com] = node[2 * root].Rsum[com] = node[2 * root].sum[com] = 0;
            node[2 * root + 1].Lsum[com] = node[2 * root + 1].Rsum[com] = node[2 * root + 1].sum[com] = 0;
        }
        else
        {
            node[2 * root].Lsum[com] = node[2 * root].Rsum[com] = node[2 * root].sum[com] = node[2 * root].R - node[2 * root].L + 1;
            node[2 * root + 1].Lsum[com] = node[2 * root + 1].Rsum[com] = node[2 * root + 1].sum[com] = node[2 * root + 1].R - node[2 * root + 1].L + 1;
        }

    }
}

void update(int root, int L, int R, int v, int com) // 将L R置为0 or 1
{
    if(node[root].L == L &amp;&amp; node[root].R == R)
    {
        node[root].lazy[com] = v;                   //1表示置为1，1表示空闲，0表示不空闲
        if(v == 0)
            node[root].Lsum[com] = node[root].Rsum[com] = node[root].sum[com] = 0;
        else if(v == 1)
            node[root].Lsum[com] = node[root].Rsum[com] = node[root].sum[com] = R - L + 1;
        return;
    }
    pushDown(root, com);
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)
        update(2 * root, L, R, v, com);
    else if(L &gt; mid)
        update(2 * root + 1, L, R, v, com);
    else
    {
        update(2 * root, L, mid, v, com);
        update(2 * root + 1, mid + 1, R, v, com);
    }
    pushUp(root, com);
}
int query(int root, int G, int com)
{
    if(node[root].sum[com] &lt; G)
        return 0;
    if(node[root].Lsum[com] &gt;= G)
        return node[root].L;

    pushDown(root, com);

    int mid = (node[root].L + node[root].R) / 2;
    if(node[2 * root].sum[com] &gt;= G)
        return query(2 * root, G, com);
    else if(node[2 * root].Rsum[com] + node[2 * root + 1].Lsum[com] &gt;= G)
        return mid - node[2 * root].Rsum[com] + 1;
    else
        return query(2 * root + 1, G, com);
}
int main()
{
    int kase = 0, cas, n, q;
    string s;
    cin &gt;&gt; cas;
    while(cas--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;q);
        printf(&quot;Case %d:\n&quot;, ++ kase);
        built(1, 1, n);
        while(q--)
        {
            cin &gt;&gt; s;
            if(s == &quot;DS&quot;)
            {
                int g;
                scanf(&quot;%d&quot;, &amp;g);           //要找一个G时长的
                int ans = query(1, g, 0);   //0的是总安排
                if(ans == 0)
                    printf(&quot;fly with yourself\n&quot;);
                else
                {
                    printf(&quot;%d,let&apos;s fly\n&quot;, ans);
                    update(1, ans, ans + g - 1, 0, 0);
                }
            }
            else if(s == &quot;NS&quot;)
            {
                int g;
                scanf(&quot;%d&quot;, &amp;g);
                int ans = query(1, g, 0);   //0表示的是所有的时间，1表示的是属于ns的时间
                if(ans == 0)
                {
                    ans = query(1, g, 1);
                    if(ans == 0)
                    {
                        printf(&quot;wait for me\n&quot;);
                        continue;
                    }
                    else
                    {
                        printf(&quot;%d,don&apos;t put my gezi\n&quot;, ans);
                        update(1, ans, ans + g - 1, 0, 0);
                        update(1, ans, ans + g - 1, 0, 1);
                    }
                }
                else
                {
                    printf(&quot;%d,don&apos;t put my gezi\n&quot;, ans);
                    update(1, ans, ans + g - 1, 0, 0);
                    update(1, ans, ans + g - 1, 0, 1);
                }

            }
            else if(s == &quot;STUDY!!&quot;) //清空一个区间...
            {
                int x, y;
                scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
                printf(&quot;I am the hope of chinese chengxuyuan!!\n&quot;);
                update(1, x, y, 1, 0);
                update(1, x, y, 1, 1);
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 2642 Stars</title>
    <url>/tpaaaaaa.github.io/2019/09/10/HDU2642Stars/</url>
    <content><![CDATA[<h1 id="Stars"><a href="#Stars" class="headerlink" title="Stars"></a>Stars</h1><p>*<em>Time Limit: 5000/2000 MS (Java/Others)    Memory Limit: 32768/65536 K (Java/Others)<br>Total Submission(s): 2894    Accepted Submission(s): 1182<br>*</em></p>
<p>Problem DescriptionYifenfei is a romantic guy and he likes to count the stars in the sky.<br>To make the problem easier,we considerate the sky is a two-dimension plane.Sometimes the star will be bright and sometimes the star will be dim.At first,there is no bright star in the sky,then some information will be given as “B x y” where ‘B’ represent bright and x represent the X coordinate and y represent the Y coordinate means the star at (x,y) is bright,And the ‘D’ in “D x y” mean the star at(x,y) is dim.When get a query as “Q X1 X2 Y1 Y2”,you should tell Yifenfei how many bright stars there are in the region correspond X1,X2,Y1,Y2.</p>
<p>There is only one case.<br>InputThe first line contain a M(M &lt;= 100000), then M line followed.<br>each line start with a operational character.<br>if the character is B or D,then two integer X,Y (0 &lt;=X,Y&lt;= 1000)followed.<br>if the character is Q then four integer X1,X2,Y1,Y2(0 &lt;=X1,X2,Y1,Y2&lt;= 1000) followed.  </p>
<p>OutputFor each query,output the number of bright stars in one line.  </p>
<p>Sample Input</p>
<p>5<br>B 581 145<br>B 581 145<br>Q 0 600 0 200<br>D 581 145<br>Q 0 600 0 200</p>
<p>Sample Output</p>
<p>1<br>0</p>
<p>Author teddy</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>  二维树状数组。好的博文：<a href="https://www.cnblogs.com/RabbitHu/p/BIT.html" target="_blank" rel="noopener">https://www.cnblogs.com/RabbitHu/p/BIT.html</a></p>
<p>如何理解二维树状数组：</p>
<p>在一维树状数组中，tree[x]（树状数组中的那个“数组”）记录的是右端点为x、长度为lowbit(x)的区间的区间和。<br>那么在二维树状数组中，可以类似地定义tree[x][y]记录的是右下角为(x, y)，高为lowbit(x), 宽为 lowbit(y)的区间的区间和。</p>
<p>tree[x]维护的是区间，不过这个区间的长度，端点是与生俱来的（长度为lowbit(x)，右端点为x）</p>
<p>同样的tree[x][y]维护的是一个二维区间，并且这个区间的范围也是与生俱来的。</p>
<p>并且要相信，只要以 x -= x&amp;(-x) 这个操作下去，一定能遍历完x的全部子节点。</p>
<p>只要以 x += x &amp;(-x) 这个操作下去，一定能完整的遍历完x的全部祖先。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-10-15.37.11
 Question_Number   ：hdu 2642
 Question_Name     ：二维树状数组
 Description       :
 二维 就是矩阵
 一维的树状数组c[i] 存的是一些 一条直线上的点
 二维的树状数组c[i][j]
 要明白的一个事情是，父节点包括的点比子节点多。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
int c[MAXN][MAXN];  //我这里开大了
bool sta[MAXN][MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
void update(int x, int y, int d)
{
    for(int i = x; i &lt;= 1001; i += lowbit(i))
        for(int j = y; j &lt;= 1001; j += lowbit(j))
               c[i][j] += d;
}
int query(int x, int y)
{
    int ans = 0;
    for(int i = x; i &gt; 0; i -= lowbit(i))
        for(int j = y; j &gt; 0; j -= lowbit(j))
            ans += c[i][j];
    return ans;
}
int main()
{
    int q, kase = 0;
    string s;
    cin &gt;&gt; q;
    memset(c, 0, sizeof c);
    memset(sta, false, sizeof sta); //我是傻子？
    while(q--)
    {
        cin &gt;&gt; s;

        if(s == &quot;Q&quot;)    //这是查询
        {
            int x1, x2, y1, y2;
            scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;x2, &amp;y1, &amp;y2);
            x1 ++; x2 ++; y1 ++; y2 ++;
            if(x1 &gt; x2)
                swap(x1, x2);
            if(y1 &gt; y2)
                swap(y1, y2);
            int ans = query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
            printf(&quot;%d\n&quot;, ans);
        }
        else
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            if(s == &quot;B&quot;)
            {
                if(sta[x][y])   //已经亮了
                    continue;
                update(x, y, 1);
                sta[x][y] = 1;
            }
            else
            {
                if(sta[x][y] == false)
                    continue;
                update(x, y, -1);
                sta[x][y] = false;
            }
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二维树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU 5091 光束加农炮</title>
    <url>/tpaaaaaa.github.io/2019/09/10/HDU5091%E5%85%89%E6%9D%9F%E5%8A%A0%E5%86%9C%E7%82%AE/</url>
    <content><![CDATA[<h1 id="Beam-Cannon"><a href="#Beam-Cannon" class="headerlink" title="Beam Cannon"></a>Beam Cannon</h1><p>*<em>Time Limit: 3000/1500 MS (Java/Others)    Memory Limit: 65536/65536 K (Java/Others)<br>Total Submission(s): 1614    Accepted Submission(s): 601<br>*</em></p>
<p>Problem DescriptionRecently, the γ galaxies broke out Star Wars. Each planet is warring for resources. In the Star Wars, Planet X is under attack by other planets. Now, a large wave of enemy spaceships is approaching. There is a very large Beam Cannon on the Planet X, and it is very powerful, which can destroy all the spaceships in its attack range in a second. However, it takes a long time to fill the energy of the Beam Cannon after each shot. So, you should make sure each shot can destroy the enemy spaceships as many as possible.</p>
<p>To simplify the problem, the Beam Cannon can shot at any area in the space, and the attack area is rectangular. The rectangle parallels to the coordinate axes and cannot rotate. It can only move horizontally or vertically. The enemy spaceship in the space can be considered as a point projected to the attack plane. If the point is in the rectangular attack area of the Beam Cannon(including border), the spaceship will be destroyed.<br>InputInput contains multiple test cases. Each test case contains three integers N(1&lt;=N&lt;=10000, the number of enemy spaceships), W(1&lt;=W&lt;=40000, the width of the Beam Cannon’s attack area), H(1&lt;=H&lt;=40000, the height of the Beam Cannon’s attack area) in the first line, and then N lines follow. Each line contains two integers x,y (-20000&lt;=x,y&lt;=20000, the coordinates of an enemy spaceship). </p>
<p>A test case starting with a negative integer terminates the input and this test case should not to be processed.<br>OutputOutput the maximum number of enemy spaceships the Beam Cannon can destroy in a single shot for each case.<br>Sample Input</p>
<p>2 3 4<br>0 1<br>1 0<br>3 1 1<br>-1 0<br>0 1<br>1 0<br>-1</p>
<p>Sample Output</p>
<p>2<br>2</p>
<p>Source<a href="http://acm.hdu.edu.cn/search.php?field=problem&key=2014%C9%CF%BA%A3%C8%AB%B9%FA%D1%FB%C7%EB%C8%FC%A1%AA%A1%AA%CC%E2%C4%BF%D6%D8%CF%D6%A3%A8%B8%D0%D0%BB%C9%CF%BA%A3%B4%F3%D1%A7%CC%E1%B9%A9%CC%E2%C4%BF%A3%A9&source=1&searchmode=source" target="_blank" rel="noopener">2014上海全国邀请赛——题目重现（感谢上海大学提供题目）</a><br>Recommendhujie   |   We have carefully selected several similar problems for you:  <a href="http://acm.hdu.edu.cn/showproblem.php?pid=6730" target="_blank" rel="noopener">6730</a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6729" target="_blank" rel="noopener">6729</a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6728" target="_blank" rel="noopener">6728</a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6727" target="_blank" rel="noopener">6727</a><a href="http://acm.hdu.edu.cn/showproblem.php?pid=6726" target="_blank" rel="noopener">6726</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树的扫描线法。将点扩展为边</p>
<p>从左往右进行扫描<br>对于每个点，我们添加两个边<br>对于点(x, y)并赋flag值为1 我们得到另一个点(x + w, y) 并赋值为-1;<br>将所有的点按照x的顺序从小到大排列<br>然后从左开始往右扫描<br>扫描到一个点(x, y) 后用它来更新（y，y+h）这个线段flag<br>最后我们要找的答案就是整个区间里面<br>cover最多的值<br>cover维护的值不是这个区域整个被cover的次数，而是，最多被覆盖的次数，不单单是整个区间完全被覆盖</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)   x &lt;&lt; 1
#define rs(x)   x &lt;&lt; 1 | 1
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int cnt, w, h;
int lisan[4 * MAXN];
struct Poi
{
    int x, y;
    int flag;
    friend bool operator &lt; (Poi a, Poi b)
    {
        if(a.x &lt; b.x)
            return true;
        else if(a.x == b.x &amp;&amp; a.y &lt; b.y)
            return true;
        return false;
    }
};
Poi poi[4 * MAXN];
struct Node
{
    int L, R;
    int lazy;
    int cover;                  //指的是这个区间里面最多cover了多少次
};
Node node[16 * MAXN];
void addPoint(int x, int y)
{
    cnt ++;
    poi[cnt].x = x;
    poi[cnt].y = y;
    poi[cnt].flag = 1;
    lisan[cnt] = y;

    cnt ++;
    poi[cnt].x = x + w;
    poi[cnt].y = y;
    poi[cnt].flag = -1;
    lisan[cnt] = y + h;
}
void pushUp(int root)
{
    node[root].cover = max(node[ls(root)].cover, node[rs(root)].cover);
}   //？？？
void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    node[root].lazy = node[root].cover = 0;
    if(L != R)
    {
        int mid = md(L, R);
        built(ls(root), L, mid);
        built(rs(root), mid + 1, R);
        pushUp(root); // ??????????????????????
    }

}

void pushDown(int root)
{
    if(node[root].lazy)
    {
        node[ls(root)].lazy += node[root].lazy;
        node[rs(root)].lazy += node[root].lazy;
        node[ls(root)].cover += node[root].lazy;
        node[rs(root)].cover += node[root].lazy;
        node[root].lazy = 0;
    }
}
void update(int root, int L, int R, int flag)       //作用是将这个区间的里面的值都+flag
{
    if(node[root].L == L &amp;&amp; node[root].R == R)
    {
        node[root].lazy += flag;
        node[root].cover += flag;  //记录的是这个线段cover的次数,此时这个区间是要被改变的，所以不是由底层决定的。
        return;
    }
    pushDown(root);
    int mid = md(node[root].L, node[root].R);
    if(R &lt;= mid)
        update(ls(root), L, R, flag);
    else if(L &gt; mid)
        update(rs(root), L, R, flag);
    else
    {
        update(ls(root), L, mid, flag);
        update(rs(root), mid + 1, R, flag);
    }
    /*if(L &lt;= mid)
        update(ls(root), L, mid, flag);
    if(R &gt; mid)
        update(rs(root), mid + 1, R, flag);*/

    pushUp(root);               //此时的cover的次数不是由函数改变的，而是有底层向上决定的
}
int binSearch(int k, int n)
{
    int L = 1;
    int R = n;
    while(L &lt;= R)
    {
        int mid = md(L, R);
        if(lisan[mid] == k)
            return mid;
        if(lisan[mid] &gt; k)
            R = mid - 1;
        else
            L = mid + 1;
    }
}
int main()
{
    int n;
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n &gt;= 0)
    {
        scanf(&quot;%d%d&quot;, &amp;w, &amp;h);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x += 20001;
            y += 20001;
            addPoint(x, y);
        }
        //这是将y坐标离散化的结果，m为离散化后的数目
        sort(lisan + 1, lisan + 1 + cnt);
        int m = unique(lisan + 1, lisan + 1 + cnt) - (lisan + 1);
        sort(poi + 1, poi + 1 + cnt);
        built(1, 1, m); //这棵树的最小单位不是线段，而是单个的点！！！
        //枚举每一个点
        int ans = 0;
        for(int i = 1; i &lt;= cnt; i ++)
        {
            int L = binSearch(poi[i].y, m);
            int R = binSearch(poi[i].y + h, m);
            update(1, L, R, poi[i].flag);
            ans = max(ans, node[1].cover);
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树，扫描线法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ 2299 Ultra-QuickSort</title>
    <url>/tpaaaaaa.github.io/2019/09/10/POJ2299Ultra-QuickSort/</url>
    <content><![CDATA[<p><strong>Ultra-QuickSort</strong></p>
<p><strong>Time Limit:</strong> 7000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 79228</p>
<p><strong>Accepted:</strong> 29743</p>
<p>Description</p>
<p><img src="http://poj.org/images/2299_1.jpg" alt=""></p>
<p>In this problem, you have to analyze a particular sorting algorithm. The algorithm processes a sequence of n distinct integers by swapping two adjacent sequence elements until the sequence is sorted in ascending order. For the input sequence<br>9 1 0 5 4 ,<br>Ultra-QuickSort produces the output<br>0 1 4 5 9 .<br>Your task is to determine how many swap operations Ultra-QuickSort needs to perform in order to sort a given input sequence.</p>
<p>InputThe input contains several test cases. Every test case begins with a line that contains a single integer n &lt; 500,000 – the length of the input sequence. Each of the the following n lines contains a single integer 0 ≤ a[i] ≤ 999,999,999, the i-th input sequence element. Input is terminated by a sequence of length n = 0. This sequence must not be processed.</p>
<p>OutputFor every input sequence, your program prints a single line containing an integer number op, the minimum number of swap operations necessary to sort the given input sequence.</p>
<p>Sample Input</p>
<p>5<br>9<br>1<br>0<br>5<br>4<br>3<br>1<br>2<br>3<br>0</p>
<p>Sample Output</p>
<p>6<br>0</p>
<p>Source<a href="http://poj.org/searchproblem?field=source&key=Waterloo+local+2005.02.05" target="_blank" rel="noopener">Waterloo local 2005.02.05</a></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用树状数组求逆序数。</p>
<pre><code>/*
 Date              : 2019-09-10-16.59.56
 Question_Number   ：2
 Question_Name     ：树状数组解逆序对问题模板
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
int c[4 *  MAXN], b[MAXN], n;
int a[MAXN];
struct Node
{
    int val, order;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.val &lt; b.val;
    }
};
Node node[MAXN];
//x是排序后的坐标
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;
    while ( x &gt; 0 )
    {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}
//x是排序后的坐标，u是要改的值
void update(int x, int u)
{
    while(x &lt;= n)
    {
        c[x] += u;
        x += lowbit(x);
    }
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;node[i].val);
            a[i] = node[i].val;
            node[i].order = i;
        }

        sort(node + 1, node + 1 + n);
        for(int i = 1; i &lt;= n; i++)
            b[node[i].order] = i;

        ll ans = 0;
        memset(c, 0, sizeof c);
        for(int i = n; i &gt; 0; i --)
        {
            update(b[i], 1);
            ans += query(b[i]);
            ans --;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树状数组求逆序对</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]莫队算法</title>
    <url>/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>好的解释：<a href="https://www.zhihu.com/question/27316467?sort=created" target="_blank" rel="noopener">https://www.zhihu.com/question/27316467?sort=created</a></p>
<p>好的博文，关于分块的选择以及时间复杂度的计算：<a href="https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html" target="_blank" rel="noopener">https://www.cnblogs.com/ouuan/p/MoDuiTutorial.html</a></p>
<p>关于带修莫队好的分析与时间复杂度的计算：<a href="https://blog.csdn.net/chenxiaoran666/article/details/82220385" target="_blank" rel="noopener">https://blog.csdn.net/chenxiaoran666/article/details/82220385</a></p>
<h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>莫队是一种基于分块思想的离线算法，用于解决区间问题，适用范围如下：</p>
<ol>
<li>只有询问没有修改。</li>
<li>允许离线。</li>
<li>在已知询问 [l,r][l,r] 答案的情况下可以 O(1)O(1) 得到 [l,r−1],[l,r+1],[l−1,r],[l+1,r][l,r−1],[l,r+1],[l−1,r],[l+1,r] 的答案。</li>
</ol>
<p>满足以上三个条件就可以在 O(nm−−√+mlogm)O(nm+mlogm) 的时间复杂度下得到每个询问的解。</p>
<p>例题：</p>
<h2 id="DQUERY-D-query"><a href="#DQUERY-D-query" class="headerlink" title="DQUERY - D-query"></a>DQUERY - D-query</h2><p>Given a sequence of n numbers a1, a2, …, an and a number of d-queries. A d-query is a pair (i, j) (1 ≤ i ≤ j ≤ n). For each d-query (i, j), you have to return the number of distinct elements in the subsequence ai, ai+1, …, aj.</p>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><ul>
<li>Line 1: n (1 ≤ n ≤ 30000).</li>
<li>Line 2: n numbers a1, a2, …, an (1 ≤ ai ≤ 106).</li>
<li>Line 3: q (1 ≤ q ≤ 200000), the number of d-queries.</li>
<li>In the next q lines, each line contains 2 numbers i, j representing a d-query (1 ≤ i ≤ j ≤ n).</li>
</ul>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><ul>
<li>For each d-query (i, j), print the number of distinct elements in the subsequence ai, ai+1, …, aj in a single line.</li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input</strong><br>5<br>1 1 2 1 3<br>3<br>1 5<br>2 4<br>3 5</p>
<p><strong>Output</strong><br>3<br>2<br>3 </p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 3e4 + 10;
const int MAXM = 2e5 + 10;
const int MAXA = 1e6 + 10;
int block;
int a[MAXN], ans[MAXM];
int cnt[MAXA];
struct Ques
{
    int L, R;
    int i;
    friend bool operator &lt; (Ques a, Ques b)
    {
        if(a.L / block == b.L / block)
            return a.R &lt; b.R;
        else
            return a.L / block &lt; b.L / block;
    }
};
Ques ques[MAXM];
int main()
{
    int n, m;
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        block = sqrt(n);
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d&quot;, &amp;a[i]);
        scanf(&quot;%d&quot;, &amp;m);
//将询问保存。
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;ques[i].L, &amp;ques[i].R);
            ques[i].i = i;
        }
        sort(ques + 1, ques + 1 + m);
//将询问分块排序。
        memset(cnt, 0, sizeof cnt);
//[l, r]为所维护的区间
        int l = 1;
        int r = 0;
        int sum = 0;
        for(int i = 1; i &lt;= m; i++)
        {
            while(l &lt; ques[i].L)// l 往左走，原来l的位置次数的数的出现次数减1
            {
                int temp = a[l];//原来l位置上的数字
                cnt[temp]--;
                if(cnt[temp] == 0)          //减为0了，说明之前有，现在无了
                    sum --;
                l++;
            }
            while(l &gt; ques[i].L)
            {
                l--;
                //说明现在l位置上的数字要算进去了
                int temp = a[l];
                cnt[temp] ++;
                if(cnt[temp] == 1)
                    sum ++;
            }
            while(r &lt; ques[i].R)
            {
                r++;
                int temp = a[r];        //r之后的位置要算了
                cnt[temp] ++;
                if(cnt[temp] == 1)
                    sum ++;
            }
            while(r &gt; ques[i].R)
            {
                int temp = a[r];
                cnt[temp] --;
                if(cnt[temp] == 0)
                    sum --;
                r--;
            }
            ans[ques[i].i] = sum;
        }
        for(int i = 1; i &lt;= m; i++)
            printf(&quot;%d\n&quot;, ans[i]);
    }
    return 0;
}</code></pre><h2 id="待修莫队模板"><a href="#待修莫队模板" class="headerlink" title="待修莫队模板"></a>待修莫队模板</h2><pre><code>/*
题目描述
墨墨购买了一套N支彩色画笔（其中有些颜色可能相同），摆成一排，你需要回答墨墨的提问。墨墨会向你发布如下指令：

1、 Q L R代表询问你从第L支画笔到第R支画笔中共有几种不同颜色的画笔。

2、 R P Col 把第P支画笔替换为颜色Col。

为了满足墨墨的要求，你知道你需要干什么了吗？

输入输出格式
输入格式：

第1行两个整数N，M，分别代表初始画笔的数量以及墨墨会做的事情的个数。

第2行N个整数，分别代表初始画笔排中第i支画笔的颜色。

第3行到第2+M行，每行分别代表墨墨会做的一件事情，格式见题干部分。

输出格式：

对于每一个Query的询问，你需要在对应的行中给出一个数字，代表第L支画笔到第R支画笔中共有几种不同颜色的画笔。

输入输出样例
输入样例#1：

6 5
1 2 3 4 5 5
Q 1 4
Q 2 6
R 1 2
Q 1 4
Q 2 6

输出样例#1：

4
4
3
4
*/
#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;string&gt;
#include&lt;cstring&gt;
#include&lt;cmath&gt;
#include&lt;ctime&gt;
#include&lt;algorithm&gt;
#include&lt;utility&gt;
#include&lt;stack&gt;
#include&lt;queue&gt;
#include&lt;vector&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#define PI acos(-1.0)
#define E 1e-9
#define INF 0x3f3f3f3f
#define LL long long
const int MOD=10007;
const int N=1000000+5;
const int dx[]= {-1,1,0,0};
const int dy[]= {0,0,-1,1};
using namespace std;

struct Node{
    int l,r;//询问的左右端点
    int time;//时间维度
    int id;//询问的编号
}q[N];
struct Change{
    int pos;//要修改的位置
    int col;//要改成的值
}c[N];
int n,m,a[N];
int block;//分块
int numQ,numC;//查询、修改操作的次数
LL ans,cnt[N];
LL res[N];

bool cmp(Node a,Node b){//排序
    return (a.l/block)^(b.l/block) ? a.l&lt;b.l : ((a.r/block)^(b.r/block)?a.r&lt;b.r:a.time&lt;b.time);
}

void add(int x){//统计新的，根据具体情况修改
    if(cnt[x]==0)
        ans++;
    cnt[x]++;

}
void del(int x){//减去旧的，根据具体情况修改
    cnt[x]--;
    if(cnt[x]==0)
        ans--;
}
void change(int x,int ti){//改变时间轴
    if(c[ti].pos&gt;=q[x].l&amp;&amp;c[ti].pos&lt;=q[x].r){
        del(a[c[ti].pos]);//删除指定位置上的值
        add(c[ti].col);//统计新的数
    }
    swap(c[ti].col,a[c[ti].pos]);//直接互换，下次执行时必定是回退这次操作
}
int main(){
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m)!=EOF){
        ans=0;
        numQ=0;
        numC=0;
        memset(cnt,0,sizeof(cnt));
        block=pow(n,0.66666);//分块

        for(int i=1;i&lt;=n;i++)
            scanf(&quot;%d&quot;,&amp;a[i]);

        for(int i=1;i&lt;=m;i++){
            char op[10];
            scanf(&quot;%s&quot;,op);
            if(op[0]==&apos;Q&apos;){//查询操作
                ++numQ;//查询操作次数+1
                scanf(&quot;%d%d&quot;,&amp;q[numQ].l,&amp;q[numQ].r);
                q[numQ].id=numQ;//序号
                q[numQ].time=numC;//时间轴
            }
            else{//修改操作
                ++numC;//修改操作次数+1
                scanf(&quot;%d%d&quot;,&amp;c[numC].pos,&amp;c[numC].col);
            }
        }
        sort(q+1,q+numQ+1,cmp);//对询问进行排序
        int l=1,r=0,time=0;//左右指针与时间轴
        for(int i=1;i&lt;=numQ;i++){
            int ql=q[i].l,qr=q[i].r;//询问的左右端点
            int qtime=q[i].time;//询问的时间轴
            while(l&gt;ql) add(a[--l]);//[l-1,r,time]
            while(l&lt;ql) del(a[l++]);//[l+1,r,time]
            while(r&lt;qr) add(a[++r]);//[l,r+1,time]
            while(r&gt;qr) del(a[r--]);//[l,r-1,time]
            while(time&lt;qtime) change(i,++time);//[l,r,time+1]
            while(time&gt;qtime) change(i,time--);//[l,r,time-1]
            res[q[i].id]=ans;//获取答案
        }

        for(int i=1;i&lt;=numQ;i++)
            printf(&quot;%lld\n&quot;,res[i]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU 2481 cow</title>
    <url>/tpaaaaaa.github.io/2019/09/10/HDU2481cow/</url>
    <content><![CDATA[<p><strong>Time Limit:</strong> 3000MS</p>
<p><strong>Memory Limit:</strong> 65536K</p>
<p><strong>Total Submissions:</strong> 24820</p>
<p><strong>Accepted:</strong> 8305</p>
<p>DescriptionFarmer John’s cows have discovered that the clover growing along the ridge of the hill (which we can think of as a one-dimensional number line) in his field is particularly good. </p>
<p>Farmer John has N cows (we number the cows from 1 to N). Each of Farmer John’s N cows has a range of clover that she particularly likes (these ranges might overlap). The ranges are defined by a closed interval [S,E]. </p>
<p>But some cows are strong and some are weak. Given two cows: cowi and cowj, their favourite clover range is [Si, Ei] and [Sj, Ej]. If Si &lt;= Sj and Ej &lt;= Ei and Ei - Si &gt; Ej - Sj, we say that cowiis stronger than cowj. </p>
<p>For each cow, how many cows are stronger than her? Farmer John needs your help!</p>
<p>InputThe input contains multiple test cases.<br>For each test case, the first line is an integer N (1 &lt;= N &lt;= 105), which is the number of cows. Then come N lines, the i-th of which contains two integers: S and E(0 &lt;= S &lt; E &lt;= 105) specifying the start end location respectively of a range preferred by some cow. Locations are given as distance from the start of the ridge. </p>
<p>The end of the input contains a single 0.</p>
<p>OutputFor each test case, output one line containing n space-separated integers, the i-th of which specifying the number of cows that are stronger than cowi.   </p>
<p>Sample Input</p>
<p>3<br>1 2<br>0 3<br>3 4<br>0</p>
<p>Sample Output</p>
<p>1 0 0</p>
<p>HintHuge input and output,scanf and printf is recommended.</p>
<p>Source<a href="http://poj.org/searchproblem?field=source&key=POJ+Contest" target="_blank" rel="noopener">POJ Contest</a>,Author:Mathematica@ZSU</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>就是给出N个区间，问这个区间是多少个区间的真子集。 用离线算法处理一下N个区间，然后再取计算ans。</p>
<p>对于N个区间[L, R] 按照R递减的顺序，如果R一致，则按L递增的顺序（有相同区间）。这样排序就能保证排序后的第一个区间一定是最大的，即他不是任何区间的真子集，然后将他区间的左端点 在 树状数组中+1。接着对于第二个区间[L, R]，判断树状数组的L的前缀和，即覆盖这个区间的区间数目。接下来是类似的操作。</p>
<p>为什么能保证正确性呢，因为排序的时候，我们已经保证了，排在后面的区间的右端点R 一定比排在前面的右端点R’ 小。那么只要排在后面区间的左端点在此区间左端点L的左边，则此区间被这些区间覆盖了。而且我们也保证了，排在后面的区间绝对不可能覆盖排在前面的区间，因此我们考虑覆盖某个区间的区间数时，只需要考虑排在这个区间前面的区间即可。</p>
<p>小tips： 用线段树维护时，0这个数字不招人喜欢。所以一般将输入的端点+1，避免取0</p>
<p>常规思路，好好理解。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
int c[MAXN], ans[MAXN];
int n;
struct Ques
{
    int L, R;
    int i;
    friend bool operator &lt; (Ques a, Ques b)
    {
        if(a.R == b.R)
            return a.L &lt; b.L;
        else
            return a.R &gt; b.R;
    }
};
Ques ques[MAXN];
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;

    for(int i = x; i &gt; 0; i -= lowbit(i))
        ans += c[i];

    return ans;
}
void update(int x, int v)
{
    for(int i = x; i &lt;= 1e5; i += lowbit(i))
        c[i] += v;
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;ques[i].L, &amp;ques[i].R);
            ques[i].L ++;
            ques[i].R ++;       //0麻烦
            ques[i].i = i;
        }
        sort(ques + 1, ques + 1 + n);
        memset(c, 0, sizeof c);

        ans[ques[1].i] = 0;
        update(ques[1].L, 1);

        for(int i = 2; i &lt;= n; i++)
        {
            if(ques[i].L == ques[i - 1].L &amp;&amp; ques[i].R == ques[i - 1].R)
            {
                ans[ques[i].i] = ans[ques[ i - 1 ].i];
            }
            else
                ans[ques[i].i] = query(ques[i].L);
            update(ques[i].L, 1);
        }
        for(int i = 1; i &lt;= n; i++)
            i == 1 ? printf(&quot;%d&quot;, ans[i]) : printf(&quot; %d&quot;, ans[i]);
        printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]树状数组解逆序对问题</title>
    <url>/tpaaaaaa.github.io/2019/09/10/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E8%A7%A3%E9%80%86%E5%BA%8F%E5%AF%B9%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>例题POJ 2299<strong>Ultra-QuickSort</strong></p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>样例输入为 9 1 0 5 4</p>
<p>设这个数组为a[]; 并顺便记录a[i]的次序order = i</p>
<p>然后将a[]从小到大排序，得到 0 1 4 5 9</p>
<p>接着得到b[]</p>
<pre><code>for(int i = 1; i &lt;= n; i++)
    b[a[i].order] = i;</code></pre><p>b[在原数组中的编号] = 经过排序后的编号</p>
<p>例如4这个数字，在原数组a[]中排第5，经过排序后排到第3，所以得到b[ 5 ] = 3;</p>
<p>然后逆序枚举b[ i ]，也就是按原数组的逆序拿数出来，第一个取出的数是4</p>
<pre><code>for(int i = n; i &gt; 0; i --)
{
    update(b[i], 1);
    ans += query(b[i]);
    ans --;

}</code></pre><p>4这个数字，在排序后的编号为b[n] = 3, 那么我们将树状数组中的第三个叶子节点标记为1（意思为已经出现了），然后求树状数组中前3个的sum，显然只有第三个叶子节点的值为1，其他的为0，所以得到的query = 1， （包括了自己），所以要再减去1，也就是说在原数组中的最后一个元素4，在他后面的比他小的数的数目为0。</p>
<p>接下来是倒数第二个数5，在排序后的编号为b[ n - 1] = 5，那么我们就将树状数组中的第5个叶子节点标记为1，然后求树状数组的前5个的sum，显然第4个和第5个都为1，所以得到的query为2，然后自减1，意思是原数组中5这个数，在他后面的比他小的数的数目为1.</p>
<p>然后是倒数第三个数0，他在排序后排在第1个位置，那么我们将树状数组中的第1个叶子节点标记为1，然后求前1个的sum，显然为1，然后自减，所以0这个数在原数组中他后面的比他小的数的数目为0；</p>
<p>然后是倒数第4个数1，他在排序后排在第2个位置，然后我们将树状数组中的第2个叶子节点标记为1，然后求前2个的sum，得到2，自减1，也就是说，2的逆序数（朝后面看）为1；</p>
<p>最后是第一个数9，他在排序后排在第5个位置，然后我们将树状数组中的第5个叶子节点标记为1，然后求前5个的sum，得到5，自减1，所以9的逆序数为4；</p>
<p>完整代码：</p>
<pre><code>/*
 Date              : 2019-09-10-16.59.56
 Question_Number   ：2
 Question_Name     ：树状数组解逆序对问题模板
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e5 + 10;
int c[4 *  MAXN], b[MAXN], n;
int a[MAXN];
struct Node
{
    int val, order;
    friend bool operator &lt; (Node a, Node b)
    {
        return a.val &lt; b.val;
    }
};
Node node[MAXN];
//x是排序后的坐标
int lowbit(int x)
{
    return x &amp; (-x);
}
int query(int x)
{
    int ans = 0;
    while ( x &gt; 0 )
    {
        ans += c[x];
        x -= lowbit(x);
    }
    return ans;
}
//x是排序后的坐标，u是要改的值
void update(int x, int u)
{
    while(x &lt;= n)
    {
        c[x] += u;
        x += lowbit(x);
    }
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d&quot;, &amp;node[i].val);
            a[i] = node[i].val;
            node[i].order = i;
        }

        sort(node + 1, node + 1 + n);

        for(int i = 1; i &lt;= n; i++)
            b[node[i].order] = i;

        ll ans = 0;
        memset(c, 0, sizeof c);
        for(int i = n; i &gt; 0; i --)
        {
            update(b[i], 1);
            ans += query(b[i]);
            ans --;
        }
        printf(&quot;%lld\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>HDU-3308 LCIS</title>
    <url>/tpaaaaaa.github.io/2019/09/08/HDU-3308LCIS/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>Given n integers.<br>You have two operations:<br>U A B: replace the Ath number by B. (index counting from 0)<br>Q A B: output the length of the longest consecutive increasing subsequence (LCIS) in [a, b].</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树的单点修改，区间查询。 LCIS：最长连续递增子序列</p>
<p>输入部分：</p>
<pre><code>while(t--)
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    built(1, 1, n);
    while(m--)
    {
        cin &gt;&gt; c;
        if(c == &apos;Q&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            int ans = querry(1, x, y);
            printf(&quot;%d\n&quot;, ans);
        }
        else if(c == &apos;U&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            update(1, x, y); //从1号节点开始，将x位置的点的值，变成y
        }
    }
}</code></pre><p>线段树的节点——Node结构体</p>
<pre><code>struct Node
{
    int L, R;           
    int Lsum, Rsum, sum;
};</code></pre><p>线段树的建立——built函数</p>
<pre><code>void built(int root, int L, int R)
{
    node[root].L = L;
    node[root].R = R;
    if(L == R)
    {
        node[root].Lsum = node[root].Rsum = node[root].sum = 1;
        return ;
    }
    int mid = (L + R) / 2;
    built(2 * root, L, mid);
    built(2 * root + 1, mid + 1, R);
    pushUp(root);
}</code></pre><p>线段树的<strong>单点修改</strong>——update函数</p>
<pre><code>void update(int root, int k, int v) //在root所维护的区间中，将k改成v
{
    if(node[root].L == node[root].R) //找到了叶子结点，当然，这叶子节点所维护的就是第k个数
    {
        a[node[root].L] = v;   
        return ;
    }
    int mid = (node[root].L + node[root].R) / 2;
    if(k &lt;= mid)
        update(2 * root, k, v); //k在左半区间
    else
        update(2 * root + 1, k, v);
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)
{
    node[root].Lsum = node[2 * root].Lsum;
    if(node[2 * root].Lsum  == (node[2 * root].R - node[2 * root].L + 1) &amp;&amp; a[ node[2 * root].R ] &lt; a[ node[2 * root].R + 1 ])
        node[root].Lsum += node[2 * root + 1].Lsum;

    node[root].Rsum = node[2 * root + 1].Rsum;
    if(node[2 * root + 1].Rsum  == (node[2 * root + 1].R - node[2 * root + 1].L + 1) &amp;&amp; a[ node[2 * root].R ] &lt; a[ node[2 * root].R + 1 ])
        node[root].Rsum += node[2 * root].Rsum;

    int temp = 0;
        if(a[ node[2 * root].R ]  &lt; a[ node[2 * root].R + 1 ] )
            temp = node[2 * root].Rsum + node[2 * root + 1].Lsum;

    node[root].sum = max(max(node[2 * root].sum, node[2 * root + 1].sum), temp);
}</code></pre><p>线段树的<strong>区间查询</strong>函数——querry</p>
<pre><code>int querry(int root, int L, int R)  //返回的是root所维护的区间中，[L, R]这个区间里面LCIS的长度
{
// 目前root所维护的区间就是我们要找的区间
    if(node[root].L == L &amp;&amp; node[root].R == R)
        return node[root].sum;
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid) //我们要找的区间完全在root的左半区间里面
        return querry(2 * root, L, R);
    else if(L &gt; mid)
        return querry(2 * root + 1, L, R);
    else
    {
// 我们将找[L, R] 中LCIS这个问题分为寻找[L, mid] 和[mid + 1, R]这两个问题
// 分别将这两个问题交给root的两个子区间
        int ans1 = querry(2 * root, L, mid);
        int ans2 = querry(2 * root + 1, mid + 1, R);
        int ans3 = 0;
        if(a[mid] &lt; a[mid + 1])
            ans3 =min(node[2 * root].Rsum, mid - L + 1) + min(node[2 * root + 1].Lsum, R - mid);
        return max(max(ans1, ans2), ans3);
    }
}</code></pre><p>tips：</p>
<p>线段树的区间查询中，如果是在root所维护的区间里面找[L, R]这个区间</p>
<p>①： 如果root所维护的区间就是[L, R] 那么直接返回root中要查找的信息即可</p>
<p>②：如果[L, R]完全在root所维护的区间的左半部分，那么将查找[L, R]的任务传给root的左半部分去做。</p>
<p>③：如果[L, R]完全在root所维护的区间的右半部分，那么将查找[L, R]的任务传给root的右半部分去做。</p>
<p>④：如果[L, R]横跨root所维护的区间的左右两半部分，我们就将查找[L, R]这个任务分解成查找[L, mid] 与 [mid + 1, R]这两个任务，[L, mid]传递给root的左半部分去找，[mid + 1, R]传递给root的右半部分去找。最后合并一下即可。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树，区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 3667 Hotel</title>
    <url>/tpaaaaaa.github.io/2019/09/08/POJ-3667Hotel/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>火山经营着一个停车场，假设的停车场有N车位（编号1-N）都在一条线上，最初所有车位都没停车。经常有人来定车位，他要定连续的k(1 ≤ k ≤ N)个车位。火山要确定是否能够满足客人的要求，如果能，他要将这k个连续的车位安排在编号最小的地方停下。若不能，则客人不停在火山的停车场。在某一时间，有些车会被车主开走了。火山的停车场很大，火山想让学弟学妹写个程序帮助他。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>线段树区间合并模板题，代码分析，当做模板。</p>
<p>线段树的节点结构体</p>
<pre><code>struct Node
{
    int L, R;             //节点维护的区间是[L, R]
    int Lsum, Rsum, sum;  //维护的区间上的一些信息
    int lazy;             //懒标记
};
Node node[4 * MAXN];</code></pre><p>输入部分</p>
<pre><code>while(t--)
{
    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
    for(int i = 1; i &lt;= n; i++)
        scanf(&quot;%d&quot;, &amp;a[i]);
    built(1, 1, n);
    while(m--)
    {
        cin &gt;&gt; c;              //别用getchar
        if(c == &apos;Q&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            y ++;
            int ans = querry(1, x, y);
            printf(&quot;%d\n&quot;, ans);
        }
        else if(c == &apos;U&apos;)
        {
            int x, y;
            scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
            x ++;
            update(1, x, y); //从1号节点开始，将x位置的点的值，变成y
        }
    }
}</code></pre><p>线段树的建立——built函数</p>
<pre><code>void built(int root, int L, int R) //建立维护[L, R]区间的root节点
{
    node[root].L = L;
    node[root].R = R;
    node[root].Lsum = node[root].Rsum = node[root].sum = R - L + 1;
    node[root].lazy = -1;      //懒标记赋初值，-1表示暂无操作
    if(L != R)
    {
        int mid = (L + R) / 2;
        built(2 * root, L, mid);
        built(2 * root + 1, mid + 1, R);
    }
}</code></pre><p>线段树的区间修改——update函数+lazy</p>
<pre><code>void update(int root, int L, int R, int v)
//作用是将root所维护的区间里面的[L, R]部分的值变成v。
{
 //目前找到的区间就是我们要改的区间，那么直接改了
    if(node[root].L == L &amp;&amp; node[root].R == R) 
    {
        node[root].lazy = v;  //root的懒标记置为v，将root节点的信息更新
        if(v == 1)
            node[root].Lsum = node[root].Rsum = node[root].sum = R - L + 1;
        else
            node[root].Lsum = node[root].Rsum = node[root].sum = 0;
        return;
    }
//  因为接下来要更新root的子节点，所以要将lazy标记传下去
    pushDown(root);                            
    int mid = (node[root].L + node[root].R) / 2;
    if(R &lt;= mid)         //说明要更新的[L, R]区间完全在root的左半区间
        update(2 * root, L, R, v);
    else if(L &gt; mid)     // 完全在root的右半区间
        update(2 * root + 1, L, R, v);
    else                 
    {
// [L, R]横跨左右半个区间，那么将我们更新[L, R]的任务，分解为更新[L, mid]
// 和[mid + 1, R]这两个任务，分别分配个root的左右子区间
        update(2 * root, L, mid, v);
        update(2 * root + 1, mid + 1, R, v);
    }
    pushUp(root);
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<pre><code>void pushUp(int root)//作用是用root的两个子区间取更新root所维护的区间
{
    node[root].Lsum = node[2 * root].Lsum;
    if(node[2 * root].Lsum == node[2 * root].R - node[2 * root].L + 1)
        node[root].Lsum += node[2 * root + 1].Lsum;

    node[root].Rsum = node[2 * root + 1].Rsum;
    if(node[2 * root + 1].Rsum == node[2 * root + 1].R - node[2 * root + 1].L + 1)
        node[root].Rsum += node[2 * root].Rsum;

    node[root].sum = max(max(node[2 * root].sum, node[2 * root + 1].sum), node[2 * root].Rsum + node[2 * root + 1].Lsum);
}</code></pre><p>线段树的向下传递——pushDown函数</p>
<pre><code>void pushDown(int root)   //将root节点的lazy标记传递给他的子节点
                          //并清空root节点的lazy标记
{
    if(node[root].lazy != -1)                   //说明存在lazy标记
    {
        node[2 * root].lazy = node[2 * root + 1].lazy = node[root].lazy;
        if(node[root].lazy == 0)                //区间清空的情况
        {
            node[2 * root].sum = node[2 * root].Lsum = node[2 * root].Rsum = 0;
            node[2 * root + 1].sum = node[2 * root + 1].Lsum = node[2 * root + 1].Rsum = 0;
        }
        else
        {
            node[2 * root].sum = node[2 * root].Lsum = node[2 * root].Rsum = node[2 * root].R - node[2 * root].L + 1;
            node[2 * root + 1].sum = node[2 * root + 1].Lsum = node[2 * root + 1].Rsum = node[2 * root + 1].R - node[2 * root + 1].L + 1;
        }
        node[root].lazy = -1;                  //将root节点的lazy标记清除  
    }

}</code></pre><p>线段树的区间查询——querry函数</p>
<pre><code>int  querry(int root, int G) //在root这个节点里面找到连续数目大于等于G个的区间端点
{
    if(node[root].sum &lt; G)
        return 0;
    //接下来开始分配下去，如果做
    if(node[root].Lsum &gt;= G)
        return node[root].L;    //目前区间的最优情况（左端点）符合条件，没必要继续找了
// 因为接下来要查询root的子节点，所以要将root的lazy标记传递下去
    pushDown(root);

    if(node[2 * root].sum &gt;= G) //左半区间存在满足的条件
        return querry(2 * root, G);

    if(node[2 * root].Rsum + node[2 * root + 1].Lsum &gt;= G)
        return (node[2 * root].R - node[2 * root].Rsum + 1);

    if(node[2 * root + 1].sum &gt;= G)
        return querry(2 * root + 1, G);
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树，区间合并，lazy</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1540 Tunnel Warfare</title>
    <url>/tpaaaaaa.github.io/2019/09/08/HDU-1540TunnelWarfare/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>在抗日战争期间，华北平原广大地区进行了大规模的隧道战。 一般来说，通过隧道连接的村庄排成一列。 除了两端，每个村庄都与两个相邻的村庄直接相连。<br>入侵者经常对一些村庄发动袭击并摧毁其中的部分隧道。 八路军指挥官要求最新的隧道和村庄连接状态。 如果某些村庄严重隔离，必须立即恢复连接！<br> 输入的第一行包含两个正整数n和m（n，m≤50,000），表示村庄和事件的数量。 接下来的m行中的每一行描述一个事件。 以下所示的不同格式描述了三种不同的事件： D x：第x个村庄被毁。 Q x：指挥官询问第x个村庄与其直接或间接相关的村庄数量。 R：最后毁坏的村庄被重建了。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>这是线段树的重要应用之一：区间合并，这作为一个模板题，详细分析一下代码</p>
<p>首先是输入部分</p>
<pre><code>while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
 {
     built(1, n, 1); 
     stack &lt; int &gt; st;
     while(m--)
     {
         cin &gt;&gt; c;
         if(c == &apos;D&apos;)
         {
             int x;
             scanf(&quot;%d&quot;, &amp;x);
             st.push(x);
             update(1, x, 0);
         }
         else if( c == &apos;Q&apos;)
         {
             int x;
             scanf(&quot;%d&quot;, &amp;x);
             printf(&quot;%d\n&quot;, query(1, x));
         }
         else if( c == &apos;R&apos;)
         {
             if(st.empty())
                 continue;
             int x = st.top();
             st.pop();
             update(1, x, 1);
         }
     }
 }</code></pre><p>线段树的节点——Node节点</p>
<pre><code>struct Node
{
    int L,R;             //记录着这个节点维护的区间是[L, R]
    int Lsum, Rsum, sum; //Lsum表示这个区间里面从L端点开始的连续1的长度
                         //Rsum表示这个区间里面从R端点开始的连续1的长度
                         //sum表示这个区间里面最长的连续1的长度
};</code></pre><p>线段树的建立——built</p>
<pre><code>void built(int L, int R, int root) // 作用是建立第root个节点，其维护[L, R]
{
    node[root].L = L;
    node[root].R = R;
    if(L == R)    //递归出口，到了叶子节点
        {
            node[root].Lsum = node[root].Rsum = node[root].sum = 1;
            return ;
        }
    int mid = (L + R) / 2;
    built(L, mid, root * 2);
    built(mid + 1, R, root * 2 + 1);
    pushUp(root);   //其实也可以直接在本次built里面就处理完Rsum，Lsum，sum等信息
                    //但这样更加符合建立的顺序，由上到下，再由下回上
}</code></pre><p>线段树的向上传递——pushUp函数</p>
<p>[ root ]</p>
<p>[ 2 * root ] [ 2 * root + 1 ]</p>
<pre><code>void pushUp(int root) //作用是由root的两个子节点 更新得到root节点
{
    node[root].Lsum = node[2*root].Lsum;
    node[root].Rsum = node[2*root + 1].Rsum;
    node[root].sum = max(max(node[2*root].sum, node[2*root + 1].sum), node[2*root].Rsum + node[2*root + 1].Lsum);

    if(node[2 * root].Lsum == (node[2 * root].R - node[2 * root].L + 1))
        node[root].Lsum += node[2 * root + 1].Lsum;//噢噢噢噢我智障了

    if(node[2 * root + 1].Rsum == (node[2 * root + 1].R- node[2 * root + 1].L + 1))
        node[root].Rsum += node[2 * root].Rsum;
}</code></pre><p>线段树的<strong>单点更新</strong>——updata</p>
<pre><code>void update(int root, int k, int v)     //作用是将第k个值变成v。单点修改
{
  //为什么没必要去判断k在不在范围内呢，因为下面的函数已经规定了k肯定会在root所
  //维护的区间里面。找到叶子节点的话，叶子结点维护的就是k
    if(node[root].L == node[root].R)        //已经找到了叶子节点了
    {
        node[root].Lsum = node[root].Rsum = node[root].sum = v;
        return ;
    }
    int mid = (node[root].L + node[root].R) / 2;
//这里已经保证了k一定会在所要update的root所维护的区间里面
    if(k &lt;= mid)
        update(root * 2, k , v);
    else
        update(root * 2 + 1, k, v);
    pushUp(root);
}</code></pre><p>线段树的<strong>单点查询</strong>——query</p>
<pre><code>int  query(int root, int k) //询问在root节点所维护的区间里面，第k值左右连续1的个数最多是多少
{
    if(node[root].L == node[root].R || node[root].sum == 0 || node[root].sum == (node[root].R - node[root].L + 1))
        return node[root].sum;
//如果递归到了叶子节点，或者该结点维护的区间里面全是1 or 0（意味着没必要向下了）
// 就直接返回即可
    int mid = (node[root].L + node[root].R) / 2;                             
    if(k &lt;= mid)
        if(k &gt;= mid - node[2 * root].Rsum + 1)
            return query(2 * root, k) + query(2 * root + 1, mid + 1);
        else
            return query(root * 2, k);
    else    
        if(k &lt;= mid + node[2 * root + 1].Lsum)
            return query(2 * root + 1, k) + query(2 * root, mid);
        else
            return query(root * 2 + 1, k);
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树，区间合并</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]归并排序</title>
    <url>/tpaaaaaa.github.io/2019/09/07/%5B%E7%AE%97%E6%B3%95%5D%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>博文地址<a href="https://www.jianshu.com/p/33cffa1ce613" target="_blank" rel="noopener">https://www.jianshu.com/p/33cffa1ce613</a></p>
<p>博文地址<a href="https://blog.csdn.net/k_koris/article/details/80508543" target="_blank" rel="noopener">https://blog.csdn.net/k_koris/article/details/80508543</a></p>
<p>博文地址<a href="https://blog.csdn.net/doubleguy/article/details/81390951" target="_blank" rel="noopener">https://blog.csdn.net/doubleguy/article/details/81390951</a></p>
<p>关于逆序数</p>
<p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个<strong>逆序</strong>。一个排列中逆序的总数就称为这个排列的<strong>逆序数</strong>。一个排列中所有逆序总数叫做这个排列的逆序数。也就是说，对于n个不同的元素，先规定各元素之间有一个标准次序（例如n个 不同的自然数，可规定从小到大为标准次序），于是在这n个元素的任一排列中，当某两个元素的先后次序与标准次序不同时，就说有1个逆序。一个排列中所有逆序总数叫做这个排列的逆序数。</p>
<p>OJ 2299 <a href="https://www.cnblogs.com/zhangmingcheng/p/3912958.html" target="_blank" rel="noopener">Ultra-QuickSort</a></p>
<p>但是用<strong>归并排序</strong>并不是为了求交换次数，而是为了求序列的<strong>逆序数</strong>（学过《线代》的同学应该很熟悉了）</p>
<p><strong>一个乱序序列的 逆序数 = 在只允许_相邻_两个元素交换的条件下,得到有序序列的交换次数</strong></p>
]]></content>
      <categories>
        <category>模板</category>
      </categories>
      <tags>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]ST表</title>
    <url>/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5DST%E8%A1%A8/</url>
    <content><![CDATA[<p>博文地址：<a href="https://www.cnblogs.com/qq965921539/p/9608980.html" target="_blank" rel="noopener">https://www.cnblogs.com/qq965921539/p/9608980.html</a></p>
<p>ST表类似树状数组，线段树这两种算法，是一种用于解决RMQ(Range Minimum/Maximum Query,即区间最值查询)问题的离线算法</p>
<p>与线段树相比，预处理复杂度同为O(nlogn),<strong>查询时间上，ST表为O(1),线段树为O(nlogn)</strong></p>
<p>st表的主体是一个二维数组st[i][j]，表示需要查询的数组的从下标i到下标i+2^j - 1的最值，这里以最小值为例</p>
<pre><code>int a[1010];//原始输入数组
int st[1010][20];//st表

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        st[i][0] = a[i];

    for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++)
    {
        for (int i = 0; i + (1 &lt;&lt; j) - 1 &lt; n; i++)
            st[i][j] = min(st[i][j - 1],st[i + (1 &lt;&lt; (j - 1))][j - 1]);
    }
}</code></pre><p>这里首先把从0~n-1的2^0部分进行覆盖，再往下继承</p>
<p>继承这里也很好理解，我们以一个长度为5的数组[5,1,2,3,4]为例</p>
<p>2^0部分覆盖过去自然是5，4，3，2，1</p>
<p>2^1部分的长度为4，从0一直到3，因为从下标为4开始后面只有他自己</p>
<p>st[0][1]是下标为0~1的最小值，自然也就是st[0][0]和st[1][0]的最值</p>
<p>以此往下类推我们可以得出结论：</p>
<p><strong>st[i][j] = min(st[i][j - 1],st[i + 2^(j - 1))][j - 1**</strong>])**</p>
<p>到这里初始化就完成了，注意下标不要越界，如果你对为什么这么处理有困惑的话，请继续看查询</p>
<p>查询函数这里不太好理解</p>
<p>初始化时，每一个状态对应的区间长度都为2^j，由于给出的查询区间长度不一定恰好为2^j，</p>
<p>所以我们要引出一个定理：<strong>2^log(a)&gt;a/2</strong> 。</p>
<p><a href="https://blog.csdn.net/Hanks_o/article/details/77547380" target="_blank" rel="noopener">https://blog.csdn.net/Hanks_o/article/details/77547380</a> 这里有一段非常非常好理解的解释，这里超级感谢原作者，我本人不能做出更好的解释，他的讲解是这样的：</p>
<p>这个很简单，因为log(a)表示小于等于a的2的最大几次方。<br>比如说log(4)=2,log(5)=2,log(6)=2,log(7)=2,log(8)=3,log(9)=3…….<br>那么我们要查询x到y的最小值。<br>设len=y-x+1,t=log(len)<br>根据上面的定理：2^t&gt;len/2<br>从位置上来说，x+2^t越过了x到y的中间！<br>因为位置过了一半<br>所以x到y的最小值可以表示为min(从x往后2^t的最小值，从y往前2^t的最小值)<br>前面的状态表示为mn[t][x]<br>设后面（从y往前2^t的最小值）的初始位置是k，<br>那么k+2^t-1=y，所以k=y-2^t+1<br>所以后面的状态表示为mn[t][y-2^t+1]<br>所以x到y的最小值表示为min(mn[t][x],mn[t][y-2^t+1])，所以查询时间复杂度是O（1）</p>
<p>查询函数：</p>
<pre><code>1 int search(int l, int r)
2 {
3     int k = (int)(log((double)(r - l + 1)) / log(2.0));
4     return min(st[l][k],st[r - (1 &lt;&lt; k) + 1][k]);
5 }</code></pre><p>示例程序：</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;algorithm&gt;

using namespace std;

int a[1010];//原始输入数组
int st[1010][20];//st表

void init(int n)
{
    for (int i = 0; i &lt; n; i++)
        st[i][0] = a[i];

    for (int i = 1; (1 &lt;&lt; i) &lt;= n; i++)
    {
        for (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++)
            st[j][i] = min(st[j][i - 1],st[j + (1 &lt;&lt; (i - 1))][i - 1]);
    }
}

int search(int l, int r)
{
    int k = (int)(log((double)(r - l + 1)) / log(2.0));
    return min(st[l][k],st[r - (1 &lt;&lt; k) + 1][k]);
}

int main()
{
    int n,m;
    while (cin &gt;&gt; n &gt;&gt; m)
    {
        for (int i = 0; i &lt; n; i++)
            cin &gt;&gt; a[i];

        init(n);

        while (m--)
        {
            int l, r;
            cin &gt;&gt; l &gt;&gt; r;
            cout &lt;&lt; search(l,r) &lt;&lt; endl;;
        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>ST表，RMQ问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[数据结构]单调栈</title>
    <url>/tpaaaaaa.github.io/2019/09/07/%5B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5D%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h2 id="什么是单调栈？"><a href="#什么是单调栈？" class="headerlink" title="什么是单调栈？"></a><strong>什么是单调栈？</strong></h2><p>单调栈分为单调递增栈和单调递减栈，单调递增栈即栈内元素保持单调递增的栈，同理单调递减栈即栈内元素保持单调递减的栈，跟单调队列差不多，但是只用到它的一端，利用它可以用来解决一些ACM/ICPC和OI的题目，如RQNOJ 的诺诺的队列等。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>单调递增栈</p>
<pre><code>for(int i = 0; i &lt; T.size(); i++){
  while(! stk.empty() &amp;&amp; stk.top() &gt; T[i]){
    ​stk.pop();
  }
  stk.push(A[i]);
}</code></pre><h2 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h2><p>可以以 O(1) 的时间复杂度得知某个位置左右两侧比他大（或小）的数的位置，当你需要高效率获取某个位置左右两侧比他大（<strong>或小</strong>）的数的位置的的时候就可以用到单调栈。</p>
<p>求解数组中元素右边第一个比它小的元素的下标，从前往后，构造单调递增栈；<br>求解数组中元素右边第一个比它大的元素的下标，从前往后，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递减栈；<br>求解数组中元素左边第一个比它小的元素的下标，从后往前，构造单调递增栈。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>[数论]素数筛</title>
    <url>/tpaaaaaa.github.io/2019/09/06/%5B%E6%95%B0%E8%AE%BA%5D%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    <content><![CDATA[<p>博文地址：<a href="https://blog.csdn.net/qq_41117236/article/details/81152055" target="_blank" rel="noopener">https://blog.csdn.net/qq_41117236/article/details/81152055</a></p>
<h2 id="普通筛法-埃式筛法"><a href="#普通筛法-埃式筛法" class="headerlink" title="普通筛法- 埃式筛法"></a>普通筛法- 埃式筛法</h2><p>普通代码： 时间复杂度O(nloglogn)</p>
<pre><code>bool prime[maxn+5];
void isprime()
{
    int i,j;
    memset(prime,true,sizeof(prime));
    for(i=2;i&lt;=maxn;i++)
    {
        if(prime[i]==true)
        {
            for(j= i + i ;j &lt;= N;j += i)
                prime[j]=false;
        }
    }
}</code></pre><p>改进：</p>
<pre><code>bool prime[maxn+5];
void isprime()
{
    int i,j;
    memset(prime,true,sizeof(prime));
    for(i=2;i&lt;=sqrt(N);i++) //第一处： i &lt;= max --- &gt;  i &lt;= sqrt(N)
    {
        if(prime[i]==true)
        {
            for(j = i * i; j &lt;= N ; j += i) //第二处: j = 2 i  --- &gt; j = i*i
                prime[j]=false;
            //二次筛选法:i是素数，则下一个起点是i*i,把后面的所有的i*i+2*n*i筛掉
        }
    }</code></pre><h2 id="线性筛——欧拉Euler筛"><a href="#线性筛——欧拉Euler筛" class="headerlink" title="线性筛——欧拉Euler筛"></a>线性筛——欧拉Euler筛</h2><p>博客地址：<a href="https://www.cnblogs.com/NSD-email0820/p/9490828.html#_label4" target="_blank" rel="noopener">https://www.cnblogs.com/NSD-email0820/p/9490828.html#_label4</a></p>
<pre><code>void primes(int n)
{
    memset(v,0,sizeof(v));//假设全是素数，无合数标记 
    for(int i=2;i&lt;=n;i++)
    {
        if(!v[i])        //是素数
        {
            prime[++cnt]=i;
            v[i]=i;     //存的就是自己，v[i]记录的是筛掉自己的最小质因子 
        }
        for(int j=1;j&lt;=cnt;j++)
        {
            if(prime[j]&gt;v[i]||prime[j]*i&gt;n)break;
            //出现了比i的最小质因数还小的质数（对于4来说出现了3） 
            v[prime[j]*i]=prime[j];
        }    
    }
    for(int i=1;i&lt;=cnt;i++)
        cout&lt;&lt;prime[i]&lt;&lt;&quot; &quot;;
}</code></pre>]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>[数论]积性函数与线性筛</title>
    <url>/tpaaaaaa.github.io/2019/09/05/%5B%E6%95%B0%E8%AE%BA%5D%E7%A7%AF%E6%80%A7%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
    <content><![CDATA[<p>博客地址<a href="https://www.cnblogs.com/zhoushuyu/p/8275530.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoushuyu/p/8275530.html</a></p>
<p><em>积性函数_指对于所有互质的整数a和b有性质f(ab)=f(a)f(b)的数论_函数</em></p>
<p>常用积性函数举例</p>
<p>φ(n) －欧拉函数<br>μ(n) －莫比乌斯函数，关于非平方数的质因子数目<br>gcd(n,k) －最大公因子，当k固定的情况<br>d(n) －n的正因子数目<br>σ(n) －n的所有正因子之和</p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]广义Fibonacci数列找循环节</title>
    <url>/tpaaaaaa.github.io/2019/09/05/%5B%E7%AE%97%E6%B3%95%5D%E5%B9%BF%E4%B9%89Fibonacci%E6%95%B0%E5%88%97%E6%89%BE%E5%BE%AA%E7%8E%AF%E8%8A%82/</url>
    <content><![CDATA[<p>原博文连接：<a href="https://blog.csdn.net/ACdreamers/article/details/25616461" target="_blank" rel="noopener">https://blog.csdn.net/ACdreamers/article/details/25616461</a></p>
<p><img src="https://img-blog.csdn.net/20140512141202250" alt=""></p>
<p><img src="https://img-blog.csdn.net/20140512141344500" alt=""></p>
<p><img src="https://img-blog.csdn.net/20140512141547343" alt=""></p>
<p><strong>问题：</strong>给定如上的递推式，求其循环节长度</p>
<p><strong>结论：</strong>设</p>
<p><img src="https://img-blog.csdn.net/20140512150213093" alt=""></p>
<ul>
<li>如果c是模p的二次剩余时：枚举n = p - 1的因子</li>
<li>如果c是模p的非二次剩余时：枚举n = (p - 1)*(p + 1)的因子</li>
</ul>
<p>找到最小的ans，使得</p>
<p><img src="https://img-blog.csdn.net/20140512155210937" alt=""></p>
<p>何为二次剩余：</p>
<p>简单来说就是如果存在一个整数x，使得x^2 ≡ n(mod p)<br>那么则称n是模p的二次剩余。</p>
]]></content>
      <categories>
        <category>数论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 1816 Get Luffy Out *</title>
    <url>/tpaaaaaa.github.io/2019/09/04/HDU-1816GetLuffyOut/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>某两个钥匙为一对，一旦使用了其中一个钥匙，另一个钥匙就不能用了（约束条件1） 开每个门，至少要用一个钥匙（约束条件2），求能开的门数的最大值（二分）。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>将钥匙的状态视为0和1。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-04-15.56.39
 Question_Number   ：hdu 1816
 Question_Name     ：二分 + 2-sat
 Description       :
每片钥匙，有两个状态 A1为用这片钥匙， A0 为不用这片钥匙

 你还是没理解透彻2-SAT的实质
 对于第一个约束规则（一对钥匙中的一片用了，另一篇就不能用了）
 假如有一对钥匙A B
 所以得到约束关系   A and B ！= 1；
 也就是说如果
 A1  -- &gt; B0        //如果用A这片钥匙，那么B的状态就是不用这片钥匙了
 B1  -- &gt; A0

 对于第二个约束规则（一扇门有两把锁，开了一把，另一把的钥匙就不能用了）
 假如这扇门用的钥匙为A，B；
 所以得到约束关系   A and B != 1;   A or B != 0
 A1  -- &gt; B0;
 B1  -- &gt; A0;
 A0  -- &gt; B1;
 B0  -- &gt; A1;


 然后本题问的是能打开的最多的门数是多少
 一般这种都是二分
 每次都建一遍图

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1024 + 10;
const int MAXM = 2048 + 10;
stack &lt; int &gt; st;
int n, m, tot, cnt, sum;
int head[4 * MAXN], low[4 * MAXN], dfn[4 * MAXN], belong[4 * MAXN];
bool vis[4 * MAXN];
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXN + 4 * MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
struct Node
{
    int x, y;
};
Node key[MAXN];
Node door[MAXM];
void init()
{
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    cnt = sum = tot = 0;
}
void Tarjan(int u)
{
    vis[u] = true;
    low[u] = dfn[u] = ++tot;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 4 * n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
    for(int i = 0; i &lt; 4 * n; i += 2)
        if(belong[i] == belong[i + 1])
            return false;

    return true;
}
void built(int mid)
{
    init();
    for(int i = 1; i &lt;= n; i++)
    {
        int u = key[i].x;
        int v = key[i].y;
        int u1 = u * 2;     //u1表示选这个钥匙
        int u2 = u * 2 + 1;
        int v1 = v * 2;
        int v2 = v * 2 + 1;
        addEdge(u1, v2);
        addEdge(v1, u2);
    }
    for(int i = 1; i &lt;= mid; i++)   //一种特殊情况，一个门两片的钥匙是一样的
    {
        int u = door[i].x;
        int v = door[i].y;
        int u1 = u * 2;     //u1表示选这个钥匙
        int u2 = u * 2 + 1;
        int v1 = v * 2;
        int v2 = v * 2 + 1;
   //     addEdge(u1, v2);
     //   addEdge(v1, u2); 为什么不要？？
        addEdge(u2, v1);
        addEdge(v2, u1);
    }
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) &amp;&amp; n + m)
    {
        // 意思是有2n把钥匙，那么图中有4n个点
        // 编号为0 .... 4n - 1
        // 01  23
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;, &amp;key[i].x, &amp;key[i].y);
        for(int i = 1; i &lt;= m; i++)
            scanf(&quot;%d%d&quot;, &amp;door[i].x, &amp;door[i].y);
        int L = 0;  //
        int R = m;  // 这是最多的层数
        int mid;
        int ans = 0;
        while(L &lt;= R)
        {
            mid = (L + R) / 2;
            built(mid);
            if(solve())
            {
                ans = max(ans, mid);
                L = mid + 1;
            }
            else
            {
                R = mid - 1;
            }
        }
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1815 Building roads</title>
    <url>/tpaaaaaa.github.io/2019/09/04/HDU-1815Buildingroads/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n个堆，2个特殊点，每个堆有两个状态，要么连接到s1这个特殊点，要么连到s2这个特殊点。存在某些约束关系，例如某两堆不能连在同一个特殊点，or某两堆必须连在同一个特殊点。求任意两点距离的最大值的 最小值</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>二分最大值，如果两点距离大于这个最大值，就说明这两者矛盾，填加约束条件。再配合上之前的两堆不能连同一点，两堆要连同一点的约束条件，构成一个图。用2-SAT求适定性即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-04-13.46.03
 Question_Number   ：hdu 1815
 Question_Name     ：二分+ 2-sat
 Description       :
 二分一个最大距离
 首先求出每个点  到s1 和 s2的距离
 然后求出每对点（A,B）的距离
 如果A到s1的距离 加上distance 再加上B到s2的距离
 要大于mid，说明不能连二者
 也就是说如果A连到s1,  B那么一定不能连s2
 如果B连到了s2，A那么一定不能连到s1
 每对点，要考虑4个情况
 都连s1  都连s2  A连s1 B连s2  A连s2 A连s1
 然后将这四种诞生的限制条件添加入图中
 如果适定，说明限制条件还少了
 那么缩小mid
 如果不适定，说明限制条件多了
 那么放大mid
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 500 + 10;
const int MAXM = 1000 + 10;
stack &lt; int &gt; st;
int head[2*MAXN], ans[2*MAXN], low[2*MAXN], dfn[2*MAXN], belong[2*MAXN];
bool mark[2*MAXN], vis[2*MAXN];
int dis[MAXN][2], cnt, dfsSum, distant, n, m, a, b, tot, sum;
struct Node
{
    int x, y;
};
Node node[MAXN];
Node s1, s2;
Node dislike[MAXM];
Node like[MAXM];
int getDis(Node a, Node b)
{
    return abs(a.x - b.x) + abs(a.y - b.y);
}
struct Edge
{
    int v, next;
};
Edge edge[MAXN * MAXN * 4];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(head, -1, sizeof head);
    while(!st.empty())
        st.pop();
    cnt = tot = sum = 0;
}
int oth(int x)
{
    if(x % 2)
        return x + 1;
    else
        return x - 1;
}
void built(int mid)
{
    for(int i = 1; i &lt;= a; i++)
    {
            int u = dislike[i].x;
            int v = dislike[i].y;
            int u1 = u * 2 - 1;
            int u2 = u * 2;
            int v1 = v * 2 - 1;
            int v2 = v * 2;
            addEdge(u1, v2);
            addEdge(u2, v1);
            addEdge(v1, u2);
            addEdge(v2, u1);
    }
    for(int i = 1; i &lt;= b; i++)
    {
            int u = like[i].x;
            int v = like[i].y;
            int u1 = u * 2 - 1;
            int u2 = u * 2;
            int v1 = v * 2 - 1;
            int v2 = v * 2;
            addEdge(u1, v1);
            addEdge(u2, v2);
            addEdge(v1, u1);
            addEdge(v2, u2);
    }
    for(int i = 1; i &lt; n; i++)          //枚举两对点
        for(int j = i + 1; j &lt;= n; j++)     //有四种情况
        {
            int u1 = i * 2 - 1;
            int u2 = i * 2;
            int v1 = j * 2 - 1;         //我是瞎子吗
            int v2 = j * 2;
            int dis1 = dis[i][0] + dis[j][0];
            int dis2 = dis[i][1] + dis[j][1];
            int dis3 = dis[i][0] + dis[j][1] + distant;
            int dis4 = dis[i][1] + dis[j][0] + distant;
            if(dis1 &gt; mid)                //u v 不能同时选0
            {
                addEdge(u1, v2);
                addEdge(v1, u2);
            }
            if(dis2 &gt; mid)              //u v不能同时选1
            {
                addEdge(u2, v1);
                addEdge(v2, u1);
            }
            if(dis3 &gt; mid)              //u选了0后v不能选1
            {
                addEdge(u1, v1);
                addEdge(v2, u2);
            }
            if(dis4 &gt; mid)              //u选了1后， v不能选0
            {
                addEdge(u2, v2);
                addEdge(v1, v1);
            }
        }

}
bool dfs(int u)
{
    if(mark[oth(u)])
        return false;
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++dfsSum] = u;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }

    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)
        if(mark[i] == false &amp;&amp; mark[i + 1] == false)
        {
            dfsSum = 0;
            if(dfs(i) == false)
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;

                if(dfs(i + 1) == false)
                    return false;
            }
        }
    return true;
}
// 的确可以用Tarjan写
/*void Tarjan(int u)
{
    vis[u] = true;
    dfn[u] = low[u] = ++tot;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;      //我是瞎了吗
      //  printf(&quot;@&quot;);
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
   // printf(&quot;@@@@&quot;);
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            //printf(&quot;?&quot;);
            int temp = st.top();
            st.pop();
            belong[temp] = sum;
            vis[temp] = false;
        }
        st.pop();
        belong[u] = sum;
        vis[u] = false;
    }
//    printf(&quot;?&quot;);
}
bool solve()
{
    for(int i = 1; i &lt;= 2*n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
//printf(&quot;there&quot;);
    for(int i = 1; i &lt;= 2*n; i += 2)
        if(belong[i] == belong[i + 1])
            return false;
  //  printf(&quot;here&quot;);
    return true;
}*/
int main()
{
    while(scanf(&quot;%d%d%d&quot;, &amp;n, &amp;a, &amp;b) != EOF)
    {
        //2n个点 12  34 ....
        scanf(&quot;%d%d%d%d&quot;, &amp;s1.x, &amp;s1.y, &amp;s2.x, &amp;s2.y);
        distant = getDis(s1, s2);
        for(int i = 1; i &lt;= n; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;node[i].x, &amp;node[i].y);
            dis[i][0] = getDis(node[i], s1);
            dis[i][1] = getDis(node[i], s2);
        }

        for(int i = 1; i &lt;= a; i++)
            scanf(&quot;%d%d&quot;, &amp;dislike[i].x, &amp;dislike[i].y);
        for(int i = 1; i &lt;= b; i++)
            scanf(&quot;%d%d&quot;, &amp;like[i].x, &amp;like[i].y);
        int L = 0;
        int R = 44444444;
        int mid;
        int ans = INF;      //最小的min
        while(L &lt;= R)
        {
           // printf(&quot;i am here\n&quot;);
            init();         //注意
            mid = (L + R) / 2;
          //  printf(&quot;mid = %d\n&quot;, mid);
            built(mid);     //添加一些边
            if(solve())
            {
                ans = mid;
                R = mid - 1;
          //      printf(&quot; i ma&quot;);
            }
            else
            {
                L = mid + 1;
            }
        }
        if(ans &lt; INF)
            printf(&quot;%d\n&quot;, ans);
        else
            printf(&quot;-1\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1814 Peaceful Commission</title>
    <url>/tpaaaaaa.github.io/2019/09/04/HDU-1814PeacefulCommission/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>根据宪法，Byteland民主共和国的公众和平委员会应该在国会中通过立法程序来创立。 不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。 此委员会必须满足下列条件：每个党派都在委员会中恰有1个代表，如果2个代表彼此厌恶，则他们不能都属于委员会。<br>每个党在议会中有2个代表。代表从1编号到2n。 编号为2i-1和2i的代表属于第I个党派。<br>任务 写一程序：从文本文件读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表， 结果写入文本文件。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>因为要输出字典序最小的组合，所以只能用dfs来求。模板题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-03-22.43.10
 Question_Number   ：hdu 1814
 Question_Name     ：2sat 判断 + 输出
 Description       :
 最小字典序就只能暴力dfs
 // 通常而言，如果至少判断是否可行，则用缩点法
 如果要输出选择序列的话，就只能用dfs了

 对于每个当前不确定的变量ai，令ai=0然后沿着边DFS访问相连的点。
检查如果会导致任意一个j与j′都被选，那么撤销。否则令ai=0
否则令ai=1，重复2。如果还不行就无解。
继续考虑下一个不确定的变量

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 8e3 + 10;
const int MAXM = 2e4 + 10;
int head[2*MAXN], ans[2*MAXN];
bool mark[2*MAXN];
int n, m, cnt, dfsSum;
struct Edge
{
    int v, next;
};
Edge edge[2 * MAXM];    //一对矛盾，就意味着两个边
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
int oth(int x)  // 12是一对
{
    if(x % 2)   //1 就返回2
        return x + 1;
    else
        return x - 1;
}
bool dfs(int u)
{
    if(mark[oth(u)])
        return false;   //如果一对的两个点都被dfs到了，说明不行。
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++ dfsSum] = u;    // 第dfsSum的答案是真实图的u号点, from 1
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }
    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)//图中点的编号为1 ... 2n，枚举每队点
    {
        if(mark[i] == false &amp;&amp; mark[i + 1] == false) // 如果这对点都没有被选择过
        {
            dfsSum = 0;        //意思是从这个点开始dfs，cnt就是此次dfs涉及到的答案
            if(dfs(i) == false) //说明这样不可能，将此次dfs修改的mark标记清除
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;    //选的是j，但为了安全，把其对立点也清除
                if(dfs(oth(i)) == false)
                    return false;
            }
        }
    }
    return true;
}
void init()
{
    cnt = 0;
    memset(head, -1, sizeof head);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {   //有n个党派， 编号1 ... n
        //党派代表编号为 12  23 ...
        init();
        for(int i = 1; i &lt;= m; i++) //开始建边
        {
            int a, b;         //ab是有矛盾的代表编号
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addEdge(a, oth(b));
            addEdge(b, oth(a));
        }

        if(solve()) //能够适定，则输出答案，不能则输出NIE
        {
            for(int i = 1; i &lt;= 2*n; i += 2)    // 枚举每对点，输出这对的选择。
            {
                if(mark[i])
                    printf(&quot;%d\n&quot;, i);
                else
                    printf(&quot;%d\n&quot;, i + 1);
            }
        }
        else
            printf(&quot;NIE\n&quot;);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>2-SAT的DFS解法</tag>
      </tags>
  </entry>
  <entry>
    <title>[总结]图论基础刷题总结。</title>
    <url>/tpaaaaaa.github.io/2019/09/04/%5B%E6%80%BB%E7%BB%93%5D%E5%9B%BE%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93%E3%80%82/</url>
    <content><![CDATA[<p>刷专题的成就感不错，但是需要进一步总结，使得能够明确哪些题目是图论题，是哪类图论题，该怎样解这道题….</p>
<p>将题目抽象简化并且总结归纳。</p>
<p><strong>不要把这个视为累赘，而应该是在享受进步。</strong></p>
<h2 id="目录："><a href="#目录：" class="headerlink" title="目录："></a>目录：</h2><h3 id="最短路径问题"><a href="#最短路径问题" class="headerlink" title="最短路径问题"></a>最短路径问题</h3><ul>
<li>单源最短路问题</li>
<li>多源最短路问题</li>
</ul>
<h3 id="生成树问题"><a href="#生成树问题" class="headerlink" title="生成树问题"></a>生成树问题</h3><ul>
<li>最小生成树</li>
<li>次小生成树</li>
<li>最小树形图</li>
<li>斯坦纳树</li>
</ul>
<h3 id="并查集问题"><a href="#并查集问题" class="headerlink" title="并查集问题"></a>并查集问题</h3><ul>
<li>简单并查集</li>
<li>带权并查集（种类并查集，异或并查集）</li>
</ul>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a>最近公共祖先</h3><ul>
<li>Tarjan求LCA</li>
<li>转化为RMQ问题求LCA</li>
</ul>
<h3 id="强连通问题"><a href="#强连通问题" class="headerlink" title="强连通问题"></a>强连通问题</h3><ul>
<li>判断强连通</li>
<li>添边变成强连通</li>
</ul>
<h3 id="双连通问题"><a href="#双连通问题" class="headerlink" title="双连通问题"></a>双连通问题</h3><ul>
<li>求割点</li>
<li>求割边</li>
<li>求边双连通分量</li>
<li>求点双连通分量</li>
</ul>
<h3 id="2-SAT问题"><a href="#2-SAT问题" class="headerlink" title="2-SAT问题"></a>2-SAT问题</h3><ul>
<li>判断适定性</li>
<li>字典序输出决策结果</li>
</ul>
<h3 id="欧拉回路问题："><a href="#欧拉回路问题：" class="headerlink" title="欧拉回路问题："></a>欧拉回路问题：</h3><h3 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h3><h3 id="二分匹配问题"><a href="#二分匹配问题" class="headerlink" title="二分匹配问题"></a>二分匹配问题</h3><p>——————分割线———————————————</p>
<h2 id="2-SAT"><a href="#2-SAT" class="headerlink" title="2 - SAT"></a>2 - SAT</h2><p>因为刚刷了不少这类题，趁热总结一下。</p>
<h3 id="刷题总结："><a href="#刷题总结：" class="headerlink" title="刷题总结："></a>刷题总结：</h3><p>常常配合 <strong>二分</strong>来使用 ： <strong>用二分来确定最大值的最小，最小值的最大</strong>等等</p>
<p>如果只是判断适定性，dfs和Tarjan缩点的方法都行。</p>
<p>如果要字典序输出，则只能用dfs。</p>
<h3 id="题目抽象："><a href="#题目抽象：" class="headerlink" title="题目抽象："></a>题目抽象：</h3><p>给你n个点，每个点有<strong>两种状态0 或 1</strong>， 不同点之间可能存在<strong>某些约束条件</strong>（例如i点的状态为0的话，j点状态必须为1 等等），<strong>问：是否存在满足这些约束条件的n个点，或者让你输出字典序最小的满足这些约束条件的n个点。</strong></p>
<p><strong>一些常用的建图方式（两个点A,B，A状态为0 表示为 A0 , A点状态为1 表示为A1 ）注意建图过程中，只看约束条件！！！填的边都是约束条件</strong></p>
<ul>
<li>A，B 不能同时取：A1 - &gt; B0; B1 - &gt; A0;</li>
<li>A，B 至少取一个：A0 - &gt; B1; B0 - &gt; A1;</li>
<li>A，B 必须同时选：A1 - &gt; B1 , B1 - &gt;A1;</li>
<li>A，B 必须选一个：A1 - &gt; B0，B1 - &gt; A0, A0 - &gt; B1, B0 - &gt; A1;</li>
<li>A必须选：A0 - &gt; A1</li>
</ul>
<p>建好图然后就是考虑怎么用图论的方式解决2-SAT了。</p>
<p>如果在以上约束条件下，A1 跟 A0在同一个环中，说明无法满足约束条件，所以在二分的时候，如果目前的mid满足了存在满足约定条件的解，那么可以适当添加边，否则就需要适当减少一些边。<strong>要清楚，图中边越多，就以为着约束条件越多，意味着A1 和 A0在同一个环的可能性越大</strong></p>
<h3 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h3><p>用dfs算法求解并字典序输出（ <a href="https://cn.vjudge.net/problem/21647/origin" target="_blank" rel="noopener">HDU - 1814</a> 模板题）</p>
<pre><code>bool dfs(int u)
{
    if(mark[oth(u)])
        return false;   //如果一对的两个点都被dfs到了，说明不行。
    if(mark[u])
        return true;
    mark[u] = true;
    ans[++ dfsSum] = u;    // 第dfsSum的答案是真实图的u号点, from 1
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfs(v) == false)
            return false;
    }
    return true;
}
bool solve()
{
    memset(mark, false, sizeof mark);
    for(int i = 1; i &lt;= 2*n; i += 2)//图中点的编号为1 ... 2n，枚举每队点
    {
        if(mark[i] == false &amp;&amp; mark[i + 1] == false) // 如果这对点都没有被选择过
        {
            dfsSum = 0;        //意思是从这个点开始dfs，cnt就是此次dfs涉及到的答案
            if(dfs(i) == false) //说明这样不可能，将此次dfs修改的mark标记清除
            {
                for(int j = 1; j &lt;= dfsSum; j++)
                    mark[ans[j]] = mark[oth(ans[j])] = false;    //选的是j，但为了安全，把其对立点也清除
                if(dfs(oth(i)) == false)
                    return false;
            }
        }
    }
    return true;
}
..........部分代码略.............
       if(solve()) //能够适定，则输出答案，不能则输出NIE
        {
            for(int i = 1; i &lt;= 2*n; i += 2)    // 枚举每对点，输出这对的选择。
            {
                if(mark[i])
                    printf(&quot;%d\n&quot;, i);
                else
                    printf(&quot;%d\n&quot;, i + 1);
            }
        }
        else
            printf(&quot;NIE\n&quot;);</code></pre><p>用Tarjan缩点判断适定性</p>
<pre><code>   void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++dfsClock;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }

    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)
        if(dfn[i] == 0)
            Tarjan(i);  //对每个点进行缩点
    for(int i = 0; i &lt; n; i++)
        if(belong[i*2] == belong[i*2 + 1])
            return false;
    return true;
}
  ....部分代码略..............
        if(solve())
            printf(&quot;YES\n&quot;);
        else
            printf(&quot;NO\n&quot;);</code></pre><h3 id="题集-题解："><a href="#题集-题解：" class="headerlink" title="题集+题解："></a>题集+题解：</h3><p><a href="http://localhost/?p=192" target="_blank" rel="noopener">HDU – 3062 Party</a> 2-SAT适定性判断的模板题</p>
<p><a href="http://localhost/?p=194" target="_blank" rel="noopener">HDU – 1824 Let’s go home</a> 适定性判断的模板题</p>
<p><a href="http://localhost/?p=197" target="_blank" rel="noopener">HDU – 3622 Bomb Game</a> 二分 + 2 - SAT</p>
<p><a href="http://localhost/?p=199" target="_blank" rel="noopener">HDU – 3715 Go Deeper</a> 二分 +2 - SAT</p>
<p><a href="http://localhost/?p=207" target="_blank" rel="noopener">HDU – 1814 Peaceful Commission</a> dfs求2-SAT的模板题</p>
<p><a href="http://localhost/?p=210" target="_blank" rel="noopener">HDU – 1815 Building roads</a> 二分 + 2-SAT</p>
<p><a href="http://localhost/?p=212" target="_blank" rel="noopener">HDU – 1816 Get Luffy Out *</a> 二分 + 2-SAT</p>
<h2 id="最短路问题："><a href="#最短路问题：" class="headerlink" title="最短路问题："></a>最短路问题：</h2><h3 id="单源最短路问题"><a href="#单源最短路问题" class="headerlink" title="单源最短路问题"></a>单源最短路问题</h3><h4 id="Dijkstral算法："><a href="#Dijkstral算法：" class="headerlink" title="Dijkstral算法："></a>Dijkstral算法：</h4><p>我们首先得到一个边权值全为1的图，那么这个图中的单源最短路问题显然可以用BFS解。在解这个问题的时候，维护一个队列，这个队列存的是刚刚更新过的节点编号。并且在这个队列里面，排序的顺序是节点dis顺序递增的。也就是说，每次弹出的队首元素是目前确定下来的节点中的dis最小的那个。 根据等式dis[v] = dis[u] + 1; 要使得dis[v]最小，显然要取dis[u]，而我们每次都取出队列中dis最小的节点，让它去更新其他点，然后将更新过的点，放入队列中…直到队列为空。</p>
<p>即我们想要更新dis[v] = dis[u] + 1的话，一定要取最小的dis[u]。</p>
<p>当我们图的权值不全为1的时候，我们就需要来维护一个优先队列。每次出队的是目前dis最小的点，然后让它去更新dis[v] = dis[u] + w(u, v); 然后将v放入队列。虽然这个时候的dis[v] 不像之前那样就直接确定了，但可以确定是 dis[u] 肯定要小于dis[v] , 接下了队列中弹出下一个点去更新其他点，一直到v从队列中弹出时，dis[] 比他小的点已经全部弹出去更新点了，所以此时dis[v] 已经能够确定为最小值了。</p>
<h4 id="Bellman-Ford算法"><a href="#Bellman-Ford算法" class="headerlink" title="Bellman_Ford算法"></a>Bellman_Ford算法</h4><p>外层一个n - 1次循环，内层循环遍历每条边，进行松弛操作。</p>
<p>但我们发现，这样子nm就跑满了，有大部分冗余操作。我们实际上每次循环要考虑的边，是上次循环更新过的点发出的边。因此用一个队列进行优化，得到了SPFA算法</p>
<h2 id="割点与割边"><a href="#割点与割边" class="headerlink" title="割点与割边"></a>割点与割边</h2><p>在一个无向图中，如果有一个顶点集合，<strong>删除这个顶点集合以及这个集合中所有顶点相关联的边以后，图的连通分量增多，就称这个点集为割点集合</strong>，如果某个割点集合只含有一个顶点 X（也即{X}是一个割点集合），那么X称为一个割点。</p>
<p>类似的，在一个无向图中，如果有一个边集合，<strong>删除这个边集合以后，图的连通分量增多，就称这个边集为割边集合</strong>，如果某个割边集合只含有一条边 X（也即{X}是一个边集合），那么X称为一个割边，也叫做桥。</p>
<h3 id="Tarjan算法求割点与割边模板"><a href="#Tarjan算法求割点与割边模板" class="headerlink" title="Tarjan算法求割点与割边模板"></a>Tarjan算法求割点与割边模板</h3><p>我们先回顾一下Tarjan算法的精髓— dfn 和 low</p>
<p>dfn（x）为节点 x 搜索的次序编号（时间戳）；<br>low（x）为 x 或 x 的子树能够追溯到的最早的祖先的次序号。</p>
<p><strong>割点:</strong></p>
<p>对于一个点 u，有以下两种情况：</p>
<p>如果 u 是根节点，那么当它有多于一个子树时，它就是割点<br>如果 u 不是根节点，并且 u 为 v 在搜索树中的父亲，当 dfn[ u ] ≤ low[ v ] 时，它就是割点  </p>
<p><strong>割边:</strong></p>
<p>一条边（u，v）是割边，当且仅当 u 为 v 在搜索树中的父亲，并且 dfn[ u ] &lt; low[ v ]</p>
<p>在实现的时候，由于有重边的存在，我们还要用一个数组记录一下树枝边</p>
<p><strong>更新low值</strong></p>
<p>起初，low[ u ] = dfn [ u ]，表示能追溯到的最早祖先就是 u</p>
<p>现有一条边（u，v）</p>
<p>如果 dfn[ v ] == 0，那么就继续dfs，回溯的时候 low[ u ] = min ( low[ u ] , low[ v ] )</p>
<p>如果 dfn[ v ] != 0，那么 low[ u ] = min ( low[ u ] , dfn[ v ] )</p>
<p>求割点模板</p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2e4 + 10;
int cnt, head[MAXN], dfn[MAXN], root, low[MAXN], tot;
bool cut[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2];
void addEdge(int u, int v)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u, int root)
{
    int child = 0;
    tot++;
    dfn[u] = tot;
    low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v, root);
            low[u] = min(low[u], low[v]);
            if(u != root &amp;&amp; low[v] &gt;= dfn[u])   cut[u] = true;
            if(u == root)   child++;
        }
        low[u] = min(low[u], dfn[v]);
    }
    if(u == root &amp;&amp; child &gt;= 2) cut[root] = true;
}
int solve(int n, int m)
{
    for(int i = 1; i &lt;= n; i++)
        if(dfn[i] == 0)
            Tarjan(i, i);
    int ans = 0;
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  ans++;
    return ans;
    /*
    for(int i = 1; i &lt;= n; i++)
        if(cut[i])  printf(&quot;%d&quot;, i);    //输出割点编号
    */
}
void init()
{
    cnt = tot = 0;
    memset(head, -1, sizeof head);
    memset(cut, false, sizeof cut);
    memset(dfn, 0, sizeof dfn);

}
int main()
{
    int t, kase = 0, n, m;
    cin &gt;&gt; t;
    while(t--)
    {
        init();
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            addEdge(a, b);
            addEdge(b, a);
        }
        int ans = solve(n, m);
        printf(&quot;Case %d: %d\n&quot;, ++kase, ans);            //割点的数目
    }
    return 0;
}</code></pre><p><strong>求割边模板</strong></p>
<pre><code>#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#define md(x, y)  (x + y) / 2
#define ls(x)      x &lt;&lt; 1
#define rs(x)      x &lt;&lt; 1 | 1
#define fileopen freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout)
#define fileclose fclose(stdin); fclose(stdout)
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e5 + 10;
const int MAXM = 1e5 + 10;
int cnt, tot, head[MAXN], fron[MAXN], dfn[MAXN], low[MAXN];
struct Edge
{
    int v, next;
}edge[MAXM * 2], cut[MAXM * 2];
void addEdge(Edge *edge, int u, int v, int *head)
{
    cnt++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    tot = cnt = 0;
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(fron, -1, sizeof fron);
}
void Tarjan(int u, int root)
{
    ++tot;
    dfn[u] = low[u] = tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(v == root)   continue;   //双向边
        if(dfn[v] == 0)
        {
            Tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] &gt; dfn[u])                 //AC
                if(u &lt; v)
                    addEdge(cut, u, v, fron);
                else addEdge(cut, v, u, fron);

        }
        low[u] = min(low[u], dfn[v]);
    }

}
int solve(int n)
{
    for(int i = 0; i &lt; n; i++)
        if(dfn[i] == 0) Tarjan(i, i);
    int ans = 0;
    for(int u = 0; u &lt; n; u++)
        for(int i = fron[u]; i != -1; i = cut[i].next)
            ans ++;
    return ans;
}
int main()
{
    int t, n;
    cin &gt;&gt;t;
    for(int kase = 1; kase &lt;= t; kase ++)
    {
        //点的数目
        init();
        scanf(&quot;%d&quot;, &amp;n);
        for(int i = 1; i &lt;= n; i++)
        {
            int u, k, v;
            scanf(&quot;%d (%d)&quot;, &amp;u, &amp;k);
            while(k--)
            {
                scanf(&quot;%d&quot;, &amp;v);
                addEdge(edge, u, v, head);
            }
        }
        cnt = 0;
        int ans = solve(n);
        printf(&quot;Case %d:\n&quot;, kase);
        printf(&quot;%d critical links\n&quot;, ans);
        for(int u = 0; u &lt; n; u++)          //点的编号从0开始
        {
            vector &lt; int &gt; vec;
            vec.clear();
            for(int i = fron[u]; i != -1; i = cut[i].next)
                vec.push_back(cut[i].v);
            sort(vec.begin(), vec.end());
            for(int i = 0; i &lt; vec.size(); i++)
                printf(&quot;%d - %d\n&quot;, u, vec[i]);
        }
    }
    return 0;
}</code></pre><h3 id="边双连通分量"><a href="#边双连通分量" class="headerlink" title="边双连通分量"></a>边双连通分量</h3><p>若一个无向图中的去掉任意一个节点（一条边）都不会改变此图的连通性，<strong>即不存在割点（桥）</strong>，则称作点（边）双连通图。<strong>一个无向图中的每一个极大点（边）双连通子图称作此无向图的点（边）双连通分量</strong>。</p>
<p>Tarjan求边双连通分量模板</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 3715 Go Deeper</title>
    <url>/tpaaaaaa.github.io/2019/09/03/HDU-3715GoDeeper/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个递推式，问你最多能循环几层？</p>
<p>go(int dep, int n, int m)<br>begin<br>output the value of dep.<br>if dep &lt; m and x[a[dep]] + x[b[dep]] != c[dep] then go(dep + 1, n, m)<br>end   </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样的 二分答案+ 2-SAT。 代码不难敲，重要的是思路。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>二分部分：</p>
<pre><code>int L = 0;
int R = m;
int mid;
int ans = -1;
while(L &lt;= R) //一般整型就可以这样，浮点形的等于不好用。
{
    mid = (L + R) / 2;
    built(mid);             //一直到第mid个约束条件，那么深度就是mid - 1；每次都要建一个新图哦！！！
    if(solve())             //如果满足约束条件，说明深度可以变大，添加更多的约束条件
    {
        ans = max(ans, mid);
        L = mid + 1;        //如果mid = L的话  可以无限循环
    }
    else                    //不满足，说明减少一些深度
        R = mid - 1;
}</code></pre><p>完整代码+分析：</p>
<pre><code>/*
 Date              : 2019-09-03-18.47.52
 Question_Number   ：hdu 3715
 Question_Name     ：2 sat
 Description       :
 n = 2, m = 1;
 a 0
 b 1
 c 0

 x[ai] + x[bi] != ci;
 a1 表示a选0   意思是x这个数组里面ai位置选0
 a2 表示a选1                              1
 因为x这个数组长为n
 所以图中实际上有2n个点
 这2n个点，编号从0开始

 0 1   2 3   4 5

 a1  为 ai * 2;
 a2  为 ai * 2 + 1;
 b1 为

 i*2  i*2+1
 得到约束条件
 a1 - &gt; b2;
 b1 - &gt; a2;

 x[a] + x[b] != 1;
 a2 &gt; b2;
 b2 &gt; a2;
 a1 &gt; b1;
 b1 &gt; a1;

 x[a] + x[b] != 2;
 a2 &gt; b1;
 b2 &gt; a1;
 // 要使得他们不为0

 //为什么要二分呢？？  因为可以简化深度越大，意味着所连的边就越多
                                        //就越有可能ai 和 ai^1 形成一个环
                                        // 假如一个图中  所有 ai 和 ai ^ 1 都不在一个环内
                                        // 那么删掉一些边，这些对点肯定也不再一个环内
                                        // 这就出现了单调性
                                                //  最多有m个条件
        //  所以可以二分边界   0 &lt;= dep &lt;= m
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2*200 + 10;  //图中点的数目为
const int MAXM = 1e4 + 10;
int a[MAXM], b[MAXM], c[MAXM];
int dfn[MAXN], low[MAXN], belong[MAXN], head[MAXN];
bool vis[MAXN];
int n, m, cnt, sum, tot;
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXN * MAXN];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void init()
{
    memset(head, -1, sizeof head);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    cnt = sum = tot = 0;
}
void built(int mid)
{
    init();                         //建图之前  清空图
    for(int i = 1; i &lt;= mid; i++)
    {
        int a1 = a[i] * 2;
        int a2 = a[i] * 2 + 1;
        int b1 = b[i] * 2;
        int b2 = b[i] * 2 + 1;
        switch(c[i])
        {
                case 0:
                    {
                        addEdge(a1, b2);
                        addEdge(b1, a2);
                        break;
                    }
                case 1:
                    {
                        addEdge(a2, b2);
                        addEdge(b2, a2);
                        addEdge(a1, b1);
                        addEdge(b1, a1);
                        break;
                    }
                case 2:
                    {
                        addEdge(a2, b1);
                        addEdge(b2, a1);
                        break;
                    }
        }
    }

}
void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++ tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}
bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)       //图中点的编号为0 ... 2n - 1
        if(dfn[i] == 0)
            Tarjan(i);
    for(int i = 0; i &lt; 2*n; i+= 2)
        if(belong[i] == belong[i + 1])
            return false;

    return true;
}
int main()
{
    int t;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;, &amp;n, &amp;m);
        for(int i = 1; i &lt;= m; i++)
            scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;c[i]);
        int L = 0;
        int R = m;
        int mid;
        int ans = -1;
        while(L &lt;= R)
        {
            mid = (L + R) / 2;
            built(mid);             //一直到第mid个约束条件，那么深度就是mid - 1；
            if(solve())             //如果满足约束条件，说明深度可以变大，添加更多的约束条件
            {
                ans = max(ans, mid);
                L = mid + 1;        //如果mid = L的话  可以无限循环
            }
            else                    //不满足，说明减少一些深度
                R = mid - 1;
        }

         printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>二分，2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3622 Bomb Game</title>
    <url>/tpaaaaaa.github.io/2019/09/03/HDU-3622BombGame/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>每回合给定两个坐标点，可以选择一个放置炸弹，自己决定炸弹的半径，问 n 个回合后，使炸弹半径最小值最大。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>二分答案 + 2-SAT;</p>
<p>如何看出用2-SAT呢，因为每回合有两个选择，只能选其中一个。</p>
<p>二分是因为，随着爆炸的半径越大，约束条件就越来越多，约束条件越来越多就意味着存在某对点在同一环的情况就越有可能发生。 是一个单调的，所以可以用二分来求。</p>
<p>二分确定一个半径，然后将所有点中距离小于这个两倍这个半径的两个点(a, b)找出来，说明这两个点在这个半径情况下，不能同时选择,所以一旦选择了a点，那么我们不能选择b点，只能选择b的对立点b^1(b^1 表示b的对立点)，同样的，一旦我们选择了b点，我们就只能选择a的对立点 (a^1 表示a的对立点) 。因此诞生了两个约束条件。</p>
<p>在这个半径的情况下，如果存在满足这个的可能，说明还能添加更多的约束条件，也就是还能添加更多边(约束边)，所以向更大的区间进行二分。如果不能满足这个可能，说明要减少一些边，才能使得某对点由原来的在同一个环中变成不在同一个环中的情况，也就是要往更小的区间二分。</p>
<p><strong>注意：每次二分一个条件后，要重新建一个图哦！！！</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>二分部分</p>
<pre><code>double L = 0.0;              
double R = 40001.0;
double ans = -1; //最大的半径
while( R - L &gt; eps)            // 如果是 R &lt;= L,  则 L = mid - 1 
                                                 // or R = mid + 1;
{
    double mid = (L + R) / 2;
    init();                            //每次都要重新建图！！！
    for(int i = 1; i &lt; 2*n; i += 2)  // 1 3 5 ..
        for(int j = i + 2; j &lt;= 2*n; j ++)//3 4 5 ...
        {
            if(getDis(node[i], node[j]) &lt; 2 * mid) //意思是i j 之间不能选
                int aj;
                if(j % 2)
                    aj = j + 1;
                else
                    aj = j - 1;
                addEdge(i, aj);  //j + 1是j的对立点
                addEdge(j, i + 1);
            }

    for(int i = 2; i &lt;= 2*n; i += 2) // 2 4 6 ...
        for(int j = i + 1; j &lt;= 2*n; j ++)// 3 5 6 ...
            if(getDis(node[i], node[j]) &lt; 2 * mid) //
            {
                int aj;
                if(j % 2)
                    aj = j + 1;
                else
                    aj = j - 1;
                addEdge(i, aj);
                addEdge(j, i - 1);
            }
    if(solve())                                     //这个mid可行，那么mid往右走，变大一些
    {
        ans = max(ans, mid);                        //记录答案
        L = mid;// 因为是 R &lt; L, 所以这样子ok
    }
    else
    {
        R = mid;
    }
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>二分，2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1824 Let&#39;s go home</title>
    <url>/tpaaaaaa.github.io/2019/09/03/HDU-1824Let&#39;sgohome/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>小时候，乡愁是一枚小小的邮票，我在这头，母亲在那头。<br>                        —— 余光中 </p>
<p>集训是辛苦的，道路是坎坷的，休息还是必须的。经过一段时间的训练，lcy决定让大家回家放松一下，但是训练还是得照常进行，lcy想出了如下回家规定，每一个队（三人一队）或者队长留下或者其余两名队员同时留下；每一对队员，如果队员A留下，则队员B必须回家休息下，或者B留下，A回家。由于今年集训队人数突破往年同期最高记录，管理难度相当大，lcy也不知道自己的决定是否可行，所以这个难题就交给你了，呵呵，好处嘛~，免费**漂流一日。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>同样的，根据题目给的条件，建立约束边。a1表示队长离开，a2表示队长留下，b1表示第一个队员离开 …..</p>
<p>那么对于第一个规定，如果队长留下了那么 其他队员肯定要离开，则形成了约束条件</p>
<p>a2 -&gt; b1 ; a2 -&gt; c1; //选了a2 就必选b1 c1</p>
<p>对于第一个规定，如果队长离开了，那么必然有其他两名队友留下</p>
<p>a1 -&gt; b2; a1 - &gt; c2 //</p>
<p>同样的，在第一种情况里面，如果b留下了，c肯定一同留下，b走了，c肯定一同走了，所以存在约束条件</p>
<p>b1 - &gt; c1; b2 - &gt; c2;</p>
<p>同样的b留下了， a肯定走， b走了，a肯定留下。。。。</p>
<p>对此会有一大堆约束条件</p>
<p>我们尽量以点来分类，对每个点的情况进行全方面的约束分析。</p>
<p>另外的规范的分析法</p>
<p>对于a点，如果a留下了，b肯定会走，c肯定会走</p>
<p>得到约束条件 a2 - &gt; b1, a2 - &gt; c1;</p>
<p>对于a点，如果a走了，b肯定会留下，c肯定会留下</p>
<p>得到约束条件 a1 - &gt; b2, a1 - &gt; c2;</p>
<p>对于b点，如果b走了，那么a肯定会留下，c肯定会走</p>
<p>b1 - &gt; a2; b1 - &gt; c1;</p>
<p>对于b点，如果b留下了，那么a肯定会离开，c肯定会留下</p>
<p>b2 - &gt; c2, b2 - &gt; a1;</p>
<p>对于c点，如果c走了，那么a肯定会留下，b肯定会走</p>
<p>c1 - &gt; a2, c1 - &gt;b1;</p>
<p>对于c点，如果c留下了，那么a肯定会离开，b肯定会走</p>
<p>c2 - &gt; a1; c2 - &gt; b2;</p>
<p>所以第一个规则下，诞生了12个约束条件</p>
<p>对于第二个规则，相对而言更直接，就不加赘述了。</p>
<p>此后，图建完了，跑一边Tarjan看看同一个点的两个状态是否在同一个环内，如果是则说明不符合条件..</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-09-03-12.55.06
 Question_Number   ：hdu 1824
 Question_Name     ：2 sat
 Description       :
 枚举每个队伍的情况，如果队长回去，然后继续枚举其他队伍，如果存在，则ok
 否则 队员回去..继续dfs
 题解比较硬核，就直接全部分析了
 好蠢的方法，但真香。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e3 + 10;
const int MAXM = 6 * MAXN;
stack &lt; int &gt; st;
int head[MAXM], low[MAXM], dfn[MAXM], belong[MAXM];
bool vis[MAXM];
int cnt, sum, n, m, tot;
struct Edge
{
    int v, next;
};
Edge edge[MAXM*MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++tot;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
   // printf(&quot;?&quot;);
}
bool solve()
{
    for(int i = 0; i &lt; 2 * n; i++)
        if(dfn[i] == 0)
            Tarjan(i);
   // printf(&quot;?&quot;);
    for(int i = 0; i &lt; n; i++)
        if(belong[i * 2] == belong[i * 2 + 1])
            return false;
    return true;
}
void init()
{
    cnt = sum = tot = n = 0;
    memset(head, -1, sizeof head);
    memset(vis, false, sizeof vis);
    memset(dfn, 0, sizeof dfn);
}
int main()
{
    int t;
    while(scanf(&quot;%d%d&quot;, &amp;t, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= t; i++)
        {
            int a, b, c;

            scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
            n = max(n, a);
            n = max(n, b);
            n = max(n, c);
            int a1 = a * 2;
            int a2 = a * 2 + 1;
            int b1 = b * 2;
            int b2 = b * 2 + 1;
            int c1 = c * 2;
            int c2 = c * 2 + 1;
            addEdge(a1, b2);    //a走b留
            addEdge(a1, c2);    //a  c
            addEdge(b1, c1);    //b走c走
            addEdge(b1, a2);
            addEdge(c1, b1);    //c走b走
            addEdge(c1, a2);

            addEdge(a2, b1);
            addEdge(a2, c1);
            addEdge(b2, a1);
            addEdge(b2, c2);
            addEdge(c2, a1);
            addEdge(c2, b2);

        }
        for(int i = 1; i &lt;= m; i++)
        {
            int a, b;
            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);
            n = max(n, a);
            n = max(n, b);
            int a1 = a * 2;         //a 回去
            int a2 = a * 2 + 1;     //a 不回去
            int b1 = b * 2;
            int b2 = b * 2 + 1;
            addEdge(a1, b2);    //a回去，b就不能回去
            addEdge(b1, a2);    //b回去了，a就不能回去
        }
      //  printf(&quot;n = %d\n&quot;, n);
      //  printf(&quot;?&quot;);
        if(solve())
            printf(&quot;yes\n&quot;);    //直接用Tarjan缩点就行
        else
            printf(&quot;no\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3062 Party</title>
    <url>/tpaaaaaa.github.io/2019/09/03/HDU-3062Party/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n对夫妻被邀请参加一个聚会，因为场地的问题，每对夫妻中只有1人可以列席。在2n 个人中，某些人之间有着很大的矛盾（当然夫妻之间是没有矛盾的），有矛盾的2个人是不会同时出现在聚会上的。有没有可能会有n 个人同时列席？</p>
<h3 id="input："><a href="#input：" class="headerlink" title="input："></a>input：</h3><p>n： 表示有n对夫妻被邀请 (n&lt;= 1000)<br>m： 表示有m 对矛盾关系 ( m &lt; (n - 1) * (n -1)) </p>
<p>在接下来的m行中，每行会有4个数字，分别是 A1,A2,C1,C2<br>A1,A2分别表示是夫妻的编号<br>C1,C2 表示是妻子还是丈夫 ，0表示妻子 ，1是丈夫<br>夫妻编号从 0 到 n -1 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>裸的2-SAT模板，点都帮你分好了，就借此题来分析一下用强连通分量解2-SAT问题的代码吧</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>数据录入部分</p>
<pre><code>for(int i = 1; i &lt;= m; i++)    // 存在m个矛盾关系
{
    int a1, a2, c1, c2;        //意思是第a1 和 a2对夫妻之间有矛盾
                               // 值得是c1 和 c2 有矛盾
    scanf(&quot;%d%d%d%d&quot;, &amp;a1, &amp;a2, &amp;c1, &amp;c2);
    a1 = 2 * a1 + c1;         // 这个a1存的是图中那个点的编号
    a2 = 2 * a2 + c2;         // 意思是a1 和 a2 不能相连
    addEdge(a1, a2^1);        // 那么a1 只能和 a2的相对点联合
    addEdge(a2, a1^1);        // a2只能和a1的相对点联合
}
if(solve())
    printf(&quot;YES\n&quot;);
else
    printf(&quot;NO\n&quot;);</code></pre><p>一般的裸题就直接一遍录入一遍建图即可，但某些需要二分的题目，就是先二分条件，然后再在这个条件下建图，去跑一边2-SAT看看能不能成立。</p>
<p>solve函数部分</p>
<pre><code>bool solve()
{
    for(int i = 0; i &lt; 2*n; i++)  // 要清楚真正的图中的点数，点的编号等
        if(dfn[i] == 0)
            Tarjan(i);           //对每个点进行缩点
    for(int i = 0; i &lt; n; i++)
        if(belong[i*2] == belong[i*2 + 1])  //如果一个点和他的相对点相连通了，说明违背了题目中的选了妻子不能选丈夫，选了丈夫不能选妻子的条件，所以不满足条件
            return false;
    return true;
}</code></pre><p>Tarjan部分</p>
<pre><code>void Tarjan(int u)
{
    vis[u] = true;
    st.push(u);
    low[u] = dfn[u] = ++dfsClock;
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])
            low[u] = min(low[u], dfn[v]);
    }

    if(dfn[u] == low[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong[temp] = sum;
        }
        st.pop();
        vis[u] = false;
        belong[u] = sum;
    }
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]2-SAT</title>
    <url>/tpaaaaaa.github.io/2019/09/02/%5B%E7%AE%97%E6%B3%95%5D2-SAT/</url>
    <content><![CDATA[<p>博客连接：</p>
<p><a href="https://www.cnblogs.com/cjjsb/p/9771868.html" target="_blank" rel="noopener">https://www.cnblogs.com/cjjsb/p/9771868.html</a></p>
<h2 id="何为SAT问题"><a href="#何为SAT问题" class="headerlink" title="何为SAT问题:"></a>何为SAT问题:</h2><blockquote>
<p>SAT是适定性(Satisfiability)问题的简称 。一般形式为k-适定性问题，简称 k-SAT。</p>
</blockquote>
<p>可以证明，当k&gt;2时，k-SAT是<strong>NP完全</strong>的。因此一般讨论的是k=2的情况，即2-SAT问题。</p>
<p>我们通俗的说，就是给你<strong>n个变量ai</strong>，每个变量<strong>能且只能</strong>取0/1的值。同时给出若干条件，形式诸如(not)ai <strong>opt</strong> (not) aj = 0/1，其中opt表示and,or,xor中的一种</p>
<p>而求解2-SAT的解就是求出满足所有限制的一组a</p>
<h2 id="如何将2-SAT问题转化为图论问题"><a href="#如何将2-SAT问题转化为图论问题" class="headerlink" title="如何将2-SAT问题转化为图论问题:"></a>如何将2-SAT问题转化为图论问题:</h2><p>首先我们考虑将2-SAT问题往图论的方向靠，我们发现每个点<strong>要么取0，要么取1</strong>。因此对于ai，我们建两个点<strong>2i−1与2i</strong>分别表示ai取0和1//奇0偶1</p>
<p>然后我们考虑建边来表示这些关系，我们令一条<strong>有向边</strong>的意义：x→y表示如果选择了x就必须选y</p>
<p>那么我们可以举一些简单的例子来总结下连边的规律（用i′表示i的反面）：</p>
<ul>
<li>i,j<strong>不能</strong>同时选：选了i就要选j′，选j就要选i′。故i→j′,j→i′。一般操作即为ai or aj = 1</li>
<li>i,j<strong>必须</strong>同时选：选了i就要选j，选j就要选i。故i→j,j→i。一般操作即为aixoraj=0</li>
<li>i,j<strong>任选（但至少选一个）</strong>选一个：选了i就要选j′，选j就要选i′，选i′就要选j，选j′就要选i。故i→j′,j→i′,i′→j,j′→i。一般操作即为ai or aj=1</li>
<li>i<strong>必须</strong>选：直接i′→i，可以保证无论怎样都选i。一般操作为给出的ai=1或ai and aj=1</li>
</ul>
<p>建好图然后就是考虑怎么用图论的方式解决2-SAT了。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 1878  欧拉回路</title>
    <url>/tpaaaaaa.github.io/2019/09/01/HDU-1878%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>现给定一个有向图，问是否存在欧拉回路？</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>要想使用连通有向图存在欧拉回路的条件，首先要<strong>证明给定的有向图是连通的。</strong></p>
<p><strong>注意：有向图的连通和强连通不同，可以将有向图暂时看成无向图，如果这个无向图连通，则这个有向图也连通。</strong></p>
<p>好吧，题目给的是无向图，我看错了，但是以上任然成立。</p>
<p>有向图的连通性，可以用并查集来求即可，（众所周知也可以用warshall算法（传递关系闭包算法）来求一个关系矩阵）。如果最后 i == findRoot(i) 的点只有一个，那么说明这个图是连通的。</p>
<p>证明完连通性后就可以利用 之前博客里面的条件求解了。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>欧拉回路，判断图连通</tag>
      </tags>
  </entry>
  <entry>
    <title>poj 1041 John&#39;s trip</title>
    <url>/tpaaaaaa.github.io/2019/09/01/poj1041John&#39;strip/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>判断无向图是不是欧拉图，如果是则求出欧拉回路。欧拉回路输出时候要字典序最小。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先已知无向图是连通的，因此要判断连通的无向图是不是欧拉图，我们只需要看每个点的度是不是偶数即可。</p>
<p>如果是欧拉图，那么我们就用基本（套圈）法求出欧拉回路即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是录入部分，题目比较奇葩，不给你N和M。</p>
<pre><code>    while(scanf(&quot;%d%d&quot;, &amp;x, &amp;y) &amp;&amp; x + y)
    {
        init();
        scanf(&quot;%d&quot;, &amp;z);
        degree[x]++;                //x的度加1
        degree[y]++;             
        m ++;                       //m记录边数
        n = max(x, y);              //n记录点数
        edge[z].x = x;
        edge[z].y = y;
        edge[z].del = false;        //del = true 表示这个边已经访问过了
        while(scanf(&quot;%d%d&quot;, &amp;x, &amp;y) &amp;&amp; x + y)
        {
            scanf(&quot;%d&quot;, &amp;z);
            edge[z].x = x;
            edge[z].y = y;
            edge[z].del = false;
            n = max(x, y);
            m ++;
            degree[x]++;
            degree[y]++;
        }
.............</code></pre><p>接下来是从任意一个点开始用dfs求欧拉回路</p>
<pre><code>void dfs(int u)                    //套圈法求欧拉回路
{
    for(int i = 1; i &lt;= m; i++)    //枚举与u相连的没有访问过的边，随便哪一条都行
    {
        int x = edge[i].x;
        int y = edge[i].y;
        if((x == u || y == u) &amp;&amp; edge[i].del == false)
        {
            edge[i].del = true;   //将这个边标记为已访问过
            if(x == u)
                dfs(y);           // 从下一个点开始dfs
            else
                dfs(x);
            vec.push_back(i);    // 最后会重新绕回到起点，所以逆序将边存入，之前从某点到起点的点，变成起点到的第一个点。
        }

    }

}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>欧拉回路，套圈法</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]欧拉路径问题与欧拉回路问题</title>
    <url>/tpaaaaaa.github.io/2019/09/01/%5B%E7%AE%97%E6%B3%95%5D%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>博客链接：<a href="https://www.cnblogs.com/shao0099876/p/7366852.html" target="_blank" rel="noopener">https://www.cnblogs.com/shao0099876/p/7366852.html</a></p>
<p>求解欧拉回路的算法：<a href="https://www.cnblogs.com/Ash-ly/p/5397702.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ash-ly/p/5397702.html</a></p>
<h3 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a><strong>一、基本概念：</strong></h3><p><strong>欧拉路</strong>：欧拉路是指从图中任意一个点开始到图中任意一个点结束的路径，并且<strong>图中每条边通过的且只通过一次</strong>。</p>
<p><strong>欧拉回路:</strong>欧拉回路是指起点和终点相同的欧拉路。</p>
<h2 id="二、存在欧拉路和欧拉回路的条件"><a href="#二、存在欧拉路和欧拉回路的条件" class="headerlink" title="二、存在欧拉路和欧拉回路的条件:"></a><strong>二、存在欧拉路和欧拉回路的条件:</strong></h2><p>1.<strong>无向连通图</strong>存在欧拉路的条件：</p>
<blockquote>
<p><strong>所有点度都是偶数，或者恰好有两个点度是奇数，则有欧拉路。</strong>若有奇数点度，则奇数点度点一定是欧拉路的起点和终点，否则可取任意一点作为起点。</p>
</blockquote>
<p>2.<strong>有向连通图</strong>存在欧拉路的条件：</p>
<ul>
<li><strong>每个点的入度等于出度，则存在欧拉回路</strong>（任意一点有度的点都可以作为起点）</li>
<li><strong>除两点外，所有入度等于出度。</strong>这两点中一点的出度比入度大，另一点的出度比入度小，则存在欧拉路。取出度大者为起点，入度大者为终点。</li>
</ul>
<p><strong>3.有向连通图</strong>存在欧拉回路的条件</p>
<p>图连通，所有的顶点<strong>出度=入度</strong>。</p>
<p><strong>4.无向连通图</strong>存在欧拉回路的条件</p>
<p>图连通，所有顶点都是<strong>偶数度</strong>。</p>
<hr>
<h2 id="三、无向图欧拉路径的求解方法"><a href="#三、无向图欧拉路径的求解方法" class="headerlink" title="三、无向图欧拉路径的求解方法"></a>三、无向图欧拉路径的求解方法</h2><p>　　欧拉路径的求解方法一般是使用深度优先搜索（以下简称DFS）来做。</p>
<p>　　首先我们需要确定搜索的起点。<strong>如果度数全为偶数</strong>，由欧拉回路在无向图中存在的充要条件（图中顶点度数全为偶数）可知，搜索结果必定为一条环，<strong>所以用任何一个顶点当做起点都可以得到一条欧拉路径</strong>。<strong>如果有两个奇度数顶点</strong>，那么欧拉路径必<strong>定以一个顶点作为出发点，以另一个顶点作为终点</strong>。因此从两个顶点中选一个出来即可。关于这一点可以解释为：欧拉路径如果要经过所有的边，对于度数为偶数的点必定是“到达-&gt;离开”这样的访问形式，不会在此停留（也就是中间点），这可以解释两个奇度数顶点的情况，<strong>全偶度数顶点的情况可以理解为奇度数的出发点与奇度数的终点重合为同一个偶度数的点。</strong></p>
<p>　　欧拉路径在无向图中的求解可以用“过河拆桥”来形容。通过定义我们可以得到：<strong>如果我们经过了一条边，那么在以后的搜索过程中我们不能再次经过这条边，因此要把这条边删除掉，使得搜索的过程中不会出现重复的情况。</strong>计算过程如下：</p>
<p>　　1.用图的数据初始化顶点，vis标记设为false。</p>
<p>　　2.按上述方法寻找起点，同时排除不合法情况。</p>
<p>　　3.从起点开始DFS，每次访问到顶点x的时候，将vis标记设为true，枚举x的邻接边，如果边没有被删除（del标记为false），那么就删除这条边（del设为true），同时找到下一个顶点，也删除这条边（无向图），DFS下一顶点，直到无法扩展，将顶点压栈。最后得到的栈按顺序出栈得到的序列就是顶点的访问顺序。</p>
<p>　　4.检查顶点的访问情况，如果有<strong>没有访问到的顶点</strong>就说明图<strong>不是连通图</strong>，不是合法情况。</p>
<h2 id="四、有向图欧拉路径求解方法"><a href="#四、有向图欧拉路径求解方法" class="headerlink" title=" 四、有向图欧拉路径求解方法"></a> 四、有向图欧拉路径求解方法</h2><p>　　与无向图欧拉路径求解方法类似，但是有以下改动：</p>
<p>　　1.如果顶点的入度和出度均相等，情况同无向图全偶度数顶点。如果顶点中有一个 出度 - 入度 = 1，有一个 入度 - 出度 = 1，那么用 入度 - 出度 = 1的顶点作为起点</p>
<p>　　2.删除边的时候只需要从起点删除一次即可</p>
<h2 id="update：-下面找到的是更好的博文"><a href="#update：-下面找到的是更好的博文" class="headerlink" title="update： 下面找到的是更好的博文"></a>update： 下面找到的是更好的博文</h2><p>求解欧拉回路的算法：<a href="https://www.cnblogs.com/Ash-ly/p/5397702.html" target="_blank" rel="noopener">https://www.cnblogs.com/Ash-ly/p/5397702.html</a></p>
<p><strong>基本(套圈)法</strong>：</p>
<p>首先从一个节点(v0)出发，随便往下走(走过的边需要标记一下，下次就别走了)，当走到不能再走的时候，<strong>所停止的点必然也是起点</strong>(因为所有的点的度数都是偶数，能进去肯定还会出来，再者中间有可能再次经过起点，但是如果起点还能继续走，那么就要继续往下搜索，直到再次回来时不能往下搜索为止)，<strong>然后停止时，走过的路径形成了一个圈</strong>，但因为是随便走的，所以可能有些边还没走就回来了，那些剩下的边肯定也会形成一个或者多个环，然后可以从刚才终止的节点往前回溯，找到第一个可以向其他方向搜索的节点(vi)，然后再以这个点继续往下搜索，同理还会继续回到该点(vi)，于是这个环加上上次那个环就构成了一个更大的环，即可以想象成形成了一条从 v0 到 vi的路径，再由 vi 走了一个环回到 vi，然后到达v0 的一条更长的路径，如果当前的路径还不是最长的，那么继续按照上面的方法扩展。只需要在回溯时记录下每次回溯的边，最后形成的边的序列就是一条欧拉回路。如果要记录点的顺序的话，那么每访问一个点，就把这个点压入栈中，当某个点不能继续搜索时，即在标记不能走的边是，这个点成为了某种意义上的孤点，然后把这个点输出最后得到的就是一条欧拉回路路径的点的轨迹。</p>
<p>　　总之，求欧拉回路的方法是，使用深度优先搜索，如果某条边被搜索到，则标记这条边为已选择，并且即使回溯也不能将当前边的状态改回未选择，每次回溯时，记录回溯路径。深度优先搜索结束后，记录的路径就是欧拉回路。</p>
<p><strong>下面用图描述一遍：</strong></p>
<p><img src="http://localhost/wp-content/uploads/2019/09/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-2.png" alt=""></p>
<p><img src="http://localhost/wp-content/uploads/2019/09/%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF-3.png" alt=""></p>
<p>假设我们选择从v1开始走,由于随便走，所以可能出现以下走法</p>
<p>第一步：v1 – v9</p>
<p>第二步：v9 – v8</p>
<p>第三步：v8 – v10</p>
<p>第四步：v10 – v1</p>
<p>此时由于走过的边不能再走，那么从 v1 就无法继续向下探索,所以往前回溯,记录边集Eu{&lt;v1, v10&gt;}，此时回溯到 v10 ,发现可以继续走，那么</p>
<p>第五步: v10 – v3</p>
<p>第六步: v3 – v2</p>
<p>第七步: v2 – v4</p>
<p>第八步: v4 – v10</p>
<p>发现已经无路可走，那么继续回溯，记录回溯路径得到Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;}，此时回溯到了 v8.发现可以向其他方向搜索, 那么</p>
<p>第九步：v8 – v6</p>
<p>第十步：v6 –v7</p>
<p>第十一步：v7– v8</p>
<p>又无路可走，继续回溯Eu{&lt;v1,v10&gt;, &lt;v10, v4&gt;, &lt;v4, v2&gt;, &lt;v2, v3&gt;, &lt;v3, v10&gt;, &lt;v10, v8&gt;, &lt;v8, v7&gt;, &lt;v7, v6&gt;,&lt;v6,v8&gt;,&lt;v8,v9&gt;,&lt;v9,v1&gt;}，到这里整个DFS就结束了，我们得到的边集Eu就是一条欧拉回路。</p>
<p><strong>具体实现与分析:</strong></p>
<p>使用链式前向星和DFS实现寻找欧拉回路的算法，用链式前向星存无向边时每条边要存储两次。</p>
<p>代码已经测试数据</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstdio&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;cstring&gt;
#include &lt;queue&gt;
using namespace std;

const int MAXV = 100 + 7;
const int MAXE = 100 * 100 + 7;
int head[MAXV];
int V, E;

typedef struct EdgeNode
{
    int to;
    int w;
    int next;
}edgeNode;
edgeNode Edges[MAXE];

bool visit[2 * MAXE];
stack&lt;int&gt; stv;
queue&lt;int&gt; quv;//点集
queue&lt;int&gt; que;//边集

void EulerDFS(int now)
{
    printf(&quot;Now = %d\n&quot;, now);
    stv.push(now);//每访问一个点，就把该点压入栈
   // printf(&quot;stack 中\n&quot;);

    printf(&quot;\n&quot;);
    for(int k = head[now]; k != -1; k = Edges[k].next)
    {
        if(!visit[k])
        {
            visit[k] = true;            //有向图每条边保存了两次，也要标记两次
            if(k &amp; 1)
                visit[k + 1] = true;
            else
                visit[k - 1] = true;
            EulerDFS(Edges[k].to);
            que.push(k);//回溯时记录
            printf(&quot;插入了\n&quot;);
            printf(&quot;%d号边\n&quot;, k);
            printf(&quot;%d &lt; - &gt; %d&quot;, now, Edges[k].to);
            printf(&quot;\n&quot;);
        }
    }
    printf(&quot;栈顶元素为\n&quot;);
    printf(&quot;%d\n&quot;, stv.top());
    quv.push(stv.top());//记录点
    stv.pop();
}

int main()
{
    //freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);
    scanf(&quot;%d%d&quot;, &amp;V, &amp;E);
    memset(head, -1, sizeof(head));
    for(int i = 1; i &lt;= E; i++)
    {
        int u, v, w;
        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
        Edges[2 * i - 1].to = v;                //双向储存边
        Edges[2 * i - 1].w = w;
        Edges[2 * i - 1].next = head[u];
        head[u] = 2 * i - 1;
        Edges[2 * i].to = u;
        Edges[2 * i].w = w;
        Edges[2 * i].next = head[v];
        head[v] = 2 * i;
    }
    memset(visit, false, sizeof(visit));
    EulerDFS(1);
    return 0;
}
/ * 
10 11
1 9 1
1 10 2
9 8 3
10 8 4
10 3 5
3 2 6
2 4 7
10 4 8
8 6 9
6 7 10
8 7 11

*/</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 3072  Intelligence System</title>
    <url>/tpaaaaaa.github.io/2019/08/31/HDU-3072IntelligenceSystem/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>After a day, ALPCs finally complete their ultimate intelligence system, the purpose of it is of course for ACM … …<br>Now, kzc_tc, the head of the Intelligence Department (his code is once 48, but now 0), is sudden obtaining important information from one Intelligence personnel. That relates to the strategic direction and future development of the situation of ALPC. So it need for emergency notification to all Intelligence personnel, he decides to use the intelligence system (kzc_tc inform one, and the one inform other one or more, and so on. Finally the information is known to all).<br>We know this is a dangerous work. Each transmission of the information can only be made through a fixed approach, from a fixed person to another fixed, and cannot be exchanged, but between two persons may have more than one way for transferring. Each act of the transmission cost Ci (1 &lt;= Ci &lt;= 100000), the total cost of the transmission if inform some ones in our ALPC intelligence agency is their costs sum.<br>Something good, if two people can inform each other, directly or indirectly through someone else, then they belong to the same branch (kzc_tc is in one branch, too!). This case, it’s very easy to inform each other, so that the cost between persons in the same branch will be ignored. The number of branch in intelligence agency is no more than one hundred.<br>As a result of the current tensions of ALPC’s funds, kzc_tc now has all relationships in his Intelligence system, and he want to write a program to achieve the minimum cost to ensure that everyone knows this intelligence.<br>It’s really annoying! </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用tarjan缩点得到DAG图后，知道DAG图肯定无环，并且连通的（ Believe kzc_tc’s working! There always is a way for him to communicate with all other intelligence personnel. ），所以我们就用求最小树形图的朱刘算法一次循环即可，即得到最小弧集合，然后判断是否成树和是否有环，显然已经成树，并且无环，所以此时的最小弧集合就是最小树形图，然后我们要求的是最小树形图的权值，所以我们直接将每个点的最小入弧的权值相加即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-10.42.14
 Question_Number   ：hdu 3072
 Question_Name     ：tarjan 强连通
 Description       ：
                     最小树形图？？
                     用tarjan缩点求出强连通子图
                     我们可以知道这个图肯定没有环路
                     并且这个图肯定是联通的。
                     然后求这个图的最小树型图
                     朱刘算法
                     如果一个图没有环路，并且已经联通了
                     那么它的树形图就是最短弧集合

                     首先将每个点的最小的入边保留下来
                     最短弧集合
                     如果得到的是一棵树，则棵树就是最小树形图

                     如果这个图联通，并且无环，那么
                     对于最后一个节点A，他最小的入弧所连的点为B，
                     接下来判断B的最小入弧所连的点，肯定不是A（不然就形成了环），因此为C
                     同理C的最小入弧所连的点，肯定不是A或B，（会形成环）因此肯定为剩余节点中的D
                     一路下来，直到第一个节点root。

                      题目的意思是，n个点，编号 0 .. n - 1
                      以0号点为root的树的权值
                      因为题目说 如果是同一个branch，那么他们之间的联系free
                      因此将同一个branch的人，用tarjan缩成一个点。
                      又因为题目保证联通，所以缩完之后，就是从0
                      所在的那个连通分量到各个联通分量形成的树的最小值。
                      那么我们只要找到每个联通分量的入边最小的权值
                      将这些权值加起来就可以啦。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5e4 + 10;
const int MAXM = 1e5 + 10;
const int MAXB = 100 + 10;
int n, m, tot, sum ,cnt;
bool vis[MAXN];
int head[MAXN], low[MAXN], dfn[MAXN], belong[MAXN];
int cost[MAXB];
stack &lt; int &gt; st;
struct Edge
{
    int u, v, w, next;
};
Edge edge[MAXM];
void addEdge(int u, int v, int w)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].w = w;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[v], low[u]);
        }
        else if(vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            belong[temp] = sum;
            vis[temp] = false;
            st.pop();
        }
        belong[u] = sum;
        vis[u] = false;
        st.pop();
    }

}
void init()
{
    cnt = sum = tot = 0;
    memset(dfn, 0, sizeof dfn);
    memset(low, 0, sizeof low);
    memset(vis, false, sizeof vis);
    memset(head, -1, sizeof head);
    memset(belong, 0, sizeof belong);
    memset(cost, INF, sizeof cost);
    while(!st.empty())
        st.pop();
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v, w;
            scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
            addEdge(u, v, w); // u - &gt; v cost =w;
        }
        for(int i = 0; i &lt; n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int i = 0; i &lt; n; i++)
            for(int j = head[i]; j != -1; j = edge[j].next)
            {
                int u = i;
                int v = edge[j].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                {
                    cost[b] = min(cost[b], edge[j].w);
                }
            }
        int ans = 0;
        int expt = belong[0];//0 所在的入边就不考虑了
        for(int i = 1; i &lt;= sum; i++)
            if(i != expt)
                ans += cost[i];
        printf(&quot;%d\n&quot;, ans);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan，最小树形图，朱刘算法</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1236 Network of Schools</title>
    <url>/tpaaaaaa.github.io/2019/08/31/POJ-1236NetworkofSchools/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>一些学校连接到了一个计算机网络。网络中的学校间有如下约定：每个学校维护一个列表，当该学校收到软件或信息后将会转发给列表中的所有学校（也就是接收方列表）。需要注意的是如果B学校在A学校的接收方列表中，A学校<strong>不一定</strong>会出现在B学校的接收方列表中。<br>你现在的任务是写出一个程序来计算必须收到一份软件来使网络中的所有学校都能收到软件的学校的数量的最小值（<strong>此为子任务A</strong>）。作为一个远期目标，我们希望给任意一个学校发送一份软件都能使网络中的所有学校都收到软件。为了实现这个目标，我们或许需要在一些学校的接收方列表中添加新项。 你现在需要计算出至少需要添加多少新项才能实现这个远期目标（<strong>此为子任务B</strong>）。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan缩点得到DAG图后，要想遍历图上的所有点，则必须从起点开始，所以起点的数目就是必须要访问点的数目。</p>
<p>为了要使DAG图成为一个强连通图，我们可以将同一条topo链上的起点和终点连在一起，因此需要添边的数目为max(起点的数目 , 终点的数目)。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-13.17.38
 Question_Number   ：poj 1236
 Question_Name     ：强连通？？
 Description       :
    DAG图，有向无环图（有向树）
    要明白DAG图的性质。。
    入度为0的点，就是起点。
    出度为0的点，就是终点。
    test A 要想遍历所有点，肯定要从起点开始
    设起点有x个， 终点y个
    则最少要从x个点出发
    test A  入度为0的点的数目

    test B 将一个DAG图要加多少边才能变成强连通图
    易知，要将起点和终点联系在一起。
    因此要填的边的数目是
    max(x, y);

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100 + 10;
const int MAXM = MAXN * MAXN;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], in[MAXN], ou[MAXN];
bool vis[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(in, 0, sizeof in);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) != EOF)
    {
        init();
        for(int u = 1; u &lt;= n; u++)
        {
            int v;
            while(scanf(&quot;%d&quot;, &amp;v) &amp;&amp; v)
                addEdge(u, v);
         //   printf(&quot;?&quot;);
        }
      //  printf(&quot;??&quot;);
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int u = 1; u &lt;= n; u ++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                {
                    ou[a] ++;
                    in[b] ++;
                }
            }
        int ans1 = 0, ans2 = 0;
        for(int i = 1; i &lt;= sum; i++)
        {
            if(in[i] == 0)
                ans1 ++;
            if(ou[i] == 0)
                ans2 ++;
        }
        //如果原本就是强连通的图，那么ans1 == ans2 == 0;
        if(sum == 1)
            printf(&quot;1\n0\n&quot;);
        else
            printf(&quot;%d\n%d\n&quot;, ans1, max(ans1, ans2));
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan，出度入度</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2553 The Bottom of a Graph</title>
    <url>/tpaaaaaa.github.io/2019/08/31/POJ-2553TheBottomofaGraph/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求点A，点A的性质：点A能到的点， 这些点也能到达A。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan求缩点后的DAG图，因为点A能到的点，那个点也能到A，说明这些点和A构成了一个强连通分量，点A除了能到这些点之外，就再也不能到其他点了，也就是说这个强连通分量的出度为0。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-14.42.33
 Question_Number   ：poj2553
 Question_Name     ：强连通
 Description       :
 sink的意思是  点A能到的所有点， 所有的这些点也能到达A
                强连通？？ 用Tarjan
                然后遍历点
                    再遍历与这个点相连的边，得到另一个点
                        如果另一个点与这个点在同一个强连通分量中
                        则ok
                // 以上这个方法，显然行不通..
                我们可以将强连通分量中的边全部删掉
                然后求出出度为0 的点即可

                我们用Tarjan求连通分量
                然后出栈的时候
                 对于栈顶元素，我们将他连到的栈中的点的边去掉
                以上思路又错了
                是用tarjan缩点，然后找出出度为0的强连通分量。
                将这个强连通分量中的点全部输出。
                缩点的思想要掌握！！
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 5000 + 10;
const int MAXM = MAXN * MAXN;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], ou[MAXN];
bool vis[MAXN];
int arr[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
    memset(arr, 0, sizeof arr);
}
int main()
{
    while(scanf(&quot;%d&quot;, &amp;n) &amp;&amp; n)
    {
        scanf(&quot;%d&quot;, &amp;m);
        init();
        for(int i = 1; i &lt;= m; i++)
        {
            int u, v;
            scanf(&quot;%d %d&quot;, &amp;u, &amp;v);
            addEdge(u, v); // u - &gt; v;
        }
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);

        for(int u = 1; u &lt;= n; u ++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if(a != b)
                    ou[a] ++;
            }
        int all = 0;
        for(int i = 1; i &lt;= sum; i++)
        {
            if(ou[i] == 0)  //i是出度为0的强连通分量
            {
                for(int j = 1; j &lt;= n; j++)
                    if(belong[j] == i)
                    {
                        arr[++all] = j;
                    }
            }
        }
        sort(arr + 1, arr + 1 + all);
        for(int i = 1; i &lt;= all; i++)
            printf(&quot;%d &quot;, arr[i]);
        printf(&quot;\n&quot;);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan，出度入度</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2186 Popular Cows</title>
    <url>/tpaaaaaa.github.io/2019/08/31/POJ-2186PopularCows/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求所给有向图中，所有点都能到达的点。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>用Tarjan进行缩点，得到DAG图，如果存在唯一一个强连通分量，其出度为0，说明其他所有的强联通分量都能够到达它。也就是说，其他强联通分量中的点都能到达这个强连通分量中的任意一点，并且这个强连通分量中的任意两点都能互达。因此这个强连通分量中的点就是所谓的最受欢迎的cow。输出这个强连通分量中点的数目即可。如果这个强连通分量不唯一，说明这些强连通分量之间不能互达，也就是没有任何一个点满足条件，则输出数目为0；</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-31-15.20.21
 Question_Number   ：poj 2186
 Question_Name     ：强连通分量
 Description       :
                     图中所有的点都能到A
                     自己能到自己。
                     强连通缩点，得到DAG图
                     然后枚举每个终点？？，用floyd求连通性？？？
                     最多有1e4个数，3次肯定超了
                    对每个点用Dij，看看能不能连通
                    Dij的复杂度是O(E+VlgV)，最坏情况(5n);
                    然后枚举点n
                    所以最坏情况(5n^2)
                    貌似刚好。
                    我好蠢
                          先用tarjan求出每个强连通分量，
                          再缩点，统计每个点的出度，如果有且只有1个出度为0的点，
                          就输出这个点包含的节点数，否则输出0.
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 5e4 + 10;
int n, m, tot, sum, cnt;
int low[MAXN], dfn[MAXN], head[MAXN], belong[MAXN], ou[MAXN];
bool vis[MAXN];
stack &lt; int &gt; st;
struct Edge
{
    int v, next;
};
Edge edge[MAXM];
void addEdge(int u, int v)
{
    cnt ++;
    edge[cnt].v = v;
    edge[cnt].next = head[u];
    head[u] = cnt;
}
void Tarjan(int u)
{
    low[u] = dfn[u] = ++ tot;
    vis[u] = true;
    st.push(u);
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        if(dfn[v] == 0)
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if (vis[v] == true)
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])
    {
        sum ++;
        while(st.top() != u)
        {
            int temp = st.top();
            st.pop();
            vis[temp] = false;
            belong [temp] = sum;
        }
        vis[u] = false;
        belong [u] = sum;
        st.pop();
    }
}
void init()
{
    tot = cnt = sum = 0;
    while(!st.empty())
        st.pop();
    memset(head, -1, sizeof head);
    memset(low, 0, sizeof low);
    memset(dfn, 0, sizeof dfn);
    memset(vis, false, sizeof vis);
    memset(ou, 0, sizeof ou);
    memset(belong, 0, sizeof belong);
 //   memset(arr, 0, sizeof arr);
}
int main()
{
    while(scanf(&quot;%d%d&quot;, &amp;n, &amp;m) != EOF)
    {
        init();
        for(int i = 1; i &lt;= m; i ++)
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
            addEdge(u, v); // u - &gt; v
        }
        for(int i = 1; i &lt;= n; i++)
            if(dfn[i] == 0)
                Tarjan(i);
        for(int u = 1; u &lt;= n; u++)
            for(int i = head[u]; i != -1; i = edge[i].next)
            {
                int v = edge[i].v;
                int a = belong[u];
                int b = belong[v];
                if( a != b )
                    ou[a]++;
            }
        int sum0 = 0;
        int temp;
        for(int i = 1; i &lt;= sum; i++)
            if(ou[i] == 0)
            {
                sum0++;
                temp = i;
            }

        int ans = 0;
        if(sum0 == 1)
            for(int i = 1; i &lt;= n; i++)
                if(belong[i] == temp)
                    ans++;
        printf(&quot;%d\n&quot;, ans);

    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan，出度入度</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2762 Going from u to v or from v to u?</title>
    <url>/tpaaaaaa.github.io/2019/08/31/POJ-2762Goingfromutovorfromvtou/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给你一个图，问你这个图中的任意两个点A , B，存不存在A到B <strong>或者</strong> B到A的路径。如果任意一对点都存在，则输出Yes，否则输出No</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先，我们用Tarjan将图进行缩点简化，得到一个DAG图。但对于DAG图，topo排序得到的序列不一定唯一。对于topo排序期间的入度为0的点的数目大于1，（假设数目为2，并将这两点设为A,B） 说明A,B在topo序列中的地位是一样的，然而点在topo排序中的关系是<strong>：在topo排序中排在后面点，无法到达排到前面的点，排在前面的点，能够到达后面的点</strong>。 因此A，B这两点 既从A不能到达B，也不能从B到A，因此不符合条件。</p>
<p>所以整题的思路是，用Tarjan将图缩点，成DAG图，对DAG图进行topo排序， 如果排序期间入度为0的点的数目大于1，则return false， 否则到最后return true。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是根据Tarjan建立新图的代码</p>
<pre><code>for(int u = 1; u &lt;= n; u++)
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].v;
        int a = belong[u];
        int b = belong[v];
        if(a != b)
        {
            if(mp[a][b] == false)   // 在新图中这条边已经存在过了
            {
                mp[a][b] = true;
                in[b] ++;
            }
        }
    }</code></pre><p>对新DAG图进行topo排序</p>
<pre><code>bool topo()
{
    queue &lt; int &gt; Q;
    for(int i = 1; i &lt;= sum; i++)
        if(in[i] == 0)
            Q.push(i);
    while(!Q.empty())
    {
        if(Q.size() &gt; 1)
            return false;
        int u = Q.front();
        Q.pop();
        for(int v = 1; v &lt;= sum; v ++)   //这是新的图，mp存的是新图
        {
            if(mp[u][v])
            {
                in[v] -- ;
                if(in[v] == 0)
                    Q.push(v);
            }

        }
    }
    return true;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan缩点，拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[图论]有向无环图（DAG图）</title>
    <url>/tpaaaaaa.github.io/2019/08/31/%5B%E5%9B%BE%E8%AE%BA%5D%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%88DAG%E5%9B%BE%EF%BC%89/</url>
    <content><![CDATA[<h2 id="百度百科："><a href="#百度百科：" class="headerlink" title="百度百科："></a>百度百科：</h2><p>有向无环图指的是一个<strong>无回路的有向图</strong>。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。将从C到A的边方向改为从A到C，则变成有向无环图。<strong>有向无环图的生成树个数等于入度非零的节点的入度积</strong>。</p>
<p>因为有向图中一个点经过两种路线到达另一个点未必形成环，因此有向无环图未必能转化成树，但任何有向树均为有向无环图。</p>
<p><img src="http://localhost/wp-content/uploads/2019/08/DAG.jpg" alt=""></p>
<p>我们称入度为0的点为起点，出度为0的点为终点。</p>
<p>如果要想从S点遍历完DAG中的所有点，必须额外连接S到起点的边因此，需要额外连的边的数目就是起点的数目</p>
<p><img src="http://localhost/wp-content/uploads/2019/08/DAG-1.jpg" alt=""></p>
<p>那么要将DAG图通过填边变成强连通图呢，需要填多少边呢</p>
<p>我们从每个起点出发，走到某个终点，如图，我们从1号点出发，走到15号终点，然后我们添加一条15指向1的点即可。对于每个起点走出来的链，我们只要把他的起点和终点连起来就可以了，因此要添加的边的数目为MAX（起点的数目，终点的数目）</p>
<p>解题小技巧：</p>
<p>如果一个DAG图有多个起点，要求这个图中的任意起点的最短路径，我们可以虚拟出一个超级起点，然后将这个超级起点连到各个起点上，边的权值都是0，然后跑一边spfa就可以了。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 1827 Summer Holiday</title>
    <url>/tpaaaaaa.github.io/2019/08/31/HDU-1827SummerHoliday/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>听说lcy帮大家预定了新马泰7日游，Wiskey真是高兴的夜不能寐啊，他想着得快点把这消息告诉大家，虽然他手上有所有人的联系方式，但是一个一个联系过去实在太耗时间和电话费了。他知道其他人也有一些别人的联系方式，这样他可以通知其他人，再让其他人帮忙通知一下别人。你能帮Wiskey计算出至少要通知多少人，至少得花多少电话费就能让所有人都被通知到吗？ </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>我们暂且将一群可以彼此互相联系的人成为一组人，因此wiskey要联系这一组的所有人，只要联系这组里面的其中一个人即可，并且联系代价最小的那个人。当然，一组人和另一组人可能存在一条单向边，假如A组可以联系B组，那么wiskey只要联系A组即可。 这一群可以彼此相互联系的人 就可以理解为图的一个强联通分量。因此我们首先求出给出的有向图的强连通分量，然后找出强联通分量中入度为0的点，取得这个强连通分量中点的代价最小的那个即可。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>录入部分</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    int u, v;
    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
    G[u].push_back(v);    // 用的是邻接表
}
for(int i = 1; i &lt;= n; i++)
    if(!dfn[i])
        Tarjan(i);</code></pre><p>tarjan</p>
<pre><code>void Tarjan(int x)
{
    dfn[x] = low[x] = ++tot;
    vis[x] = true;
    st.push(x);
    for(int i = 0; i &lt; G[x].size(); i++)
    {
        int node = G[x][i];
        if(dfn[node] == 0) //说明这点没有dfs
        {
            Tarjan(node);
            low[x] = min(low[x], low[node]);
        }
        else if(vis[node] == true)//这点dfs过，并且存在stack中
                                  // 说明node可以到达x，并且x也可以到node
            low[x] = min(low[x], dfn[node]);
    }
    if(low[x] == dfn[x])
    {
        sum ++;                          //强连通分量的数目
        cost[sum] = INF;      // cost[i]记录的是第i个强联通分量中的权值最小的点的权值
        while(st.top() != x)            //从下面往上面弹回来。不一定要弹空。
        {
            cost[sum] = min(cost[sum], val[st.top()]);
            belong[st.top()] = sum; //st.top()这个点属于第几个连通分量
            vis[st.top()] = false;
            st.pop();
        }
        cost[sum] = min(cost[sum], val[x]);
        belong[x] = sum;
        vis[x] = false;
        st.pop();
    }
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan缩点</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2767 Proving Equivalences</title>
    <url>/tpaaaaaa.github.io/2019/08/31/HDU-2767ProvingEquivalences/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>Tarjan入门经典题，用tarjan缩点，然后就变成一个有向无环图(DAG)了。 我们要考虑的问题是让它变成强连通，<strong>让DAG变成强连通就是把尾和头连起来，也就是入度和出度为0的点。</strong> 统计DAG入度和出度，然后计算头尾，<strong>最大的那个就是所求。</strong></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>有向图的录入部分</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    int u, v;
    scanf(&quot;%d%d&quot;, &amp;u, &amp;v);
    addEdge(u, v);  //u &gt; v; 链式前向星
}

for(int i = 1; i &lt;= n; i++)
    if(dfn[i] == 0)  //dfn == 0意思是没有dfs过
        Tarjan(i);</code></pre><p>Tarjan</p>
<pre><code>void Tarjan(int u)
{
    vis[u] = true;            //标记入栈
    low[u] = dfn[u] = ++tot;  
    st.push(u);               //入栈
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        int v = edge[i].to;
        if(dfn[v] == 0)      //这个点没有dfs过
        {
            Tarjan(v);
            low[u] = min(low[u], low[v]);
        }
        else if(vis[v])      //这个点dfs过，并且在栈内
            low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u])        //这是一个关键点
    {
        sum ++;                 //sum记录的是强连通分量的数目
        while(st.top() != u)    //将栈中在u之后的元素视为与u为同一个强联通分量中的元素
        {
            int temp = st.top();
            st.pop();
            belong[temp] = sum;
            vis[temp] = false;
        }
        belong[u] = sum;
        vis[u] = false;
        st.pop();
    }
}</code></pre><p>处理强连通分量中的入度和出度</p>
<pre><code>for(int i = 1; i &lt;= n; i++) //遍历每个点
    for(int j = head[i]; j != -1; j = edge[j].next)
    {
        int u = i;
        int v = edge[j].to;
        int a = belong[u];      //a ，b分别为二者在新图中的编号
        int b = belong[v];
        if(a != b)  //这两个点在新的图中不是一个联通分量，
        {
            in[b]++;
            ou[a]++;
        }
    }</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Tarjan缩点，DAG填边变强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]Tarjan 求强连通分量</title>
    <url>/tpaaaaaa.github.io/2019/08/31/%5B%E7%AE%97%E6%B3%95%5DTarjan%E6%B1%82%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/</url>
    <content><![CDATA[<h2 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h2><p>参考博客<a href="https://www.cnblogs.com/stxy-ferryman/p/7779347.html" target="_blank" rel="noopener">https://www.cnblogs.com/stxy-ferryman/p/7779347.html</a></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>        for(int i = 1; i &lt;= m; i++) //有向图的录入
        {
            int u, v;
            scanf(&quot;%d%d&quot;, &amp;u, &amp;v); // u - &gt; v
            G[u].push_back(v);     // 用邻接表存图
//          addEdge(u, v)          // 用链式前向星当然也行
        }

        for(int i = 1; i &lt;= n; i++)
            if(!dfn[i])              // dfn[i]记录的是i这个点再dfs整个图的次序。dfn == 0就表示还没有dfs过
                Tarjan(i);           //因此就以它为根进行dfs

void Tarjan(int x)                //作用是处理以i为根的子树的low，dfn数组等
{
    dfn[x] = low[x] = ++times;    // times 记录的是dfs次序号
    vis[x] = true;                // 标记x在栈中
    st.push(x);                   // 压入栈中
    for(int i = 0; i &lt; G[x].size(); i++)  //枚举每个和x相连的点
    {
        int node = G[x][i];
        if(dfn[node] == 0)        //说明这点还没有被处理过
        {
            Tarjan(node);
            low[x] = min(low[x], low[node]);
        }
        else if(vis[node] == true)//这点已经遍历过，但这点已经存在栈中，说明形成了环
            low[x] = min(low[x], dfn[node]);
    }
    if(low[x] == dfn[x])         //x是一个关键点
    {
        sum ++;                  //强连通分量的数目
        while(st.top() != x)            //从下面往上面弹回来。不一定要弹空。
        {
            int temp = st.top();      //temp存的是目前栈顶的元素
            belong[temp] = sum;       //st.top()这个点属于第sum个强连通分量
            vis[temp] = 0;            //出栈后标记清除
            st.pop();                 //首元素出栈
        }
        belong[x] = sum;              //x自己的处理
        vis[x] = 0;
        st.pop();
    }
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>[算法] 二分图相关问题</title>
    <url>/tpaaaaaa.github.io/2019/08/29/%5B%E7%AE%97%E6%B3%95%5D%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p><strong>二分图：</strong>简单来说，如果图中点可以被分为两组，并且使得所有边都跨越组的边界，则这就是一个二分图。准确地说：把一个图的顶点划分为两个不相交集   和  ，使得每一条边都分别连接 、   中的顶点。如果存在这样的划分，则此图为一个二分图。二分图的一个等价定义是：不含有「含奇数条边的环」的图。图 1 是一个二分图。为了清晰，我们以后都把它画成图 2 的形式。</p>
<p><strong>匹配：</strong>在图论中，一个「匹配」（matching）是一个边的集合，其中任意两条边都没有公共顶点。例如，图 3、图 4 中红色的边就是图 2 的匹配  </p>
<p><img src="https://img-blog.csdn.net/20180522192143192" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180522192210128" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180522192221924" alt=""></p>
<p><img src="https://img-blog.csdn.net/20180522192217254" alt=""></p>
<p>我们定义<strong>匹配点、匹配边、未匹配点、非匹配边</strong>，它们的含义非常显然。例如图 3 中 1、4、5、7 为匹配点，其他顶点为未匹配点；1-5、4-7为匹配边，其他边为非匹配边。</p>
<p><strong>最大匹配：</strong>一个图所有匹配中，所含匹配边数最多的匹配，称为这个图的最大匹配。图 4 是一个最大匹配，它包含 4 条匹配边。</p>
<p><strong>完美匹配：</strong>如果一个图的某个匹配中，所有的顶点都是匹配点，那么它就是一个完美匹配。图 4 是一个完美匹配。显然，完美匹配一定是最大匹配（完美匹配的任何一个点都已经匹配，添加一条新的匹配边一定会与已有的匹配边冲突）。但并非每个图都存在完美匹配。</p>
<p>上述是基本概念，接下来讲一下为匈牙利算法服务的一些概念</p>
<p><strong>交替路</strong>：从一个未匹配点出发，依次经过非匹配边、匹配边、非匹配边…形成的路径叫交替路。</p>
<p><img src="https://img-blog.csdn.net/2018052219273516" alt=""></p>
<p><strong>增广路</strong>：从一个未匹配点出发，走交替路，如果途径另一个未匹配点（出发的点不算），则这条交替路称为增广路（agumenting path）。例如，图 5 中的一条增广路如图 6 所示（图中的匹配点均用红色标出）：</p>
<p><img src="http://img.renfei.org/2013/08/6.png" alt="6"></p>
<p>增广路有一个重要特点：非匹配边比匹配边多一条。因此，研究增广路的意义是改进匹配。只要把增广路中的匹配边和非匹配边的身份交换即可。由于中间的匹配节点不存在其他相连的匹配边，所以这样做不会破坏匹配的性质。交换后，图中的匹配边数目比原来多了 1 条。其实，如果交替路以非匹配点结束的，那么这条交替路就是一条增广路</p>
<p>我们可以通过不停地找增广路来增加匹配中的匹配边和匹配点。找不到增广路时，达到最大匹配（这是增广路定理）。匈牙利算法正是这么做的。</p>
<h2 id="匈牙利算法："><a href="#匈牙利算法：" class="headerlink" title="匈牙利算法："></a>匈牙利算法：</h2><p>对代码进行分析</p>
<pre><code>while (m--)//输入边的信息和更新邻接矩阵 m条边
      {
          cin&gt;&gt;x&gt;&gt;y;
          e[x][y]=1;
      }</code></pre><p>接下来是hungry函数</p>
<pre><code>int hungry()
{
    int sum = 0;
    for(int i = 1; i &lt;= p; i++) //p是x部的点的数目
    {
        ms(vis,false);
        if(find(i))         //如果能够找到匹配
            sum++;      // sum记录的是匹配的数目
    }
    return sum;
}</code></pre><p>接下来是find函数</p>
<pre><code>bool find(int x)
{
    for(int i = 1; i &lt;= n; i++) 
        if(map[i][x] == 1 &amp;&amp; vis[i] == false) // 存在边，并且那个点没有访问过
        {
            vis[i] = true;
            if(boy[i] == 0 || find(boy[i])) // 如果那个点之前没有匹配的点，或者之前匹配的点可以找到另一个。
            {
                boy[i] = x;
                return true;
            }
        }
    return false;
}</code></pre><p>匈牙利算法博客！！以男女找对象作为例子的<a href="https://blog.csdn.net/sunny_hun/article/details/80627351" target="_blank" rel="noopener">https://blog.csdn.net/sunny_hun/article/details/80627351</a></p>
<h2 id="KM算法："><a href="#KM算法：" class="headerlink" title="KM算法："></a>KM算法：</h2><p>KM算法解决的是 二分图最大权分配 ， 相对于以上的二分图匹配，这里多了一个权值的概念。</p>
<p>比较好的博客</p>
<p><a href="https://www.cnblogs.com/wenruo/p/5264235.html" target="_blank" rel="noopener">https://www.cnblogs.com/wenruo/p/5264235.html</a></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>POJ - 1094 Sorting It All Out</title>
    <url>/tpaaaaaa.github.io/2019/08/29/POJ-1094SortingItAllOut/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>用小于号”&lt;”来定义两元素之间的关系，并于一个没有重复元素的有序上升序列 从小到大地排列这些元素。<br>比如说，序列A,B,C,D意味着A&lt;B;B&lt;C;C&lt;D。<br>在这个问题里，我们会给你一组形如”A&lt;B”的关系，询问你有序序列的合法性或其本身。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>不断的加边，加一次边，跑一次topo，记录加了这条边后图的点数(sum)。</p>
<p>如果拓扑出现环路(topo涉及到的点要小于sum)，则说明在加入这条边后，出现矛盾</p>
<p>如果topo涉及的点的数目等于n（并且每次入度为1的点只有一个），则说明拓扑成功了，说明唯一的序列已经找出了</p>
<p>如果到最后入度为1的点任然大于1，则说明所给的边无法建立唯一关系。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>topo部分：</p>
<pre><code>int topo()                 // 返回1表示topo成功，-1表示出现环， 0 表示无法判断
{
    queue &lt; int &gt; Q;
    int inn[MAXN];   //因为每加一条边，就要topo一次，因此用inn数组暂时代替in数组
    int sum = 0;     //sum记录的是  加完这次边后  图中的点的数目
    for(int i = 0; i &lt; n; i++) //点的编号从0开始
    {
        inn[i] = in[i];
        if(vis[i])
        {
            sum++;
            if(in[i] == 0)
                Q.push(i);
        }
    }
    int tot = 0;
    bool uncertain = false;
    while(!Q.empty())
    {
        if(Q.size() &gt; 1)
            uncertain = true;  //说明topo序列不为1，但是冲突的优先级大于不确定，所以不break；
        int u = Q.front();
        Q.pop();
        anss[tot] = &apos;A&apos; + u;  //记录弹出来的序列
        tot ++;               //记录topo涉及到点的数目
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            inn[v] --;        //是对inn数组进行处理，而不是in数组
            if(inn[v] == 0)
                Q.push(v);
        }
    }
    if(tot &lt; sum ) //说明topo涉及到的点的数目要小于目前图中的点数
        return -1;
    anss[tot] = &apos;\0&apos;;
    if(tot == n &amp;&amp; uncertain == false)
        return 1;

    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1269 迷宫城堡</title>
    <url>/tpaaaaaa.github.io/2019/08/29/HDU-1269%E8%BF%B7%E5%AE%AB%E5%9F%8E%E5%A0%A1/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>麻神想要体验生活，于是他建立斥巨资在NIT山上建了一座洞窟，里面有N个洞穴(N&lt;=10000) 和M条通道(M&lt;=100000)，每个通道都是单向的，就是说若称某通道连通了A洞穴和B洞穴，只说明可以通过这个通道由A洞穴到达B洞穴，但并不说明通过它可以由B洞穴到达A洞穴。麻神需要请你写个程序确认一下是否任意两个洞穴都是相互连通的，即：对于任意的i和j，至少存在一条路径可以从洞穴i到洞穴j，也存在一条路径可以从洞穴j到洞穴i。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>强连通的模板题，就借此题详细的分析一下Tarjan求强连通的代码</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>首先是输入部分：</p>
<pre><code>for(int i = 1; i &lt;= m; i++)   // m个有向边
{
    int x, y;
    scanf(&quot;%d%d&quot;, &amp;x, &amp;y);
    addEdge(x, y); // x - &gt; y
}</code></pre><p>然后是枚举每个点，如果该点没有被访问过，就以此为根节点进行Tarjan（dfs）</p>
<pre><code>for(int i = 1; i &lt;= n; i ++)
{
    if(vis[i] == false)
        Tarjan(i);
}</code></pre><p>接下来的是Tarjan函数部分</p>
<pre><code>void Tarjan(int u) // Tarjan函数，从u开始往下dfs
{
    vis[u] = true;           //dfs标记已访问     
    low[u] = dfn[u] = cnt++; //cnt保存的是u节点在dfs访问时候的编号
    for(int i = head[u]; i != -1; i = edge[i].next) //枚举与他相连的每一个点
    {
        int v = edge[i].to;
        if(vis[v] == false)   //如果此点未访问过
            Tarjan(v);        
        if(vis[v] == true)
            low[u] = min(low[v], low[u]);
    }
    if(dfn[u] == low[u])      //说明这个点是强连通分量的一个代表
        sig ++;
}</code></pre><p>实际上，Tarjan(i)的作用是从 i 这个根节点开始，往下找强连通分量。也就是处理以i为根节点的树 / 环。的情况。有两种可能：</p>
<p>第一种是 以 i 为根节点的是一棵树， 那么找下去，到最后一个叶子节点时候，这个叶子节点发现没有与他相连的节点了，并且dfn[ x ] = low[ x ]，则这个叶子节点自身就是一个强连通分量，然后往上回溯，发现上面的每一个单独的点自身都是一个强联通分量，一直回溯到根节点 i 。</p>
<p>第二种是 以 i 为根节点的最后成了一个环， 那么找下去，到最后一个叶子节点时候，这个时候发现与他相连的节点是根节点，但是根节点已经访问过了，则low[ x ] 发生改变，然后往上回溯，使得到达根节点整个路径上的low[x] = low[u]，然后回溯到根节点，最后只有根节点 i 的low[ i ] = dfn[ i ], 因此这个根节点就是这个联通分量的代表。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>强连通的判断，Tarjan求强连通</tag>
      </tags>
  </entry>
  <entry>
    <title>hdu 3572 Task Schedule</title>
    <url>/tpaaaaaa.github.io/2019/08/29/hdu3572TaskSchedule/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>某工厂有 M 台机器要完成 N 个任务。 第i个任务的开始时间不早于Si, 需要干Pi天, a并要在不晚于Ei时完成. 一台机器一天只能干一个任务，一个任务在同一天只能用一台机器. 任务完成不需要连续，只要有足够的天数即可。<br>能不能搞完这些工作 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p> 最大流。这个题的建图算是经典，因为限定每个时刻每台机器只能处理一个任务，所以可以把时间点分配给各个合法的机器…具体是先设定一个超级源点S，连向各个任务，容量为该任务所需时间，各个任务连向在范围内的时间点，容量为1（保证每个时刻xxx这个条件），所有时间点连向超级汇点T，容量为机器台数，最后求最大流，等于所有机器所需时间和的就是yes</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>经典的最大流</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]网络流</title>
    <url>/tpaaaaaa.github.io/2019/08/29/%5B%E6%A8%A1%E6%9D%BF%5D%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    <content><![CDATA[<h1 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h1><p><strong>网络：</strong>（1）有一个源点 s 和汇点 t 。</p>
<pre><code>（2）每一条有向边e=（u，v）都有一个容量限制记做c（e）。</code></pre><p><strong>流：</strong>定义在网络弧集上的实值函数 f ，满足三个性质</p>
<pre><code>（1）对任意的弧 0 &lt;= f &lt;= c(e)，容量限制。

（2）f(u,v) == -f(v,u)，反对称性。

（3）流守恒性：除源汇点外，其余顶点都是过度点，流进顶点的流总和等于流出顶点的流总和。</code></pre><p><strong>残余网络：</strong>用e表示网络中的边，e’ 表示残余网络中的边，残余网络中的边由以下两种构成：</p>
<pre><code>（1）若f(e) &lt; c(e) ，e=（u，v），则e&apos; =（u，v）容量为 c(e) - f(e)

（2）若f(e)&gt;0，e=（u，v），则加入边 e&apos;=（v，u），容量为 f(e)

  其中有（1）生成的边表示沿着这条边还能推进多少流；由（2）生成的边表示沿着该边的逆方向能退回多少流。</code></pre><p><strong>增广路：</strong> 定义增广路 P 是在残余网络上的一条从源点 s 到汇点 t 的简单路径，路径的残余流量为该边上的边 e’ 容量的最小值，其实就是残余网络上增广的流值大于 0 的一条路径。</p>
<p><strong>割的定义：</strong>设网络G，如果 X 是 V 的顶点子集，Y 是 X 的补集，即 Y = V - X，且满足 源点 属于X,汇点 属于 Y。则称K=（X,Y）为网络 G 的割，K的容量记为 cap（K） 最小割就是该网络中流量最小的割。</p>
<p><strong>最小割最大流定理：</strong></p>
<p>指在一个网络流中，能够从源点到达汇点的最大流量  等于  如果从网络中移除就能够导致网络流中断的边的集合的最小容量和。即在任何网络中，最大流的值等于最小割的容量</p>
<p>完整描述：下面给出的三个定理是等价的</p>
<p>（1）f 是 G 的最大流 （2）残余网络不包含增广路径  （3）对于图的某个割K=(X,Y)，最大流=cap（K）</p>
<h2 id="最大流问题："><a href="#最大流问题：" class="headerlink" title="最大流问题："></a>最大流问题：</h2><p> 在不超过个边容量限制的情况下，求源点到汇点的最大流量</p>
<p>Ford-Fulkson算法思想：</p>
<p>（1）初始化网络中所有边的容量，c（u，v）表示边的容量，c（v , u）=0 边（v,u）为回退边</p>
<p>（2）在残量网络中找一条从源点到汇点的增广路P，找到进行（3）否则进行（5）</p>
<p>（3）在增广路中找到路径中容量最小的边 X，累加到最大流中。</p>
<p>（4）将增广路中所有的c（u，v）减去 X ，所有的c（v,u）加上X，构成新的残余网络，转步骤（2）</p>
<p>（5）得到最大流，退出</p>
<p>《算法导论》中将Ford-Fulkson归结为一种方法而非算法，也许正是因为（2）中为给出寻找增广路的具体方法。</p>
<p>而能否高效的寻找到增广路是判断各算法优劣的主要依据。</p>
<p>根据刘汝佳大大在书中的建议：理解Ford-Fulkson算法的原理，比赛中使用Dinic或者ISAP（当做黑盒算法）</p>
<p>Dinic算法模板：</p>
<pre><code>#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;cstdio&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;
const int maxn=1e3+10,INF=1e8;
struct Edge{
    int from,to,cap,flow;
    Edge(int u,int v,int c,int f):from(u),to(v),cap(c),flow(f){}
};
struct Dinic{
    int n,m,s,t;
    vector&lt;int &gt;G[maxn];
    vector&lt;Edge&gt;edges;
    bool vis[maxn];
    int d[maxn],cur[maxn];
    void init(int n){
        this-&gt;n=n;
        for(int i=0;i&lt;=n;i++)G[i].clear();
        edges.clear();
    }
    void AddEdge(int from,int to,int cap){
        edges.push_back(Edge(from,to,cap,0));
        edges.push_back(Edge(to,from,0,0));
        m=edges.size();
        G[from].push_back(m-2);
        G[to].push_back(m-1);
    }
    bool bfs(){
        memset(vis,false,sizeof(vis));
        queue&lt;int&gt;Q;
        vis[s]=true;
        d[s]=0;
        Q.push(s);
        while(!Q.empty()){
            int x=Q.front();Q.pop();
            for(int i=0;i&lt;G[x].size();i++){
                Edge &amp;e=edges[G[x][i]];
                if(!vis[e.to] &amp;&amp; e.cap&gt;e.flow){
                    vis[e.to]=1;
                    d[e.to]=d[x]+1;
                    Q.push(e.to);
                }
            }
        }
        return vis[t];
    }
    int dfs(int x,int a){//a当前为止所有弧的最小残量 
        if(x==t || a==0)return a;
        int flow=0,f;
        for(int &amp;i=cur[x];i&lt;G[x].size();i++) {//cur当前弧优化
            Edge &amp;e=edges[G[x][i]];
            if(d[e.to]==d[x]+1 &amp;&amp; (f=dfs(e.to,min(a,e.cap-e.flow)))&gt;0){
                e.flow+=f;
                edges[G[x][i]^1].flow-=f;
                flow+=f;
                a-=f;
                if(a==0)break;
            }
        }
        return flow;
    }
    int max_flow(int s,int t){
        this-&gt;s=s;this-&gt;t=t;
        int flow=0;
        while(bfs()){
            memset(cur,0,sizeof(cur));
            flow+=dfs(s,INF);
        }
        return flow;
    }
};
Dinic solve;
int main(){
    int n,m;
    while(~scanf(&quot;%d%d&quot;,&amp;m,&amp;n)){
        solve.init(n);
        while(m--){
            int a,b,c;
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            solve.AddEdge(a,b,c);
        }
        printf(&quot;%d\n&quot;,solve.max_flow(1,n));
    }
    return 0;
}
/*
7 6
1 2 10
1 3 10
2 4 4
2 5 8
3 5 9
4 6 10
5 6 10
*/</code></pre><h2 id="最大费用最小流："><a href="#最大费用最小流：" class="headerlink" title="最大费用最小流："></a>最大费用最小流：</h2><p>每条边除了有一个容量限制外，还有所需要的费用。而要达到的是总流量最大的前提下，总费用最小的流。</p>
<p>MCMF模板</p>
<pre><code>#include&lt;bits/stdc++.h&gt;
using namespace std;
#define LL long long
const int maxn=1e3,INF=1&lt;&lt;30;
struct Edge{
    int from,to,cap,flow,cost;
    Edge(int u,int v,int c,int f,int w):from(u),to(v),cap(c),flow(f),cost(w){}
};
struct MCMF{
    int n,m;
    vector&lt;Edge&gt;edges;
    vector&lt;int&gt;G[maxn];
    int inq[maxn];//是否在队列中 
    int d[maxn];//bellman-ford
    int p[maxn];//上一条弧 
    int a[maxn];//可改进量
    void init(int n) {
        this-&gt;n=n;
        for(int i=0;i&lt;n;i++)G[i].clear();
        edges.clear();
    }
    void AddEdge(int from,int to,int cap,int cost){
        edges.push_back(Edge(from,to,cap,0,cost));
        edges.push_back(Edge(to,from,0,0,-cost));
        m=edges.size();
        G[from].push_back(m-2);G[to].push_back(m-1);
    }
    bool BellmanFord(int s,int t,int&amp; flow,LL&amp; cost){
        for(int i=0;i&lt;n;i++)d[i]=INF;
        memset(inq,0,sizeof(inq));
        d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;
        queue&lt;int&gt;Q;
        Q.push(s);
        while(!Q.empty()){
            int u=Q.front();Q.pop();
            inq[u]=0;
            for(int i=0;i&lt;G[u].size();i++){
                Edge&amp; e=edges[G[u][i]];
                if(e.cap&gt;e.flow &amp;&amp; d[e.to]&gt;d[u]+e.cost){
                    d[e.to]=d[u]+e.cost;
                    p[e.to]=G[u][i];
                    a[e.to]=min(a[u],e.cap-e.flow);
                    if(!inq[e.to]){Q.push(e.to);inq[e.to]=1;}
                }
            }
        }
        if(d[t]==INF)return false;
        flow+=a[t];
        cost+=(LL)d[t]*(LL)a[t];
        for(int u=t;u!=s;u=edges[p[u]].from){
            edges[p[u]].flow+=a[t];
            edges[p[u]^1].flow-=a[t];
        }
        return true;
    }
    int MincostMaxflow(int s,int t,LL&amp; cost){//初始网络中没有负权边 
        int flow=0;cost=0;
        while(BellmanFord(s,t,flow,cost));
        return flow;
    }
};
int main() {
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 3938 Portal</title>
    <url>/tpaaaaaa.github.io/2019/08/29/HDU-3938Portal/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>ZLGG found a magic theory that the bigger banana the bigger banana peel .This important theory can help him make a portal in our universal. Unfortunately, making a pair of portals will cost min{T} energies. T in a path between point V and point U is the length of the longest edge in the path. There may be lots of paths between two points. Now ZLGG owned L energies and he want to know how many kind of path he could make.</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>Kruskal算法改造一下。</p>
<p>A到B有多条路径</p>
<p>每个路径的最长边是T</p>
<p>所以每次建一条A到B的路径，这个最小路径理解为min{T}.</p>
<p><strong>对于这种将两点间的路径代价定义为路径上的最长边的题目，通常考虑kruskal</strong></p>
<p>我们可以从代价最小的边 一条一条添加上去，在添加某条边时，如果使得两个点变成一个连通分量，说明这条边，就是这两个路径上的最大的边。</p>
<p>ZLGG有 L ，能建立多少种path</p>
<p>用num[w] 表示w能量下的点的对数,s[i] 表示i所在的连通分量里面的点数 我们首先将边从小到大排序</p>
<p>取边 e， u, v, w</p>
<p>如果边的两个端点不在同一个联通分量，则将这两个连通分量联系起来 //此时这两个点的路径就是w</p>
<p>那么num[w] = s[v] * s[u]</p>
<p>将询问从小到大排序</p>
<p>对于 询问L，</p>
<p>我们开始填边，如果此时边的长度已经大于L，则结束填边，考虑下一条询问</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>Kruskal改造，将两点间的路径代价定义为路径上的最长边的题目</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1811 Rank of Tetris</title>
    <url>/tpaaaaaa.github.io/2019/08/29/HDU-1811RankofTetris/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>兰兰工作之后独立开发了一个排名榜。 </p>
<p>为了更好地适应市场需求，兰兰想要制作一个实时更新的排名榜。这个排名榜是按照分数从高到底进行排名的。如果两个人的分数相同，那就按这几个人的幸运值从高到低来排。 </p>
<p>为了便于排名，每个人都被赋予了一个编号，从0到n-1,编号越大的人幸运值越高。<br>现在兰兰已知m个关于排名的信息，有三种类型，分别是”P &gt; Q”,”P = Q”,”P &lt; Q”，分别表示P的分数高于Q,等于Q,小于Q。 </p>
<p>兰兰并不需要你制作这个排名榜，只需要让你告诉他，根据已知的信息是否能够确定这个排名榜，能够确定就输出”OK”。否则输出错误的原因，如果是因为信息不完整，输出”UNCERTAIN”，如果是因为存在冲突的信息，输出”CONFLICT”。 如果错误原因有信息不完全且包含冲突信息，输出”CONFLICT”。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>理解题目意思。 给的是分数，如果分数相同则比较编号。我们可以将A&gt;B理解为AB之间存在着一条由B指向A的边。 那么就可以将原题理解为一个图。</p>
<p><strong>关于拓扑排序</strong>： 在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它之前的节点。 先统计所有节点的入度，<strong>对于入度为0的节点就可以分离出来</strong>，然后把这个节点指向的节点的入度减一。 一直做改操作，直到所有的节点都被分离出来。 <strong>如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况</strong>。</p>
<p>关于此题： 首先将分数相同的合并到一个集合里面，简化成一个点看 大致排名 分数高的 &gt; 分数中的（有一堆相同的） &gt; 分数低的</p>
<p><strong>然后相同的里面又按照编号来排名，所以只需要保证输入的时候，相同数分数 和其根分数大小不发生冲突即可</strong></p>
<p>然后对于不同分数的，我们可以建一个有向图， 分数低的指向分数高的 最后对这个图进行分析 。</p>
<p>如果这个图不能进行拓扑排序，说明存在环，则输出冲突</p>
<p>不能进行拓扑排序的意思是，逐步弹点后，不存在入度为0 的点了. 也就是<strong>已经拓扑排序的点的数目 要小于 总的点（相同的分数理解为一个点了）的个数</strong></p>
<p>如果能有多条拓扑排序，则输出无法判断</p>
<p>意思是某次弹点时，<strong>入度为0的点的数目大于1个，也就是说明有多个选择…所以无法判断</strong></p>
<p>如果只有一条拓扑排序，则输出ok</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><p>这是建图部分的代码</p>
<pre><code>for(int i = 1; i &lt;= m; i++)   
{
    int f1 = findRoot(node[i].x);
    int f2 = findRoot(node[i].y);
    if(f1 == f2 &amp;&amp; node[i].w != 0)                 //是同一个点,但却有大小，说明冲突了
    {
       conflict = true;                             //==部分发生了冲突
       break;
    }
    else if(f1 != f2)
    {
        if(node[i].w == 0)          //将这两个联通分量联系在一起
            pre[f2] = f1;
        if(node[i].w == 1)
            addEdge(f2, f1);        //连一条指向f1的边,f1的入度要加1
        else if(node[i].w == 2)
            addEdge(f1, f2);
    }
}</code></pre><p>拓扑排序部分：</p>
<pre><code>int solve()
{
    int sum = 0;                //sum记录图中联通分量（将相等部分看做点）的数目
    queue &lt; int &gt; Q;            //存的是入度为0 的点
    for(int i = 0; i &lt; n; i++)  //对每个点进行遍历一次，看看有多少个连通分量
        if(findRoot(i) == i)  
        {
            sum++;
            if(in[i] == 0)      //具有入度为0的点
                Q.push(i);
        }
    int temSum = 0;             //记录拓扑排序涉及到的点，如果点的数目少于sum，则说明存在环，说明冲突了
    bool uncertain = false;
    while(!Q.empty())           //一直到没有入度为0的点位置
    {
        if(Q.size() &gt;= 2)       //大于1个
            uncertain = true;    //无法判断,但是冲突的优先级大于无法判断的。
                                 //所以不能着急退出循环，因为有可能之后出现冲突的情况
        int u = Q.front();
        Q.pop();                  //然后将这个点连接的所有点的入度减1;
        temSum ++;                //弹出点数目
        for(int i = head[u]; i != -1; i = edge[i].next) //遍历与弹出点相连的点
                                                        //将他们的入度减一
        {
            int v = findRoot(edge[i].to);
            in[v]--;
            if(in[v] == 0)  //减为0了
                Q.push(v);  //加入入度为0的点队列中
        }
    }
    if(temSum &lt; sum)
        return -1;
    else if(uncertain == false)
        return 1;
    else
        return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>拓扑排序，并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2874 Connections between cities</title>
    <url>/tpaaaaaa.github.io/2019/08/29/HDU-2874Connectionsbetweencities/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>第一次世界大战后，许多城市遭到严重破坏，我们需要重建这些城市。但是，某些材料只能在某些地方生产。所以我们需要将这些材料从一个城市运到另一个城市。由于战争期间大部分道路已被完全摧毁，两个城市之间可能没有路径，也没有环存在。 现在，你的任务来了。在告诉您道路状况后，我们想知道任何两个城市之间是否存在路径。如果答案是肯定的，则输出它们之间的最短路径。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目给你的是森林，不是一棵树，所以存在两点不连通的情况，在使用Tarjan遍历询问的时候，之前是判断这个点vis[v] == true ，现在就是判断这个点的vis[v] == tot，也就是说vis这个点记录的不单单是访问过没有，也记录了这点是遍历哪一棵树时候访问过的。</p>
<p>主要改动是：</p>
<pre><code>for(int i = 1; i &lt;= n; i++)  //之前是直接Tarjan(1)，现在是枚举每一个未遍历过的点来进行访问，每次访问的访问标记不同，依次来区别属于哪棵树。
{
    if(vis[i] == 0)
    {
        dis[i] = 0; //dir[i]存的是这棵树到自己根的距离
        k++;
        Tarjan(i, k);
    }
}</code></pre><p>第二个改动就是</p>
<pre><code>for(int i = headq[s]; i != -1; i = ques[i].next)
{
    int v = ques[i].y;
    if(vis[v] == k)  //是在同一棵树下访问过的
    {
        if(i % 2)
            ques[i].lca = ques[i + 1].lca = findRoot(v);
        else
            ques[i].lca = ques[i - 1].lca = findRoot(v);
    }
}</code></pre><p>最后输出时候，每个询问的LCA如果为-1，就意味着这两个点不连通。</p>
<pre><code>for(int i = 1; i &lt;= c; i++)
{
    int j = i * 2;
    int u = ques[j].x;
    int v = ques[j].y;
    int lca = ques[j].lca;      //lca存的最近公共祖先的点编号
    if(lca == -1 )
        printf(&quot;Not connected\n&quot;);
    else
        printf(&quot;%d\n&quot;, dis[u] + dis[v] - 2*dis[lca]);
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最近公共祖先LCA，树上的最短路问题，Tarjan解LCA</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2586 How far away ？</title>
    <url>/tpaaaaaa.github.io/2019/08/29/HDU-2586Howfaraway%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>勇气小镇是一个有着n个房屋的小镇，为什么把它叫做勇气小镇呢，这个故事就要从勇气小镇成立的那天说起了，<br>修建小镇的时候，为了让小镇有特色，镇长特地只修了n-1条路，并且规定说，所有在勇气小镇的村民，每一次出门必须规划好路线,<br>路线必须满足在到达终点之前绝对不走回头路。每个人都要这样，不然那个人就不配在小镇生活下去，因为他没有这个勇气。<br>事实上，这并不能算一项挑战，因为n-1条路已经连通了每户人家，不回头地从起点到终点，只是一个时间上的问题。<br>由于小镇上的福利特别好，所以小懒入住了这个小镇，他规划了m次的行程，每次从L房屋到R房屋,他想问你他每次从L房屋到R房屋需要走多远的路。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>给你一棵树，让你求出任意两点的最短距离。 树上点的最短距离问题，可以用最近公共祖先来解决。 dis[i]数组表示i节点距离根节点的距离。对于L和R，我们首先得到LCA， 然后则L到R的最短距离路径就是L往上走，走到LCA，再往下走走到R。</p>
<p>因此最短距离就是 <strong>dis[L] + dis[R] - 2 * dis[LCA]</strong></p>
<p>所以问题就变成了如何求树上两点的LCA了。用离线算法Tarjan可以，或者将LCA转化为RMQ问题求解也可以。下面就依这个题目为依据，将两个方法都具体的解释一遍</p>
<h2 id="Tarjan："><a href="#Tarjan：" class="headerlink" title="Tarjan："></a>Tarjan：</h2><p>首先是输入部分：将边和询问关系全部录入相应的结构体数组中</p>
<pre><code>for(int i = 1; i &lt; n; i++)  // n 个点， 一棵树的话就有n - 1条边
{
    int x, y, w;
    scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;w);
    addEdge(x, y, w);     //无向边
    addEdge(y, x, w);
}
for(int i = 1; i &lt;= m; i++) //问题的编号1.2    3.4   5.6   ....
{
    int x, y;
    scanf(&quot;%d%d&quot;,&amp;x, &amp;y);
    addQues(x, y);            
    addQues(y, x);
}</code></pre><p>接下来以1为根节点，开始Tarjan （其本质就是DFS）</p>
<pre><code>void Tarjan(int s)        //根节点为s
{
    vis[s] = true;        //标记已访问
    pre[s] = s;           //都是自己
    for(int i = head[s]; i != -1; i = edge[i].next) // 开始遍历自己的子节点
        if(vis[edge[i].to] == false)  //这个节点没有访问过
        {
            int v = edge[i].to;
            int w = edge[i].w;
            dis[v] = dis[s] + w;      //更新这个节点的dis数组
            Tarjan(v);                //从这个节点开始继续dfs
            pre[v] = pre[s];          //这个节点dfs回来后，将子树与根合并
            //合并
        }
    for(int i = Qhead[s]; i != -1; i = ques[i].next) //开始遍历每个与s相关的询问
    {
        if(vis[ques[i].to] == true)          //如果这个点已经访问过了。
        {
            int v = ques[i].to;
            if(i%2)
                ques[i].lca = ques[i + 1].lca = findRoot(v);
            else
                ques[i].lca = ques[i - 1].lca = findRoot(v);
        }
    }
}</code></pre><p>所有处理完后，开始输出答案</p>
<pre><code>for(int i = 1; i &lt;= m; i++)
{
    int j = i * 2; // 因为ques[1]ques[2]； ques[3]ques[4] ...是同一个询问
    int u = ques[j].from, v = ques[j].to;
    int lca = ques[j].lca; // 这是这个询问的LCA
    printf(&quot;%d\n&quot;, dir[u] + dir[v] - 2 * dir[lca]);
}</code></pre><h2 id="LCA转RMQ："><a href="#LCA转RMQ：" class="headerlink" title="LCA转RMQ："></a>LCA转RMQ：</h2><p>首先是输入部分：因为是在线算法，所以不需要提前将询问录入</p>
<pre><code>for(int i = 1; i &lt; n; i++)
{
    int u, v, w;
    scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);
    addEdge(u, v, w);          //无向边
    addEdge(v, u, w);
}</code></pre><p>接下来也是从根节点开始DFS，生成ver数组（DFS的欧拉序列），depth数组（DFS每次的深度）, dis数组（节点距离根节点的距离），first数组（每个节点第一次出现在ver数组之中的下标）。</p>
<pre><code>void dfs(int u, int dep)
{
    vis[u] = true;  //dfs 的标记           
    ver[++tot] = u; //ver记录的是欧拉序列, tot记录的是节点的访问编号
    first[u] = tot; //u这个点第一次出现的位置
    depth[tot] = dep;   //深度表
    for(int k = head[u]; k != -1; k = edge[k].next) //遍历下一个点
    {
        int v = edge[k].v;
        if(vis[v] == false)
        {
            int w = edge[k].w;
            dis[v] = dis[u] + w;    //更新距离
            dfs(v, dep + 1);        // 向下dfs
            ver[++tot] = u;         //递归下去又上来了
            depth[tot] = dep;
        }
    }
}</code></pre><p>这RMQ求的是区间里面深度最小的点。</p>
<p>如果欧拉序列ver:1 <strong>2</strong> 5 2 6 2 1 3 1 <strong>4</strong> 1；深度序列Depth为: 0 <strong>1</strong> 2 1 2 1 <strong>0</strong> 1 0 <strong>1</strong> 0，first(u)为:1 <strong>2</strong> 8 <strong>10</strong> 3 5。 如果我们要求 2号点到4号点的LCA。则首先利用first数组知道2号点第一次出现在ver数组中的第2个位置，4号点第一次出现在ver数组的第10个位置，那么我们要找的就是depth数组中[2, 10]这个区间里面深度最小的点，显然为depth第7个位置(深度为0)，其对应在ver数组中为 1号点，也就是说2号点和4号点的最近公共祖先是1号点。</p>
<p>求完以上几个数组，还有一个重要的数组要求，就是dp数组，用的是动态规划的思想, dp[i][j] 表示的是从ver第i个点开始的2^j 个点中的深度最小的点的编号，我们用ST函数求。</p>
<pre><code>void ST(int len)                    //len是ver数组的长度
{
    int k = (int) (log((double) len ) / log(2.0) ); //意思是最长的长度为len == 2^k次 
    for(int i = 1; i &lt;= len; i++)   //初始化
        dp[i][0] = i;               //这记得的深度最下的点的下标
    for(int j = 1; j &lt;= k; j++)     //首先枚举j
        for(int i = 1; i + _pow[j] - 1 &lt;= len; i++) // 枚举起点
                                     //这一次枚举考虑的区间就是[i, i + 2^j - 1]
        {
            int a = dp[i][j - 1];    //这个区间的最值，就是将这个区间分成a，b两个区间的这两个区间中的最值的最值。因为原区间为从i开始，连续的2^j个点，所以a区间就是从i开始，连续的2^(j-1)个点，b区间就是从i + 2^(j - 1)开始的连续的2^(j-1)个点
            int b = dp[i + _pow[j - 1]] [j - 1];
            if(depth[a] &lt; depth[b])
                dp[i][j] = a;
            else
                dp[i][j] = b;
        }
}</code></pre><p>然后求的是RMQ函数，作用是返回ver区间中[x, y]这个区间里面深度最小的点的下标。</p>
<pre><code>int RMQ(int x, int y)
{
    int k = (int)(log((double)(y-x+1)) / log(2.0));
    int a = dp[x][k];
    int b = dp[y - _pow[k] + 1][k];
    if(depth[a] &lt; depth[b])
        return a;
    else
        return b;
}</code></pre><p>然后就是LCA函数了，返回的是u号点和v号点的LCA点的编号</p>
<pre><code>int LCA(int u, int v)   // 求的是u 和v的LCA
{
    int x = first[u], y = first[v]; 
    if(x &gt; y)
        swap(x, y);          //要保证x在前，y在后
    int res = RMQ(x, y);    //返回的是在ver的下标
    return ver[res];
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>LCA问题，Tarjan解法， LCA转RMQ问题，模板</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]RMQ区间最值查询</title>
    <url>/tpaaaaaa.github.io/2019/08/28/%5B%E7%AE%97%E6%B3%95%5DRMQ%E5%8C%BA%E9%97%B4%E6%9C%80%E5%80%BC%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>RMQ（Range Minimum/Maximum Query），即区间最值查询，这是一种在线算法，所谓在线算法，是指用户每次输入一个查询，便马上处理一个查询。RMQ算法一般用较长时间做预处理，时间复杂度为O(nlogn)，然后可以在O（1）的时间内处理每次查询。</p>
<p>下面我们从一个实际问题来解释RMQ</p>
<p>我们假设数组arr为：1，2，6，8，4，3，7</p>
<p>我们设二维数组dp[i][j]表示从第i位开始连续2^j个数中的最小值。例如dp[2][1]就表示从第二位数开始连续两个数的最小值（也就是从第二位数到第三位数的最小值），即2，6中的最小值，所以dp[2][1] = 2;</p>
<p>其实我们求 dp[i][j] 的时候可以把它分成两部分，第一部分是从 i 到 i + 2^(j - 1) - 1 ，第二部分从 i + 2 ^( j - 1) 到 i + 2 ^ j - 1，为什么可以这么分呢？其实我们都知道二进制数前一个数是后一个的两倍，那么可以把 到 这个区间通过分成相等的两部分， 那么转移方程很容易就写出来了。（dp[i][0]就表示第i个数字本身）</p>
<p><strong>dp[i][j] = min(dp [i][j - 1], dp [i + (1 &lt;&lt; j - 1)][j - 1])</strong></p>
<p>现在求出了F[i,j]之后又是怎样求出最大值或者最小值的，怎么转换为o(1)这种算法的~这就是ST算法：</p>
<p>假设我们需要查询区间[l ，r]中的最小值，令k = ln以2为底(j-i+1) <img src="http://localhost/wp-content/uploads/2019/08/%E5%9B%BE%E7%89%87.gif" alt=""> ， 则区间[l, r]的最小值RMQ[l,r] = min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);</p>
<p>但是为什么这样就可以保证是区间最小值了呢？</p>
<p>dp[l][k]维护的是区间 [l, l + 2^k - 1] , dp[r - (1 &lt;&lt; k) + 1][k]维护的是区间 [r - 2^k + 1, r] 。</p>
<p>那么只要我们保证  r - (1 &lt;&lt; k) + 1 ≤ l + 2^k - 1 就能保证RMQ[l,r] = min(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k])；</p>
<p>这个时候询问时只要取k=ln(j-i+1)/ln2即可，那么可以令A为i到2^k的块，和B为到2^k结束的长度为2^k的块;那么A，B都是区间[i,j]的子区间，所以即求A区间的最小值和B区间的最小值的最小值。这个时候动态规划为：<strong>RMQ(i,j)=min(dp[i,k],dp[j-2^k+1,k]);</strong></p>
<h2 id="LCA问题转RMQ问题："><a href="#LCA问题转RMQ问题：" class="headerlink" title="LCA问题转RMQ问题："></a>LCA问题转RMQ问题：</h2><p>当然对于RMQ并不只有这个用法，我们可以用它来解决LCA问题。<br> 假设LCA(T,u,v)表示在有根树T中，询问一个离根最远的结点x,使得x为u,v的公共祖先。现在分析下LCA向RMQ问题转化的过程:</p>
<p>对有根树T进行深度优先遍历(DFS),将遍历到的结点按照顺序记录下来，那么我们会得到一个长度为2N-1的序列，称之为T的欧拉序列F，设序列Depth是DFS遍历过程中的结点深度的变化情况。其中每一个结点都会出现在欧拉序列F中，我们记录结点u在欧拉序列中出现的第一个位置pos(u);根据DFS的特性，对于任意两个结点u,v，那么从pos(u)(也就是第一次访问u的时候)到pos(v)(第一次访问v)的过程中，所经历的路径为F(pos(u)…..pos(v)),虽然这些包括u的后代，但是其深度最小的结点一定是u和v的LCA(公共祖先)，不论pos(u)与pos(v)的关系如何，都一定有LCA(T,u,v)=RMQ(Depth,pos(u),pos(v));</p>
<p>下面这个图是有根树的欧拉序列F和深度序列B已经pos(u)的变化情况:</p>
<pre><code>                  1                   深度为0

             /     \     \

       **2**          **3**     4          深度为1

     /   \

5        6                          深度为2</code></pre><p>那么欧拉序列F:1 <strong>2</strong> 5 2 6 2 1 <strong>3</strong> 1 4 1；深度序列Depth为: 0 1 2 1 2 1 0 1 0 1 0，pos(u)为:1 2 8 10 3 5<br>妙哉妙哉</p>
<p>所以步骤就是，首先从根开始用dfs求出 欧拉序列，深度序列，pos数组, dis数组</p>
<p>然后对RMQ中的dp数组初始化</p>
<p>对于每一个询问, u 跟 v, 我们用pos[u], pos[v] 知道其在欧拉序列中的编号L,R</p>
<p>然后求出欧拉序列[L，R]中 深度最小的点，就是u跟v的LCA了</p>
<p>RMQ模板：  </p>
<hr>
<pre><code> // dp[i][j] 保存的是[i, i + 2^j - 1] 这个区间里面的最小值
void rmq_init()  // 作用是初始化dp数组， 题目给的数组是arr[1] ... arr[N]
{
    for(int i=1;i&lt;=N;i++)
        dp[i][0]=arr[i];//初始化
    for(int j=1;(1&lt;&lt;j)&lt;=N;j++)
        for(int i=1;i+(1&lt;&lt;j)-1&lt;=N;i++)
            dp[i][j]=min(dp[i][j-1],dp[i+(1&lt;&lt;j-1)][j-1]);

}

//rmq(l, r) 的作用是查询区间[l, r]中的最小值
int rmq(int l,int r)
{
    int k=log2(r-l+1);
    return min(dp[l][k],dp[r-(1&lt;&lt;k)+1][k]);
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>[模板]LCA最近公共祖先</title>
    <url>/tpaaaaaa.github.io/2019/08/27/%5B%E6%A8%A1%E6%9D%BF%5DLCA%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h2 id="Tarjan-离线-算法-："><a href="#Tarjan-离线-算法-：" class="headerlink" title="Tarjan(离线)算法 ："></a>Tarjan(离线)算法 ：</h2><p>博文推荐：<a href="https://www.cnblogs.com/JVxie/p/4854719.html" target="_blank" rel="noopener">https://www.cnblogs.com/JVxie/p/4854719.html</a></p>
<p>TarjanTarjan 算法基于 dfs ，在 dfs 的过程中，对于每个节点位置的询问做出相应的回答。</p>
<p>　　dfs 的过程中，当一棵子树被搜索完成之后，就把他和他的父亲合并成同一集合；在搜索当前子树节点的询问时，如果该询问的另一个节点已经被访问过，那么该编号的询问是被标记了的，于是直接输出当前状态下，另一个节点所在的并查集的祖先；如果另一个节点还没有被访问过，那么就做下标记，继续 dfs 。</p>
<h3 id="模板代码："><a href="#模板代码：" class="headerlink" title="模板代码："></a>模板代码：</h3><pre><code>#include&lt;cstdio&gt;
#define N 420000
struct hehe{
    int next;
    int to;
    int lca;
};
hehe edge[N];//树的链表
hehe qedge[N];//需要查询LCA的两节点的链表
int n,m,p,x,y;
int num_edge,num_qedge,head[N],qhead[N];
int father[N];
int visit[N];//判断是否被找过
void add_edge(int from,int to){//建立树的链表
    edge[++num_edge].next=head[from];
    edge[num_edge].to=to;
    head[from]=num_edge;
}
void add_qedge(int from,int to){//建立需要查询LCA的两节点的链表
    qedge[++num_qedge].next=qhead[from];
    qedge[num_qedge].to=to;
    qhead[from]=num_qedge;
}
int find(int z){//找爹函数
    if(father[z]!=z)
        father[z]=find(father[z]);
    return father[z];
}
int dfs(int x){//把整棵树的一部分看作以节点x为根节点的小树
    father[x]=x;//由于节点x被看作是根节点，所以把x的father设为它自己
    visit[x]=1;//标记为已被搜索过
    for(int k=head[x]; k; k=edge[k].next)//遍历所有与x相连的节点
        if(!visit[edge[k].to]){//若未被搜索
            dfs(edge[k].to);//以该节点为根节点搞小树
            father[edge[k].to]=x;//把x的孩子节点的father重新设为x
        }
    for(int k=qhead[x]; k; k=qedge[k].next)//搜索包含节点x的所有询问
        if(visit[qedge[k].to]){//如果另一节点已被搜索过
            qedge[k].lca=find(qedge[k].to);//把另一节点的祖先设为这两个节点的最近公共祖先
            if(k%2)//由于将每一组查询变为两组，所以2n-1和2n的结果是一样的
                qedge[k+1].lca=qedge[k].lca;
            else
                qedge[k-1].lca=qedge[k].lca;
        }
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;p);//输入节点数，查询数和根节点
    for(int i=1;i&lt;n;++i){    //因为有n个点，树肯定只有n-1个边
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//输入每条边
        add_edge(x,y);
        add_edge(y,x);
    }
    for(int i=1;i&lt;=m;++i){
        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);//输入每次查询，考虑(u,v)时若查找到u但v未被查找，所以将(u,v)(v,u)全部记录
        add_qedge(x,y);
        add_qedge(y,x);
    }
    dfs(p);//进入以p为根节点的树的深搜
    for(int i=1;i&lt;=m;i++)
        printf(&quot;%d &quot;,qedge[i*2].lca);//两者结果一样，只输出一组即可
    return 0;
}</code></pre><h2 id="倍增算法："><a href="#倍增算法：" class="headerlink" title="倍增算法："></a>倍增算法：</h2><p>推荐博文：<a href="https://www.cnblogs.com/sllr15/p/5164996.html" target="_blank" rel="noopener">https://www.cnblogs.com/sllr15/p/5164996.html</a></p>
<p><a href="https://www.cnblogs.com/zwfymqz/p/7795299.html" target="_blank" rel="noopener">https://www.cnblogs.com/zwfymqz/p/7795299.html</a></p>
<p>在没有学习倍增写LCA之前，你是怎么样求LCA的呢？至少，我是老老实实地让这两个点一步一步往上移并找出它们的路径第一次交汇的地方。这种方法固然可行、好想，但它的效率实在不高。但是，我们完全可以通过提高“这两个点一步一步往上移”来提高效率。</p>
<p>所以，我们采用倍增的思路来预处理，分别记录这点的祖先，记录为anc[i][j]。即为第i个点往上2^j个祖先。比如说，当j=0时，2^j=1,anc[i][j]是第i个点的上一个节点，即它的父亲节点。</p>
<p>那么该如何预处理出anc数组呢？</p>
<pre><code>int anc[1005][25];
int fa[1005];
vector &lt;int &gt; tree[1005];
int deep[1005];

void dfs(int x)
{
    anc[x][0]=fa[x]; //x这个节点向上1个节点就是他的父节点
    for (int i=1;i&lt;=22;i++) // 往上处理
    {
        anc[x][i]=anc[anc[x][i-1]][i-1];//倍增思想的体现。不妨在纸上试着画一棵树，脑补一下QWQ
    }
    // anc[x][1] = anc[ anc[x][0] ] [0] x向上两个节点就是他父节点的父节点
    // anc[x][2] = anc[ anc[x][1] ] [1]; 
    //以此类推
    for (int i=0;i&lt;tree[x].size();i++) // 往下处理
    {
        if (tree[x][i]!=fa[x])
        {
            int y=tree[x][i];
            fa[y]=x;//记录父亲节点
            deep[y]=deep[x]+1;//记录深度
            dfs(y);
        }
    }
}

int lca(int x,int y)
{
    if (deep[x]&lt;deep[y]) _swap(x,y);//我们希望X是较深的点。

    for (int i=22;i&gt;=0;i--)//这个循环在完成第一步。
    {
        if (deep[y]&lt;=deep[anc[x][i]]) //不可以丢掉“=“哦Q^Q
        {
            x=anc[x][i];
        }
    }

    if (x==y) return x;//如果Y是X的祖先，就可以直接返回结果了。

    for (int i=22;i&gt;=0;i--)
    {
        if (anc[x][i]!=anc[y][i]) //第二步。
        {
            x=anc[x][i];
            y=anc[y][i];
        }
    }

    return anc[x][0];//注意第二步IF语句的条件。
}</code></pre><p>另一个博主<a href="https://blog.csdn.net/Q_M_X_D_D_/article/details/89924963" target="_blank" rel="noopener">https://blog.csdn.net/Q_M_X_D_D_/article/details/89924963</a></p>
<p>  DP[4][1]=1；结点4的向上2^1=2层的祖先是结点1。<br>        DP[10][1]=2；结点10的向上2^1=2层的祖先是结点2。<br>        特别地，DP[6][0]=3，结点6的向上2^0=1层的祖先是3，即6的父节点。而这一现象正好可以当做DP的初始条件。DP[i][0]为i的父节点。下面写出递推式：</p>
<pre><code>    DP\[i\]\[j\] = DP\[ DP\[i\]\[j-1\] \] \[j-1\]。        如何理解这个递推式呢？DP\[i\]\[j-1\]是结点i往上跳2^(j-1)层的祖先，那我们就在跳到这个结点的基础上，再向上跳2^(j-1)层，这样就相当于从结点i，先跳2^(j-1)层，再跳2^(j-1)层，最后还是到达了2^j层。这部分的代码如下：

//fa表示每个点的父节点 
int fa[100],DP[100][20];
void init()
{
    //n为结点数，先初始化DP数组 
    for(int i=1;i&lt;=n;i++)
        dp[i][0]=fa[i];
    //动态规划求出整个DP数组 
    for(int j=1;(1&lt;&lt;j)&lt;=n;j++)
        for(int i=1;i&lt;=n;i++)
            DP[i][j]=DP[DP[i][j-1]][j-1];
}</code></pre><p>查询函数：<br>        这个函数的参数就是要查询的两个结点a和b。在函数中我们应指定a是深度较大的那个（b也可以），这样方便操作。然后让b不断向上回溯，直到跟a处于同一深度。然后让a和b同时向上回溯，直到二者相遇。这个过程不难理解，但是要实现我们刚才说的一步跳好几层就需要细细思考了。在函数中，共有两次回溯，一次是发生在使a与b处于同一深度时，另一次发生在使a和b共同向上回溯找LCA时，下面我们运用刚才说的两个关键理论对这两次回溯分别进行分析：</p>
<p>假设a和b的深度相差5，我们需要让b向上跳，步步逼近a所在的深度，直到与a同深度。如何选取这个步长呢？两个原则：<br>1、选取的步长肯定不能大于二者的深度差，否则b的深度就小于a的了；<br>2、选择最接近深度差但又不大于深度差的2的幂次数。这使我们每一步都不会超出a，而且步步逼近a。<br>那么我们要做的就是本着这两个原则，根据二者的深度差来选取合适的步长，步步逼近。根据正整数拆分理论，不管深度差是多少，二者最后一定能处于同一深度。<br>第二次回溯与第一次不同的是：第一次回溯，已经知道了要跳多少层，所以就可以用正整数拆分理论选择步长。而这次回溯是要找LCA，即找一个层数使a和b跳上去之后正好相遇，也就是说我们只能试探着往上跳，步步逼近。<br>那我们如何选取a和b同时向上跳的步长？这里用到了我们刚才说的第二个关键理论：若c是a和b的LCA，则c的祖先也是a和b的祖先，但不是最近的。所以这里选取步长的原则就是：大胆地、试探性地往上跳。<br>可能出现两种情况：<br>1、若跳到了某一层后a和b相遇了，则说明相遇处的结点就是a和b的公共祖先，但不一定是最近的。这个点就告诉我们：LCA可能还在这个点的下方。那我们就不往这个点上跳，因为这个点有可能不是我们要找的LCA。<br>2、若跳到了某一层后，a和b没有相遇，则说明a和b的LCA在这层之上，那我们完全可以跳到这一层上，这会使我们步步逼近最终的LCA。根据正整数拆分理论，我们最后也一定能找到LCA。<br>        第一次回溯比较容易理解。重点说一下第二次回溯。换个角度讲，假设我们事先知道LCA与a、b差10层，那么我们如果一步跳了10层以上的话，肯定会跳到LCA的祖先上，那我们就减少步长。如果一步跳8层的话，a和b肯定没有相遇，这时我们就可以跳上来。然后LCA与a、b就差两层了。虽然再跳两层就到了，但是程序只知道这是a和b的公共祖先，但不知道这是不是最近公共祖先，而我们只是开了上帝视角知道了而已，所以程度就会放弃2这个步长，还会将步长减小为1并跳上去。当步长减小为1时，这个试探的过程就可以结束了，因为LCA肯定就是此时a和b的父节点。</p>
<pre><code>    不管LCA与a、b差几层，哪怕是8层、4层这种一步就可以跳上去的情况，程序也不会一步跳上去，因为程序总觉得可能这不是最近的公共祖先。而是会步步逼近，直到与LCA只差一层。所以当试探结束后，a和b的父节点就是他们的LCA啦。结合代码理解一下：  


//查询函数
int LCA(int a,int b)
{
    //确保a的深度大于b，便于后面操作。
    if(dep[a]&lt;dep[b])
        swap(a,b);
    //让a不断往上跳，直到与b处于同一深度
    //若不能确保a的深度大于b，则在这一步中就无法确定往上跳的是a还是b
    for(int i=19;i&gt;=0;i--)
    {
        //往上跳就是深度减少的过程
        if(dep[a]-(1&lt;&lt;i)&gt;=dep[b])
            a=dp[a][i];
    }
    //若二者处于同一深度后，正好相遇，则这个点就是LCA
    if(a==b)
        return a;
    //a和b同时往上跳，从大到小遍历步长，遇到合适的就跳上去，不合适就减少步长
    for(int i=19;i&gt;=0;i--)
    {
        //若二者没相遇则跳上去
        if(dp[a][i]!=dp[b][i])
        {
            a=dp[a][i];
            b=dp[b][i];
        }
    }
    //最后a和b跳到了LCA的下一层，LCA就是a和b的父节点
    return dp[a][0];
}


    至此，倍增法的主要思想和编码就完成了。程序中还剩一小段编码没有完成，就是对树的深搜。在此过程中我们要保存各节点的深度和父节点。</code></pre><p>另一个模板</p>
<pre><code>#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
using namespace std;
const int MAXN = 1000010;
inline void read(int &amp;n) {
    char c = getchar(); bool flag = 0; n = 0;
    while (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;)    c == &apos;-&apos; ? flag = 1, c = getchar() : c = getchar();
    while (c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;)    n = n * 10 + c - 48, c = getchar(); flag == 1 ? n = -n : n = n;
}
struct node {
    int v, nxt;
} edge[MAXN];
int head[MAXN];
int num = 1;
inline void add_edge(int x, int y) {
    edge[num].v = y;
    edge[num].nxt = head[x];
    head[x] = num++;
}
int f[MAXN][21];
int deep[MAXN];
int n, m, root;
void dfs(int now) {
    for (int i = head[now]; i != -1; i = edge[i].nxt)
        if (!deep[edge[i].v])
            deep[edge[i].v] = deep[now] + 1, f[edge[i].v][0] = now, dfs(edge[i].v);
}
void PRE() {
    for (int i = 1; i &lt;= 19; i++)
        for (int j = 1; j &lt;= n; j++)
            f[j][i] = f[f[j][i - 1]][i - 1];
}
int LCA(int x, int y) {
    if (deep[x] &lt; deep[y])    swap(x, y);
    for (int i = 19; i &gt;= 0; i--)
        if (deep[f[x][i]] &gt;= deep[y])
            x = f[x][i];
    if (x == y)    return x;
    for (int i = 19; i &gt;= 0; i--)
        if (f[x][i] != f[y][i])
            x = f[x][i], y = f[y][i];
    return    f[x][0];
}
int main() {

    memset(head, -1, sizeof(head));
    read(n); read(m); read(root);
    for (int i = 1; i &lt;= n - 1; i++) {
        int x, y; read(x); read(y);
        add_edge(x, y);
        add_edge(y, x);
    }
    deep[root] = 1;
    dfs(root);
    PRE();
    for (int i = 1; i &lt;= m; i++) {
        int x, y;
        read(x); read(y);
        printf(&quot;%d\n&quot;, LCA(x, y));
    }
    return 0;
}</code></pre><h2 id="RMQ算法："><a href="#RMQ算法：" class="headerlink" title="RMQ算法："></a>RMQ算法：</h2><p>看我的另一个博文<a href="http://localhost/?p=114" target="_blank" rel="noopener">http://localhost/?p=114</a></p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]最小树形图--朱刘算法</title>
    <url>/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E6%A0%91%E5%BD%A2%E5%9B%BE--%E6%9C%B1%E5%88%98%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="最小树形图："><a href="#最小树形图：" class="headerlink" title="最小树形图："></a>最小树形图：</h2><p><strong>定义：</strong>设G = (V,E)是一个有向图，它具有下述性质：</p>
<ol>
<li>G中不包含有向环；　(也就是E的数目等于 V - 1)</li>
<li>存在一个顶点vi，它不是任何弧的终点，而V中的其它顶点都恰好是唯一的一条弧的终点，则称 G是以vi为根的<strong>树形图</strong>。(G是一棵有向图的生成树)</li>
</ol>
<p>最小树形图就是有向图G = (V, E)中以vi为根的树形图中权值和最小的那一个。</p>
<p>另一种说法：最小树形图，就是给有向带权图一个特殊的点root，求一棵以root为根节点的树使得该树的的总权值最小。</p>
<p><strong>性质：</strong>最小树形图基于贪心和缩点的思想。</p>
<p><strong>缩点：</strong>将几个点看成一个点，所有连到这几个点的边都视为连到收缩点,所有从这几个点连出的边都视为从收缩点连出</p>
<p><strong>实现细节 ：</strong></p>
<p>设根结点为v0，</p>
<ul>
<li>（1）求最短弧集合E0</li>
</ul>
<p>　　从所有以vi(i ≠ 0)为终点的弧中取一条最短的，若对于点i，<strong>没有入边，则不存在最小树形图</strong>，算法结束；如果能取，则得到由n个点和n-1条边组成的图G的一个子图G’，这个子图的权值一定是最小的，但是不一定是一棵树</p>
<ul>
<li>（2）检查E0</li>
</ul>
<p>　　若E0没有有向环且不包含收缩点,则计算结束，E0就是图G以v0为根的最小树形图；若E0含有有向环，则转入步骤(3)；若E0没有有向环,但是存在收缩点，转到步骤(4)。</p>
<ul>
<li>（3）收缩G中的有向环</li>
</ul>
<p>　　把G中的环C收缩成点u，对于<strong>图G中两端都属于C的边就会被收缩掉</strong>，其他弧仍然保留，得到一个新的图G1，G1中以<strong>收缩点为终点的弧的长度要变化</strong>。变化的规则是：设点v在环C中，且环中指向v的边的权值为w，点v’不在环C中，则对于G中的每一条边&lt;v’, v&gt;，在G1中有边&lt;v’, u&gt;和其对应，且<strong>权值W**</strong>G1<strong><strong>(&lt;v’, u&gt;) = W</strong></strong>G<strong>**(&lt;v’, v&gt;) - w</strong>；对于图G中以环C中的点为起点的边&lt;v, v’&gt;，在图G1中有边&lt;u, v’&gt;，则WG1(&lt;u, v’&gt;) = WG(&lt;v, v’&gt;)。有一点需要注意,在这里生成的图G1可能存在重边。</p>
<p>　　对于图G和G1：  </p>
<p>　　①如果图G1中没有以v0为根的最小树形图，则图G也没有；</p>
<p>　　②如果G1中有一v0为根的最小树形图，则可按照步骤（4）的展开方法得到图G的最小树形图。</p>
<p>所以，应该对于图G1代到(1)中反复求其最小树形图，直到G1的最小树形图u求出。</p>
<ul>
<li>（4）展开收缩点</li>
</ul>
<p>　　假设图G1的最小树形图为T1,<strong>那么T**</strong>1<strong>**中所有的弧都属于图G的最小树形图T</strong>。将G1的一个收缩点u展开成环C，<strong>从C中去掉与T**</strong>1<strong>**具有相同终点的弧</strong>，其他弧都属于T。</p>
<p><img src="https://pic002.cnblogs.com/images/2012/307740/2012071809493394.jpg" alt=""></p>
<p>最小树形图的构造过程  </p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>int Directed_MST(int root, int V, int E) // 传入的是构造最小树形图的根， 点的数目， 边的数目
{
    int ret = 0;//存最小树形图总权值
    while(true)
    {
        int i;
        //1.找每个节点的最小入边
        for( i = 0; i &lt; V; i++)
            in[i] = INF;//in[i] 保存的是第i个点的最小入边的权值  初始化为无穷大
        for( i = 0; i &lt; E; i++)//遍历每条边
        {
            int u = edge[i].u;
            int v = edge[i].v;
            if(edge[i].w &lt; in[v] &amp;&amp; u != v)//说明顶点v有条权值较小的入边  记录之
            {
                pre[v] = u;//节点u指向v，pre[v]记录的是指向v的最小入边的起始点
                in[v] = edge[i].w;//最小入边
                if(u == root)//这个点就是实际的起点
                    pos = i; //??
            }
        }
        for( i = 0; i &lt; V; i++)//判断是否存在最小树形图
        {
            if(i == root)   // 根 天生不管
                continue;
            if(in[i] == INF)
                return -1;//除了根以外有点没有入边,则根无法到达它  说明它是独立的点 一定不能构成树形图
        }
        //2.找环
        int cnt = 0;//记录环数
        memset(id, -1, sizeof(id)); //id[i] 记录的是点i是属于第几个环
        memset(vis, -1, sizeof(vis));
        in[root] = 0;          // 根的入度为0 
        for( i = 0; i &lt; V; i++) //遍历每个点，标记每个环
        {
            ret += in[i];    //记录权值，就是G1图的n-1条边的权值
            int v = i;
            while(vis[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root)
            {
                vis[v] = i;
                v = pre[v];
            }
            if(v != root &amp;&amp; id[v] == -1) // 找到环了
            {
                for(int u = pre[v]; u != v; u = pre[u])
                    id[u] = cnt;//标记节点u为第几个环
                id[v] = cnt++;
            }
        }
        if(cnt == 0)
            break; //无环，   则break
        for( i = 0; i &lt; V; i++)
            if(id[i] == -1)
                id[i] = cnt++; // 给每个单独的点赋予一个连通分量的编号
            //3.建立新图   缩点,重新标记
            for( i = 0; i &lt; E; i++)
            {
                int u = edge[i].u;
                int v = edge[i].v;
                edge[i].u = id[u];
                edge[i].v = id[v];
                if(id[u] != id[v])
                    edge[i].w -= in[v];
            }
            V = cnt;   // 这是新图上点的数目
            root = id[root];
    }
    return ret;
}</code></pre><p>另外一个博主的</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

using namespace std;
const int MAXN = 1e4 , INF = 1e8;
int d[MAXN] , id[MAXN] , vis[MAXN] , pre[MAXN]; //d:除root点外每个点的最小入边 id:下一次建图新的节点号 vis:用来判断是否成环 下面程序见 pre:点的前序节点
int V , E;    // V:点的个数    E:边的个数
struct node {
    int u , v , cost;  //边的起点  终点  以及长度
}edge[MAXN];

int zhuliu(int root) {
    int res = 0;   //最小树形图的长度
    while(true) {
        for(int i = 0 ; i &lt; V ; i++) {
            d[i] = INF;
        }
        for(int i = 0 ; i &lt; E ; i++) {    //寻找最小入边
            int u = edge[i].u , v = edge[i].v;
            if(u != v &amp;&amp; edge[i].cost &lt; d[v]) {
                pre[v] = u;
                d[v] = edge[i].cost;
            }
        }
        for(int i = 0 ; i &lt; V ; i++) {
            if(i != root &amp;&amp; d[i] == INF) {        //除了root之外  有别的点无最小入边
                return -1;               
            }
        }
        int cont = 0;
        memset(id , -1 , sizeof(id));
        memset(vis , -1 , sizeof(vis));
        d[root] = 0;
        for(int i = 0 ; i &lt; V ; i++) {   //找环
            res += d[i];
            int v = i;
            //vis[v] == i 表明找到一个环    id[v] != -1 表明这个点在循环中已经被下面的操作缩点(在环中)    v == root 说明寻找到了根节点
            while(vis[v] != i &amp;&amp; id[v] == -1 &amp;&amp; v != root) {    //每个点寻找前序节点  要么找到根部  要么找到一个环
                vis[v] = i;
                v = pre[v];
            }
            if(v != root &amp;&amp; id[v] == -1) {   //成环 缩点
                for(int u = pre[v] ; u != v ; u = pre[u]) {
                    id[u] = cont;
                }
                id[v] = cont++;
            }
        }
        if(cont == 0) {   //无环  break
            break;
        }
        for(int i = 0 ; i &lt; V ; i++) {
            if(id[i] == -1) {    //没有成环的点
                id[i] = cont++;
            }
        }
        for(int i = 0 ; i &lt; E ; i++) {   //重新建图 重新标记
            int u = edge[i].u , v = edge[i].v;
            edge[i].u = id[u] , edge[i].v = id[v];
            if(id[v] != id[u]) {   
                edge[i].w -= d[v];  //理解上面的文字描述 &gt; . &lt; !(特别是二)
            }
        }
        V = cont;
        root = id[root];   //新的根
    }
}

int main()
{

}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>[算法]斯坦纳树</title>
    <url>/tpaaaaaa.github.io/2019/08/27/%5B%E7%AE%97%E6%B3%95%5D%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/</url>
    <content><![CDATA[<h2 id="什么是斯坦纳树？"><a href="#什么是斯坦纳树？" class="headerlink" title="什么是斯坦纳树？"></a>什么是斯坦纳树？</h2><pre><code>斯坦纳树问题是组合优化学科中的一个问题。将**指定点集合**中的所有点连通，且边权总和最小的生成树称为最小斯坦纳树（Minimal Steiner Tree），其实最小生成树是最小斯坦纳树的一种特殊情况。而斯坦纳树可以理解为使得指定集合中的点连通的树，但不一定最小。 （ 给出一个无向图，选择一些边使得几个**特定点**连接起来那就是**斯坦纳树**且边权和最小就是**最小斯坦纳树** ）</code></pre><h2 id="如何求解最小斯坦纳树？"><a href="#如何求解最小斯坦纳树？" class="headerlink" title="如何求解最小斯坦纳树？"></a>如何求解最小斯坦纳树？</h2><p>可以用DP求解，dp[i][state]表示以i （什么点都行）为根，指定集合中的点的连通状态为state的生成树的最小总权值。</p>
<pre><code>转移方程有两重：

第一重(不同的state，由之前的state转移而来)，先通过连通状态state的子集进行转移。

**dp\[i\]\[state\]=min{ dp\[i\]\[subset1\]+dp\[i\]\[subset2\] } **</code></pre><p>说明，dp[i][sta]的最优解可以由合并两棵以i为根的不同形态(相加 == sta)子树得到。</p>
<pre><code>枚举子集的技巧可以用 for(sub=(state-1)&amp;state;sub;sub=(sub-1)&amp;state)。

第二重（相同的state），在当前枚举的连通状态下，对该连通状态进行松弛操作。</code></pre><p>**     dp[j][state | sta[j]] = min( dp[j][sta | sta[j]], dp[i][sta] + w[i][j]);**</p>
<p>看到这个转移方程，与最短路的松弛条件何其相似！因此在枚举状态sta时，如果遇到在第一类转移之后有更新的节点（其实直接使用此时已经取到“最优解”的点即可），将其加入队列，在第一类转移全部完成之后用spfa做一次迭代更新，由于这种转移（第一类转移得到的优解，只是相对于前面状态的，而同一状态之间的差别不知道）既可以从i到j，也可以从j到i，因此普通的转移（第一类转移）是不能保证最优性的，而spfa采用迭代逼近的方式，<strong>将更新过的点再进行更新，</strong>可以保证最后每个节点都是“最短路”。  </p>
<pre><code>为什么只需对该连通状态进行松弛？**因为更后面的连通状态会由先前的连通状态通过第一重转移得到**，所以无需对别的连通状态松弛。松弛操作用SPFA即可</code></pre><p>有点每个连接状态就是一层的感觉，不同层用状压dp求解，然后SPFA只在同一层跑来松弛，这样时间也比较稳定优秀。 。</p>
<pre><code>复杂度 O(n\*3^k+cE\*2^k)

c为SPFA复杂度中的常数，E为边的数量，但几乎达不到全部边的数量，甚至非常小。3^k来自于子集的转移sum{C(i,n)*2^i} (1&lt;=i&lt;=n)，用二项式展开求一下和。</code></pre><h2 id="代码模板："><a href="#代码模板：" class="headerlink" title="代码模板："></a>代码模板：</h2><pre><code>/*
 *  Steiner Tree：求，使得指定K个点连通的生成树的最小总权值
 *  st[i] 表示顶点i的标记值，如果i是指定集合内第m(0&lt;=m&lt;K)个点，则st[i]=1&lt;&lt;m 
 *  endSt=1&lt;&lt;K
 *  dptree[i][state] 表示以i为根，连通状态为state的生成树值
 */
#define CLR(x,a) memset(x,a,sizeof(x))

int dptree[N][1&lt;&lt;K],st[N],endSt;
bool vis[N][1&lt;&lt;K];
queue&lt;int&gt; que;

int input()
{
   /*
    *    输入，并且返回指定集合元素个数K
    *    因为有时候元素个数需要通过输入数据处理出来，所以单独开个输入函数。
    */
}

void initSteinerTree()
{
    CLR(dptree,-1);
    CLR(st,0);
    for(int i=1;i&lt;=n;i++) CLR(vis[i],0);
    endSt=1&lt;&lt;input();
    for(int i=1;i&lt;=n;i++)
        dptree[i][st[i]]=0;
}

void update(int &amp;a,int x)
{
    a=(a&gt;x || a==-1)? x : a;
}

void SPFA(int state)
{
    while(!que.empty()){
        int u=que.front();
        que.pop();
        vis[u][state]=false;
        for(int i=head[u];i!=-1;i=e[i].next){
            int v=e[i].to;
 // st[v] | state 这个状态是由u 这个点 转移 到v这个点的
            if(dptree[v][st[v]|state]==-1 || 
                dptree[v][st[v]|state] &gt; dptree[u][state]+e[i].w){

                dptree[v][st[v]|state]=dptree[u][state]+e[i].w;
                if(st[v]|state!=state || vis[v][state]) 
                    continue; //只更新当前连通状态
                vis[v][state]=true;
                que.push(v);
            }
        }
    }
}

void steinerTree()
{
    for(int j=1;j&lt;endSt;j++){
        for(int i=1;i&lt;=n;i++){
            if(st[i] &amp;&amp; (st[i]&amp;j)==0) continue;  //这个情况显然不存在
            for(int sub=(j-1)&amp;j;sub;sub=(sub-1)&amp;j){
                int x=st[i]|sub,y=st[i]|(j-sub); // x, y为两个互补的子状态
                if(dptree[i][x]!=-1 &amp;&amp; dptree[i][y]!=-1)//这两个子状态都存在
                    update(dptree[i][j],dptree[i][x]+dptree[i][y]);
  // 这里面dptree记录的是边的权值，所以直接加没问题，有的题目可能要考虑重复.
            }
            if(dptree[i][j]!=-1) //说明这个状态有可能存在,且目前是最优的点
                que.push(i),vis[i][j]=true;  
        }
        SPFA(j);
    }
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
  </entry>
  <entry>
    <title>[模板]最小生成树</title>
    <url>/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
    <content><![CDATA[<h2 id="Kruskal算法："><a href="#Kruskal算法：" class="headerlink" title="Kruskal算法："></a>Kruskal算法：</h2><pre><code>int   Kruskal()
{
    int mst = 0;  // 记录加入边的长度和
    int sum = 0;  // 加入边的数目， 如果数目 == 顶点数减1，说明所有点联通了 
    for(int i = 0; i &lt;= n; i++)
        pre[i] = i;    //并查集的初始化
    sort(edge + 1, edge + 1 + m);   // 对每条边按权重从小到大排序
    for(int i = 1; i &lt;= m; i ++)  // 从小到大枚举每一条边
    {
        int u = edge[i].from;
        int v = edge[i].to;
        int f1 = findRoot(u);
        int f2 = findRoot(v);
        if(f1 != f2)           //这条边的两个端点不在同一个集合里面
        {
            pre[f2] = f1;      // 将这两个集合合并
            sum++;             // 边数加1
            mst += edge[i].cost; // mst += cost
        }
    }
    if(sum == n - 1)          // n个点完成了联通
        return mst;
    else                       //n个点无法联通
        return -1;
}</code></pre><h2 id="Prim算法："><a href="#Prim算法：" class="headerlink" title="Prim算法："></a>Prim算法：</h2>]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>[模板]并查集</title>
    <url>/tpaaaaaa.github.io/2019/08/26/%5B%E6%A8%A1%E6%9D%BF%5D%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<p><strong>并查集：将不同分散的结点，通过某种关系将他们连接成一个森林</strong><br><strong>并查集分为3步：<br>1、并：给出两点关系，如果属于同一集合，进行unionSet<br>2、查：在合并时，需要先写出查，即找到该点的祖先点<br>3、集：unoinSet后，将新加入的点的祖先点更新</strong></p>
<h3 id="并查集-路径压缩-Rank："><a href="#并查集-路径压缩-Rank：" class="headerlink" title="并查集 + 路径压缩 + Rank："></a>并查集 + 路径压缩 + Rank：</h3><pre><code>int findRoot(int root)
{
    if(pre[root] == root)
        return root;
    return pre[root] = findRoot(pre[root]);    
}
void unionSet(int p, int q)
{
    int f1 = findRoot(p);
    int f2 = findRoot(q);
    if(f1 != f2)
    {
        if(rank[f1] &gt; rank[f2])
            pre[f2] = f1;
        else if(rank[f1] &lt; rank[f2])
            pre[f1] = f2;
        else
        {
            pre[f1] = f2;
            rank[f2] ++;
        }
    }   
}</code></pre><h3 id="带权并查集："><a href="#带权并查集：" class="headerlink" title="带权并查集："></a>带权并查集：</h3><p><a href="https://blog.csdn.net/yjr3426619/article/details/82315133" target="_blank" rel="noopener">更多细节</a></p>
<pre><code>int findRoot(int x)
{
    if(pre[x] != x)
    {
        int par = pre[x];           //记录原来的父节点，  
        pre[x] = findRoot(pre[x]);  // 父节点变成根节点
        value[x] += value[par];
    }
    return pre[x];
}
/*更新权值只多了两行代码，先记录下原本父节点的编号，因为在路径压缩后父节点就变为根节点了，再将当前节点的权值加上原本父节点的权值，此时父节点的权值已经是父节点到根节点的权值了，因此加上这个权值就会得到当前节点到根节点的权值。*/</code></pre><p>普通的带权并查集题目链接</p>
<p><a href="http://localhost/?p=72" target="_blank" rel="noopener">POJ – 1988 Cube Stacking</a></p>
<p><a href="http://localhost/?p=74" target="_blank" rel="noopener">HDU – 3635 Dragon Balls</a></p>
<p><a href="http://localhost/?p=77" target="_blank" rel="noopener">HDU – 3038 How Many Answers Are Wrong</a></p>
<p>模2系的题目链接</p>
<p><a href="http://localhost/?p=89" target="_blank" rel="noopener">POJ – 2492 A Bug’s Life</a></p>
<p><a href="http://localhost/?p=87" target="_blank" rel="noopener">POJ – 1703 Find them, Catch them</a></p>
<p><a href="http://localhost/?p=79" target="_blank" rel="noopener">POJ – 1733 Parity game</a></p>
<p>模3系的题目链接</p>
<p><a href="http://localhost/?p=85" target="_blank" rel="noopener">POJ</a> <a href="http://localhost/?p=85" target="_blank" rel="noopener">– 2912 Rochambeau</a></p>
<p><a href="http://localhost/?p=83" target="_blank" rel="noopener">POJ – 1182 食物链</a></p>
<p>模300系</p>
<p><a href="http://localhost/?p=81" target="_blank" rel="noopener">HDU – 3047 Zjnu Stadium</a></p>
<h3 id="异或并查集："><a href="#异或并查集：" class="headerlink" title="异或并查集："></a>异或并查集：</h3>]]></content>
      <categories>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title>HDU - 1875 畅通工程再续</title>
    <url>/tpaaaaaa.github.io/2019/08/26/HDU-1875%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B%E5%86%8D%E7%BB%AD/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>相信大家都听说一个“百岛湖”的地方吧，百岛湖的居民生活在不同的小岛中，当他们想去其他的小岛时都要通过划小船来实现。现在政府决定大力发展百岛湖，发展首先要解决的问题当然是交通问题，政府决定实现百岛湖的全畅通！经过考察小组RPRush对百岛湖的情况充分了解后，决定在符合条件的小岛间建上桥，所谓符合条件，就是2个小岛之间的距离不能小于10米，也不能大于1000米。当然，为了节省资金，只要求实现任意2个小岛之间有路通即可。其中桥的价格为 100元/米。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>Kruskal模板题</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-16.12.35
 Question_Number   ：hdu 1875
 Question_Name     ：最小生成树水题
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;

const int MAXN = 100 + 10;
const int MAXM = MAXN * MAXN ;
int cnt, n;
bool vis[MAXN];
int head[MAXN], pre[MAXN];
struct Node
{
    int x, y;
    Node(int x = 0, int y = 0):x(x), y(y){};

};
struct Edge
{
    int from;
    int to;
    double cost;
    Edge(int from = 0, int to = 0, double cost = 0):from(from), to(to), cost(cost){};
    friend bool operator &lt; (Edge a, Edge b)
    {
        return a.cost &lt; b.cost;
    }
};
Node node[MAXN];
Edge edge[MAXM];
double getDis(Node a, Node b)
{
    double temp = (a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y);
    return sqrt(temp);
}
void addEdge(int x, int y, double cost)
{
    cnt ++;
    edge[cnt].from = x;
    edge[cnt].to = y;
    edge[cnt].cost = cost;
};
int findRoot(int x) //普通并查集
{
    if(x == pre[x])
        return x;
    return  pre[x] = findRoot(pre[x]);
}
double  Kruskal()
{
    double mst = 0;
    int sum = 0;
    for(int i = 0; i &lt;= n; i++)
        pre[i] = i;
    for(int i = 1; i &lt;= cnt; i ++)
    {
        int u = edge[i].from;
        int v = edge[i].to;
        int f1 = findRoot(u);
        int f2 = findRoot(v);
        if(f1 != f2)
        {
            pre[f2] = f1;
            sum++;
            mst += edge[i].cost;
        }
    }
    if(sum == n - 1)
        return mst;
    else
        return 0;
}
int main()
{
    int t;
    cin &gt;&gt; t;
    while(t--)
    {
        scanf(&quot;%d&quot;,&amp;n);
        memset(head, -1, sizeof head);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
            scanf(&quot;%d%d&quot;,&amp;node[i].x, &amp;node[i].y);

        for(int i = 1; i &lt; n; i++)
            for(int j = i + 1; j &lt;= n; j++)
            {
                double temp = getDis(node[i], node[j]);
                if(temp &gt;= 10 &amp;&amp; temp &lt;= 1000 )
                     addEdge(i, j, temp);       //我是猪吗，不用链式前向星
            }
        sort(edge + 1, edge + 1 + cnt);
        double ans = Kruskal();
        if(ans == 0)
            printf(&quot;oh!\n&quot;);
        else
            printf(&quot;%.1f\n&quot;, ans * 100);

    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小生成树，Kruskal</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2492 A Bug&#39;s Life</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-2492ABug&#39;sLife/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p><strong>Background</strong><br>若雨妹妹在Debug。他惊奇的发现 Bug有两种性别，异性之间才交往，他感觉很奇怪，于是要做个实验。在他的实验中，Bug们已经被从1开始编好号了。此外，Bug的性别很好辨别。<br><strong>Problem</strong><br>因为若雨妹妹太懒了，他懒得去分析他总结出来的bug数据。你需要根据数据判断是否存在同性恋，输入有 t 组数据,每组数据给出bug数量n, 和关系数m, 以下m行给出相交往的一对Bug编号 a, b。只需要判断有没有，按题目要求输出。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>带权并查集，模2系。 注意找到冲突后千万不要直接break，因为输入还没有结束！！。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-15.50.44
 Question_Number   ：poj 2492
 Question_Name     ：带权并查集，模2系
 Description       : cnt[x] 表示x和fx是不是同一个性别
                     cnt[x] == 0表示是同一个性别
                     cnt[x] == 1
                     题目给
                     x, y
                     [x, y] == 1 意思是x和y性别不同
                     [f1, x]   [f2, y]
                     如果f1 == f2
                     [f1, y] = [f1, x] + [x, y];
                     if(f1 == f2)
                     {
                        if(cnt[y] != (cnt[x] + 1)%2)
                        {
                            flag = false;//发现异常
                            break;
                        }
                     }
                     else
                     {
                        pre[f2] = f1; // [f1, f2] = [f1, x] + [x, y] - [f2, y];
                        cnt[f2] = (cnt[x] + 1 - cnt[y] + 2) % 2;
                     }
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2000 + 10;
const int MAXM = 1e6 + 10;
int pre[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if(x != pre[x])
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] = (cnt[x] + cnt[f]) % 2;
    }
    return pre[x];
}
int main()
{
    int t, kase = 0, n, m, x, y;
    cin &gt;&gt;t;
    while(t--)
    {
        scanf(&quot;%d%d&quot;,&amp;n, &amp;m);

        for(int i = 0; i &lt;= n; i++)
        {
            pre[i] = i;
            cnt[i] = 0;
        }
        bool flag = true;   //如果存在异常，变成false
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;,&amp;x, &amp;y);
            int f1 = findRoot(x);
            int f2 = findRoot(y);
            if(f1 == f2)
            {
                if(cnt[y] != (cnt[x] + 1) % 2)
                {
                    flag = false;
                   // break;          //是我太傻
                }
            }
            else
            {
                pre[f2] = f1;
                cnt[f2] = (cnt[x] + 1 - cnt[y] + 2) % 2;
            }
        }
        printf(&quot;Scenario #%d:\n&quot;, ++ kase);
        if(flag == false)
            printf(&quot;Suspicious bugs found!\n&quot;);
        else
            printf(&quot;No suspicious bugs found!\n&quot;);
        if(t)
            printf(&quot;\n&quot;);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，模2系</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1703 Find them, Catch them</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-1703Findthem,Catchthem/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>警方决定捣毁两大犯罪团伙：龙帮和蛇帮，显然一个帮派至少有一人。该城有N个罪犯，编号从1至N（N&lt;=100000。将有M（M&lt;=100000）次操作。<br>D a b 表示a、b是不同帮派<br>A a b 询问a、b关系</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>模2系的带权并查集，水题略。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-15.32.46
 Question_Number   ：poj 1703
 Question_Name     ：带权并查集，模2系
 Description       :
                     cnt[x] 表示x和fx的关系
                     cnt[x] == 1 表示x与fx 不同 [fx, x]
                     cnt[x] == 0 表示相同
                     A x y  问我x y是不是一个帮派的
                     int f1 = findRoot(x);
                     int f2 = findRoot(y);
                     case A
                     if(f1 == f2)   //
                     {
                        if(cnt[x] == cnt[y]) 是一个帮派的
                        {

                        }
                        else                no
                        {

                        }
                     }
                     else
                     {
                        无法判判断;
                     }
                     case D;
                     D x y  意思是告诉我 x y 是一个帮派的
                     pre[f2] = f1;  [f1, f2]   =  [f1, x] + [x, y] - [f2, y]
                     cnt[f2] = (cnt[x] + 1 - cnt[y] + 2) % 2;
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100000 + 10;
const int MAXM = 100000 + 10;
int pre[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] = (cnt[x] + cnt[f]) % 2;
    }
    return pre[x];
}
int main()
{
    int T, n, m, x, y;
    char ch;
    cin &gt;&gt; T;
    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i = 0; i &lt;= n; i++)
        {
            pre[i] = i;
            cnt[i] = 0;
        }
        for(int i = 1; i &lt;= m; i++)
        {
            getchar();  //一个回车
            scanf(&quot;%c&quot;,&amp;ch);
            scanf(&quot;%d%d&quot;,&amp;x,&amp;y);
            int f1 = findRoot(x);
            int f2 = findRoot(y);
            if(ch == &apos;D&apos;)
            {
                pre[f2] = f1;
                cnt[f2] =  (cnt[x] + 1 - cnt[y] + 2) % 2;

            }
            else if(ch == &apos;A&apos;)
            {
                if(f1 == f2)
                {
                    if(cnt[x] == cnt[y])
                        printf(&quot;In the same gang.\n&quot;);
                    else
                        printf(&quot;In different gangs.\n&quot;);
                }
                else
                {
                    printf(&quot;Not sure yet.\n&quot;);
                }
            }


        }
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，模2系</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2912 Rochambeau</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-2912Rochambeau/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>n个小伙伴进行猜拳有戏，除了一个比较聪明的家伙以外，其他人只会出单一的一种，给出m中猜拳的结果，要求找出那个比较聪明的小伙伴序号，并且输出在第几次猜拳可以确定。（注意&lt;,&gt;,=前后可能有空格）</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>带权并查集，也是模3系。每次枚举一个小朋友的时候，要对pre初始化一次。题目要理解透彻。</p>
<p>代码：</p>
<pre><code>/*
 Date              : 2019-08-26-13.27.04
 Question_Number   ：poj 2912
 Question_Name     ：带权并查集，种类并查集
 Description       :  n个人，编号0 .. n - 1
                      m个回合
                      除了裁判，每个小朋友出的姿势是固定的，也就是除了裁判之外的小朋友之间的关系是固定的
                      但是裁判可以变，所以裁判跟其他小朋友的关系不固定。
                      题目的意思是要我们找出哪个hj8是裁判
                      但是如果有大于1个人出拳的意思可以变
                      意思是可能有多个裁判，那就输出impossible
                      如果没有裁判，则输出no detemine

                      步骤：
                      枚举每一个小朋友，然后把他参与的比赛全部去掉，再用并查集判断其他小朋友有没有出现
                      反常现象，如果没有，说明这个小朋友是可能的裁判，如果出现了反常现象，说明他不是裁判
                      如果可能的裁判大于1个，则说明裁判根本没被选进来
                      如果可能的裁判为1个，那这个hj8就是裁判
                      如果可能的裁判为0，说明裁判多于一个，是impossible的情况
                      判断轮数，就是枚举每个小朋友时，发生冲突的时候的轮数最大的那个（因为每次发生冲突，就意味着这个小朋友的考虑结束了， 不需要考虑下面的回合了）
                      cnt[x] 表示x跟其根节点fx的关系
                      cnt[x] == 0 表示 [fx, x] x与fx平局
                      cnt[x] == 1 表示 [fx, x] x胜fx
                      cnt[x] == 2 表示 [fx, x] x输fx
                      输入如果 x &gt; y 则 w == 2  x &lt; y  w == 1
                      int f1 = findRoot(x);     // [f1, x]  == 1   [x, y] == 1;
                      int f2 = findRoot(y);     // [f1, y]  == 2
                      if(f1 == f2)
                      {
                         if(cnt[x] + d != cnt[y])
                         {

                         }
                      }
                      else                    // [f1, x] == 1   [f2, y] == 2    [f1, f2] = [f1, x] + [x, y] - [f2, y];
                      {
                         pre[f2] = f1;
                         cnt[f2] = cnt[x] + w - cnt[y]  % 3;
                      }


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 500 + 10;
const int MAXM = 2000 + 10;
int pre[MAXN], cnt[MAXN];
struct Node
{
    int x, y, w;    //用来记录每一回合的情况
    Node(int x = 0, int y = 0, int w = 0):x(x), y(y), w(w){};
};
Node node[MAXM];
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]); // [f2, f1]  [f1, x]  == [f2, x];
        cnt[x] = (cnt[x] + cnt[f]) % 3;
    }
    return pre[x];
}
int main()
{
    char ch;
    int n, m;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {

        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d&quot;,&amp;node[i].x);     // 这时候w保存的是cnt[x, y]的顺序
            scanf(&quot;%c&quot;,&amp;ch);
            if(ch == &apos;&lt;&apos;)
                node[i].w = 1;
            else if(ch == &apos;&gt;&apos;)
                node[i].w = 2;
            else if(ch == &apos;=&apos;)
                node[i].w = 0;
            scanf(&quot;%d&quot;,&amp;node[i].y);
        }
        int sum = 0;                //可能裁判的数目
        int cir = 0;
        int jud = 0;
        for(int i = 0; i &lt; n; i++)  //枚举每个人
        {
            for(int i = 0; i &lt;= n; i++)//有道理，这里1！！（博客）
            {
                pre[i] = i;
                cnt[i] = 0;
            }
            bool  flag = true;        //如果没发生冲突，那么一直是true，说明这人是可能的裁判，sum++
            for(int j = 1; j &lt;= m; j++) //
            {
                int u = node[j].x;
                int v = node[j].y;
                int w = node[j].w;
                if(u == i || v == i)    //是枚举的那个小朋友
                        continue;                   //   1        2         0
                int f1 = findRoot(u);
                int f2 = findRoot(v);               //   2        2          1
                if (f1 == f2)
                {                                   //   1         1         2
                    if( (cnt[u] + w) % 3 != cnt[v]) //[f1, u] + [u, v] != [f1, v]
                    {
                        cir = max(cir, j);
                        //jud = i;
                        flag = false;
                        break;
                    }

                }
                else                // [f2, v] * 2 % 3
                {                   
                    pre[f2] = f1;   // [f1, f2] = [f1, u] + [u, v] - [f2, v];
                    cnt[f2] = (cnt[u] + w - cnt[v] + 3) % 3;
                }
            }
            if(flag)
            {
                sum++;
                jud = i;
            }

        }
        if(sum == 0)
            printf(&quot;Impossible\n&quot;);
        else if(sum &gt; 1)
            printf(&quot;Can not determine\n&quot;);
        else
            printf(&quot;Player %d can be determined to be the judge after %d lines\n&quot;, jud, cir);

    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>debug能力要加强</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，模3系</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1182 食物链</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-1182%E9%A3%9F%E7%89%A9%E9%93%BE/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br>第一种说法是”1 X Y”，表示X和Y是同类。<br>第二种说法是”2 X Y”，表示X吃Y。<br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br>1） 当前的话与前面的某些真的话冲突，就是假话；<br>2） 当前的话中X或Y比N大，就是假话；<br>3） 当前的话表示X吃X，就是假话。<br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>cnt[x] 表示的是[fx, x] x和fx的关系 = 0 表示 x和fx是同类， = 1 表示x吃fx， =2表示x被fx吃.（具体分析验算自己到时候走一遍）</p>
<p>关于怎么设计0，1, 2。自己凭感觉，然后举几个例子试试区间加减法成不成立即可。</p>
<p>题目给的信息是x y是同类 or x 吃 y 也就是[x, y] == 0 or 2 或 [y, x] == 0 or 1;</p>
<p>对于查找函数</p>
<pre><code>int findRoot(int x)
{
    if(pre[x] != x)  // cnt[x] 表示的是[f, x]的关系，也就是x和f的关系
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);// 此后cnt[f] 表示的是[根,f]的关系
        cnt[x] = (cnt[x] + cnt[f]) % 3;//此时cnt[x] 表示的是[根,x]的关系
//  [根,x] = [根,f] + [f, x]  
    }
    return pre[x];
}</code></pre><p>关于合并函数：</p>
<pre><code>int f1 = findRoot(x);
int f2 = findRoot(y);
if(f1 == f2)
{
    if((cnt[x] - cnt[y] + 3) % 3 != d)
        ans ++;
}
else
{
    pre[f2] = f1;
    cnt[f2] = (cnt[x] + (d*2) % 3 - cnt[y] + 3) % 3;
}</code></pre><p>题目给的关系是[y, x] == 0 or 1 , cnt[x] 表示的是[f1, x] ; cnt[y]表示的是[f2, y];</p>
<p>如果f1 == f2</p>
<p>[f1, y] + [y, x] = [f1, x];</p>
<p>也就是cnt[y] + d =?= cnt[x]; (上面的代码只是移项了而已)</p>
<p>如果f1 != f2 , 令pre[f2] = f1； 把f2挂在f1后面, 此时cnt[f2] 变成了[f1, f2]的关系</p>
<p>[f1, f2] = [f1, x] + [x, y] + [y, f2];</p>
<p>[f1, f2] = [f1, x] - [y, x] - [f2, y]; (与以上代码里面的不一样，思想重要)</p>
<p>也就是cnt[f2] = cnt[x] - d - cnt[y];</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-12.43.48
 Question_Number   ：poj 1182
 Question_Name     ：带权并查集之种类并查集
 Description       :
                    cnt[x] 记录的是x跟fx的关系
                    1 x y 表示 x 跟y是同类
                    2 x y 表示 x 吃 y
                    cnt[x] == 0 表示是同类
                    cnt[x] == 1 表示x吃fx
                    cnt[x] == 2 表示x被fx吃

                    [fx, x] == 0;   x 和 fx是同类
                    [fy, fx] == 1;  fx 吃 fy
                    那么[fy, x] == 1;             // x 吃fy
                    [fx, x] == 2;   x 被 fx吃
                    [fy, fx] == 1;  fx 吃 fy
                    那么[fy, x] == (1 + 2) % 3;   //x 和 fy是同类

                    [fx, x] == 1;   x吃fx
                    [y, fx] == 1;   fx 吃y
                    [y, x] = 2;                   //x 被 y 吃
                    所以实际上是一个模3系的带权并查集
                                            // 如果d == 2, d--, [y, x] == 1;
                                            // [x, y] = [y, x]*2 % 3
                    int f1 = findRoot(x);   // [f1, x]  [f2, y]
                    int f2 = findRoot(y);   // cnt[x] - cnt[y] != d
                                            // [f1, x] - [f2, y] != d;
                    if(f1 == f2)
                    {
                        if((cnt[x] - cnt[y] + 3) % 3 != d)
                            ans ++;
                    }
                    else
                    {
                        pre[f2] = f1;       // [f1, f2];
                                            // [f1, f2] = [f1, x] + [x, y] - [f2, y]
                        cnt[f2] =  (cnt[x] + (d*2) % 3 - cnt[y] + 3) % 3;
                    }

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 50000 + 10;
int pre[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] = (cnt[x] + cnt[f]) % 3;
    }
    return pre[x];
}
int main()
{
    int n, k;
    scanf(&quot;%d%d&quot;,&amp;n, &amp;k);
    for(int i = 0; i &lt;= n; i++)
    {
        pre[i] = i;
        cnt[i] = 0;
    }
    int ans = 0;
    int d, x, y;
    for(int i = 1; i &lt;= k; i++)
    {
        scanf(&quot;%d%d%d&quot;,&amp;d, &amp;x, &amp;y); //d== 2  cnt[y, x] = 2;
        if(x &gt; n || y &gt; n || ((d == 2)&amp;&amp;(x == y)) )
        {
            ans ++;
            continue;
        }
        d--;
        int f1 = findRoot(x);
        int f2 = findRoot(y);

        if(f1 == f2)
        {
            if((cnt[x] - cnt[y] + 3) % 3 != d)
                ans ++;
        }
        else
        {
            pre[f2] = f1;
            cnt[f2] = (cnt[x] + (d*2) % 3 - cnt[y] + 3) % 3;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>理清思路再写，舒服</p>
<p>带权并查集相较于普通并查集多出来的一个cnt[x] 实际上反映的是<strong>x和其根节点fx的关系</strong> 或者 <strong>(fx, x]这个区间的属性</strong>（属性就要考虑加减时候的区间开闭，建议左开右闭）</p>
<p>一般而言，关系是模2系、模3系的，区间的属性是模n系的。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，模3系</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3047 Zjnu Stadium</title>
    <url>/tpaaaaaa.github.io/2019/08/26/HDU-3047ZjnuStadium/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>铁头王国最近忙着举行比赛，但他们体育场的座位且非常少仅仅300列(还是比较穷。。。 好吧非常穷)，这当然跟zx的统治有直接关系。体育场列标号为1-300,行无限(一列可以有多人重复坐）体育场是一个环。为了清楚的知道某两个市民之间的距离，国王zx给了你一些数据。给出n个人和m个关系,关系为A B x表示A位置若为i,则B位置在A顺时针加x的位置。如果一个关系在前面给出的关系中矛盾,则称其不成立。求不成立关系个数。 </p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>带权并查集，模300。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code>/*
 Date              : 2019-08-26-11.18.28
 Question_Number   ：hdu 3047
 Question_Name     ：zjnu stadium
 Description       : 种类并查集
                    cnt[x] 表示x距离其根节点位置的距离
                    pre[x] = fx;
                    则cnt[x] = x - fx; (fx, x];
                    输入 A,B,x;//x 表示的是(A, B];
                    int f1 = findRoot(A), f2 = findRoot(B);
                    if(f1 == f2)
                    {
                        if(sum[B] - sum[A] != x)
                        {
                            ans ++;
                        }
                    }
                    else
                    {
                        pre[f2] = f1; // sum[f2] =  (f1, f2] = ((f1, A] + (A, B] + (B, f2]) % 300;
                        sum[f2] = sum[A] + x - sum[B] % 300;
                    }
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 50000 + 10;
int pre[MAXN], sum[MAXN];
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        sum[x] = (sum[x] + sum[f]) % 300;
    }
    return pre[x];
}
int main()
{
    int n, m, A, B, w;
    while(scanf(&quot;%d%d&quot;,&amp;n, &amp;m) != EOF)
    {
        int ans = 0;
        for(int i = 0; i &lt;= n; i++)
        {
            pre[i] = i;
            sum[i] = 0;
        }
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;w);
            int f1 = findRoot(A);
            int f2 = findRoot(B);
            if(f1 == f2)
            {
                if((sum[B] - sum[A] + 300) % 300!= w)
                    ans ++;
            }
            else
            {
                pre[f2] = f1;
                sum[f2] = (sum[A] + w - sum[B] + 300) % 300;
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>水题略</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，模300系</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1733 Parity game</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-1733Paritygame/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>现在你和你的朋友正在玩一种游戏。 你的朋友写下一串0和1的序列，然后你选择其中一串子序列（如[3,5]）并且问他这个序列是包含奇数个1还是偶数个1（和是奇数还是偶数）。 你可以问你的朋友任意个问题，而你的朋友会回答你的问题。 你的任务是猜出整个朋友的序列。</p>
<p>但是，你发现你的朋友告诉你的信息可能有误，所以你想写一个程序来指出他的错误。这个程序应该接受一系列你的问题和答案。程序的目标是找到第一个错误的答案。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>带权并查集，模2系，离散化处理。</p>
<p>cnt[x] 表示的是(fx, x] 这个区间和是奇数还是偶数 奇数为1， 偶数为0</p>
<p>题目给的是[x, y] 这个区间是奇数还是偶数 也就是(x - 1, y]这个区间</p>
<p>查找代码</p>
<pre><code>int findRoot(int x)
{
    if(pre[x] != x)   //此时的cnt[x] 表示的是(f, x]这个区间的属性
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);// 此时cnt[f] 表示的是(根, f]的属性
        cnt[x] = (cnt[x] ^ cnt[f]);//此时cnt[x] 变成 (根, x]这个属性
   //(根, x] = ((根, f] + (f, x]) % 2;
    }
    return pre[x];
}</code></pre><p>合并代码</p>
<pre><code>if(f1 == f2)
{
    if((cnt[x] + w[i]) % 2 != cnt[y])       //我他妈的是个瞎子。
    {
        ans = i - 1;
        break;
    }
}
else
{
    pre[f2] = f1;
    cnt[f2] = (cnt[x] + w[i]- cnt[y] + 2) % 2;
}</code></pre><p>题目给的是[x, y] == (x - 1, y] 这个区间的奇偶性, cnt[x - 1] 表示的是(f1, x - 1]这个区间, cnt[y] 表示的是(f2, y]这个区间 (与以上代码不同，重要的是思想)</p>
<p>如果f1 == f2, 则 (f1, y] == (f1, x - 1] + (x - 1, y];</p>
<p>如果f1 != f2，则pre[f2] = f1 之后的 cnt[f2] 表示的是(f1, f2]这个区间</p>
<p>(f1, f2] = (f1, x - 1] + (x - 1, y] - (f2, y] 这个区间</p>
<p>关于离散化：</p>
<p>将要用到的点加到数组 or vector 中，排序后去重即可获得离散化后的表.</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-26-09.47.56
 Question_Number   ：poj 1733
 Question_Name     ：离散化，带权并查集
 Description       :
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e9 + 10;
const int MAXM = 200005;
int  w[MAXM];
vector &lt; int &gt;  vec;//离散化后的表，最多有2MAXM个点
int record[2][MAXM];    //用来记录的
int cnt[MAXM], pre[MAXM];
string str;
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] = (cnt[x] ^ cnt[f]);
    }
    return pre[x];
}
int main()
{
    int n, m;
    while(scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        scanf(&quot;%d&quot;,&amp;m);
        vec.clear();
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d&quot;, &amp;record[0][i], &amp;record[1][i]);
            vec.push_back(record[0][i] - 1);
            vec.push_back(record[1][i]);
            cin &gt;&gt; str;
            if(str == &quot;even&quot;)
                w[i] = 0;
            else if(str == &quot;odd&quot;)
                w[i] = 1;
        }
        sort(vec.begin(), vec.end());
        int sizee = unique(vec.begin(), vec.end()) - vec.begin();
        for(int i = 0; i &lt;= sizee; i++)
        {
            pre[i] = i;
            cnt[i] = 0;
        }
        int ans = m;
        for(int i = 1; i &lt;= m ; i++)
        {
            int x = lower_bound(vec.begin(), vec.begin() + sizee, record[0][i] - 1) - vec.begin();
            int y = lower_bound(vec.begin(), vec.begin() + sizee, record[1][i]) - vec.begin();
            int f1 = findRoot( x );
            int f2 = findRoot( y );
            if(f1 == f2)
            {
                if((cnt[x] + w[i]) % 2 != cnt[y])       //我他妈的是个瞎子。
                {
                    ans = i - 1;
                    break;
                }
            }
            else
            {
                pre[f2] = f1;
                cnt[f2] = (cnt[x] + w[i]- cnt[y] + 2) % 2;
            }
        }
        printf(&quot;%d\n&quot;,ans);
    }

    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>眼睛有点不好使，一个分号WA了半天，总算找到了。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，离散化，模2系</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3038 How Many Answers Are Wrong</title>
    <url>/tpaaaaaa.github.io/2019/08/26/HDU-3038HowManyAnswersAreWrong/</url>
    <content><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>给定一个长为N的数组a[]，有M个询问和结果。所谓询问形如：x y z，表示a[x]+a[x+1]+……+a[y]=z。如果某个询问及结果与前面的询问及结果冲突，即为错误结果。输出总共有多少错误结果。 tip：假设已知{1 10 100}，之后出现{1 9 200} ，则显然{1 9 200}是错误的（我们假定先出现的必定正确）</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>带权并查集的 区间统计。配合自创的区间分析法更佳 , 注意区间要变成左开右闭.</p>
<p>cnt[x] 表示x到fx 这个区间的和 (fx, x]</p>
<p>题目给你x y z 给的就是[x , y ]== (x - 1, y] == z 的意思</p>
<p>对于查找函数：</p>
<pre><code>int findRoot(int x)
{
    if( pre[x] != x ) // 此时cnt[x] 记录的是(f, x]的区间和
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);//此后cnt[f] 记录的是(根, f] 的值
        cnt [x] += cnt[f];//cnt[x] 此时记录的是(根, x]的值
                          //(根, x] = (根, f] + (f, x];
    }
    return pre[x];
}</code></pre><p>合并部分：</p>
<pre><code>int f1 = findRoot(x - 1);   //sum1 =  (f1, x-1];
int f2 = findRoot(y);       //sum2 =  (f2, y];
if(f1 == f2)
{
    if(cnt[x - 1] + w != cnt[y])    // sum1 + w != sum2   (f1,x-1] + [x,y] != (f1, y]
        s++;
}
else
{
    pre[f2] = f1;           // sum3 = (f1, f2];
    cnt[f2] = cnt[x - 1] + w - cnt[y];// sum3 = sum1 + w - sum2 = (f1, x-1] + [x, y] - (f2, y];
}</code></pre><p>f1 == f2 以为着, cnt[x - 1] 记录的是(f1, x-1]的值 cnt[y] 记录的是(f1, y]的值</p>
<p>而题目给的是 (x - 1, y] = d 联系起来</p>
<p>(f1, x - 1] + (x - 1, y ] = (f1, y]</p>
<p>也就是 cnt[x - 1] + d =?= cnt[y]</p>
<p>如果 f1 != f2; 那么将f2挂在f1后面，之后cnt[f2] 记录的是 (f1, f2]的值</p>
<p>(f1, f2] = (f1, x - 1] + (x - 1, y] - (f2, y];</p>
<p>所以cnt[f2] = cnt[x] + w - cnt[y];</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-25-19.27.30
 Question_Number   ：hdu 3038
 Question_Name     ：区间统计，并查集
 Description       :
                fx = 3   x = 6
                fy = 3   y = 4
                fy = 4   y = 5
                fy = 3
                [3,6]
                [4,5]
                    [3,4] = [3,6] - [4,5] + [5,6];

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 2e5 + 10;
const int MAXM = 4e4 + 10;
int pre[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if( pre[x] != x )
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt [x] += cnt[f];
    }
    return pre[x];

}
int main()
{
    int n, m, ans;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        int s = 0;
        int x, y, w;
        for(int i = 0; i &lt;= n; i++)
        {
            pre[i] = i;
            cnt[i] = 0;
        }
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;w);   //  w  =  [x, y];
            int f1 = findRoot(x - 1);   //sum1 =  (f1, x-1];
            int f2 = findRoot(y);       //sum2 =  (f2, y];
            if(f1 == f2)
            {
                if(cnt[x - 1] + w != cnt[y])    // sum1 + w != sum2   (f1,x-1] + [x,y] != (f1, y]
                    s++;
            }
            else
            {
                pre[f2] = f1;           // sum3 = (f1, f2];
                cnt[f2] = cnt[x - 1] + w - cnt[y];// sum3 = sum1 + w - sum2 = (f1, x-1] + [x, y] - (f2, y];
            }
        }
        printf(&quot;%d\n&quot;,s);
    }

    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>并查集好好玩！！！明天剪头发</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集，区间统计</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3635 Dragon Balls</title>
    <url>/tpaaaaaa.github.io/2019/08/26/HDU-3635DragonBalls/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有标号为1到n的n个龙珠，分别放在对应标号为1到n的n个城市里。<br>下面有两种操作:<br>T A B表示把A龙珠所在城市的所有龙珠都转移到B龙珠所在的城市中<br>Q A 表示查询A，需要知道A龙珠现在所在的城市，A所在的城市有几颗龙珠，A转移到这个城市移动了多少次,分别输出3个整数，表示上述信息。</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>cnt[x] 表示的是x移动到fx移动了多少次, s[x] 表示的是x所在集合的数目</p>
<p>查找函数</p>
<pre><code>int findRoot(int x)
{
    if(pre[x] != x)       //  此时的cnt[x] 表示是x移动到f的次数 [f, x]
    {
        int f = pre[x];   // 
        pre[x] = findRoot(pre[x]);// cnt[f] 表示的将f移动到根节点的次数 [根, f]
        cnt[x] += cnt[f];// 此时的cnt[x] 表示的是将x 移动到根的次数
                         //[根, x] = [根, f] + [f, x]
                         // = 自己移动到f的次数  加上  f移动到根的次数（此时自己已经和f一起动了）
    }
    return pre[x];
}</code></pre><p>合并部分：</p>
<pre><code>if(f1 != f2)
    {
        pre[f1] = f2;   // 将f1合并到f2的后面
        s[f2] += s[f1]; // f2的对数发生改变
        s[f1] = s[f2];
        cnt[f1] ++;     //f1 这一堆移动的次数加1, 只是根节点加
                        //以后利用findRoot函数会往下传递
    }</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-25-19.04.39
 Question_Number   ：HDU 3635
 Question_Name     ：dragon balls
 Description       : T A B
                     意味着把A这棵树，放到B下面
                     int f1 = findRoot(A)
                     int f2 = findRoot(B)
                     pre[f1] = f2;
                     s[f2] += s[f1];
                     cnt[f1]++;  //
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
int pre[MAXN], s[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if(pre[x] != x)
    {
        int f = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] += cnt[f];
    }
    return pre[x];
}
int main()
{
    int T, n, q, kase = 0;
    cin &gt;&gt; T;
    while(T--)
    {
        printf(&quot;Case %d:\n&quot;, ++kase);
        scanf(&quot;%d%d&quot;,&amp;n,&amp;q);
        for(int i = 1; i &lt;= n; i++)
        {
            pre[i] = i;
            s[i] = 1;
            cnt[i] = 0;
        }
        char ch;
        int u,v;
        for(int i = 1; i &lt;= q; i++)
        {
            cin &gt;&gt; ch;
            if(ch == &apos;T&apos;)
            {
                scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
                int f1 = findRoot(u);
                int f2 = findRoot(v);
                if(f1 != f2)
                {
                    pre[f1] = f2;
                    s[f2] += s[f1];
                    s[f1] = s[f2];
                    cnt[f1] ++;
                }
            }
            else if(ch == &apos;Q&apos;)
            {
                scanf(&quot;%d&quot;,&amp;u);
                int f = findRoot(u);
                printf(&quot;%d %d %d\n&quot;,f,s[f],cnt[u]);
            }
        }
    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>状态不错，好好保持，明天去剪个头。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 1988 Cube Stacking</title>
    <url>/tpaaaaaa.github.io/2019/08/26/POJ-1988CubeStacking/</url>
    <content><![CDATA[<h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有n个箱子，初始时每个箱子单独为一列；<br>接下来有p行输入，M, x, y 或者 C, x；<br>对于M,x,y：表示将x箱子所在的一列箱子搬到y所在的一列箱子上；<br>对于C,x：表示求箱子x下面有多少个箱子；</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>简单的带权并查集。采用自创的<strong>区间分析法</strong>(#^.^#)</p>
<p>我们令cnt[x] 表示x到其根fx中间的箱子数,s[x] 表示x所在集合中的箱子数</p>
<p>那么并查集中的查找函数为：</p>
<pre><code>int findRoot(int x)
{
    if(x != pre[x])  // 所以此时cnt[x] 表示的是[fa, x] 这个区间的属性
    {
        int fa = pre[x];          //可以知道cnt[fa] 表示的是[根, fa]这个区间
        pre[x] = findRoot(pre[x]);//这个时候f的根更改了，所以cnt[x] 表示的是[根, x]
        cnt[x] += cnt[fa];// [根, x] = [根, fa] + [fa, x];
    }
    return pre[x];
}</code></pre><p>见注释！！</p>
<p>集合合并部分：</p>
<pre><code>if(f1 != f2)
{
    pre[f1] = f2;  // 此时cnt[f1] 表示的是[f2, f1]这个区间
    cnt[f1] = s[f2];// 因为是将f1这个集合接在f2整个集合下面
    s[f2] += s[f1];
}</code></pre><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-25-18.35.26
 Question_Number   ：POJ - 1988
 Question_Name     ：cube stacking
 Description       : n个点，M x,y，将x点合并到y上面
                     cnt[i] 表示i下面的块数
                     s[i] 表示所在堆的数目
                     M x y
                     f1 = pre[x], f2 = pre[y];
                     实际上是pre[y] = f1;
                             cnt[x] += cnt[f2];
                    emmmm 题目意思转一转，就是cnt[i] 表示i到根的块数，M x y 表示将x合并到y的下面

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 30000 + 10;
int pre[MAXN], s[MAXN], cnt[MAXN];
int findRoot(int x)
{
    if(x != pre[x])
    {
        int fa = pre[x];
        pre[x] = findRoot(pre[x]);
        cnt[x] += cnt[fa];
    }
    return pre[x];
}
int main()
{
    for(int i = 1; i &lt; MAXN - 5; i++)
    {
        pre[i] = i;
        s[i] = 1;
    }
    int n,u,v;
    char ch;
    scanf(&quot;%d&quot;,&amp;n);
    for(int i = 1; i &lt;= n; i++)
    {
        getchar();
        scanf(&quot;%c&quot;,&amp;ch);
        if(ch == &apos;M&apos;)
        {
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            int f1 = findRoot(u);
            int f2 = findRoot(v);
            if(f1 != f2)
            {
                pre[f1] = f2;
                cnt[f1] = s[f2];
                s[f2] += s[f1];
            }
        }
        else
        {
            scanf(&quot;%d&quot;,&amp;u);
            findRoot(u);
            printf(&quot;%d\n&quot;,cnt[u]);
        }
    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>并查集是一种对于区间的操作，所以我的区间分析法很有用，屡试不爽哦</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>带权并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 4114 Disney&#39;s FastPass</title>
    <url>/tpaaaaaa.github.io/2019/08/25/HDU-4114Disney&#39;sFastPass/</url>
    <content><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>Disneyland is a large theme park with plenties of entertainment facilities, also with a large number of tourists. Normally, you need to wait for a long time before geting the chance to enjoy any of the attractions. The FastPass is a system allowing you to pick up FastPass-tickets in some specific position, and use them at the corresponding facility to avoid long lines. With the help of the FastPass System, one can arrange his/her trip more efficiently.<br>You are given the map of the whole park, and there are some attractions that you are interested in. How to visit all the interested attractions within the shortest time?</p>
<h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>首先用floyd求出各对点的最短路。然后从起点开始刷表法。</p>
<p>DP数组 dp[i][s1][s2] 表示当前在位置 i 处，已经拥有s1(状态压缩)处的FT，已经遍历过s2（状态压缩）处的所耗时间.</p>
<p>对于某个位置，他能转移到两种情况：</p>
<p>第一种情况是去游玩一个兴趣点，第二种情况是去某个点取FT票。</p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><pre><code>/*
 Date              : 2019-08-24-11.19.51
 Question_Number   ：HDU - 4114
 Question_Name     ：disney&apos;s fastpass
 Description       : N个点，M个边，K个想去的点
                     N个点1 .. N 路径必须从1到1
                     对于感兴趣的点
                     Pi 表示该点编号
                     Ti 表示不用Fastpath要耗的时间
                     FTi 表示用..耗的时间
                     Ni 有Ni个点可以获得第i个点的Fp
                     Fi ... Ni 个 点的位置
                     也就是说如果到达i点之间
                     已经到过Ni个点中的其中一个
                     则该点耗时time = FTi,否则为
                     Ti
                    有可能由重复点
                     经过某个点拿fp不需要排队，旅游某个点需要排队
                     状态压缩 + DP刷表法 + floyd
                     好好总结一下刷表法（博客）
                     熟练掌握状压... 这题目好（博客）
                     首先根据所给的图，求一遍floyd
                     DP数组 dp[i][s1][s2] 表示当前在位置i处，已经拥有s1处的FT，已经遍历过s2处的所耗时间
                     由这一个位置，可以转移至我的某个兴趣点去游玩，更新下一个点的数据（要加上路上的时间和排队的时间）
                     也可以转移到另一个点去取票，更新下一个点的数据(要加上路上的时间)
                     关于刷表法.
                     边界条件
                        如果该点的dp = INF, 说明这个点没有被之前的点刷到过，也可以理解为该点到不了，所以continue
                        如果兴趣点都去了，则ans = dp + dis[1][i]


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 50 + 10;
const int MAXK = 10;
const int MAXM = (1 &lt;&lt; 8) + 10;
int n,m;
int mp[MAXN][MAXN], pos[MAXK], time[MAXK], ftim[MAXK];
int FT[MAXN], dp[MAXN][MAXM][MAXM];
void floyd()
{
    for(int k = 1; k &lt;= n; k++)
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                    mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);

}
int main()
{
    int T,kase = 0,k;
    cin &gt;&gt; T;
    while(T--)
    {
        int A,B,D;
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
        //n个点，m个边，k个兴趣点
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                mp[i][j] = (i == j ? 0 : INF);
        memset(FT, 0, sizeof FT);
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;A,&amp;B,&amp;D);
            mp[A][B] = mp[B][A] = D;
        }

        for(int i = 1; i &lt;= k; i++)
        {
            int N;
            scanf(&quot;%d%d%d%d&quot;,&amp;pos[i],&amp;time[i],&amp;ftim[i],&amp;N);
            for(int j = 1; j &lt;= N; j++)
            {
                int temp;           //在temp这个位置可以领到第 i 个景区的FT票
                scanf(&quot;%d&quot;,&amp;temp);
                FT[temp] = FT[temp] | (1 &lt;&lt; (i - 1));   //FT[temp] 表示temp这个位置能领到的兴趣点的FT票
            }
        }
        floyd();    //求最短路，保存到mp[][]
 /*       for(int i = 1; i &lt;= n; i++)
        {
            for(int j = 1; j &lt;= n; j++)
                printf(&quot;%d &quot;,mp[i][j]);
            cout &lt;&lt; endl;
        }*/
        memset(dp, INF, sizeof dp);
        dp[1][0][0] = 0;    // 刷表法的起点 dp[i][s1][s2];
                            // 一共有k个兴趣点，所以为2^k   所以 1 &lt;&lt; (k);
                            // 一共有n个位置点
        int ans = INF;
        for(int s1 = 0; s1 &lt; (1 &lt;&lt; k); s1++)
            for(int s2 = 0; s2 &lt; (1 &lt;&lt; k); s2++)
                for(int i = 1; i &lt;= n; i++) //所处的位置
                {
                    int now = dp[i][s1][s2];
                    if(now == INF)
                        continue;        //说明这是一个没有被刷到过的状态
                    if(s2 == (1 &lt;&lt; k) - 1)  //说明兴趣点全部走完了
                    {
                      //  printf(&quot;i am here\n&quot;);
                        ans = min(ans, now + mp[i][1]);
                        continue;
                    }
            //        printf(&quot; i am here!\n&quot;);
                    for(int j = 1; j &lt;= k; j++) //下一步是去游玩没有游玩过的点
                        if( (s2 &amp; (1 &lt;&lt; (j - 1))) == 0)    //意思是j这个兴趣点没有游玩过,我改了这里
                        {
                            int &amp;nxt = dp[pos[j]][s1 | FT[pos[j]]][ s2 ^ ( 1 &lt;&lt; (j-1) )];    // 用取值符获得下一个状态，然后去更新
                            int tim = 0;
                            if( s1 &amp; (1 &lt;&lt; (j-1)) )   //说明有FT票
                                tim = ftim[j];
                            else
                                tim = time[j];
                            nxt = min(nxt, now + mp[i][pos[j]] + tim);
                         //   printf(&quot;he\n&quot;);
                        }
                    for(int j = 1; j &lt;= n; j++) //下一步是去某个位置点拿票
                    {
                        int &amp;nxt = dp[j][s1 | FT[j]][s2];
                        nxt = min(nxt, now + mp[i][j]);
                       // printf(&quot;her\n&quot;);
                    }


                }
        printf(&quot;Case #%d: %d\n&quot;,++kase,ans);
    }
    return 0;
}</code></pre><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>大部分情况下，最短路算法只是一个预处理而已。</p>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>DP刷表法，floyd，状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3873 Invade the Mars</title>
    <url>/tpaaaaaa.github.io/2019/08/25/HDU-3873InvadetheMars/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>It’s now the year 21XX,when the earth will explode soon.The evil U.S. decided to invade the Mars to save their lives.<br>But the childlike Marsmen never keeps any army,because war never take place on the Mars.So it’s very convenient for the U.S. to act the action.<br>Luckily,the Marsmen find out the evil plan before the invadation,so they formed a defense system.The system provides enchantment for some citys,and the enchantment generator for city A maybe set in city B,and to make things worse,both city B and C and more will provide echantment for city A.<br>The satelite of U.S. has got the map of the Mars.And they knows that when they enter a city,they can destory all echantment generator in this city at once,and they can enter a city only if they has destoryed all enchantment generator for this city,but troops can stay at the outside of the city and can enter it at the moment its echantment is destoryed.Of course the U.S. army will face no resistance because the Mars keep no army,so troops can invade in many way at the same time.<br>Now the U.S. will invade the Mars,give you the map,your task is to calculate the minimium time to enter the capital of the Mars. </p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>Dijkstral 的 本质BFS，这题目是将Dijstral变形。明白什么样的点可以入队，出队后又需要进行哪些操作</p>
<p>保护点问题，带有限制的最短路。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-24-15.16.38
 Question_Number   ：HDU - 3873
 Question_Name     ：invade the mars
 Description       : n个点，m条边
                     进入一点的前提是，某些点要已经进入过了
                     求1到n的最短距离，
                     每个点都有一个值
                     这个值是对应其所有的发生器都被销毁的时间
                     emmm
                     pro[x] 表示保护x的所有城市被攻占的最早时间
                     dist[x] 表示到达x的最早时间
                     首先将起点入队，然后起点出队，所有起点保护的
                     城市的保护值 - 1,如果某个点的保护值减为0 了
                     说明这个城市没有保护了，并且我们已经到达城外了
                     那么这个城的最短时间就是max(pro[x], dis[x]);
                     然后将这个城入队
                     然后将所有起点相连的点的dist更新
                     如果更新的这个点的保护值也为0了
                     说明就直接入侵了，那么这个点就可以入队了

                     能够入队的点  是已经入侵了的点。然后去更新出队的点，包括其保护的点，以及其相连的点
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
//const int INF = 0x3f3f3f3f;
const long long  INF = 1ll&lt;&lt;55; //这
const int MAXN = 3000 + 10;
const int MAXM = 7e4 + 10;
int cnt = 0,n,m;
bool vis[MAXN];
int head[MAXN], in[MAXN];
ll dis[MAXN], pro[MAXN];
vector &lt; int &gt; prot[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
typedef pair &lt;ll , int&gt; P;
void Dijkstral(int s)
{
    for(int i = 1; i &lt;= n; i++)
        dis[i] = INF, pro[i] = 0;
    memset(vis, false, sizeof vis);
    priority_queue&lt; P, vector &lt; P &gt;, greater&lt; P &gt; &gt; Q;//一个优先队列
    dis[s] = 0;
    Q.push(P(dis[s],s ));   //first 权值，second 编号，因为默认比较前一个
    while(!Q.empty())
    {
        P now = Q.top();
        Q.pop();
        int u = now.second;
        if(vis[u])
            continue;
        vis[u] = true;
        for(int i = 0; i &lt; prot[u].size(); i++)     //这是他所保护的
        {
            int v = prot[u][i];
            in[v] --;
            pro[v] = max(pro[v], dis[u]);           //pro[v] 表示保护v的城市被全部消灭的最短时间
                                                    // dis[u] 就是u被消灭的时间（此时u已经是被消灭了）
            if(in[v] == 0 &amp;&amp; dis[v] != INF)         //但是dis[v] 指的是到达v的时间\or最大保护时长
            {
                dis[v] = max(dis[v], pro[v]);       //比较的是到达时间和保护城市被灭的时间的最大值
                Q.push(P(dis[v],v));
            }
        }
        for(int i = head[u]; i != -1; i = edge[i].next) //这是他所相连接的
        {
            Edge e = edge[i];
            int v = e.to;
            int w = e.cost;
            if(dis[v] &gt; dis[u] + w)                     //
            {
                dis[v] = max(pro[v],dis[u] + w);        //
                if(in[v] == 0)
                {
                    Q.push(P(dis[v], v));
                }
            }
        }
    }

}
int main()
{
    int T,ai,bi,ci,li;
    cin &gt;&gt; T;
    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        cnt = 0;
        for(int i = 1; i &lt;= n; i++)
            prot[i].clear();
        memset(in, 0, sizeof in);
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;ai,&amp;bi,&amp;ci);
            addEdge(ai,bi,ci);
        //    addEdge(bi,ai,ci); 这是单向的，弟弟
        }
        for(int i = 1; i &lt;= n; i++)
        {
            int temp;
            scanf(&quot;%d&quot;,&amp;temp);
            in[i] = temp;               //保护i的城市数目为temp;
            for(int j = 1; j &lt;= temp; j++)
            {
                scanf(&quot;%d&quot;,&amp;li);
                prot[li].push_back(i);//li这座城市保护的城市加一个i
            }
        }
        Dijkstral(1);
 //       printf(&quot;here?&quot;);
        //cout &lt;&lt; dis[n] &lt;&lt; endl;
        printf(&quot;%I64d\n&quot;,dis[n]);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>Dijkstral的本质是BFS</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>保护点问题，Dijkstral变形</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2433 Travel</title>
    <url>/tpaaaaaa.github.io/2019/08/25/HDU-2433Travel/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><pre><code>One day, Tom traveled to a country named BGM. BGM is a small country, but there are N (N &lt;= 100) towns in it. Each town products one kind of food, the food will be transported to all the towns. In addition, the trucks will always take the shortest way. There are M (M &lt;= 3000) two-way roads connecting the towns, and the length of the road is 1.   
Let SUM be the total distance of the shortest paths between all pairs of the towns. Please write a program to calculate the new SUM after one of the M roads is destroyed. </code></pre><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>求最大路径树，删边的方法，剪枝的方法，重边的处理，Dij本质是BFS；</p>
<p>可用numEdge[u][v] 记录u到v的边有多少条，如果删掉了一条边，则numEdge[u][v] –, 如果 == 0 则说明没有边了。used[k][i][j] 表示的是以k为根个最短路径树中从有没有从i到j的这条边。因为如果删掉的边不在最短路径树上，最短路径树的边权和不会发生改变，然后删掉边后，numEdge任然大于0，说明可以走重边，那么最短路径树的边权和也不会发生改变，如果减完之后为0了，说明最短路径树会发生改变，因此重新计算一遍最短路径树。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-25-09.18.41
 Question_Number   ：HDU 2433
 Question_Name     ：travel
 Description       : n个点，m个无向边，长度为1，SUM为所有最短路之和
                     计算某条路删掉后的SUM；
                     计算每个点i为起点的最短路径树，求出树路径之和
                     总的SUM 就是这个路径数和相加;
                     删掉一条边，如果这条边是这个路径树上的一条边，那么从小算一遍，否则不变
                     而且可能有大量重边
                     用的Dij，但因为边长都为1，所以变成了BFS了
                     用bfs
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 110;
const int MAXM = 3000+10;
int cnt, n, m;
int numEdge[MAXN][MAXN], dis[MAXN], sumTree[MAXN], head[MAXN];
bool used[MAXN][MAXN][MAXN], vis[MAXN];

struct Edge
{
    int from, to, cost, next; //用cost来记录能不能过，1 废了，这个不好用
    //表示可以，0表示不行
    Edge(int from = 0, int to = 0, int cost = 0, int next = 0):from(from), to(to), cost(cost), next(next){}
};
Edge edge[2*MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++ ;
    edge[cnt].to = b;
    edge[cnt].from = a;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
int bfs(int s, int com)   //返回一个最小路径树的值
                 // 如果存在不连通，返回INF
{
    memset(dis, INF, sizeof dis);   //到各点的距离，
    memset(vis, false ,sizeof vis);
    queue &lt; int &gt; Q;    //用BFS的思想来处理;
    Q.push(s);          //起点入栈
    dis[s] = 0;
    vis[s] = true;
    while(!Q.empty())
    {
        int u = Q.front();  //出队
        Q.pop();
        for(int i = head[u]; i != -1; i = edge[i].next) //枚举与u相连的边
        {
            int v = edge[i].to;
 //           if(edge[i].cost == 0)                         //这条边已经被删掉了,或者这个点已经访问过了
   //             continue;
            if(numEdge[u][v] &lt;= 0 || vis[v])
                continue;
            if(com)
            {
                used[s][u][v] = true;
                used[s][v][u] = true;
            }

            if(vis[v] == false)
            {
       //          printf(&quot;s = %d u = %d, v = %d, dis[%d] = %d\n&quot;,s,u,v,v,dis[u] + 1);
                dis[v] = dis[u] + 1;
                vis[v] = true;
                Q.push(v);
            }
        }
    }
    int SUM = 0;
    for(int i = 1; i &lt;= n; i++)
    {
        int temp = dis[i];
        if(temp == INF)
            return INF;
        else
            SUM += temp;
    }
    return SUM;
}
int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        cnt = 0;    //边的数目，最后cnt = 2m;
        memset(numEdge, 0, sizeof numEdge);
        memset(head, -1, sizeof head);
        memset(used, false, sizeof used);
        for(int i = 1; i &lt;= m; i++)
        {
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            addEdge(u,v,1); // 编号1,2是一对边
            addEdge(v,u,1); //
            numEdge[u][v] ++;
            numEdge[v][u] ++;
        }
        bool flag = true;   //如果原图已经不连通了，就直接全输出INF，flag标记为false
        for(int i = 1; i &lt;= n; i++)
        {
            sumTree[i] = bfs(i,1);    //sumTree[i] 表示第i个路径树的值为bfs(i);
            if(sumTree[i] == INF)   //有一个树不连通
            {
                for(int j = 1; j &lt;= m; j++)
                    printf(&quot;INF\n&quot;);
                flag = false;
                break;
            }
        }
      //  int ans = 0;
       // for(int i = 1; i &lt;= n; i++)
       //     printf(&quot;sumTree[%d] = %d\n&quot;,i,sumTree[i]);
      //  printf(&quot;ans = %d\n&quot;, ans);
        if(flag)                    //原来是联通的。
            for(int i = 1; i &lt; 2*m; i += 2) //枚举删掉每一条边
            {
                bool fla = true;        //用来记录删除后是或否联通，如果删除后不连通，输出INF，否则输出SUM
                int u = edge[i].from;   //
                int v = edge[i].to;
                int SUM = 0;
                for(int j = 1; j &lt;= n &amp;&amp; fla; j++) //遍历每个路径树
                {
                    if(used[j][u][v] == false &amp;&amp; used[j][v][u] == false)//这个路径树没用过这条边，则直接加
                        SUM += sumTree[j];
                    else if(numEdge[u][v] &gt; 1 || numEdge[v][u] &gt; 1)      //路劲树用过这条边，但是有重边，所以还是直接加
                        SUM += sumTree[j];
                    else
                    {
                        //edge[i].cost = 0;       //删掉这条边
                        //edge[i + 1].cost = 0;
                        numEdge[u][v]--;
                        numEdge[v][u]--;
                        int temp = bfs(j,0);
                        numEdge[u][v]++;
                        numEdge[v][u]++;
                        edge[i].cost = 1;
                        edge[i+1].cost = 1;
                        if(temp == INF)         //
                        {
                            SUM = INF;
                            fla = false;
                            break;
                        }
                        else SUM += temp;

                    }

                }
                if(fla == false)
                    printf(&quot;INF\n&quot;);
                else
                    printf(&quot;%d\n&quot;,SUM);
            }


    }
    return 0;
}
/*
 4 5
 1 2
 2 3
 3 4
 1 4
 1 3
*/</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：重边多的情况，考虑numEdge的表示方法。删边就直接numEdge–; ==0就是没边了</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路径树，删边，大量重边，BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 2833 WuKong</title>
    <url>/tpaaaaaa.github.io/2019/08/25/HDU-2833WuKong/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>Alice每天往返于A、B，Bob每天往返于C、D。他们很忙所以每次都会挑选最短的路线，尽管如此他们仍想增加见面的机会。他们认为两个人所选路线的公共点越多见面机会越多。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>求两条最短路的最多公共点。分析这些公共点的性质。</p>
<p>①这些点肯定是连续的。</p>
<p>证法： 设最短路1 为s1 到 s2，最短路2为e1 到 e2; 如果这两条最短路上有4个公共点，分别为A,B,C,D； 并且A,B连续， C,D连续。 因此说明这两条最短路都要经过点A和点D， 那么可知 起点到终点的最短路 = 起点到A的最短路 + A到D的最短路 + D到终点的最短路。 所以两条最短路的一部分都是A到D的最短路。那么要使得两条最短路的公共点更多，所以肯定二者的这一部分（A到D的最短路）肯定是一条相同路，所以A到D上的点都是公共点，即A,B,,,C,D这一串连续点都是公共点。</p>
<p>②这些点(i 到 j)在最短路(s1 到 s2)上的数学语言是 mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2]</p>
<p>因此我们可以枚举一对点[i,j] 如果这一段[i,j]既在最短路1上（根据性质②），又在最短路2上，那么取 从i到j的最短路的最多点数dp[i][j] 和ans 相比较，最后取ans即可</p>
<p>dp[i][j] 表示考虑前k个点，从i到j的最短路中经历最多的点数。在floyd里面改改就行</p>
<pre><code>for(int k = 1; k &lt;= n ; k++)
     for(int i = 1; i &lt;= n; i++)
         for(int j = 1; j &lt;= n; j++)
         {
             if(mp[i][j] &gt; mp[i][k] + mp[k][j])
             {
                 mp[i][j] = mp[i][k] + mp[k][j];
                 dp[i][j] = dp[i][k] + dp[k][j] - 1;
             }
             else if(mp[i][j] == mp[i][k] + mp[k][j])
                 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] - 1);

         }
  for(int i = 1; i &lt;= n; i++)    //枚举一段
     for(int j = i; j &lt;= n; j++)
         if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2])
         {
             //这意味着枚举的这一段[i,j] 都是二者最短路上的一段
             ans = max(ans, dp[i][j]);
         }</code></pre><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-25-10.54.33
 Question_Number   ：HDU - 2833
 Question_Name     ：WuKong
 Description       : 图中两对点的最短路径的公共点最多
                     每对点可能存在多个最短路。
                     我们知道，我们可以先求出最短路的dis数组
                     如果dis[v] = dis[u] + e.w
                     说[u,v] 这条边是最短路中的；
                     我们首先把第一对点中所有在最短路上的点标记出来
                     哇，好巧妙啊呀！！！！
                     dp[i][j] 表示这个图中，从i点到j点的最短路上最多有多少个点
                     mp[i][j] 表示图中i到j的最短路长度
                     for(int k = 1; k &lt;= n ; k++)
                        for(int i = 1; i &lt;= n; i++)
                            for(int j = 1; j &lt;= n; j++)
                            {
                                if(mp[i][j] &gt; mp[i][k] + mp[k][j])
                                {
                                    mp[i][j] = mp[i][k] + mp[k][j];
                                    dp[i][j] = dp[i][k] + dp[k][j] - 1;
                                }
                                else if(mp[i][j] == mp[i][k] + mp[k][j])
                                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j] - 1);

                            }
                     for(int i = 1; i &lt;= n; i++)    //枚举一段
                        for(int j = i; j &lt;= n; j++)
                            if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2])
                            {
                                //这意味着枚举的这一段[i,j] 都是二者最短路上的一段
                                ans = max(ans, dp[i][j]);
                            }
                    //妙哉

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 300 + 10;
int mp[MAXN][MAXN], dp[MAXN][MAXN], n, m;
void floyd()
{
    for(int k = 1; k &lt;= n; k++)
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
            {
             //   if( i == j || i == k || j == k)
               //       continue;                   //这个剪枝反而复杂了。
               if(mp[i][j] &gt; mp[i][k] + mp[k][j])
               {
                   mp[i][j] = mp[i][k] + mp[k][j];
                   dp[i][j] = dp[i][k] + dp[k][j] - 1;
               }
               else if(mp[i][j] == mp[i][k] + mp[k][j])
                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] -1 );
            }
}
int main()
{
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) &amp;&amp; n+m)
    {
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
            {
                 mp[i][j] = ( i == j ? 0 : INF);
                 dp[i][j] = (i == j ? 1 : 2);
            }


        for(int i = 1; i &lt;= m; i++)
        {
            int a,b,c;
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            mp[a][b] = mp[b][a] = min(c ,mp[a][b]);//有可能有重边
        }
        floyd();
        int ans = 0;
        int s1,s2,e1,e2;
        scanf(&quot;%d%d%d%d&quot;,&amp;s1,&amp;s2,&amp;e1,&amp;e2);
        for(int i = 1; i &lt;= n; i++)
            for(int j = i; j &lt;= n; j++) //枚举一段[i,j];
                if(mp[s1][i] + mp[i][j] + mp[j][s2] == mp[s1][s2] &amp;&amp; mp[e1][i] + mp[i][j] + mp[j][e2] == mp[e1][e2])
                    ans = max(ans, dp[i][j]);
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：要深刻理解题意，简化题目</p>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最短路径的公共点，动态规划，floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3768 Shopping</title>
    <url>/tpaaaaaa.github.io/2019/08/25/HDU-3768Shopping/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>You have just moved into a new apartment and have a long list of items you need to buy. Unfortunately, to buy this many items requires going to many different stores. You would like to minimize the amount of driving necessary to buy all the items you need. </p>
<p>Your city is organized as a set of intersections connected by roads. Your house and every store is located at some intersection. Your task is to find the shortest route that begins at your house, visits all the stores that you need to shop at, and returns to your house. </p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>有n个点，但只有S个点必须去的，所以我们只需计算出这S个点彼此的最短距离mp[i][j],将这S个点和起点0形成一个新的图。因为内存有限，floyd开不了，就可以对每个S点求一次最短路。</p>
<p>得到新的mp数组后（新的图），此时的问题就是已知一个图，求从起点出发，遍历完所有的点，之后回到起点的最短路径。我们可以用 <strong>刷表法 + 状态压缩</strong> 解决</p>
<p>dp[i][s1] 表示目前在点i处，已经遍历完的点为s1(状态压缩)。那么这个点可以转移到与他相连的其他点（点j）</p>
<p>则状态转移方程为：dp[j][s1 | (1 &lt;&lt; j - 1 ）] = min(dp[j][s1 | (1 &lt;&lt; j - 1)], dp[i][s1] + mp[i][j] ); 然后用刷表法 从dp[0][0]刷</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><p>当时精神状态不好，写的稀乱</p>
<pre><code>/*
 Date              : 2019-08-25-13.17.19
 Question_Number   ：HDU - 3768
 Question_Name     ：Shopping
 Description       : n个点，m个无向边，起点 为0
                   ：有s个点必须去，去完之后回起点0
                   跟那个啥很像（博客）
                   floyd + 刷表法？首先求出每对点之间的最短距离
                   dp[i][s1]表示目前在i位置，s1表示已经访问过的购买点  的最短距离
                   dp[0][0] = 0;
                   对于每个i，根据他相连的边，可以知道他下一步可以去v位置
                   如果v位置是购买点，dp[v][s1 | shop[v]] min(,dp[i][s1] + mp[i][v])
                   如果v位置不是购买点, dp[v][s1] = min(,dp[v][s1] + mp[i][v]);
                    爆空间了,.
                   这代码写的贼丑

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100000 + 10;
int n, m, cnt;
int mp[11][11], dp[20][(1 &lt;&lt; 10) + 5], loc[MAXN], head[MAXN];
int shop[11];
int dis[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXN* 2];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
void floyd()
{
    for(int k = 0; k &lt; n; k++)
        for(int i = 0; i &lt; n; i++)
            for(int j = 0; j &lt; n; j++)
                mp[i][j] = min(mp[i][j], mp[i][k] + mp[k][j]);
}
void spfa(int s)
{
    queue &lt; int &gt; Q;
    memset(dis, INF, sizeof dis);
    memset(vis, false ,sizeof vis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            int w = edge[i].cost;
            if(dis[v] &gt; dis[u] + w)
            {
                dis[v] = dis[u] + w;
                if(vis[v] == false)
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int T;
    cin &gt;&gt;T;

    while(T--)
    {
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        // 编号 0 .. n-1
        memset(mp, INF, sizeof mp);
        cnt = 0;
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            int A,B,C;
            scanf(&quot;%d%d%d&quot;, &amp;A, &amp;B, &amp;C);
          //  mp[A][B] = mp[B][A] = min(C, mp[A][B]);
            addEdge(A,B,C);
            addEdge(B,A,C);
        }

        int S;
        scanf(&quot;%d&quot;,&amp;S);
        memset(loc, -1, sizeof loc);//loc = -1表示该点没有商店
        for(int i = 1; i &lt;= S; i++)
        {
            int temp;
            scanf(&quot;%d&quot;,&amp;temp);
            shop[i] = temp; //第i个shop在temp这个位置
            loc[temp] = i;  //temp这个位置有第i个shop
        }
     //   printf(&quot; i am here\n&quot;);
        spfa(0);
        for(int i = 1; i &lt;= S; i++)
            mp[0][i] = mp[i][0] = dis[shop[i]];

        for(int i = 1; i &lt; S ; i++)
        {
            spfa(shop[i]);
            for(int j = i + 1; j &lt;= S;j ++)
                mp[i][j] = mp[j][i] = dis[shop[j]];
        }
//        printf(&quot;mp[1][3]  = %d\n&quot;,mp[1][3]);
        memset(dp, INF, sizeof dp);
        dp[0][0] = 0;
        int ans = INF;
        for(int s1 = 0; s1 &lt; (1 &lt;&lt; S); s1++)    //当前状态
            for(int i = 0; i &lt;= S; i++)          //当前位于的商店编号
            {
                int now = dp[i][s1];
                if(now == INF)
                    continue;                   //说明没有被刷到过
          //      printf(&quot; i = %d, s1 = %d\n&quot;, i , s1);
                if(s1 == (1 &lt;&lt; S) - 1 )
                {
                    ans = min(ans, now + mp[i][0]);
            //        printf(&quot; ?? &quot;);
                }

                for(int j = 0; j &lt;= S; j++)      //枚举下一个点
                {
                    if(mp[i][j] == INF || i == j)   //没有边 or 相同了
                        continue;
            //        printf(&quot; j = %d\n&quot;,j);
                    int &amp;nxt = dp[j][s1 | (1 &lt;&lt; j - 1)];
                    nxt = min(nxt, now + mp[i][j]);

                }
            }
        printf(&quot;%d\n&quot;,ans);
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>①：学会根据题目来获得一个简化的图</strong>。</p>
<p><strong>②：刷表法</strong></p>
]]></content>
      <categories>
        <category>动态规划</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>图的简化，DP刷表法，状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title>POJ - 2449 Remmarguts&#39; Date</title>
    <url>/tpaaaaaa.github.io/2019/08/24/POJ-2449Remmarguts&#39;Date/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>给定一个n个点，m条边的有向图 求s到t的第k短路</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>k短路问题。spfa + A* + Dijktral 。模板题，见下面代码中的描述</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-09.44.19
 Question_Number   ：POJ - 2449
 Question_Name     ：Remmarguts&apos; Date
 Description       : n 个点，m条有向边，求s到t的第k短路
                    k短路问题： 单源点最短路跑 反向边 + A*
                    算法步骤：
                    1、以原终点t为源点，求解t到所有点的最短距离
                    2、新建一个优先队列，将源点s放入队列中
                    3、从优先队列中弹出f(p) 距离最小的点p，如果点p
                        就是t，则计算t出队的次数，如果当前为t的第k次出队
                        ，则当前路径的长度就是s到t的第k短路的长度，算法结束
                        否则遍历与p相连的所有的边，将扩展出来的p的邻接点信息
                        加入到优先队列中
                    定义估价函数 f[i] = d[i] + dis[i]
                    其中 d[i] 表示起点到i点的路径长度, dis[i] 表示i到终点的路径长度
                    则f[i] 表示一条起点到终点经过i这个点的路径的长度
                    具体实现步骤（更新博客）：
                    1、存两个图，一个正图，一个反图，用反图跑一边（SPFA or Dij）记录每一个点到最后一个点的最短距离dis[]
                    2、

*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1000 + 10;
const int MAXM = 1e5 + 10;
int cnt1 = 0, cnt2 = 0,n,m,s,t,k;
int head1[MAXN], head2[MAXN], dis[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to),cost(cost),next(next){}
};  // 用链式前向星存图
Edge edge1[MAXM];
Edge edge2[MAXM];
struct Node
{
    int to, g, f;
    friend bool operator &lt; (Node a, Node b)
    {
        if(a.f == b.f)
            return a.g &gt; b.g;
        return a.f &gt; b.f;
    }
};
void addEdge1(int a, int b, int c)
{
    cnt1 ++;
    edge1[cnt1].cost = c;
    edge1[cnt1].to = b;
    edge1[cnt1].next = head1[a];
    head1[a] = cnt1;
}
void addEdge2(int a, int b, int c)
{
    cnt2 ++;
    edge2[cnt2].cost = c;
    edge2[cnt2].to = b;
    edge2[cnt2].next = head2[a];
    head2[a] = cnt2;
}
void spfa(int s)            //对图二进行操作哦
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(dis, INF, sizeof dis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while( !Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head2[u]; i != -1; i = edge2[i].next)
        {
            int v = edge2[i].to;
            if(dis[v] &gt; dis[u] + edge2[i].cost)
            {
                dis[v] = dis[u] + edge2[i].cost;
                if(!vis[v])
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int Astar()
{
    Node now, e;
    int cnt = 0;    //记录终点出队多少次了
    priority_queue&lt; Node &gt; Q;
    if(s == t)
        k ++;       // WA的原因
    if(dis[s] == INF)
        return -1;          //说明终点和起点不连通，不存在k短路
    e.to = s;               //将起点压入队列中
    e.g = 0;                // g函数表示的是起点到该点的距离
    e.f = e.g + dis[e.to];  //估价函数f
    Q.push(e);
    while( !Q.empty())
    {
        e = Q.top();
        Q.pop();
        if(e.to == t)       //为终点了
            cnt ++;
        if(cnt == k)
                return e.g; //已经的第k条边了，则返回g
        int u = e.to;
        for(int i = head1[u]; i != -1; i = edge1[i].next)
        {
            now.to = edge1[i].to;
            now.g  = e.g + edge1[i].cost;
            now.f  = now.g + dis[now.to];
            Q.push(now);
            //if(now.g &gt; T) return -1;
        }
    }
    return -1;
}
int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    memset(head1, -1, sizeof head1);
    memset(head2, -1, sizeof head2);
    cnt1 = cnt2 = 0;
    int a,b,c;
    for(int i = 1; i &lt;= m; i++)
    {
        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
        addEdge1(a,b,c);    //在第一个图中存边
        addEdge2(b,a,c);    //在第二个图中存入反向边
    }
    cin &gt;&gt; s &gt;&gt; t &gt;&gt; k;
    spfa(t);                //以原终点t为起点
    int ans = Astar();      //返回的是k短路的长度
    cout &lt;&lt; ans;
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>k短路问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1839 Delay Constrained Maximum Capacity Path</title>
    <url>/tpaaaaaa.github.io/2019/08/24/HDU-1839DelayConstrainedMaximumCapacityPath/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>考虑一个包含 N 个顶点的无向图，编号从 1 到 N，并包含 M 条边。编号为 1 的顶点对应了一个矿藏，可从中提取珍稀的矿石。编号为 N 的顶点对应了一个矿石加工厂。每条边有相应的通行时间 (以时间单位计)，以及相应的运载量 (以矿石单位计)。现决定使用一条路径，将从矿藏中提取的矿石运送到加工厂。这条路径应当具有尽可能高的运载量，以便并行运输尽可能多的矿石。路径的运载量等于它的各边的最小运载量。然而，这些矿石很敏感，一旦从矿藏中提取出来，就会在 T 个时间单位之后开始分解，除非在这个时间截止之前到达工厂。因此，所选路径的总通行时间 (各条边的通行时间之和) 应当小于或等于 T。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>这是带有限制条件的最短路，常用二分，见下面代码里面的Description.</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-16.44.26
 Question_Number   ：HDU - 1839
 Question_Name     ：Delay Constrained Maximum Capacity Path
 Description       : n个点，m个边，边有两个长度和流量两个属性
                     求1到n 的路径中最小流量最大的路径
                     并且这条路径的长度 要小于or等于T；
                     有限制条件的最短路 + 二分下限
                     最多能运的货物取决于路径上边的最小容量，所以二分容量，再用最短路判断时限即可。
                     最短路里面多加一个判断保证走的边都能满足当前容量
                     二分一个流量，将图中比这个流量小的边去掉，求一次最短路
                     看看到终点的长度是否超过T，如果超过了
                     那么二分向下走，
                     如果没有超过T，就向上走。
                     用Dij吧因为没有负权值边
                     //原来时间翻倍的原因是cin 呀 o(╥﹏╥)o
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1e4 + 10;
const int MAXM = 2*(5e4 + 10);
int cnt = 0, minFlow, n, m, t;
int head[MAXN], d[MAXN];
bool inq[MAXN];
int flo[MAXM];      //将边长录入并且排序哦
typedef pair &lt;int ,int &gt; P;
struct Edge
{
    int to, cost, flow, next;
    Edge(int to = 0, int cost = 0, int flow = 0, int next = 0)
    :to(to), cost(cost), flow(flow), next(next){}
};
Edge edge[MAXM];
void addEdge(int A, int B, int C, int D)
{
    cnt ++;
    edge[cnt].to = B;
    edge[cnt].flow = C;
    edge[cnt].cost = D;
    edge[cnt].next = head[A];
    head[A] = cnt;
}
void Dijkstra(int s)        // 这是链式前向星的写法
{
    priority_queue &lt;P, vector &lt;P&gt;, greater &lt;P&gt; &gt; que; // 见注释①
    memset(d, INF, sizeof d);
    memset(inq, false ,sizeof inq);
    d[s] = 0;                                         // 将起点的d赋值为0
    que.push(P(0,s));                                 //first 为值， second为编号
    while( !que.empty())
    {
        P now = que.top();
        que.pop();
        int u = now.second;                             //u记录的是弹出点的编号
        if(inq[u])
            continue;
        inq[u] = true;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            if(edge[i].flow &lt; minFlow)
                continue;
            Edge e = edge[i];                        //e存的是与u连接的边
            if(d[e.to] &gt; d[u] + e.cost)                //进行松弛操作
            {
                d[e.to] = d[u] + e.cost;
                que.push(P(d[e.to], e.to));
             }
         }
    }

}
int main()
{
    int x, A, B, C, D;
    cin &gt;&gt; x;
    while(x--)
    {
        cnt = 0;
        memset(head, -1, sizeof head);
        //cin &gt;&gt; n &gt;&gt; m &gt;&gt; t; //n个点，m个边
        scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;t);
        for(int i = 1; i &lt;= m; i++)
        {
    //        cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D;
            scanf(&quot;%d%d%d%d&quot;,&amp;A,&amp;B,&amp;C,&amp;D);
            flo[i] = C;     //编号1 .. m
            addEdge(A,B,C,D);
            addEdge(B,A,C,D);
        }
        sort(flo + 1, flo + 1 + m);
        //按从小到大排序，编号1..m;
  //      printf(&quot;flo[1] = %d, flow[m] = %d\n&quot;,flo[1],flo[m]);
        int l = 1;
        int r = m;
        int mid = 0;
 //       int mid = (l + r) / 2;      //中间
        // [l,r]  l = 1  r = 5
        // mid = 3;  [1,2] [4,5];
        // l = 1, r = 2;
        // mid = 1, mid = 4;
        // [2,2]
        int ans = 0;
        while(l &lt;= r)
        {
            mid = (l + r) / 2;          //这个存的是位于mid位置的值
            minFlow = flo[mid];         // now 存的是流量，所以流量小于now的边全部去掉,去计算1到n的最短路，如果小于T，则记录ans = max(now)
        //    printf(&quot;l = %d,r = %d, mid = %d,midFlow = %d\n&quot;,l,r,mid,minFlow);
            Dijkstra(1);   // 并且二分向上走，如果大于T，则二分向下走
          //  printf(&quot;d[n] = %d\n&quot;,d[n]);

            if(d[n] &lt;= t)       //你也算个人才，弟弟
            {
               // printf(&quot;i am here\n&quot;);
                ans = max(ans, minFlow);
                l = mid + 1;
            }
            else
                r = mid - 1;
        }
        printf(&quot;%d\n&quot;,ans);

    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：cin 在大量输入的情况下不推荐使用！！！</p>
<p>②：二分好神奇。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>二分，带限制条件的最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1595 find the longest of the shortest</title>
    <url>/tpaaaaaa.github.io/2019/08/24/HDU-1595findthelongestoftheshortest/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>有一城市，这个城市有n个地点和m条连接他们的路，点的编号是从1到n，小X住在1，他想去n。但是最近正在维修公路，也就是说这m条路有且只有一条是坏的，但是小X不知道是哪一条，一条很关键的路坏了路程就会增加很多，所以小X想知道从1到n <em>最</em>坏<em>情</em>况* 下的路程。你能帮助他吗?</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>在原图中用spfa求一遍最短路。那么要坏路，肯定是要坏这条最短路上的路（因为坏其他的路，此时的最短路还是原最短路）。所以我们可以枚举每一条最短路上的边，然后将其赋值INF（意思路坏了），然后再求一遍spfa就可以了。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-14.43.16
 Question_Number   ：HDU - 1595
 Question_Name     ：Find the longest of the shortest
 Description       : 这条路肯定是在原来的最短路径上面，
                     因为如果不在，那最短路就是原来的最短路
                     所以只需要枚举最短路上的每一段路即可
                     // 补充一下链式前向星的一个作用
                     // 是可以处理重边的情况
                     所以步骤就是求一遍最短路
                     枚举路径上面每一段路，删掉
                     就是将枚举的路的cost = INF;

                     然后再求一遍最短路
                     将cost 改回去，循环往复
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 1010;
const int MAXM = MAXN * MAXN / 2;
int n, m, cnt;
int head[MAXN], pre[MAXN], d[MAXN];
bool vis[MAXN];
struct Edge
{
    int to, cost ,next;
    Edge(int to = 0, int cost = 0,int next = 0):to(to), cost(cost), next(next){}
};
Edge edge[MAXM];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].to   = b;
    edge[cnt].cost = c;
    edge[cnt].next = head[a];
    head[a]        = cnt;
}
void Change(int u, int v, int cost)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        Edge &amp;e = edge[i];  //这里憨憨了
        if(e.to == v)
        {
            e.cost = cost;
            break;
        }
    }
}
int getCost(int u, int v)
{
    for(int i = head[u]; i != -1; i = edge[i].next)
    {
        Edge e = edge[i];
        if(e.to == v)
        {
            return e.cost;
        }
    }
    return -1;

}
void spfa(int s)
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(d, INF, sizeof d);
    d[s] = 0;
    vis[s] = true;
    memset(pre, -1, sizeof pre);
    Q.push(s);
    while(!Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(d[v] &gt; d[u] + edge[i].cost)
            {
                pre[v] = u;
                d[v] = d[u] + edge[i].cost;
                if(vis[v] == false)
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        // n个点，m个边，起点1，终点n
        cnt = 0;
        memset(head, -1, sizeof head);
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            addEdge(a,b,c);
            addEdge(b,a,c);
        }
        spfa(1);        //起点1，存路径
        int ans = -1;    //
        int v = n;   //这是终点
        while(pre[v] != -1)  //往前找
        {
            int u = pre[v]; //得到一条边 u --- v
            int temp = getCost(u,v);
            Change(u,v,INF);    //将这条边的cost 改成INF;
            Change(v,u,INF);
            spfa(1);
            ans = max(d[n],ans);
            Change(u,v,temp);
            Change(v,u,temp);
            v = u;
        }
        cout &lt;&lt; ans &lt;&lt; endl;
    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>继续努力</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>记录最短路路径，删边</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 1599 find the mincost route</title>
    <url>/tpaaaaaa.github.io/2019/08/24/HDU-1599findthemincostroute/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p>杭州有N个景区，景区之间有一些双向的路来连接，现在8600想找一条旅游路线，这个路线从A点出发并且最后回到A点，假设经过的路线为V1,V2,….VK,V1,那么必须满足K&gt;2,就是说至除了出发点以外至少要经过2个其他不同的景区，而且不能重复经过同一个景区。现在8600需要你帮他找一条这样的路线，并且花费越少越好。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>解最小环问题。可以用floyd求最小环模板。</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-15.23.09
 Question_Number   ：HDU - 1599
 Question_Name     ：find the mincost route
 Description       : 旅行商是整个图所有点都走一圈
                     前提是一个图就是一个连通分量
                     然而这个问题是
                     这图中有许多联通分量，求某个连通分量中的
                     最小环。
                     可以用floyd 求最小环（更新博客！）
                     floyd 也是一种DP的思想
                     so ...
                     floyd里面有的数组 dp[k][i][j] 意思是
                     从i 到 j，且通过的点属于[1..k]的最短路径长度;
                     dp[0][i][j] 为原图的邻接矩阵
                     对于第k个点，有两种情况：
                     第一种情况是：不经过k点，则
                     dp[k][i][j] 可以从 dp[k-1][i][j] 转移过来
                     第二种情况是：经过k点，则
                     dp[k][i][j] = dp[k-1][i][k] + dp[k-1][k][j];
                     然后用滚动数组优化成我们熟知的模样。
*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0xfffffff;  //呵呵。我爱你
const int MAXN = 100 + 10;
int mp[MAXN][MAXN];
int dp[MAXN][MAXN];
int main()
{
    int n,m,a,b,c;
    while(scanf(&quot;%d%d&quot;,&amp;n,&amp;m) != EOF)
    {
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                mp[i][j] = (i == j ? 0 : INF); 

        for(int i = 1; i &lt;= m; i++)
        {
            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
            if( c &lt; mp[a][b])   // 重边的情况
                mp[a][b] = mp[b][a] = c;
        }
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                dp[i][j] = mp[i][j];    // 已知dp[0][i][j] 实际上为原图的邻接矩阵
        int ans = INF;
        for(int k = 1; k &lt;= n; k++)
        {
            for(int i = 1; i &lt; k; i++)
                for(int j = i+1; j &lt; k; j++)
                            ans = min(ans,dp[i][j] + mp[i][k] + mp[k][j]);  
// 此时等号左边的ans 表示的是考虑前k个点 时候的最小环长度
// 所以等号右边的ans 表示的是前k - 1个点时候的最小环的权值
// 对于第k个点，我们有两种情况，一种是这个点在环上，一种是该点不在
// 所以我们可以枚举每一对点，然后让其和第k个点连成一个环，判断这个环是否小于目前ans
// 我们枚举两个点i,j 并且二点都要属于[1,k-1]，所以此时的dp[i][j] 就是前k-1个点的情况下的从i到j的最小路长度
// 将这个最短路 再加上到k这个点的两条边，就是要进行判断的环了
            for(int i = 1; i &lt;= n; i++)
                for(int j = 1; j &lt;= n; j++)
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j]);
        }

        if(ans != INF)
            printf(&quot;%d\n&quot;,ans);
        else
            printf(&quot;It&apos;s impossible.\n&quot;);
    }

    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：const int INF = 0x3f3f3f3f；会WA的原因是因为有可能INF加了多次，然后溢出了。所以应该 const int INF = 0xfffffff; or 在处理dp时候判断一下是否小于INF；（这是个好习惯）</p>
<p>②：可能有重边的情况。</p>
<p>③：理解好floyd是一种DP哦！！</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>最小环问题</tag>
      </tags>
  </entry>
  <entry>
    <title>HDU - 3339 In Action（最短路+背包）</title>
    <url>/tpaaaaaa.github.io/2019/08/24/HDU-3339InAction%EF%BC%88%E6%9C%80%E7%9F%AD%E8%B7%AF+%E8%83%8C%E5%8C%85%EF%BC%89/</url>
    <content><![CDATA[<h3 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h3><p> 自1945年以来，当美国的曼哈顿项目小组引爆了第一颗核弹时，全球的核武器数量急剧增加。<br> 如今，FZU的一个名叫AekdyCoin的疯狂男孩拥有核武器，想要毁灭我们的世界。幸运的是，我们神秘的间谍网络已经得到了他的计划。现在，我们需要阻止它。<br> 但这项艰巨的任务显然并不容易。首先，我们知道，核武器的操作系统由一些连接的电站组成，它们构成了一个庞大而复杂的电网。每个电站都有它的功率值。要启动核武器，它必须消耗电网一半的电力。所以首先，我们需要将一半以上的能量分散。我们的坦克已经为我们在基地的行动做好了准备(ID是0)，我们必须在路上驾驶它们。至于发电站，只有当我们的坦克停在那里时，我们才能控制它们。1单位距离花费1单位油。我们有足够的坦克使用。<br> 现在我们的指挥官想知道这次行动的最小石油成本。</p>
<h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p>Description : n + 1个点，起点为0,<br>因为我们有足够多的坦克.并且每个坦克到一个点后就停在哪里了<br>所以我们要求的是起点 到各个点的最短路长度之和<br>意思是占领某些点后，使得这些点的功率总和大于原总功率的一半<br>因此我们先求出起点到每个点的最短路径dis<br>因此对于每个点，我们有两个属性<br>一个是dis， 一个是pow<br>我们要使得pow和这个值大于一半的情况下使得dis最小<br>dp[i][j]// 表示考虑前i个点，pow和为j的情况下的最短距离之和<br>最后我们求出的是 min(dp[n][j]) j &gt; 总pow/2;<br>对于每个点我们有两种情况，选or不选<br>dp[i][j] = min(dp[i-1][j],dp[i-1][j-pow[i]] + dis[i]);<br>就变成了一个背包问题（更新博客）<br>优化成一维<br>memset(INF);<br>for(int i = 1; i &lt;= n; i++) //那么问题来，考虑前i个，最大的pow和就是前i个的pow之和 // 最少的pow和就是0 for(int j = powSum[i]; j &gt;= 0;j–)<br>{<br>if(j - pow[i] &gt;= 0)<br>dp[j] = min(dp[j], dp[j - pow[i]]+dis[i]);<br>}</p>
<h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><pre><code>/*
 Date              : 2019-08-23-10.28.17
 Question_Number   ：HDU - 3339
 Question_Name     ：In Action
 Description       : n + 1个点，起点为0,
                     因为我们有足够多的坦克.并且每个坦克到一个点后就停在哪里了
                     所以我们要求的是起点 到各个点的最短路长度之和
                     意思是占领某些点后，使得这些点的功率总和大于原总功率的一般
                     因此我们先求出起点到每个点的最短路径dis
                     因此对于每个点，我们有两个属性
                     一个是dis， 一个是pow
                     我们要使得pow和这个值大于一半的情况下使得dis最小
                     dp[i][j]// 表示考虑前i个点，pow和为j的情况下的最短距离之和
                     最后我们求出的是 min(dp[n][j]) j &gt; 总pow/2;
                     对于每个点我们有两种情况，选or不选
                     dp[i][j] = min(dp[i-1][j],dp[i-1][j-pow[i]] + dis[i]);
                     就变成了一个背包问题（更新博客）
                     优化成一维
                     memset(INF);
                     for(int i = 1; i &lt;= n; i++)    //那么问题来，考虑前i个，最大的pow和就是前i个的pow之和
                                                    //                       最少的pow和就是0
                        for(int j = powSum[i]; j &gt;= 0;j--)
                        {
                            if(j - pow[i] &gt;= 0)
                                dp[j] = min(dp[j], dp[j - pow[i]]+dis[i]);
                        }


*/
#include&lt;functional&gt;
#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;algorithm&gt;
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include&lt;bitset&gt;
#include&lt;cstdlib&gt;
#include&lt;cmath&gt;
#include&lt;set&gt;
#include&lt;list&gt;
#include&lt;deque&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
using namespace std;
typedef long long ll;
const double PI = acos(-1.0);
const double eps = 1e-6;
const int INF = 0x3f3f3f3f;
const int MAXN = 100 + 10;  //点数
const int MAXM = 10000 + 10;//  一定要注意边数   和无向边的时候要开两倍
const int MAXT = 4*MAXM * 100;
int cnt,n,m;
int head[MAXN], dis[MAXN], powSum[MAXN], powNum[MAXN], dp[MAXT];
bool vis[MAXN];
struct Edge
{
    int to, cost, next;
    Edge(int to = 0, int cost = 0, int next = 0):to(to),cost(cost),next(next){}
};  // 用链式前向星存图
Edge edge[MAXM * 2];
void addEdge(int a, int b, int c)
{
    cnt ++;
    edge[cnt].cost = c;
    edge[cnt].to = b;
    edge[cnt].next = head[a];
    head[a] = cnt;
}
void spfa(int s)            //对图二进行操作哦
{
    queue &lt; int &gt; Q;
    memset(vis, false, sizeof vis);
    memset(dis, INF, sizeof dis);
    dis[s] = 0;
    vis[s] = true;
    Q.push(s);
    while( !Q.empty())
    {
        int u = Q.front();
        Q.pop();
        vis[u] = false;
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            int v = edge[i].to;
            if(dis[v] &gt; dis[u] + edge[i].cost)
            {
                dis[v] = dis[u] + edge[i].cost;
                if(!vis[v])
                {
                    vis[v] = true;
                    Q.push(v);
                }
            }
        }
    }
}
int main()
{
    int t,a,b,c;
    cin &gt;&gt; t;
    while( t --)
    {
        memset(head, -1, sizeof head);
        cnt = 0;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    //总点数为n+1  编号 0 ... n 起点n
        for(int i = 1; i &lt;= m; i++)
        {
            scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);
            addEdge(a,b,c);
            addEdge(b,a,c);
        }
        spfa(0);            //求出dis数组
        powSum[0] = 0;      // powSum[ i ] 存的是前i个点的pow和，总的pow和就是pow[n];
        for(int i = 1; i &lt;= n; i++)
        {
            cin &gt;&gt; powNum[i];  //记录每个点的pow
            powSum[i] = powSum[i-1] + powNum[i];
        }
        memset(dp, INF, sizeof dp);
        // dp[0][j] 表示的是考虑0个，最短路径和
        // dp[0][0] 考虑前0个，pow和为0;
        dp[0] = 0;
        for(int i = 1; i &lt;= n; i++)     //考虑前i个到...前n个
            for(int j = powSum[i]; j - powNum[i] &gt;= 0; j--) //我改了这里哦
            {
                    dp[j] = min(dp[j], dp[j - powNum[i]]+dis[i]);
            }
        int ans = INF;

        int start = powSum[n] / 2 + 1;
        for(int i = start ; i &lt;= powSum[n]; i++)
            if(dp[i] &lt; ans)
                ans = dp[i];

        if(ans &lt; INF)
            cout &lt;&lt; ans;
        else
            cout &lt;&lt; &quot;impossible&quot;;
        cout &lt;&lt; endl;

    }
    return 0;
}</code></pre><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>①：题目告诉你边的MAXM,但因为是无向边，所以你实际存图的数量应该开到 2*MAXM，不然会报WA or RE！！</p>
<p>②：要对一些经典的DP模型了如指掌。</p>
]]></content>
      <categories>
        <category>图论</category>
      </categories>
      <tags>
        <tag>HDU，图论，背包</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]最小环问题</title>
    <url>/tpaaaaaa.github.io/2019/08/23/%5B%E7%AE%97%E6%B3%95%5D%E6%9C%80%E5%B0%8F%E7%8E%AF%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><em>解法：floyd实际上也是一种DP。改一改dp方程就ok了<em>；</em>Dijkstral也可以解</em></p>
<h3 id="最小环："><a href="#最小环：" class="headerlink" title="最小环："></a>最小环：</h3><p><strong>最小环</strong>：从一个点出发,经过一条简单路径回到起点成为环.图的最小环就是所有环 中长度最小的. 例题见HDU - 1599 find the mincost route</p>
<h3 id="如何求最小环"><a href="#如何求最小环" class="headerlink" title="如何求最小环"></a>如何求最小环</h3><h4 id="解法一：用Dijkstral算法"><a href="#解法一：用Dijkstral算法" class="headerlink" title="解法一：用Dijkstral算法"></a>解法一：用Dijkstral算法</h4><pre><code>任意一个最小环环的权值，我们都可以看成**两个有边相连的结点i、j的直接距离（边长）加上i、j间不包含边(边i-&gt;j)的最短路径（用Dij求出）**。求最短路径我们第一个想到的就**Dijkstra算法**。</code></pre><p>解法就是：枚举所有边，<strong>每次删去一条边(u, v)</strong>，然后从u开始跑Dijkstra（用堆或者c++中优先队列优化的）<strong>求u到v的距离再加上(u, v)的权值</strong>，枚举完所有边就得出答案了，复杂度为O(m * n * logn)。。</p>
<h4 id="解法二：Floyd算法"><a href="#解法二：Floyd算法" class="headerlink" title="解法二：Floyd算法"></a>解法二：Floyd算法</h4><pre><code>for(int i = 1; i &lt;= n; i++)
    for(int j = 1; j &lt;= n; j++)
        dp[i][j] = mp[i][j];    // 已知dp[0][i][j] 实际上为原图的邻接矩阵，并且注意dp[i][i] = INF 不是0哦
int ans = INF;
for(int k = 1; k &lt;= n; k++)
{
    for(int i = 1; i &lt; k; i++)
        for(int j = 1; j &lt; i; j++)                              // i &lt; k   j &lt; i 这情况下的dp[i][j] 才纯正
            ans = min(ans,dp[i][j] + mp[i][k] + mp[k][j]);    //这时候的dp[i][j] 实际上是 dp[k-1][i][j]，上一个状态的
    for(int i = 1; i &lt;= n; i++)
        for(int j = 1; j &lt;= n; j++)
            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][i]);
}</code></pre><h4 id="解法三：最小生成树（留坑）"><a href="#解法三：最小生成树（留坑）" class="headerlink" title="解法三：最小生成树（留坑）"></a>解法三：最小生成树（留坑）</h4><p>我们先求所给图的最小生成树，可以保证<strong>最小环就是由最小生成树上的边再加上一条非生成树上的边构成的</strong>，依次枚举所有边，每次加上一条边后，求出由其构成的环的权值，最后求最小值就解决了图的最小环问题。</p>
<p>再说说具体怎么求每次的环的权值，我们把图变成了一颗树，假设我们枚举了一条边(u, v)， 我们只需要<strong>在生成树上求出u到v的距离再加上(u, v)这一条边的权值就算是求出环的权值了</strong>，至于求u到v的距离，用最近公共祖先(LCA)可以解决，求出u和v到其公共祖先的距离之和就是u到v的距离了。</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>最小环问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[算法]双调旅行商问题</title>
    <url>/tpaaaaaa.github.io/2019/08/23/%5B%E7%AE%97%E6%B3%95%5D%E5%8F%8C%E8%B0%83%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>解法：经典的DP问题</p>
<h3 id="旅行商问题"><a href="#旅行商问题" class="headerlink" title="旅行商问题"></a>旅行商问题</h3><p>旅行商问题（TSP）:</p>
<p>是旅行商要到若干个城市旅行，各城市之间的费用是已知的，为了节省费用，旅行商决定从所在城市出发，到每个城市旅行一次后返回初始城市，问他应选择什么样的路线才能使所走的总费用最短。</p>
<p>解法：回溯法、动态规划</p>
<h3 id="双调旅行商问题"><a href="#双调旅行商问题" class="headerlink" title="双调旅行商问题"></a>双调旅行商问题</h3><p>双调旅行商/双调欧几里得旅行商 问题（DTSP）：</p>
<p>欧几里得旅行商问题是对平面上给定的n个点确定一条连接各点的最短闭合旅程的问题。如图（a）给出了一个7个点问题的解。这个问题的一般形式是NP完全的，故其解需要多于多项式的时间。</p>
<pre><code>J.L. Bentley 建议通过只考虑双调旅程(bitonic tour)来简化问题,这种旅程即为从最左点开始，严格地从左到右直至最右点，然后严格地从右到左直至出发点。下图(b)显示了同样的7个点的最短双调路线。在这种情况下，多项式的算法是可能的。事实上，存在确定的最优双调路线的O(n*n)时间的算法。</code></pre><p><img src="http://localhost/wp-content/uploads/2019/08/DTSP.jpg" alt=""></p>
<p>解法：</p>
<p>1.将平面上所有点按横坐标x升序排序（O（nlogn））<br>2.子结构：我们定义d[i][j]为i经过起点到达j点的路径长度，i到起点x单调变小，起点到j单调变大，d[n][n]即为答案。定义dist[i][j] 为i&lt;-&gt;j之间的直接距离。<br>3.DP时会有三种情况<br>当j &lt; i-1时 d[i][j] = d[i - 1][ j ] + dist[i][i-1];</p>
<p>由定义可知，点Pi-1一定在路径Pi-Pj上，而且又由于j&lt;i-1,因此Pi的左边的相邻点一定是Pi-1.因此可以得出上述等式。</p>
<p>当j = i-1时 d[i][j] = min(d[i][j],d[j][k] + dist[i][k]) (1 &lt; = k &lt; j);</p>
<p>与Pi左相邻的那个点可能是P1到Pj-1 中的任何一个。因此需要递归求出最小的那个路径</p>
<p>当j = i 时 d[i][j] = min(d[i][j],d[j][k] + dist[i][k]) (1&lt; = k &lt; j);<br>第二和第三种情况可以合并一下。</p>
<h3 id="代码（HDU-2224）："><a href="#代码（HDU-2224）：" class="headerlink" title="代码（HDU - 2224）："></a>代码（HDU - 2224）：</h3><pre><code>int main()
{
    while(scanf(&quot;%d&quot;,&amp;n) != EOF)
    {
        for(int i = 1; i &lt;= n; i++) //n个点 起点为1
        {
            scanf(&quot;%d%d&quot;,&amp;node[i].x, &amp;node[i].y);
        }
        for(int i = 1; i &lt;= n; i++)
            for(int j = i ; j &lt;= n; j++)
                mp[i][j] = mp[j][i] = getDis(node[i], node[j]);
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= n; j++)
                dp[i][j] = (double) INF;
        dp[1][1] = 0;
        dp[2][1] = dp[1][2] = mp[2][1];
        for(int i = 1; i &lt;= n; i++)
            for(int j = 1; j &lt;= i; j++)
            {
             //   cout &lt;&lt; &quot;?&quot;;
                if(j &lt; i - 1)
                    dp[i][j] = dp[i-1][j] + mp[i][i-1];
                else
                {
                    for(int k = 1; k &lt; j; k++)
                        dp[i][j] = min(dp[i][j], dp[j][k] + mp[i][k]);//改了这里
                }
            }
       printf(&quot;%.2f\n&quot;,dp[n][n]);
    }
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>动态规划</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>双调旅行商问题，旅行商问题</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]多源点最短路Floyd</title>
    <url>/tpaaaaaa.github.io/2019/08/22/%5B%E6%A8%A1%E6%9D%BF%5D%E5%A4%9A%E6%BA%90%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%AFFloyd/</url>
    <content><![CDATA[<p><em>其本质为动态规划</em></p>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>floyd里面有的数组 dp[k][i][j] 意思是：<br>从i 到 j，且通过的点都属于[1..k]的最短路径长度;<br>dp[0][i][j] 为原图的邻接矩阵</p>
<p>对于第k个点，有两种情况：<br>第一种情况是：不经过k点，则<br>dp[k][i][j] 可以从 dp[k-1][i][j] 转移过来<br>第二种情况是：经过k点，则<br>dp[k][i][j] = dp[k-1][i][k] + dp[k-1][k][j];<br>然后用滚动数组优化成我们熟知的模样。</p>
<h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><p>for(int k = 1; k &lt;= n; k++)<br>   for(int i = 1; i &lt;= n; i++)<br>      for(int j = 1; j &lt;= n; j++)<br>         if(dis[j] &gt; dis[i][k] + dis[k][j])<br>             dis[j] = dis[i][k] + dis[k][j];</p>
<h4 id="解传递闭包"><a href="#解传递闭包" class="headerlink" title="解传递闭包"></a>解传递闭包</h4><p>for(int k = 1; k &lt;= n; k++)<br>  for(int i = 1; i &lt;= n; i++)<br>    for(int j = 1; j &lt;= n; j++)<br>      if(dis[j]  == true ||(dis[i][k] &amp;&amp; dis[k][j]) )<br>         dis[j] = true;</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>动态规划思想，Floyd</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]单源点最短距离 SPFA</title>
    <url>/tpaaaaaa.github.io/2019/08/22/%5B%E6%A8%A1%E6%9D%BF%5D%E5%8D%95%E6%BA%90%E7%82%B9%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BBSPFA/</url>
    <content><![CDATA[<p><em>编程习惯：Bellman_Ford + 队列优化</em></p>
<h3 id="SPFA模板"><a href="#SPFA模板" class="headerlink" title="SPFA模板"></a>SPFA模板</h3><h4 id="Normal"><a href="#Normal" class="headerlink" title="Normal"></a>Normal</h4><pre><code>void bellman_ford(int s)
{
    queue&lt; int &gt; q;
    memset(vis,false,sizeof s);
        memset(pre, -1, sizeof pre);
    for(int i = 1; i &lt;= n; i++)
        dis[i] = INF;
    dis[s] = 0;
    q.push(s);
    vis[s] = true;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false ;    //可以多次入队哦
//  这是用vector邻接表存的图
        for(int i = 0; i &lt; G[u].size(); i++)
        {
            Edge e = G[u][i];
                        int v = e.to;
//  需要更新的点 的前提是 其前继是之前已经更新过了的emmm有点废话
            if(d[v] &gt; d[u] + e.dist)
            {
                d[v]   = d[u] + e.dist;
                pre[v] = u;// 记录路径
                if(vis[v] == false)
                {
                    vis[v] = true;
                    q.push(v);
                }
             } 
         } 
    }


}</code></pre><h4 id="判断负环存在与否（与起点为同一个连通分量）"><a href="#判断负环存在与否（与起点为同一个连通分量）" class="headerlink" title="判断负环存在与否（与起点为同一个连通分量）"></a>判断负环存在与否（与起点为同一个连通分量）</h4><pre><code>void bellman_ford(int s)
{
    queue&lt; int &gt; q;
    memset(vis,false,sizeof s);
        memset(pre, -1, sizeof pre);
        memset(cnt, 0, sizeof cnt);
    for(int i = 1; i &lt;= n; i++)
        dis[i] = INF;
    dis[s] = 0;
        cnt[s] = 1; //起点进队次数为1
    q.push(s);
    vis[s] = true;
    while(!q.empty())
    {
        int u = q.front();
        q.pop();
        vis[u] = false ;    //可以多次入队哦
                if(cnt[u] &gt; n)          //n为点数
                    cout &lt;&lt; &quot; 在s上存在负环 &quot;&lt;&lt; endl; 
//  这是用vector邻接表存的图
        for(int i = 0; i &lt; G[u].size(); i++)
        {
            Edge e = G[u][i];
                        int v = e.to;
//  需要更新的点 的前提是 其前继是之前已经更新过了的emmm有点废话
            if(d[v] &gt; d[u] + e.dist)
            {
                d[v]   = d[u] + e.dist;
                pre[v] = u;// 记录路径
                if(vis[v] == false)
                {
                    vis[v] = true;
                                        cnt[v] ++;
                    q.push(v);
                }
             } 
         } 
    }


}</code></pre>]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>SPFA</tag>
      </tags>
  </entry>
  <entry>
    <title>[模板]Dijktral算法</title>
    <url>/tpaaaaaa.github.io/2019/08/22/%5B%E6%A8%A1%E6%9D%BF%5DDijktral%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><em>编程习惯：用Dijkstral + 链式前向星 + 优先队列</em></p>
<h4 id="三种存图方式的比较："><a href="#三种存图方式的比较：" class="headerlink" title="三种存图方式的比较："></a>三种存图方式的比较：</h4><p><strong>邻接矩阵：</strong>适合稠密图，一般不推荐使用</p>
<p><strong>vector邻接表：</strong>适合稀疏图，但不论是在内存上还是在速度上都是略逊于链式前向星写法的，写法实现上也并没有简洁多少，所以能采用链式前向星写法还是采用链式前向星写法吧(但要提前知道边的数目MAXM。 vector邻接表与链式前向星有内存性能上的差异，因为vector扩充时是默认多申请2倍空间 ）</p>
<p><strong>链式前向星：</strong>适合稀疏图，推荐（所以待会的板子也是用它，前提是要知道MAXM哦）</p>
<h4 id="链式前向星模板："><a href="#链式前向星模板：" class="headerlink" title="链式前向星模板："></a>链式前向星模板：</h4><p>边的结构体：</p>
<pre><code>struct Edge
{
     int next;

     int to;

     int w;
};</code></pre><p>其中edge[i].to表示第i条边的终点,edge[i].next表示与第i条边同起点的下一条边的存储位置,edge[i].w为边权值.</p>
<p>另外还有一个数组head[],它是用来表示以i为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实在 以i为起点的所有边的最后输入的那个编号.  </p>
<p><strong>head[]数组一般初始化为-1</strong></p>
<p>对于加边的addEdge函数是这样的:</p>
<pre><code>// 传入 u 为 边的起点， v 为边的终点， w 为边的权值
void addEdge(int u,int v,int w)
{
    edge[cnt].w = w;
    edge[cnt].to = v;
    edge[cnt].next = head[u];
    head[u] = ++cnt;
//  head[u] = cnt ++;  这是从0开始
}</code></pre><p>其中 cnt 保存的边的编号(从1开始)，最终cnt保存的是边的数目</p>
<p>遍历与某个点相连的所有边的方法：</p>
<pre><code>for(int i=head[u]; i != -1; i=edge[i].next)//遍历u这个点出发的所有的边i</code></pre><h4 id="Dij模板："><a href="#Dij模板：" class="headerlink" title="Dij模板："></a>Dij模板：</h4><pre><code>void Dijkstra(int s)        // 这是链式前向星的写法 
{
    priority_queue &lt;P, vector &lt;P&gt;, greater &lt;P&gt;&gt; que; // 见注释① 
    fill(d, d + V, INF);                             // V为点数 
    memset(inq, false ,sizeof inq);
    d[s] = 0;                                         // 将起点的d赋值为0 
    que.push(P(0,s));                                 //first 为值， second为编号
    while( !que.empty())
    {
        P now = que.top();
        que.pop();
        int u = now.second;                             //u记录的是弹出点的编号
        if(inq[u])
            continue;
        inq[u] = true;                        
        for(int i = head[u]; i != -1; i = edge[i].next)
        {
            Edge e = edge[i];                        //e存的是与u连接的边
            if(d[e.to] &gt; d[u] + e.cost)                //进行松弛操作 
            {
                d[e.to] = d[u] + e.cost;
                que.push(P(d[e.to], e.to));
             } 
         } 
    } 

} 
/*
关于priority_queue

priority_queue 对于基本类型的使用方法相对简单。他的模板声明带有三个参数:
priority_queue&lt;Type, Container, Functional&gt;
其中Type 为数据类型， Container 为保存数据的容器，Functional 为元素比较方式。
Container 必须是用数组实现的容器，比如 vector, deque 但不能用 list.
STL里面默认用的是 vector. 比较方式默认用 operator&lt; , 所以如果你把后面俩个参数缺省的话，
优先队列就是大顶堆，队头元素最大。


注释①四种priority_queue声明方法：
1、priority_queue&lt;int&gt; q;//通过操作，按照元素从大到小的顺序出队
2、priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q; //通过操作，按照元素从小到大的顺序出队
3、struct cmp {     
　　operator bool ()(int x, int y)     
　　{        
　　　　 return　x &gt; y; // x小的优先级高       //也可以写成其他方式，如： return p[x] &gt; p[y];表示p[i]小的优先级高
　　}
};
priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;    //定义方法
//其中，第二个参数为容器类型。第三个参数为比较函数。 

4、struct node {     
　　int x, y;     
　　friend bool operator &lt; (node a, node b)     
　　{         
　　　　return a.x &gt; b.x;    //结构体中，x小的优先级高     
　　}
};
priority_queue&lt;node&gt;q;   //定义方法
//在该结构中，y为值, x为优先级。
//通过自定义operator&lt;操作符来比较元素中的优先级。
//在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误
*/ </code></pre><h3 id="各种算法的使用场景"><a href="#各种算法的使用场景" class="headerlink" title="各种算法的使用场景"></a>各种算法的使用场景</h3><p>Dijkstra：适用于权值为非负的图的单源最短路径，用斐波那契堆的复杂度O(E+VlgV)<br>BellmanFord：适用于权值有负值的图的单源最短路径，并且能够检测负圈，复杂度O(VE)<br>SPFA：适用于权值有负值，且没有负圈的图的单源最短路径，论文中的复杂度O(kE)，k为每个节点进入Queue的次数，且k一般&lt;=2，但此处的复杂度证明是有问题的，其实SPFA的最坏情况应该是O(VE).<br>Floyd：每对节点之间的最短路径。</p>
<p>先给出结论：<br>(1)当权值为非负时，用Dijkstra。<br>(2)当权值有负值，且没有负圈，则用SPFA，SPFA能检测负圈，但是不能输出负圈。<br>(3)当权值有负值，而且可能存在负圈，则用BellmanFord，能够检测并输出负圈。<br>(4)SPFA检测负环：当存在一个点入队大于等于V次，则有负环，后面有证明。</p>
]]></content>
      <categories>
        <category>图论</category>
        <category>模板</category>
      </categories>
      <tags>
        <tag>Dijkstral</tag>
        <tag>图论算法的比较</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搬到这个新家了~</title>
    <url>/tpaaaaaa.github.io/2019/08/21/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%88%B0%E8%BF%99%E4%B8%AA%E6%96%B0%E5%AE%B6%E4%BA%86~/</url>
    <content><![CDATA[<p>之间的博文写的太乱太丑，换个新家（换个地方乱写）。大一一年已经完全过去了，有不少收获，也有些遗憾。在大一下学期终于狠下心转了计算机专业，希望自己在新的学期能遇到更好的自己吧(#^.^#)。努力呀！！！小火汁！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
</search>
